----------------------------------------------------------------------------------------------------
module private long_arithmetic =
-- Long signed integer arithmetic operations.
-- Advanced Multi-platform Library.
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------

-- číslo je uloženo ve tvaru LSB first
-- interně je znaménko uloženo jako první element pole. 
-- nejvyšší bit posledního bytu je znaménko, kde 0 znamená
-- záporné číslo, 0 je kladné číslo. Například pro typ t_long_signed 32 bits:
--   5 -> 00000101 00000000 00000000 00000000 00000000 00000000 00000000 00000000
--  -5 -> 00000101 00000000 00000000 00000000 00000000 00000000 00000000 10000000

const
  long_signed_neutral  = 0;
  long_signed_positive = 1;
  long_signed_negative = 2;

type
  t_cmp_result = enum 
      cmp_res_equal;
      cmp_res_smaller;
      cmp_res_greater;
      end enum;

  t_cmp_result_set = set of t_cmp_result;



-- základní práce (alokace, uvolnění)

----------------------------------------------------------------------------------------------------
procedure long_unsigned_bits_to_items =
----------------------------------------------------------------------------------------------------
begin
  result:=(precision+t_long_unsigned:base:bits-1) div t_long_unsigned:base:bits;
  end long_unsigned_bits_to_items;



----------------------------------------------------------------------------------------------------
procedure long_signed_bits_to_items =
----------------------------------------------------------------------------------------------------
begin
  result:=(precision+t_long_signed:base:bits-1) div t_long_signed:base:bits
         -- v prvním elementu čísla je uloženo znaménko
         +1;
  end long_signed_bits_to_items;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_new =
----------------------------------------------------------------------------------------------------
begin
  -- velikost prostoru zaokrouhlíme nahoru na nejbližší násobek velikosti slova
  new number range long_unsigned_bits_to_items(precision);
  end long_unsigned_new;



----------------------------------------------------------------------------------------------------
procedure long_signed_new =
----------------------------------------------------------------------------------------------------
begin
  -- velikost prostoru zaokrouhlíme nahoru na nejbližší násobek velikosti slova
  new number range long_signed_bits_to_items(precision);
  end long_signed_new;



-- načtení malého čísla

----------------------------------------------------------------------------------------------------
procedure long_unsigned_load =
----------------------------------------------------------------------------------------------------
var
  wsize : t_unsigned;  -- délka dlouhého čísla v bytech

begin
  -- změřit číslo
  wsize:=number:size;
  #syntax asm;
      -- převzít požadovanou hodnotu
      mov    eax,n
      mov    edi,number

      -- zjistit z kolika slov se skládá dlouhé číslo
      mov    ecx,wsize
      shr    ecx,<t_unsigned8>2

      -- uložit do cílového prostoru
      cld
      stosd
      dec    ecx

      -- zbytek dlouhého čísla zaplnit nulami
      xor    eax,eax
      rep stosd
      #end asm;
  end long_unsigned_load;



----------------------------------------------------------------------------------------------------
procedure long_signed_load =
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  nlen             : t_mod_unsigned;             -- délka dlouhého čísla ve slovech 

begin
  -- změřit číslo (počet slov), až bude překladač umět atribut length, bude to jednodušší
  nlen:=t_mod_unsigned(number:size) shr 2;
  #syntax asm;
      -- převzít požadovanou hodnotu
      mov    eax,i
      mov    edi,number

      cld

      -- zjistit znaménko
      xor    ecx,ecx
      cmp    eax,1
      adc    ecx,0
      cmp    eax,$80000000
      adc    ecx,0

      -- nezáporná čísla pokračují dál
      jnz    @2

      -- číslo je záporné, musíme ho převést na jeho dvojkový komplement
      neg    eax

      -- v této chvíli máme v ECX znaménko (2="0", 1="+", 0="-")
      -- normalizujeme ho do tvaru         (0="0", 1="+", 2="-")
      -- a uložíme
  @2: xor    ecx,$10
      mov    [edi],ecx
      add    edi,4

      -- zjistit velikost cílového čísla
      mov    ecx,nlen

      -- uložit absolutní hodnotu čísla do cílového prostoru
      stosd

      -- znaménko a absolutní hodnota čísla už byly uloženy
      sub    ecx,2
    --jc     @INVALID_LONG_NUMBER             <- nemělo by nastat, to má zařídit překladač

      -- zbytek dlouhého čísla zaplnit nulami
      xor    eax,eax
      rep    stosd
      #end asm;
end long_signed_load;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_assign =
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  srclen           : t_mod_unsigned;             -- délka dlouhého čísla ve slovech
  dstlen           : t_mod_unsigned;             -- délka dlouhého čísla ve slovech

begin
  -- změřit číslo (počet slov), až bude překladač umět atribut length, bude to jednodušší
  srclen:=t_mod_unsigned(src:size) shr 2;
  dstlen:=t_mod_unsigned(dst:size) shr 2;
  #syntax asm;
      -- adresy operandů
      mov   esi,src
      mov   edi,dst

      cld

      -- předpoklad: cílové číslo je větší než zdroj
      mov   ecx,srclen
      mov   edx,dstlen
      sub   ecx,edx
      jae   @1

      -- předpoklad se nevyplnil, cílové číslo je kratší
      mov   ecx,dstlen
      xor   edx,edx
             
      -- zkopírovat
  @1: cld
      rep   movsd

      -- zbytek cíle zaplnit nulami
      mov   ecx,edx
      xor   eax,eax
      rep   stosd
  #end asm;
  end long_unsigned_assign;



----------------------------------------------------------------------------------------------------
procedure long_signed_assign =
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  srclen           : t_mod_unsigned;             -- délka dlouhého čísla ve slovech
  dstlen           : t_mod_unsigned;             -- délka dlouhého čísla ve slovech

begin
  -- změřit číslo (počet slov), až bude překladač umět atribut length, bude to jednodušší
  srclen:=t_mod_unsigned(src:size) shr 2;
  dstlen:=t_mod_unsigned(dst:size) shr 2;
  #syntax asm;
      -- adresy operandů
      mov   esi,src
      mov   edi,dst

      cld

      -- předpoklad: cílové číslo je větší než zdroj
      mov   ecx,srclen
      mov   edx,dstlen
      sub   ecx,edx
      jae   @1

      -- předpoklad se nevyplnil, cílové číslo je kratší
      mov   ecx,dstlen
      xor   edx,edx
             
      -- zkopírovat
  @1: cld
      rep   movsd

      -- zbytek cíle zaplnit nulami
      mov   ecx,edx
      xor   eax,eax
      rep   stosd
  #end asm;
  end long_signed_assign;



----------------------------------------------------------------------------------------------------
procedure long_signed_abs =
----------------------------------------------------------------------------------------------------
begin
  if a[0]<>long_signed_neutral then
    a[0]:=long_signed_positive;
    end if;
  end long_signed_abs;



----------------------------------------------------------------------------------------------------
procedure long_signed_neg =
-- Provede přiřazení A:=-A
----------------------------------------------------------------------------------------------------
begin
  case a[0]
    when long_signed_positive do a[0]:=long_signed_negative;
    when long_signed_negative do a[0]:=long_signed_positive;
    when others do;
    end case;
  end long_signed_neg;



-- sčítání, odečítání
-- jako první jsou zde primitivní (základní obecné) neveřejné operace, pro práci s unsigned čísly
-- uloženými jako array of t_unsigned. Nad těmito operacemi je vystavěna veřejně dostupná nadstavba.



----------------------------------------------------------------------------------------------------
procedure long_unsigned_add =
----------------------------------------------------------------------------------------------------
var
  alen             : t_unsigned;  -- délka prvního sčítance ve wordech
  blen             : t_unsigned;  -- délka druhého sčítance ve wordech
  clen             : t_unsigned;  -- délka součtu ve wordech

begin
  -- změřit čísla
  alen:=1+a:last;     -- %%TODO na tomto místě :size vrací totéž jako :last. Proč?
  blen:=1+b:last;
  clen:=1+c:last;
  #syntax asm;
      -- první část výpočtu bude podle schematu [edi...]=[esi...]+[ebx...], v délce ecx
      -- druhá část výpočtu bude podle schematu [edi...]=[esi...]+0,        v délce ???
      -- třetí část výpočtu bude podle schematu [edi...]=0,                 v délce ???

      -- načteme údaje o číslech [esi,edx]=A a [ebx,ecx]=B
      mov    esi,a
      mov    edx,alen
      mov    ebx,b
      mov    ecx,blen

      -- Zaměníme pořadí operandů A a B tak, aby [ebx,ecx] bylo kratší z obou čísel. V této délce
      -- budeme provádět plnohodnotný součet současně vypočteme délku ve které budeme provádět 
      -- druhou část výpočtu
      cmp    ecx,edx
      jbe    @0

      -- zdá se, že došlo k přeteční, musíme tedy zaměnit počátky obou čísel a taky právě vypočtenou
      -- délku druhého kroku výpočtu
      xchg   esi,ebx
      xchg   edx,ecx

      -- nyní máme čísla A a B načtena, přičemž v [ebx,ecx] je kratší z nich a v [esi,edx] je delší
  @0: --     za chvíli budeme potřebovat 0
      xor    edi,edi

      -- ECX je délka kratšího sčítance (kroku 1)
      -- EDX je délka delšího sčítance

      -- vypočteme délku kroku 3
      mov    eax,clen
      sub    eax,edx

      -- je-li delší sčítanec delší než C, nebudeme třetí krok provádět a sčítanec zkrátíme
      cmovc  eax,edi
      cmovc  edx,clen
      push   eax

      -- vypočítáme délku kroku 2
      mov    eax,edx
      sub    eax,ecx

      -- je-li kratší sčítanec příliš dlouhý, zkrátíme ho
      cmovc  eax,edi
      cmovc  ecx,edx
      push   eax

  --------------------
  -- vlastní výpočet
  --------------------
      xor    edx,edx
      mov    edi,c

      cld

  -- první část výpočtu C=A+B
  @1: lodsd
      adc    eax,[ebx+edx*4]
      inc    edx
      stosd
      loop   @1

  -- druhá část výpočtu, dále už budeme uvažovat jen delší z obou čísel A a B
      pop    ecx
      jecxz  @3
  @2: lodsd
      adc    eax,0
      stosd
      loop   @2

  -- třetí část výpočtu
  @3: pop    ecx
      jecxz  @4
  -- uložit přenos přechozích výpočtů...
      mov    eax,0
      adc    eax,eax
      stosd
      sub    ecx,1
  -- a vynulování nevyužité části výsledku
      xor    eax,eax
      rep    stosd
  @4: #end asm;
  end long_unsigned_add;



----------------------------------------------------------------------------------------------------
procedure long_signed_add =
----------------------------------------------------------------------------------------------------
type
  -- pracovní pointer na absolutní hodnotu dlouhého čísla
  tmpointer        = ^unchecked for machine_pointer use true;
  tupointer        = record
      ptr          : tmpointer;
      rta_tag      : tag;
      rta_last     : unsigned 32;
      end record;

var
  unsigned_a : p_long_unsigned;
  unsigned_b : p_long_unsigned;
  unsigned_c : p_long_unsigned;

begin
  -- %%TODO(SLICE)
  tupointer(unsigned_a:unchecked).ptr:=^a[1]:unchecked;
  tupointer(unsigned_a:unchecked).rta_tag:=t_long_unsigned:tag;
  tupointer(unsigned_a:unchecked).rta_last:=a:last-1;
  tupointer(unsigned_b:unchecked).ptr:=^b[1]:unchecked;
  tupointer(unsigned_b:unchecked).rta_tag:=t_long_unsigned:tag;
  tupointer(unsigned_b:unchecked).rta_last:=b:last-1;
  tupointer(unsigned_c:unchecked).ptr:=^c[1]:unchecked;
  tupointer(unsigned_c:unchecked).rta_tag:=t_long_unsigned:tag;
  tupointer(unsigned_c:unchecked).rta_last:=c:last-1;

  case a[0]
    when long_signed_neutral do
      -- A=0, výsledkem součtu je B
      long_signed_assign(c,b);

    -- A>0
    when long_signed_positive do
      case b[0]
        when long_signed_neutral do
          -- B=0, výsledkem součtu je A
          long_signed_assign(c,a);

        when long_signed_positive do
          -- A>0, B>0, výsledkem součtu je A+B, výsledek bude kladný
          long_unsigned_add(unsigned_c^,unsigned_a^,unsigned_b^);
          #if #declared kamil; #and then; kamil then;
          #end if;
        when others do
          -- A>0, B<0, výsledkem součtu je A-ABS(B), znaménko výsledku musíme zjistit
        end case;

    -- A<0
    when others do
      case b[0]
        when long_signed_neutral do
          -- B=0, výsledkem součtu je A
          long_signed_assign(c,b);

        when long_signed_positive do
          -- A<0, B>0, výsledkem součtu je B-ABS(A), znaménko výsledku musíme zjistit

        when others do
          -- A<0, B<0, výsledkem součtu je -(ABS(A)+ABS(B)), výsledek bude záporný
        end case;
    end case;
  end long_signed_add;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_add_assign =
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  alen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech
  blen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech

begin
  -- změřit obě čísla
  alen:=t_mod_unsigned(a:size) shr 2;
  blen:=t_mod_unsigned(b:size) shr 2;
  #syntax asm;
      -- sčítat budeme v délce kratšího z obou operandů
      mov   ecx,alen
      cmp   ecx,blen
      cmova ecx,blen

      -- má-li kratší číslo nulovou délku, není co sčítat
      -- jcxz  @1        TOHLE ALE NESMÍ NASTAT, ČÍSLA 0 BITŮ DLOUHÁ NEPODPORUJEME

      -- vlastní součet
      clc
      mov   edi,a
      mov   esi,b
  @2: lodsd
      adc   [edi],eax
      inc   edi
      loop  @2

      -- jestliže z posledního bloku není žádný přenos, můžeme rovnou končit
      jnc   @1

      -- pokud skončilo A (B je delší), můžeme končit výpočet, pokud skončilo B (a pokračuje) musíme
      -- ještě zapracovat přenos z posledního provedeného kroku
      mov   ecx,alen
      sub   ecx,blen
      jc    @1

      -- postupně přenos propagujeme do vyšších řádů, končit můžeme:
      --   1. když v posledním kroku nenastal přenos
      --   2. když jsme se dostali za hranice čísla A
      mov   eax,1
  @3: add   [edi],eax
      jnc   @1
      loop  @3
  @1: #end asm;
  end long_unsigned_add_assign;



----------------------------------------------------------------------------------------------------
procedure long_signed_add_assign =
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  alen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech
  blen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech

begin
  -- změřit obě čísla
  alen:=t_mod_unsigned(a:size) shr 2;
  blen:=t_mod_unsigned(b:size) shr 2;

--  if long_signed_positive(a)=long_signed_positive(b) then
    -- obě čísla mají stejné znaménko, provedeme součet a znaménko zůstane zachováno
    -- [   5 +  7  ->   12  ]
    -- [ (-5)+(-7) -> (-12) ]
--  elsif abs a>abs b then
    -- čísla mají rozdílná znaménka, vypočteme (A-B), znaménko převezmeme z čísla A
    -- [ (-7)+( 5) -> (-2) ]
    -- [ ( 7)+(-5) -> ( 2) ]
--  else
    -- čísla mají rozdílná znaménka, vypočteme (B-A), znaménko převezmeme z čísla B
    -- [ (-5)+( 7) -> ( 2) ]
    -- [ ( 5)+(-7) -> (-2) ]
--    end if;

  #syntax asm;
      -- sčítat budeme v délce kratšího z obou operandů
      mov   ecx,alen
      cmp   ecx,blen
      cmova ecx,blen

      -- má-li kratší číslo nulovou délku, není co sčítat
      -- jcxz  @1        TOHLE ALE NESMÍ NASTAT, ČÍSLA 0 BITŮ DLOUHÁ NEPODPORUJEME

      -- vlastní součet
      cld
      clc
      mov   edi,a
      mov   esi,b
  @2: lodsd
      adc   [edi],eax
      inc   edi
      loop  @2
  @3: lodsd
      adc   eax,[edi]
      stosd
      loop  @3

      -- schováme si poslední přenos
      sahf

      -- pokud skončilo A, můžeme končit výpočet, pokud skončilo B a máme přenos z posledního 
      -- součtu, musíme ho taky zapracovat
      cmp   ecx,alen
      jnc   @1

  @1: #end asm;
  end long_signed_add_assign;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_add_n =
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;

      #end asm;
  end long_unsigned_add_n;



----------------------------------------------------------------------------------------------------
procedure long_signed_add_n =
--%%TODO(KAMIL) Ošetřit práci se znaménky !!!                                                                    
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  alen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech

begin
  -- změřit číslo
  alen:=t_mod_unsigned(a:size) shr 2;

 #syntax asm;
      -- převzít požadovanou hodnotu
      mov    eax,I
      mov    edi,A

      -- zjistit z kolika slov se skládá dlouhé číslo
      mov    ecx,alen

      -- přičíst  malé číslo
      add    [edi],eax

      -- není-li přenos, konec
      jnc    @0

      -- odečíst zpracované slovo od délky
      sub    ecx,4
      jz     @0

      -- započítat přenos do vyšších řádů
      mov    eax,1
  @1: add    [edi],eax
      add    edi,4
      loop   @1
  @0: #end asm;
  end long_signed_add_n;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_sub_n =
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  alen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech

begin
  -- změřit číslo
  alen:=t_mod_unsigned(a:size) shr 2;
  #syntax asm;
      -- převzít požadovanou hodnotu
      mov    eax,N
      mov    edi,A

      -- zjistit z kolika slov se skládá dlouhé číslo
      mov    ecx,alen

      -- přičíst  malé číslo
      sub    [edi],eax

      -- není-li přenos, konec
      jnb    @0

      -- odečíst zpracované slovo od délky
      sub    ecx,4
      jz     @0

      -- započítat přenos do vyšších řádů
      mov    eax,1
  @1: add    [edi],eax
      add    edi,4
      loop   @1
  @0: #end asm;
  end long_unsigned_sub_n;



----------------------------------------------------------------------------------------------------
procedure long_signed_sub_n =
-- Ošetřit práci se znaménky !!!                                                                   
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  alen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech

begin
  -- změřit číslo
  alen:=t_mod_unsigned(a:size) shr 2;
  #syntax asm;
      -- převzít požadovanou hodnotu
      mov    eax,I
      mov    edi,A

      -- zjistit z kolika slov se skládá dlouhé číslo
      mov    ecx,alen

      -- přičíst  malé číslo
      sub    [edi],eax

      -- není-li přenos, konec
      jnb    @0

      -- odečíst zpracované slovo od délky
      sub    ecx,4
      jz     @0

      -- započítat přenos do vyšších řádů
      mov    eax,1
  @1: add    [edi],eax
      add    edi,4
      loop   @1
  @0: #end asm;
  end long_signed_sub_n;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_sub =
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  alen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech
  blen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech
  clen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech

begin
  -- změřit čísla
  alen:=t_mod_unsigned(a:size) shr 2;
  blen:=t_mod_unsigned(b:size) shr 2;
  clen:=t_mod_unsigned(c:size) shr 2;
  #syntax asm;
      -- první část výpočtu bude podle schematu [edi...]=[esi...]+[ebx...], v délce ecx
      -- druhá část výpočtu bude podle schematu [edi...]=[esi...]+0,        v délce ???
      -- třetí část výpočtu bude podle schematu [edi...]=0,                 v délce ???

      -- načteme údaje o číslech [esi,edx]=A a [ebx,ecx]=B
      mov    esi,a
      mov    edx,alen
      mov    ebx,b
      mov    ecx,blen

      -- Zaměníme pořadí operandů A a B tak, aby [ebx,ecx] bylo kratší z obou čísel. V této délce
      -- budeme provádět plnohodnotný součet současně vypočteme délku ve které budeme provádět 
      -- druhou část výpočtu
      cmp    ecx,edx
      jbe    @0

      -- zdá se, že došlo k přeteční, musíme tedy zaměnit počátky obou čísel a taky právě vypočtenou
      -- délku druhého kroku výpočtu
      xchg   esi,ebx
      xchg   edx,ecx

      -- nyní máme čísla A a B načtena, přičemž v [ebx,ecx] je kratší z nich a v [esi,edx] je delší
  @0: --     za chvíli budeme potřebovat 0
      xor    edi,edi

      -- ECX je délka kratšího sčítance (kroku 1)
      -- EDX je délka delšího sčítance

      -- vypočteme délku kroku 3
      mov    eax,clen
      sub    eax,edx

      -- je-li delší sčítanec delší než C, nebudeme třetí krok provádět a sčítanec zkrátíme
      cmovc  eax,edi
      cmovc  edx,clen
      push   eax

      -- vypočítáme délku kroku 2
      mov    eax,edx
      sub    eax,ecx

      -- je-li kratší sčítanec příliš dlouhý, zkrátíme ho
      cmovc  eax,edi
      cmovc  ecx,edx
      push   eax

  --------------------
  -- vlastní výpočet
  --------------------
      xor    edx,edx
      mov    edi,c

      cld

  -- první část výpočtu C=A+B
  @1: lodsd
      sbb    eax,[ebx+edx*4]
      inc    edx
      stosd
      loop   @1

  -- druhá část výpočtu, dále už budeme uvažovat jen delší z obou čísel A a B
      pop    ecx
      jecxz  @3
  @2: lodsd
      sbb    eax,0
      stosd
      loop   @2

  -- třetí část výpočtu
  @3: pop    ecx
      jecxz  @4
  -- uložit přenos přechozích výpočtů...
      mov    eax,0
      sbb    eax,eax
      stosd
      sub    ecx,1
  -- a vynulování nevyužité části výsledku
      xor    eax,eax
      rep    stosd
  @4: #end asm;
  end long_unsigned_sub;



----------------------------------------------------------------------------------------------------
procedure long_signed_sub =
----------------------------------------------------------------------------------------------------
begin
  case a[0]
    when long_signed_neutral do
      -- A=0, výsledkem rozdílu je -B
      long_signed_assign(c,b);
      long_signed_neg(c);

    -- A>0
    when long_signed_positive do
      case b[0]
        when long_signed_neutral do
          -- B=0, výsledkem rozdílu je A
          long_signed_assign(c,a);

        when long_signed_positive do
          -- A>0, B>0, výsledkem rozdílu je A-B, znaménko výsledku musíme zjistit

        when others do
          -- A>0, B<0, výsledkem rozdílu je A+ABS(B), výsledek bude kladný

        end case;

    -- A<0
    when others do
      case b[0]
        when long_signed_neutral do
          -- B=0, výsledkem rozdílu je A
          long_signed_assign(c,b);

        when long_signed_positive do
          -- A<0, B>0, výsledkem rozdílu je -(ABS(A)+ABS(B)), výsledek bude záporný

        when others do
          -- A<0, B<0, výsledkem rozdílu je           B-ABS(A), znaménko výsledku musíme zjistit

        end case;
    end case;
  end long_signed_sub;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_sub_assign =
----------------------------------------------------------------------------------------------------
begin
  long_unsigned_sub(a,a,b);
  end long_unsigned_sub_assign;



----------------------------------------------------------------------------------------------------
procedure long_signed_sub_assign =
----------------------------------------------------------------------------------------------------
begin
  long_signed_sub(a,a,b);
  end long_signed_sub_assign;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_mul = 
----------------------------------------------------------------------------------------------------
var
  alimit           : t_signed;
  blimit           : t_signed;

begin
  -- 1. inicializace výsledku
  long_unsigned_load(c,0);

  -- maximální délka prvního operandu, kterou má smysl se zabývat
  if a:size<c:size then
    alimit:=t_signed(t_mod_unsigned(a:size) shr 2)-1;
  else
    alimit:=t_signed(t_mod_unsigned(c:size) shr 2)-1;
    end if;

  -- provést vlastní výpočet
  for i in 0..alimit loop
    -- maximální délka druhého operandu, kterou má smysl se zabývat
    if t_signed(b:size) < t_signed(c:size)-i then
      blimit:=t_signed(t_mod_unsigned(b:size) shr 2)-1;
    else
      blimit:=t_signed(c:size)-i-1;
      end if;

    for j in 0..i loop
      -- přičíst malý součin
      -- %%X a co propagace přenosu?
      c[t_unsigned(i+j)]+(a[t_unsigned(i)]*b[t_unsigned(j)]);
      end loop;
    end loop;
  end long_unsigned_mul;



----------------------------------------------------------------------------------------------------
procedure long_signed_mul = 
----------------------------------------------------------------------------------------------------
var
  alimit           : t_signed;
  blimit           : t_signed;

begin
  -- 1. inicializace výsledku
  long_signed_load(c,0);

  -- znaménko výsledku
  if a[0]=long_signed_neutral or b[0]=long_signed_neutral then
    -- jeden z operandů je nulový výsledek bude nula
    return;

  elsif a[0]=b[0] then
    -- oba operandy mají stejné znaménko, výsledek bude kladný
    c[0]:=long_signed_positive;

  else
    -- oba operandy mají rozdílné znaménko, výsledek bude záporný
    c[0]:=long_signed_negative;
    end if;

  -- maximální délka prvního operandu, kterou má smysl se zabývat
  if a:size<c:size then
    alimit:=t_signed(t_mod_unsigned(a:size) shr 2)-1-1;
  else
    alimit:=t_signed(t_mod_unsigned(c:size) shr 2)-1-1;
    end if;

  -- provést vlastní výpočet
  for i in 0..alimit loop
    -- maximální délka druhého operandu, kterou má smysl se zabývat
    if t_signed(b:size) < t_signed(c:size)-i then
      blimit:=t_signed(t_mod_unsigned(b:size) shr 2)-1-1;
    else
      blimit:=t_signed(c:size)-i-1-1;
      end if;

    for j in 0..i loop
      -- přičíst malý součin
      -- %%X a co propagace přenosu?
      c[t_unsigned(i+j+1)]+(a[t_unsigned(i)+1]*b[t_unsigned(j)+1]);
      end loop;
    end loop;
  end long_signed_mul;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_div =
----------------------------------------------------------------------------------------------------
begin
  end long_unsigned_div;



----------------------------------------------------------------------------------------------------
procedure long_signed_div =
----------------------------------------------------------------------------------------------------
begin
  if b[0]=long_signed_neutral then
    -- dělení nulou
  elsif a[0]=long_signed_neutral then
    -- nulový čitatel, nulový výsledek
  elsif a[0]=b[0] then
    -- čitatel a jmenovatel mají stejné znaménko, výsledek bude kladný
  else
    -- čitatel a jmenovatel mají rozdílné znaménko, výsledek bude záporný
    end if;
  end long_signed_div;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_mod =
----------------------------------------------------------------------------------------------------
begin
  end long_unsigned_mod;



----------------------------------------------------------------------------------------------------
procedure long_signed_mod =
----------------------------------------------------------------------------------------------------
begin
  end long_signed_mod;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_is_odd =
----------------------------------------------------------------------------------------------------
begin
  result:=(t_mod_unsigned(a[0]) and 1)<>0;
  end long_unsigned_is_odd;



----------------------------------------------------------------------------------------------------
procedure long_signed_is_odd =
----------------------------------------------------------------------------------------------------
begin
  result:=(t_mod_unsigned(a[1]) and 1)<>0;
  end long_signed_is_odd;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_is_even = 
----------------------------------------------------------------------------------------------------
begin
  result:=(t_mod_unsigned(a[0]) and 1)=0;
  end long_unsigned_is_even;



----------------------------------------------------------------------------------------------------
procedure long_signed_is_even = 
----------------------------------------------------------------------------------------------------
begin 
  result:=(t_mod_unsigned(a[1]) and 1)=0;
  end long_signed_is_even;



----------------------------------------------------------------------------------------------------
procedure long_signed_is_positive =
----------------------------------------------------------------------------------------------------
begin
  result:=a[0]=long_signed_positive;
  end long_signed_is_positive;



----------------------------------------------------------------------------------------------------
procedure long_signed_is_negative = 
----------------------------------------------------------------------------------------------------
begin
  result:=a[0]=long_signed_negative;
  end long_signed_is_negative;



----------------------------------------------------------------------------------------------------
procedure long_signed_is_neutral =
----------------------------------------------------------------------------------------------------
begin
  result:=a[0]=long_signed_neutral;
  end long_signed_is_neutral;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_cmp (
    A              : in t_long_unsigned;
    B              : in t_long_unsigned)
    return t_cmp_result =
----------------------------------------------------------------------------------------------------
var
  -- %%X Až bude interní assembler umět pracovat s dynamickými atributy proměnných, bude tato proměnná zbytečná
  alen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech
  blen             : t_mod_unsigned;             -- délka dlouhého čísla ve wordech

begin
  -- změřit obě čísla
  alen:=t_mod_unsigned(a:size) shr 2;
  blen:=t_mod_unsigned(b:size) shr 2;

  #syntax asm;
      -- převzít a velikosti adresy obou operandů
      mov   esi,a
      mov   edi,b
      mov   ecx,alen
      mov   edx,blen

      -- předpoklad: A (ESI,ECX) je kratší
      sub   edx,ecx
      jnc   @1

      -- předpoklad se nevyplnil, zaměníme oba operandy a tím se předpoklad splní
      neg   edx
      xchg  esi,edi
      xchg  ecx,edx

      -- nyní je v (ESI,ECX délka kratšího z porovnávaných čísel), v EDI je začátek delšího, resp. 
      -- nekratšího čísla a v EDX je absolutní hodnota rozdílu délek porovnávaných čísel

      -- porovnání v délce kratšího z nich
  @1: repe  cmpsd

      -- nalezen rozdíl ještě před koncem společné části
      jne   @2

      -- počátek obou čísel je shodný, zbývá ověřit nulovost zbytku delšího z porovnávaných čísel
      mov   ecx,edx

      -- pokud jsou obě čísla stejně dlouhá, můžeme rovnou skončit
      jcxz  @2

      xor   eax,eax
      repe  scasd

      -- pokud jsme našli nenulu, je to rozdíl
      jne   @2

      -- pokud jsme se dostali až sem, jsou porovnávaná čísla shodná
--      mov   eax,l_true
      jmp   @0

  @2: -- čísla nejsou stejná
--      mov   eax,l_false

      -- uložit výsledek
  @0: mov   result,al
      #end asm;
  end long_unsigned_cmp;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_eq =
----------------------------------------------------------------------------------------------------
begin
  result:=long_unsigned_cmp(a,b) in t_cmp_result_set:[cmp_res_equal];
  end long_unsigned_eq;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_ne =
----------------------------------------------------------------------------------------------------
begin
  result:=long_unsigned_cmp(a,b) in t_cmp_result_set:[cmp_res_smaller,cmp_res_greater];
  end long_unsigned_ne;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_lt =
----------------------------------------------------------------------------------------------------
begin
  result:=long_unsigned_cmp(a,b) in t_cmp_result_set:[cmp_res_smaller];
  end long_unsigned_lt;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_le =
----------------------------------------------------------------------------------------------------
begin
  result:=long_unsigned_cmp(a,b) in t_cmp_result_set:[cmp_res_smaller,cmp_res_equal];
  end long_unsigned_le;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_gt =
----------------------------------------------------------------------------------------------------
begin
  result:=long_unsigned_cmp(a,b) in t_cmp_result_set:[cmp_res_greater];
  end long_unsigned_gt;



----------------------------------------------------------------------------------------------------
procedure long_unsigned_ge =
----------------------------------------------------------------------------------------------------
begin
  result:=long_unsigned_cmp(a,b) in t_cmp_result_set:[cmp_res_greater,cmp_res_equal];
  end long_unsigned_ge;



----------------------------------------------------------------------------------------------------
procedure long_signed_cmp (
    A              : in t_long_signed;
    B              : in t_long_signed)
    return t_cmp_result =
----------------------------------------------------------------------------------------------------
begin
  case a[0]
    when long_signed_neutral do ;
      case b[0]
        when long_signed_neutral do 
          -- A=0, B=0 -> A=B
          result:=cmp_res_equal;
        when long_signed_positive do
          -- A=0, B>0 -> A<B
          result:=cmp_res_smaller;
        when long_signed_negative do
          -- A=0, B<0 -> A>B
          result:=cmp_res_greater;
        end case;
    when long_signed_positive do ;
      case b[0]
        when long_signed_neutral do 
          -- A>0, B=0 -> A>B
          result:=cmp_res_greater;
        when long_signed_positive do
          -- A>0, B>0 -> ?
          begin
            end;
        when long_signed_negative do
          -- A>0, B<0 -> A>B
          result:=cmp_res_greater;
        end case;
    when long_signed_negative do ;
      case b[0]
        when long_signed_neutral do 
          -- A<0, B=0 -> A<B
          result:=cmp_res_smaller;
        when long_signed_positive do
          -- A<0, B>0 -> A<B
          result:=cmp_res_smaller;
        when long_signed_negative do
          -- A<0, B<0 -> ?
          begin
            end;
        end case;
    end case;
  end long_signed_cmp;



----------------------------------------------------------------------------------------------------
procedure long_signed_eq =
----------------------------------------------------------------------------------------------------
begin
  result:=long_signed_cmp(a,b) in t_cmp_result_set:[cmp_res_equal];
  end long_signed_eq;



----------------------------------------------------------------------------------------------------
procedure long_signed_ne =
----------------------------------------------------------------------------------------------------
begin
  result:=long_signed_cmp(a,b) in t_cmp_result_set:[cmp_res_smaller,cmp_res_greater];
  end long_signed_ne;



----------------------------------------------------------------------------------------------------
procedure long_signed_lt =
----------------------------------------------------------------------------------------------------
begin
  result:=long_signed_cmp(a,b) in t_cmp_result_set:[cmp_res_smaller];
  end long_signed_lt;



----------------------------------------------------------------------------------------------------
procedure long_signed_le =
----------------------------------------------------------------------------------------------------
begin
  result:=long_signed_cmp(a,b) in t_cmp_result_set:[cmp_res_greater];
  end long_signed_le;



----------------------------------------------------------------------------------------------------
procedure long_signed_gt =
----------------------------------------------------------------------------------------------------
begin
  result:=not long_signed_le(a,b);
  end long_signed_gt;



----------------------------------------------------------------------------------------------------
procedure long_signed_ge =
----------------------------------------------------------------------------------------------------
begin
  result:=long_signed_cmp(a,b) in t_cmp_result_set:[cmp_res_greater,cmp_res_equal];
  end long_signed_ge;



end long_arithmetic;