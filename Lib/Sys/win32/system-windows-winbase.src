----------------------------------------------------------------------------------------------------
module winbase =
-- Windows header [converted by h2flex]
--
-- Flex Standard Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------

with
    windef,winnt,basetsd,stdarg,guiddef;

-- /************************************************************************
-- *                                                                       *
-- *   winbase.h -- This module defines the 32-Bit Windows Base APIs       *
-- *                                                                       *
-- *   Copyright (c) Microsoft Corp. All rights reserved.                  *
-- *                                                                       *
-- ************************************************************************/
-- #pragma  once
-- 
--  Define API decoration for direct importing of DLL references.
-- 
-- /*
--  * Compatibility macros
--  */
const
  INVALID_HANDLE_VALUE : t_HANDLE = $FFFFFFFF;

const
  INVALID_FILE_SIZE : DWORD = $FFFFFFFF;

const
  INVALID_SET_FILE_POINTER : DWORD = $FFFFFFFF;

const
  INVALID_FILE_ATTRIBUTES : DWORD = $FFFFFFFF;

const
  FILE_BEGIN = 0;

const
  FILE_CURRENT = 1;

const
  FILE_END = 2;

const
  TIME_ZONE_ID_INVALID : DWORD = $FFFFFFFF;

const
  WAIT_FAILED : DWORD = $FFFFFFFF;

const
  WAIT_OBJECT_0 : DWORD = $0 + $0;

const
  WAIT_ABANDONED : DWORD = $80 + $0;

const
  WAIT_ABANDONED_0 : DWORD = $80 + $0;

-- 
--  File creation flags must start at the high end since they
--  are combined with the attributes
-- 
const
  FILE_FLAG_WRITE_THROUGH= $80000000;

const
  FILE_FLAG_OVERLAPPED= $40000000;

const
  FILE_FLAG_NO_BUFFERING= $20000000;

const
  FILE_FLAG_RANDOM_ACCESS= $10000000;

const
  FILE_FLAG_SEQUENTIAL_SCAN= $8000000;

const
  FILE_FLAG_DELETE_ON_CLOSE= $4000000;

const
  FILE_FLAG_BACKUP_SEMANTICS= $2000000;

const
  FILE_FLAG_POSIX_SEMANTICS= $1000000;

const
  FILE_FLAG_OPEN_REPARSE_POINT= $200000;

const
  FILE_FLAG_OPEN_NO_RECALL= $100000;

const
  FILE_FLAG_FIRST_PIPE_INSTANCE= $80000;

const
  CREATE_NEW        = 1;

const
  CREATE_ALWAYS     = 2;

const
  OPEN_EXISTING     = 3;

const
  OPEN_ALWAYS       = 4;

const
  TRUNCATE_EXISTING = 5;

-- 
--  Define possible return codes from the CopyFileEx callback routine
-- 
const
  PROGRESS_CONTINUE = 0;

const
  PROGRESS_CANCEL   = 1;

const
  PROGRESS_STOP     = 2;

const
  PROGRESS_QUIET    = 3;

-- 
--  Define CopyFileEx callback routine state change values
-- 
const
  CALLBACK_CHUNK_FINISHED= $00;

const
  CALLBACK_STREAM_SWITCH= $01;

-- 
--  Define CopyFileEx option flags
-- 
const
  COPY_FILE_FAIL_IF_EXISTS= $01;

const
  COPY_FILE_RESTARTABLE= $02;

const
  COPY_FILE_OPEN_SOURCE_FOR_WRITE= $04;

const
  COPY_FILE_ALLOW_DECRYPTED_DESTINATION= $08;

-- 
--  Define ReplaceFile option flags
-- 
const
  REPLACEFILE_WRITE_THROUGH= $01;

const
  REPLACEFILE_IGNORE_MERGE_ERRORS= $02;

-- 
--  Define the NamedPipe definitions
-- 
-- 
--  Define the dwOpenMode values for CreateNamedPipe
-- 
const
  PIPE_ACCESS_INBOUND= $01;

const
  PIPE_ACCESS_OUTBOUND= $02;

const
  PIPE_ACCESS_DUPLEX= $03;

-- 
--  Define the Named Pipe End flags for GetNamedPipeInfo
-- 
const
  PIPE_CLIENT_END   = $00;

const
  PIPE_SERVER_END   = $01;

-- 
--  Define the dwPipeMode values for CreateNamedPipe
-- 
const
  PIPE_WAIT         = $00;

const
  PIPE_NOWAIT       = $01;

const
  PIPE_READMODE_BYTE= $00;

const
  PIPE_READMODE_MESSAGE= $02;

const
  PIPE_TYPE_BYTE    = $00;

const
  PIPE_TYPE_MESSAGE = $04;

-- 
--  Define the well known values for CreateNamedPipe nMaxInstances
-- 
const
  PIPE_UNLIMITED_INSTANCES= 255;

-- 
--  Define the Security Quality of Service bits to be passed
--  into CreateFile
-- 
const
  SECURITY_CONTEXT_TRACKING= $40000;

const
  SECURITY_EFFECTIVE_ONLY= $80000;

const
  SECURITY_SQOS_PRESENT= $100000;

const
  SECURITY_VALID_SQOS_FLAGS= $1F0000;

-- 
--  File structures
-- 
type
  _OVERLAPPED       = record
Internal        : ULONG_PTR;
InternalHigh    : ULONG_PTR;
t_001            : record
Offset          : DWORD;
OffsetHigh      : DWORD;
      Pointer       : PVOID for position use 0;
    end record;
hEvent          : t_HANDLE;
  end record;
  OVERLAPPED        = _OVERLAPPED;
  p_OVERLAPPED      = ^_OVERLAPPED;

type
  _SECURITY_ATTRIBUTES = record
nLength         : DWORD;
lpSecurityDescriptor : LPVOID;
bInheritHandle  : BOOL;
  end record;
  SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES;
  PSECURITY_ATTRIBUTES = ^_SECURITY_ATTRIBUTES;
  LPSECURITY_ATTRIBUTES = ^_SECURITY_ATTRIBUTES;

type
  _PROCESS_INFORMATION = record
hProcess        : t_HANDLE;
hThread         : t_HANDLE;
dwProcessId     : DWORD;
dwThreadId      : DWORD;
  end record;
  PROCESS_INFORMATION = _PROCESS_INFORMATION;
  PPROCESS_INFORMATION = ^_PROCESS_INFORMATION;
  LPPROCESS_INFORMATION = ^_PROCESS_INFORMATION;

-- 
--  File System time stamps are represented with the following structure:
-- 
-- 
--  System time is represented with the following structure:
-- 
type
  _SYSTEMTIME       = record
wYear           : WORD;
wMonth          : WORD;
wDayOfWeek      : WORD;
wDay            : WORD;
wHour           : WORD;
wMinute         : WORD;
wSecond         : WORD;
wMilliseconds   : WORD;
  end record;
  t_SYSTEMTIME      = _SYSTEMTIME;
  PSYSTEMTIME       = ^_SYSTEMTIME;
  p_SYSTEMTIME      = ^_SYSTEMTIME;

type
PTHREAD_START_ROUTINE = ^procedure (
    lpThreadParameter : LPVOID)
                      return DWORD for machine_pointer use true;
type
LPTHREAD_START_ROUTINE = PTHREAD_START_ROUTINE;
type
PFIBER_START_ROUTINE = ^procedure (
    lpFiberParameter : LPVOID) for machine_pointer use true;
type
LPFIBER_START_ROUTINE = PFIBER_START_ROUTINE;
type
CRITICAL_SECTION  = RTL_CRITICAL_SECTION;
type
PCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
type
LPCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
type
CRITICAL_SECTION_DEBUG = RTL_CRITICAL_SECTION_DEBUG;
type
PCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;
type
LPCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;
type
LPLDT_ENTRY       = PLDT_ENTRY;
-- 
--  Serial provider type.
-- 
-- 
--  Provider SubTypes
-- 
-- 
--  Provider capabilities flags.
-- 
-- 
--  Comm provider settable parameters.
-- 
-- 
--  Settable baud rates in the provider.
-- 
-- 
--  Settable Data Bits
-- 
-- 
--  Settable Stop and Parity bits.
-- 
type
  _COMMPROP         = record
wPacketLength   : WORD;
wPacketVersion  : WORD;
dwServiceMask   : DWORD;
dwReserved1     : DWORD;
dwMaxTxQueue    : DWORD;
dwMaxRxQueue    : DWORD;
dwMaxBaud       : DWORD;
dwProvSubType   : DWORD;
dwProvCapabilities : DWORD;
dwSettableParams : DWORD;
dwSettableBaud  : DWORD;
wSettableData   : WORD;
wSettableStopParity : WORD;
dwCurrentTxQueue : DWORD;
dwCurrentRxQueue : DWORD;
dwProvSpec1     : DWORD;
dwProvSpec2     : DWORD;
wcProvChar      : array 0..0 of WCHAR;
  end record;
  COMMPROP          = _COMMPROP;
  p_COMMPROP        = ^_COMMPROP;

-- 
--  Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
--  is valid before a call to GetCommProperties().
-- 
type
  _COMSTAT          = record
fCtsHold        : DWORD {:1};
fDsrHold        : DWORD {:1};
fRlsdHold       : DWORD {:1};
fXoffHold       : DWORD {:1};
fXoffSent       : DWORD {:1};
fEof            : DWORD {:1};
fTxim           : DWORD {:1};
fReserved       : DWORD {:25};
cbInQue         : DWORD;
cbOutQue        : DWORD;
  end record;
  COMSTAT           = _COMSTAT;
  LPCOMSTAT         = ^_COMSTAT;

-- 
--  DTR Control Flow Values.
-- 
const
  DTR_CONTROL_DISABLE= $00;

const
  DTR_CONTROL_ENABLE= $01;

const
  DTR_CONTROL_HANDSHAKE= $02;

-- 
--  RTS Control Flow Values
-- 
const
  RTS_CONTROL_DISABLE= $00;

const
  RTS_CONTROL_ENABLE= $01;

const
  RTS_CONTROL_HANDSHAKE= $02;

const
  RTS_CONTROL_TOGGLE= $03;

type
  _DCB              = record
DCBlength       : DWORD;
BaudRate        : DWORD;
fBinary         : DWORD {:1};
fParity         : DWORD {:1};
fOutxCtsFlow    : DWORD {:1};
fOutxDsrFlow    : DWORD {:1};
fDtrControl     : DWORD {:2};
fDsrSensitivity : DWORD {:1};
fTXContinueOnXoff : DWORD {:1};
fOutX           : DWORD {:1};
fInX            : DWORD {:1};
fErrorChar      : DWORD {:1};
fNull           : DWORD {:1};
fRtsControl     : DWORD {:2};
fAbortOnError   : DWORD {:1};
fDummy2         : DWORD {:17};
wReserved       : WORD;
XonLim          : WORD;
XoffLim         : WORD;
ByteSize        : BYTE;
Parity          : BYTE;
StopBits        : BYTE;
XonChar         : character 8;
XoffChar        : character 8;
ErrorChar       : character 8;
EofChar         : character 8;
EvtChar         : character 8;
wReserved1      : WORD;
  end record;
  t_DCB             = _DCB;
  p_DCB             = ^_DCB;

type
  _COMMTIMEOUTS     = record
ReadIntervalTimeout : DWORD;
ReadTotalTimeoutMultiplier : DWORD;
ReadTotalTimeoutConstant : DWORD;
WriteTotalTimeoutMultiplier : DWORD;
WriteTotalTimeoutConstant : DWORD;
  end record;
  COMMTIMEOUTS      = _COMMTIMEOUTS;
  p_COMMTIMEOUTS    = ^_COMMTIMEOUTS;

type
  _COMMCONFIG       = record
dwSize          : DWORD;
wVersion        : WORD;
wReserved       : WORD;
dcb             : t_DCB;
dwProviderSubType : DWORD;
dwProviderOffset : DWORD;
dwProviderSize  : DWORD;
wcProviderData  : array 0..0 of WCHAR;
  end record;
  COMMCONFIG        = _COMMCONFIG;
  LPCOMMCONFIG      = ^_COMMCONFIG;

type
  _SYSTEM_INFO      = record
t_002            : record
      dwOemId       : DWORD for position use 0;
wProcessorArchitecture : WORD;
wReserved       : WORD;
    end record;
dwPageSize      : DWORD;
lpMinimumApplicationAddress : LPVOID;
lpMaximumApplicationAddress : LPVOID;
dwActiveProcessorMask : DWORD_PTR;
dwNumberOfProcessors : DWORD;
dwProcessorType : DWORD;
dwAllocationGranularity : DWORD;
wProcessorLevel : WORD;
wProcessorRevision : WORD;
  end record;
  SYSTEM_INFO       = _SYSTEM_INFO;
  LPSYSTEM_INFO     = ^_SYSTEM_INFO;

-- 
-- 
-- /* Global Memory Flags 
const
  GMEM_FIXED        = $00;

const
  GMEM_MOVEABLE     = $02;

const
  GMEM_NOCOMPACT    = $10;

const
  GMEM_NODISCARD    = $20;

const
  GMEM_ZEROINIT     = $40;

const
  GMEM_MODIFY       = $80;

const
  GMEM_DISCARDABLE  = $0100;

const
  GMEM_NOT_BANKED   = $1000;

const
  GMEM_SHARE        = $2000;

const
  GMEM_DDESHARE     = $2000;

const
  GMEM_NOTIFY       = $4000;

const
  GMEM_VALID_FLAGS  = $7F72;

const
  GMEM_INVALID_HANDLE= $8000;

-- /* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) 
const
  GMEM_DISCARDED    = $4000;

const
  GMEM_LOCKCOUNT    = $FF;

type
  _MEMORYSTATUS     = record
dwLength        : DWORD;
dwMemoryLoad    : DWORD;
dwTotalPhys     : SIZE_T;
dwAvailPhys     : SIZE_T;
dwTotalPageFile : SIZE_T;
dwAvailPageFile : SIZE_T;
dwTotalVirtual  : SIZE_T;
dwAvailVirtual  : SIZE_T;
  end record;
  MEMORYSTATUS      = _MEMORYSTATUS;
  LPMEMORYSTATUS    = ^_MEMORYSTATUS;

-- /* Local Memory Flags 
const
  LMEM_FIXED        = $00;

const
  LMEM_MOVEABLE     = $02;

const
  LMEM_NOCOMPACT    = $10;

const
  LMEM_NODISCARD    = $20;

const
  LMEM_ZEROINIT     = $40;

const
  LMEM_MODIFY       = $80;

const
  LMEM_DISCARDABLE  = $0F00;

const
  LMEM_VALID_FLAGS  = $0F72;

const
  LMEM_INVALID_HANDLE= $8000;

-- /* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) 
const
  LMEM_DISCARDED    = $4000;

const
  LMEM_LOCKCOUNT    = $FF;

-- 
--  dwCreationFlag values
-- 
const
  DEBUG_PROCESS     = $01;

const
  DEBUG_ONLY_THIS_PROCESS= $02;

const
  CREATE_SUSPENDED  = $04;

const
  DETACHED_PROCESS  = $08;

const
  CREATE_NEW_CONSOLE= $10;

const
  NORMAL_PRIORITY_CLASS= $20;

const
  IDLE_PRIORITY_CLASS= $40;

const
  HIGH_PRIORITY_CLASS= $80;

const
  REALTIME_PRIORITY_CLASS= $0100;

const
  CREATE_NEW_PROCESS_GROUP= $0200;

const
  CREATE_UNICODE_ENVIRONMENT= $0400;

const
  CREATE_SEPARATE_WOW_VDM= $0800;

const
  CREATE_SHARED_WOW_VDM= $1000;

const
  CREATE_FORCEDOS   = $2000;

const
  BELOW_NORMAL_PRIORITY_CLASS= $4000;

const
  ABOVE_NORMAL_PRIORITY_CLASS= $8000;

const
  STACK_SIZE_PARAM_IS_A_RESERVATION= $10000;

const
  CREATE_BREAKAWAY_FROM_JOB= $1000000;

const
  CREATE_PRESERVE_CODE_AUTHZ_LEVEL= $2000000;

const
  CREATE_DEFAULT_ERROR_MODE= $4000000;

const
  CREATE_NO_WINDOW  = $8000000;

const
  PROFILE_USER      = $10000000;

const
  PROFILE_KERNEL    = $20000000;

const
  PROFILE_SERVER    = $40000000;

const
  CREATE_IGNORE_SYSTEM_DEFAULT= $80000000;

const
  THREAD_PRIORITY_NORMAL= 0;

-- 
--  Debug APIs
-- 
const
  EXCEPTION_DEBUG_EVENT= 1;

const
  CREATE_THREAD_DEBUG_EVENT= 2;

const
  CREATE_PROCESS_DEBUG_EVENT= 3;

const
  EXIT_THREAD_DEBUG_EVENT= 4;

const
  EXIT_PROCESS_DEBUG_EVENT= 5;

const
  LOAD_DLL_DEBUG_EVENT= 6;

const
  UNLOAD_DLL_DEBUG_EVENT= 7;

const
  OUTPUT_DEBUG_STRING_EVENT= 8;

const
  RIP_EVENT         = 9;

type
  _EXCEPTION_DEBUG_INFO = record
ExceptionRecord : EXCEPTION_RECORD;
dwFirstChance   : DWORD;
  end record;
  EXCEPTION_DEBUG_INFO = _EXCEPTION_DEBUG_INFO;
  LPEXCEPTION_DEBUG_INFO = ^_EXCEPTION_DEBUG_INFO;

type
  _CREATE_THREAD_DEBUG_INFO = record
hThread         : t_HANDLE;
lpThreadLocalBase : LPVOID;
lpStartAddress  : LPTHREAD_START_ROUTINE;
  end record;
  CREATE_THREAD_DEBUG_INFO = _CREATE_THREAD_DEBUG_INFO;
  LPCREATE_THREAD_DEBUG_INFO = ^_CREATE_THREAD_DEBUG_INFO;

type
  _CREATE_PROCESS_DEBUG_INFO = record
hFile           : t_HANDLE;
hProcess        : t_HANDLE;
hThread         : t_HANDLE;
lpBaseOfImage   : LPVOID;
dwDebugInfoFileOffset : DWORD;
nDebugInfoSize  : DWORD;
lpThreadLocalBase : LPVOID;
lpStartAddress  : LPTHREAD_START_ROUTINE;
lpImageName     : LPVOID;
fUnicode        : WORD;
  end record;
  CREATE_PROCESS_DEBUG_INFO = _CREATE_PROCESS_DEBUG_INFO;
  LPCREATE_PROCESS_DEBUG_INFO = ^_CREATE_PROCESS_DEBUG_INFO;

type
  _EXIT_THREAD_DEBUG_INFO = record
dwExitCode      : DWORD;
  end record;
  EXIT_THREAD_DEBUG_INFO = _EXIT_THREAD_DEBUG_INFO;
  LPEXIT_THREAD_DEBUG_INFO = ^_EXIT_THREAD_DEBUG_INFO;

type
  _EXIT_PROCESS_DEBUG_INFO = record
dwExitCode      : DWORD;
  end record;
  EXIT_PROCESS_DEBUG_INFO = _EXIT_PROCESS_DEBUG_INFO;
  LPEXIT_PROCESS_DEBUG_INFO = ^_EXIT_PROCESS_DEBUG_INFO;

type
  _LOAD_DLL_DEBUG_INFO = record
hFile           : t_HANDLE;
lpBaseOfDll     : LPVOID;
dwDebugInfoFileOffset : DWORD;
nDebugInfoSize  : DWORD;
lpImageName     : LPVOID;
fUnicode        : WORD;
  end record;
  LOAD_DLL_DEBUG_INFO = _LOAD_DLL_DEBUG_INFO;
  LPLOAD_DLL_DEBUG_INFO = ^_LOAD_DLL_DEBUG_INFO;

type
  _UNLOAD_DLL_DEBUG_INFO = record
lpBaseOfDll     : LPVOID;
  end record;
  UNLOAD_DLL_DEBUG_INFO = _UNLOAD_DLL_DEBUG_INFO;
  LPUNLOAD_DLL_DEBUG_INFO = ^_UNLOAD_DLL_DEBUG_INFO;

type
  _OUTPUT_DEBUG_STRING_INFO = record
lpDebugStringData : LPSTR;
fUnicode        : WORD;
nDebugStringLength : WORD;
  end record;
  OUTPUT_DEBUG_STRING_INFO = _OUTPUT_DEBUG_STRING_INFO;
  LPOUTPUT_DEBUG_STRING_INFO = ^_OUTPUT_DEBUG_STRING_INFO;

type
  _RIP_INFO         = record
dwError         : DWORD;
dwType          : DWORD;
  end record;
  RIP_INFO          = _RIP_INFO;
  LPRIP_INFO        = ^_RIP_INFO;

type
  _DEBUG_EVENT      = record
dwDebugEventCode : DWORD;
dwProcessId     : DWORD;
dwThreadId      : DWORD;
u                : record
      Exception     : EXCEPTION_DEBUG_INFO for position use 0;
      CreateThread  : CREATE_THREAD_DEBUG_INFO for position use 0;
      CreateProcessInfo : CREATE_PROCESS_DEBUG_INFO for position use 0;
      ExitThread    : EXIT_THREAD_DEBUG_INFO for position use 0;
      ExitProcess   : EXIT_PROCESS_DEBUG_INFO for position use 0;
      LoadDll       : LOAD_DLL_DEBUG_INFO for position use 0;
      UnloadDll     : UNLOAD_DLL_DEBUG_INFO for position use 0;
      DebugString   : OUTPUT_DEBUG_STRING_INFO for position use 0;
      RipInfo       : RIP_INFO for position use 0;
    end record;
  end record;
  DEBUG_EVENT       = _DEBUG_EVENT;
  LPDEBUG_EVENT     = ^_DEBUG_EVENT;

type
p_CONTEXT         = PCONTEXT;
type
LPEXCEPTION_RECORD = PEXCEPTION_RECORD;
type
LPEXCEPTION_POINTERS = PEXCEPTION_POINTERS;
const
  DRIVE_UNKNOWN     = 0;

const
  DRIVE_NO_ROOT_DIR = 1;

const
  DRIVE_REMOVABLE   = 2;

const
  DRIVE_FIXED       = 3;

const
  DRIVE_REMOTE      = 4;

const
  DRIVE_CDROM       = 5;

const
  DRIVE_RAMDISK     = 6;

const
  FILE_TYPE_UNKNOWN = $00;

const
  FILE_TYPE_DISK    = $01;

const
  FILE_TYPE_CHAR    = $02;

const
  FILE_TYPE_PIPE    = $03;

const
  FILE_TYPE_REMOTE  = $8000;

const
  STD_INPUT_HANDLE : DWORD = $FFFFFFF6;

const
  STD_OUTPUT_HANDLE : DWORD = $FFFFFFF5;

const
  STD_ERROR_HANDLE : DWORD = $FFFFFFF4;

const
  NOPARITY          = 0;

const
  ODDPARITY         = 1;

const
  EVENPARITY        = 2;

const
  MARKPARITY        = 3;

const
  SPACEPARITY       = 4;

const
  ONESTOPBIT        = 0;

const
  ONE5STOPBITS      = 1;

const
  TWOSTOPBITS       = 2;

const
  IGNORE = 0;

const
  INFINITE          = $FFFFFFFF;

-- 
--  Baud rates at which the communication device operates
-- 
const
  CBR_110           = 110;

const
  CBR_300           = 300;

const
  CBR_600           = 600;

const
  CBR_1200          = 1200;

const
  CBR_2400          = 2400;

const
  CBR_4800          = 4800;

const
  CBR_9600          = 9600;

const
  CBR_14400         = 14400;

const
  CBR_19200         = 19200;

const
  CBR_38400         = 38400;

const
  CBR_56000         = 56000;

const
  CBR_57600         = 57600;

const
  CBR_115200        = 115200;

const
  CBR_128000        = 128000;

const
  CBR_256000        = 256000;

-- 
--  Error Flags
-- 
const
  CE_RXOVER         = $01;

const
  CE_OVERRUN        = $02;

const
  CE_RXPARITY       = $04;

const
  CE_FRAME          = $08;

const
  CE_BREAK          = $10;

const
  CE_TXFULL         = $0100;

const
  CE_PTO            = $0200;

const
  CE_IOE            = $0400;

const
  CE_DNS            = $0800;

const
  CE_OOP            = $1000;

const
  CE_MODE           = $8000;

-- 
--  Events
-- 
const
  EV_RXCHAR         = $01;

const
  EV_RXFLAG         = $02;

const
  EV_TXEMPTY        = $04;

const
  EV_CTS            = $08;

const
  EV_DSR            = $10;

const
  EV_RLSD           = $20;

const
  EV_BREAK          = $40;

const
  EV_ERR            = $80;

const
  EV_RING           = $0100;

const
  EV_PERR           = $0200;

const
  EV_RX80FULL       = $0400;

const
  EV_EVENT1         = $0800;

const
  EV_EVENT2         = $1000;

-- 
--  Escape Functions
-- 
const
  SETXOFF           = 1;

const
  SETXON            = 2;

const
  SETRTS            = 3;

const
  CLRRTS            = 4;

const
  SETDTR            = 5;

const
  CLRDTR            = 6;

const
  RESETDEV          = 7;

const
  SETBREAK          = 8;

const
  CLRBREAK          = 9;

-- 
--  PURGE function flags.
-- 
const
  PURGE_TXABORT     = $01;

const
  PURGE_RXABORT     = $02;

const
  PURGE_TXCLEAR     = $04;

const
  PURGE_RXCLEAR     = $08;

const
  LPTx              = $80;

-- 
--  Modem Status Flags
-- 
-- 
--  WaitSoundState() Constants
-- 
const
  S_QUEUEEMPTY      = 0;

const
  S_THRESHOLD       = 1;

const
  S_ALLTHRESHOLD    = 2;

-- 
--  Accent Modes
-- 
const
  S_NORMAL          = 0;

const
  S_LEGATO          = 1;

const
  S_STACCATO        = 2;

-- 
--  SetSoundNoise() Sources
-- 
const
  S_PERIOD512       = 0;

const
  S_PERIOD1024      = 1;

const
  S_PERIOD2048      = 2;

const
  S_PERIODVOICE     = 3;

const
  S_WHITE512        = 4;

const
  S_WHITE1024       = 5;

const
  S_WHITE2048       = 6;

const
  S_WHITEVOICE      = 7;

const
  NMPWAIT_WAIT_FOREVER= $FFFFFFFF;

const
  NMPWAIT_NOWAIT    = $01;

const
  NMPWAIT_USE_DEFAULT_WAIT= $00;

const
  OF_READ           = $00;

const
  OF_WRITE          = $01;

const
  OF_READWRITE      = $02;

const
  OF_SHARE_COMPAT   = $00;

const
  OF_SHARE_EXCLUSIVE= $10;

const
  OF_SHARE_DENY_WRITE= $20;

const
  OF_SHARE_DENY_READ= $30;

const
  OF_SHARE_DENY_NONE= $40;

const
  OF_PARSE          = $0100;

const
  OF_DELETE         = $0200;

const
  OF_VERIFY         = $0400;

const
  OF_CANCEL         = $0800;

const
  OF_CREATE         = $1000;

const
  OF_PROMPT         = $2000;

const
  OF_EXIST          = $4000;

const
  OF_REOPEN         = $8000;

const
  OFS_MAXPATHNAME   = 128;

type
  _OFSTRUCT         = record
cBytes          : BYTE;
fFixedDisk      : BYTE;
nErrCode        : WORD;
Reserved1       : WORD;
Reserved2       : WORD;
szPathName      : array 0..OFS_MAXPATHNAME-1 of CHAR;
  end record;
  OFSTRUCT          = _OFSTRUCT;
  LPOFSTRUCT        = ^_OFSTRUCT;
  POFSTRUCT         = ^_OFSTRUCT;

-- #pragma  intrinsic(_InterlockedIncrement)
-- #pragma  intrinsic(_InterlockedIncrement_acq)
-- #pragma  intrinsic(_InterlockedIncrement_rel)
-- #pragma  intrinsic(_InterlockedDecrement)
-- #pragma  intrinsic(_InterlockedDecrement_acq)
-- #pragma  intrinsic(_InterlockedDecrement_rel)
-- #pragma  intrinsic(_InterlockedExchange)
-- #pragma  intrinsic(_InterlockedExchangeAdd)
-- #pragma  intrinsic(_InterlockedCompareExchange)
-- #pragma  intrinsic(_InterlockedCompareExchange_acq)
-- #pragma  intrinsic(_InterlockedCompareExchange_rel)
-- #pragma  intrinsic(_InterlockedExchangePointer)
-- #pragma  intrinsic(_InterlockedCompareExchangePointer)
-- #pragma  intrinsic(_InterlockedIncrement64)
-- #pragma  intrinsic(_InterlockedDecrement64)
-- #pragma  intrinsic(_InterlockedExchange64)
-- #pragma  intrinsic(_InterlockedExchange64_acq)
-- #pragma  intrinsic(_InterlockedCompareExchange64)
-- #pragma  intrinsic(_InterlockedCompareExchange64_acq)
-- #pragma  intrinsic(_InterlockedCompareExchange64_rel)
-- #pragma  intrinsic(_InterlockedExchangeAdd64)
-- #pragma  intrinsic(_InterlockedIncrement)
-- #pragma  intrinsic(_InterlockedDecrement)
-- #pragma  intrinsic(_InterlockedExchange)
-- #pragma  intrinsic(_InterlockedExchangeAdd)
-- #pragma  intrinsic(_InterlockedCompareExchange)
-- #pragma  intrinsic(_InterlockedExchangePointer)
-- #pragma  intrinsic(_InterlockedCompareExchangePointer)
procedure InterlockedIncrement(
    lpAddend        : in out LONG)
                      return LONG;
#pragma convention(InterlockedIncrement,system);
#pragma import(InterlockedIncrement,'InterlockedIncrement','kernel32.dll');

procedure InterlockedDecrement(
    lpAddend        : in out LONG)
                      return LONG;
#pragma convention(InterlockedDecrement,system);
#pragma import(InterlockedDecrement,'InterlockedDecrement','kernel32.dll');

procedure InterlockedExchange(
    Target          : in out LONG; 
    Value           : in LONG)
                      return LONG;
#pragma convention(InterlockedExchange,system);
#pragma import(InterlockedExchange,'InterlockedExchange','kernel32.dll');

procedure InterlockedExchangeAdd(
    Addend          : in out LONG; 
    Value           : in LONG)
                      return LONG;
#pragma convention(InterlockedExchangeAdd,system);
#pragma import(InterlockedExchangeAdd,'InterlockedExchangeAdd','kernel32.dll');

procedure InterlockedCompareExchange(
    Destination     : in out LONG; 
    Exchange        : in LONG; 
    Comperand       : in LONG)
                      return LONG;
#pragma convention(InterlockedCompareExchange,system);
#pragma import(InterlockedCompareExchange,'InterlockedCompareExchange','kernel32.dll');

procedure InterlockedCompareExchange64(
    Destination     : in out LONGLONG; 
    Exchange        : in LONGLONG; 
    Comperand       : in LONGLONG)
                      return LONGLONG;
#pragma convention(InterlockedCompareExchange64,system);
#pragma import(InterlockedCompareExchange64,'InterlockedCompareExchange64','kernel32.dll');

-- 
--  Use a function for C++ so X86 will generate the same errors as RISC.
-- 
procedure InitializeSListHead(
    ListHead        : in PSLIST_HEADER);
#pragma convention(InitializeSListHead,system);
#pragma import(InitializeSListHead,'InitializeSListHead','kernel32.dll');

procedure InterlockedPopEntrySList(
    ListHead        : in PSLIST_HEADER)
                      return PSINGLE_LIST_ENTRY;
#pragma convention(InterlockedPopEntrySList,system);
#pragma import(InterlockedPopEntrySList,'InterlockedPopEntrySList','kernel32.dll');

procedure InterlockedPushEntrySList(
    ListHead        : in PSLIST_HEADER; 
    ListEntry       : in PSINGLE_LIST_ENTRY)
                      return PSINGLE_LIST_ENTRY;
#pragma convention(InterlockedPushEntrySList,system);
#pragma import(InterlockedPushEntrySList,'InterlockedPushEntrySList','kernel32.dll');

procedure InterlockedFlushSList(
    ListHead        : in PSLIST_HEADER)
                      return PSINGLE_LIST_ENTRY;
#pragma convention(InterlockedFlushSList,system);
#pragma import(InterlockedFlushSList,'InterlockedFlushSList','kernel32.dll');

procedure QueryDepthSList(
    ListHead        : in PSLIST_HEADER)
                      return USHORT;
#pragma convention(QueryDepthSList,system);
#pragma import(QueryDepthSList,'QueryDepthSList','kernel32.dll');

procedure FreeResource(
    hResData        : in t_HGLOBAL)
                      return BOOL;
#pragma convention(FreeResource,system);
#pragma import(FreeResource,'FreeResource','kernel32.dll');

procedure LockResource(
    hResData        : in t_HGLOBAL)
                      return LPVOID;
#pragma convention(LockResource,system);
#pragma import(LockResource,'LockResource','kernel32.dll');

const
  MAXINTATOM        = $C000;

procedure FreeLibrary(
    hLibModule      : in out {!}t_HMODULE)
                      return BOOL;
#pragma convention(FreeLibrary,system);
#pragma import(FreeLibrary,'FreeLibrary','kernel32.dll');

procedure FreeLibraryAndExitThread(
    hLibModule      : in t_HMODULE; 
    dwExitCode      : in DWORD);
#pragma convention(FreeLibraryAndExitThread,system);
#pragma import(FreeLibraryAndExitThread,'FreeLibraryAndExitThread','kernel32.dll');

procedure DisableThreadLibraryCalls(
    hLibModule      : in t_HMODULE)
                      return BOOL;
#pragma convention(DisableThreadLibraryCalls,system);
#pragma import(DisableThreadLibraryCalls,'DisableThreadLibraryCalls','kernel32.dll');

procedure GetProcAddress(
    hModule         : in t_HMODULE; 
    lpProcName      : in LPCSTR)
                      return FARPROC;
#pragma convention(GetProcAddress,system);
#pragma import(GetProcAddress,'GetProcAddress','kernel32.dll');

procedure GetVersion
                      return DWORD;
#pragma convention(GetVersion,system);
#pragma import(GetVersion,'GetVersion','kernel32.dll');

procedure GlobalAlloc(
    uFlags          : in UINT; 
    dwBytes         : in SIZE_T)
                      return t_HGLOBAL;
#pragma convention(GlobalAlloc,system);
#pragma import(GlobalAlloc,'GlobalAlloc','kernel32.dll');

procedure GlobalReAlloc(
    hMem            : in t_HGLOBAL; 
    dwBytes         : in SIZE_T; 
    uFlags          : in UINT)
                      return t_HGLOBAL;
#pragma convention(GlobalReAlloc,system);
#pragma import(GlobalReAlloc,'GlobalReAlloc','kernel32.dll');

procedure GlobalSize(
    hMem            : in t_HGLOBAL)
                      return SIZE_T;
#pragma convention(GlobalSize,system);
#pragma import(GlobalSize,'GlobalSize','kernel32.dll');

procedure GlobalFlags(
    hMem            : in t_HGLOBAL)
                      return UINT;
#pragma convention(GlobalFlags,system);
#pragma import(GlobalFlags,'GlobalFlags','kernel32.dll');

procedure GlobalLock(
    hMem            : in t_HGLOBAL)
                      return LPVOID;
#pragma convention(GlobalLock,system);
#pragma import(GlobalLock,'GlobalLock','kernel32.dll');

-- !!!MWH My version win31 = DWORD WINAPI GlobalHandle(UINT)
procedure GlobalHandle(
    pMem            : in LPCVOID)
                      return t_HGLOBAL;
#pragma convention(GlobalHandle,system);
#pragma import(GlobalHandle,'GlobalHandle','kernel32.dll');

procedure GlobalUnlock(
    hMem            : in t_HGLOBAL)
                      return BOOL;
#pragma convention(GlobalUnlock,system);
#pragma import(GlobalUnlock,'GlobalUnlock','kernel32.dll');

procedure GlobalFree(
    hMem            : in t_HGLOBAL)
                      return t_HGLOBAL;
#pragma convention(GlobalFree,system);
#pragma import(GlobalFree,'GlobalFree','kernel32.dll');

procedure GlobalCompact(
    dwMinFree       : in DWORD)
                      return SIZE_T;
#pragma convention(GlobalCompact,system);
#pragma import(GlobalCompact,'GlobalCompact','kernel32.dll');

procedure GlobalFix(
    hMem            : in t_HGLOBAL);
#pragma convention(GlobalFix,system);
#pragma import(GlobalFix,'GlobalFix','kernel32.dll');

procedure GlobalUnfix(
    hMem            : in t_HGLOBAL);
#pragma convention(GlobalUnfix,system);
#pragma import(GlobalUnfix,'GlobalUnfix','kernel32.dll');

procedure GlobalWire(
    hMem            : in t_HGLOBAL)
                      return LPVOID;
#pragma convention(GlobalWire,system);
#pragma import(GlobalWire,'GlobalWire','kernel32.dll');

procedure GlobalUnWire(
    hMem            : in t_HGLOBAL)
                      return BOOL;
#pragma convention(GlobalUnWire,system);
#pragma import(GlobalUnWire,'GlobalUnWire','kernel32.dll');

procedure GlobalMemoryStatus(
    lpBuffer        : in out _MEMORYSTATUS);
#pragma convention(GlobalMemoryStatus,system);
#pragma import(GlobalMemoryStatus,'GlobalMemoryStatus','kernel32.dll');

type
  _MEMORYSTATUSEX   = record
dwLength        : DWORD;
dwMemoryLoad    : DWORD;
ullTotalPhys    : DWORDLONG;
ullAvailPhys    : DWORDLONG;
ullTotalPageFile : DWORDLONG;
ullAvailPageFile : DWORDLONG;
ullTotalVirtual : DWORDLONG;
ullAvailVirtual : DWORDLONG;
ullAvailExtendedVirtual : DWORDLONG;
  end record;
  MEMORYSTATUSEX    = _MEMORYSTATUSEX;
  LPMEMORYSTATUSEX  = ^_MEMORYSTATUSEX;

procedure GlobalMemoryStatusEx(
    lpBuffer        : in out _MEMORYSTATUSEX)
                      return BOOL;
#pragma convention(GlobalMemoryStatusEx,system);
#pragma import(GlobalMemoryStatusEx,'GlobalMemoryStatusEx','kernel32.dll');

procedure LocalAlloc(
    uFlags          : in UINT; 
    uBytes          : in SIZE_T)
                      return HLOCAL;
#pragma convention(LocalAlloc,system);
#pragma import(LocalAlloc,'LocalAlloc','kernel32.dll');

procedure LocalReAlloc(
    hMem            : in HLOCAL; 
    uBytes          : in SIZE_T; 
    uFlags          : in UINT)
                      return HLOCAL;
#pragma convention(LocalReAlloc,system);
#pragma import(LocalReAlloc,'LocalReAlloc','kernel32.dll');

procedure LocalLock(
    hMem            : in HLOCAL)
                      return LPVOID;
#pragma convention(LocalLock,system);
#pragma import(LocalLock,'LocalLock','kernel32.dll');

procedure LocalHandle(
    pMem            : in LPCVOID)
                      return HLOCAL;
#pragma convention(LocalHandle,system);
#pragma import(LocalHandle,'LocalHandle','kernel32.dll');

procedure LocalUnlock(
    hMem            : in HLOCAL)
                      return BOOL;
#pragma convention(LocalUnlock,system);
#pragma import(LocalUnlock,'LocalUnlock','kernel32.dll');

procedure LocalSize(
    hMem            : in HLOCAL)
                      return SIZE_T;
#pragma convention(LocalSize,system);
#pragma import(LocalSize,'LocalSize','kernel32.dll');

procedure LocalFlags(
    hMem            : in HLOCAL)
                      return UINT;
#pragma convention(LocalFlags,system);
#pragma import(LocalFlags,'LocalFlags','kernel32.dll');

procedure LocalFree(
    hMem            : in HLOCAL)
                      return HLOCAL;
#pragma convention(LocalFree,system);
#pragma import(LocalFree,'LocalFree','kernel32.dll');

procedure LocalShrink(
    hMem            : in HLOCAL; 
    cbNewSize       : in UINT)
                      return SIZE_T;
#pragma convention(LocalShrink,system);
#pragma import(LocalShrink,'LocalShrink','kernel32.dll');

procedure LocalCompact(
    uMinFree        : in UINT)
                      return SIZE_T;
#pragma convention(LocalCompact,system);
#pragma import(LocalCompact,'LocalCompact','kernel32.dll');

procedure FlushInstructionCache(
    hProcess        : in t_HANDLE; 
    lpBaseAddress   : in LPCVOID; 
    dwSize          : in SIZE_T)
                      return BOOL;
#pragma convention(FlushInstructionCache,system);
#pragma import(FlushInstructionCache,'FlushInstructionCache','kernel32.dll');

procedure VirtualAlloc(
    lpAddress       : in LPVOID; 
    dwSize          : in SIZE_T; 
    flAllocationType : in DWORD; 
    flProtect       : in DWORD)
                      return LPVOID;
#pragma convention(VirtualAlloc,system);
#pragma import(VirtualAlloc,'VirtualAlloc','kernel32.dll');

procedure VirtualFree(
    lpAddress       : in LPVOID; 
    dwSize          : in SIZE_T; 
    dwFreeType      : in DWORD)
                      return BOOL;
#pragma convention(VirtualFree,system);
#pragma import(VirtualFree,'VirtualFree','kernel32.dll');

procedure VirtualProtect(
    lpAddress       : in LPVOID; 
    dwSize          : in SIZE_T; 
    flNewProtect    : in DWORD; 
    lpflOldProtect  : out DWORD )
                      return BOOL;
#pragma convention(VirtualProtect,system);
#pragma import(VirtualProtect,'VirtualProtect','kernel32.dll');

procedure VirtualQuery(
    lpAddress       : in LPCVOID; 
    lpBuffer        : out _MEMORY_BASIC_INFORMATION; 
    dwLength        : in SIZE_T)
                      return SIZE_T;
#pragma convention(VirtualQuery,system);
#pragma import(VirtualQuery,'VirtualQuery','kernel32.dll');

procedure VirtualAllocEx(
    hProcess        : in t_HANDLE; 
    lpAddress       : in LPVOID; 
    dwSize          : in SIZE_T; 
    flAllocationType : in DWORD; 
    flProtect       : in DWORD)
                      return LPVOID;
#pragma convention(VirtualAllocEx,system);
#pragma import(VirtualAllocEx,'VirtualAllocEx','kernel32.dll');

procedure GetWriteWatch(
    dwFlags         : in DWORD; 
    lpBaseAddress   : in PVOID; 
    dwRegionSize    : in SIZE_T; 
    lpAddresses     : in out PVOID; 
    lpdwCount       : in out ULONG_PTR; 
    lpdwGranularity : out ULONG )
                      return UINT;
#pragma convention(GetWriteWatch,system);
#pragma import(GetWriteWatch,'GetWriteWatch','kernel32.dll');

procedure ResetWriteWatch(
    lpBaseAddress   : in LPVOID; 
    dwRegionSize    : in SIZE_T)
                      return UINT;
#pragma convention(ResetWriteWatch,system);
#pragma import(ResetWriteWatch,'ResetWriteWatch','kernel32.dll');

procedure GetLargePageMinimum
                      return SIZE_T;
#pragma convention(GetLargePageMinimum,system);
#pragma import(GetLargePageMinimum,'GetLargePageMinimum','kernel32.dll');

procedure VirtualFreeEx(
    hProcess        : in t_HANDLE; 
    lpAddress       : in LPVOID; 
    dwSize          : in SIZE_T; 
    dwFreeType      : in DWORD)
                      return BOOL;
#pragma convention(VirtualFreeEx,system);
#pragma import(VirtualFreeEx,'VirtualFreeEx','kernel32.dll');

procedure VirtualProtectEx(
    hProcess        : in t_HANDLE; 
    lpAddress       : in LPVOID; 
    dwSize          : in SIZE_T; 
    flNewProtect    : in DWORD; 
    lpflOldProtect  : out DWORD )
                      return BOOL;
#pragma convention(VirtualProtectEx,system);
#pragma import(VirtualProtectEx,'VirtualProtectEx','kernel32.dll');

procedure VirtualQueryEx(
    hProcess        : in t_HANDLE; 
    lpAddress       : in LPCVOID; 
    lpBuffer        : out _MEMORY_BASIC_INFORMATION; 
    dwLength        : in SIZE_T)
                      return SIZE_T;
#pragma convention(VirtualQueryEx,system);
#pragma import(VirtualQueryEx,'VirtualQueryEx','kernel32.dll');

procedure HeapCreate(
    flOptions       : in DWORD; 
    dwInitialSize   : in SIZE_T; 
    dwMaximumSize   : in SIZE_T)
                      return t_HANDLE;
#pragma convention(HeapCreate,system);
#pragma import(HeapCreate,'HeapCreate','kernel32.dll');

procedure HeapDestroy(
    hHeap           : in out {!}t_HANDLE)
                      return BOOL;
#pragma convention(HeapDestroy,system);
#pragma import(HeapDestroy,'HeapDestroy','kernel32.dll');

procedure HeapAlloc(
    hHeap           : in t_HANDLE; 
    dwFlags         : in DWORD; 
    dwBytes         : in SIZE_T)
                      return LPVOID;
#pragma convention(HeapAlloc,system);
#pragma import(HeapAlloc,'HeapAlloc','kernel32.dll');

procedure HeapReAlloc(
    hHeap           : in t_HANDLE; 
    dwFlags         : in DWORD; 
    lpMem           : in LPVOID; 
    dwBytes         : in SIZE_T)
                      return LPVOID;
#pragma convention(HeapReAlloc,system);
#pragma import(HeapReAlloc,'HeapReAlloc','kernel32.dll');

procedure HeapFree(
    hHeap           : in t_HANDLE; 
    dwFlags         : in DWORD; 
    lpMem           : in LPVOID)
                      return BOOL;
#pragma convention(HeapFree,system);
#pragma import(HeapFree,'HeapFree','kernel32.dll');

procedure HeapSize(
    hHeap           : in t_HANDLE; 
    dwFlags         : in DWORD; 
    lpMem           : in LPCVOID)
                      return SIZE_T;
#pragma convention(HeapSize,system);
#pragma import(HeapSize,'HeapSize','kernel32.dll');

procedure HeapValidate(
    hHeap           : in t_HANDLE; 
    dwFlags         : in DWORD; 
    lpMem           : in LPCVOID)
                      return BOOL;
#pragma convention(HeapValidate,system);
#pragma import(HeapValidate,'HeapValidate','kernel32.dll');

procedure HeapCompact(
    hHeap           : in t_HANDLE; 
    dwFlags         : in DWORD)
                      return SIZE_T;
#pragma convention(HeapCompact,system);
#pragma import(HeapCompact,'HeapCompact','kernel32.dll');

procedure GetProcessHeap
                      return t_HANDLE;
#pragma convention(GetProcessHeap,system);
#pragma import(GetProcessHeap,'GetProcessHeap','kernel32.dll');

procedure GetProcessHeaps(
    NumberOfHeaps   : in DWORD; 
    ProcessHeaps    : out t_HANDLE )
                      return DWORD;
#pragma convention(GetProcessHeaps,system);
#pragma import(GetProcessHeaps,'GetProcessHeaps','kernel32.dll');

type
  _PROCESS_HEAP_ENTRY = record
lpData          : PVOID;
cbData          : DWORD;
cbOverhead      : BYTE;
iRegionIndex    : BYTE;
wFlags          : WORD;
t_004            : record
  Block             : record
hMem            : t_HANDLE;
dwReserved      : array 0..2 of DWORD;
  end record for position use 0;
  Region            : record
dwCommittedSize : DWORD;
dwUnCommittedSize : DWORD;
lpFirstBlock    : LPVOID;
lpLastBlock     : LPVOID;
  end record for position use 0;
    end record;
  end record;
  PROCESS_HEAP_ENTRY = _PROCESS_HEAP_ENTRY;
  LPPROCESS_HEAP_ENTRY = ^_PROCESS_HEAP_ENTRY;
  PPROCESS_HEAP_ENTRY = ^_PROCESS_HEAP_ENTRY;

const
  PROCESS_HEAP_REGION= $01;

const
  PROCESS_HEAP_UNCOMMITTED_RANGE= $02;

const
  PROCESS_HEAP_ENTRY_BUSY= $04;

const
  PROCESS_HEAP_ENTRY_MOVEABLE= $10;

const
  PROCESS_HEAP_ENTRY_DDESHARE= $20;

procedure HeapLock(
    hHeap           : in t_HANDLE)
                      return BOOL;
#pragma convention(HeapLock,system);
#pragma import(HeapLock,'HeapLock','kernel32.dll');

procedure HeapUnlock(
    hHeap           : in t_HANDLE)
                      return BOOL;
#pragma convention(HeapUnlock,system);
#pragma import(HeapUnlock,'HeapUnlock','kernel32.dll');

procedure HeapWalk(
    hHeap           : in t_HANDLE; 
    lpEntry         : in out _PROCESS_HEAP_ENTRY)
                      return BOOL;
#pragma convention(HeapWalk,system);
#pragma import(HeapWalk,'HeapWalk','kernel32.dll');

procedure HeapSetInformation(
    HeapHandle      : in t_HANDLE; 
    HeapInformationClass : in HEAP_INFORMATION_CLASS; 
    HeapInformation : in {out optional} PVOID; 
    HeapInformationLength : in {out optional} SIZE_T)
                      return BOOL;
#pragma convention(HeapSetInformation,system);
#pragma import(HeapSetInformation,'HeapSetInformation','kernel32.dll');

procedure HeapQueryInformation(
    HeapHandle      : in t_HANDLE; 
    HeapInformationClass : in HEAP_INFORMATION_CLASS; 
    HeapInformation : out {out optional} unchecked ; 
    HeapInformationLength : in {out optional} SIZE_T; 
    ReturnLength    : out {out optional} ULONG_PTR )
                      return BOOL;
#pragma convention(HeapQueryInformation,system);
#pragma import(HeapQueryInformation,'HeapQueryInformation','kernel32.dll');

--  GetBinaryType return values.
const
  SCS_32BIT_BINARY  = 0;

const
  SCS_DOS_BINARY    = 1;

const
  SCS_WOW_BINARY    = 2;

const
  SCS_PIF_BINARY    = 3;

const
  SCS_POSIX_BINARY  = 4;

const
  SCS_OS216_BINARY  = 5;

const
  SCS_64BIT_BINARY  = 6;

procedure GetBinaryTypeA(
    lpApplicationName : in LPCSTR; 
    lpBinaryType    : out DWORD )
                      return BOOL;
#pragma convention(GetBinaryTypeA,system);
#pragma import(GetBinaryTypeA,'GetBinaryTypeA','kernel32.dll');

procedure GetBinaryTypeW(
    lpApplicationName : in LPCWSTR; 
    lpBinaryType    : out DWORD )
                      return BOOL;
#pragma convention(GetBinaryTypeW,system);
#pragma import(GetBinaryTypeW,'GetBinaryTypeW','kernel32.dll');

#if #declared UNICODE; then;
#template GetBinaryType;
  GetBinaryTypeW 
#end GetBinaryType;
#else;
#template GetBinaryType;
  GetBinaryTypeA 
#end GetBinaryType;
#end if;

procedure GetShortPathNameA(
    lpszLongPath    : in LPCSTR; 
    lpszShortPath   : out CHARSTR ; 
    cchBuffer       : in DWORD)
                      return DWORD;
#pragma convention(GetShortPathNameA,system);
#pragma import(GetShortPathNameA,'GetShortPathNameA','kernel32.dll');

procedure GetShortPathNameW(
    lpszLongPath    : in LPCWSTR; 
    lpszShortPath   : out WCHARSTR ; 
    cchBuffer       : in DWORD)
                      return DWORD;
#pragma convention(GetShortPathNameW,system);
#pragma import(GetShortPathNameW,'GetShortPathNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetShortPathName;
  GetShortPathNameW 
#end GetShortPathName;
#else;
#template GetShortPathName;
  GetShortPathNameA 
#end GetShortPathName;
#end if;

procedure GetLongPathNameA(
    lpszShortPath   : in LPCSTR; 
    lpszLongPath    : out CHARSTR ; 
    cchBuffer       : in DWORD)
                      return DWORD;
#pragma convention(GetLongPathNameA,system);
#pragma import(GetLongPathNameA,'GetLongPathNameA','kernel32.dll');

procedure GetLongPathNameW(
    lpszShortPath   : in LPCWSTR; 
    lpszLongPath    : out WCHARSTR ; 
    cchBuffer       : in DWORD)
                      return DWORD;
#pragma convention(GetLongPathNameW,system);
#pragma import(GetLongPathNameW,'GetLongPathNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetLongPathName;
  GetLongPathNameW 
#end GetLongPathName;
#else;
#template GetLongPathName;
  GetLongPathNameA 
#end GetLongPathName;
#end if;

procedure GetProcessAffinityMask(
    hProcess        : in t_HANDLE; 
    lpProcessAffinityMask : out ULONG_PTR ; 
    lpSystemAffinityMask : out ULONG_PTR )
                      return BOOL;
#pragma convention(GetProcessAffinityMask,system);
#pragma import(GetProcessAffinityMask,'GetProcessAffinityMask','kernel32.dll');

procedure SetProcessAffinityMask(
    hProcess        : in t_HANDLE; 
    dwProcessAffinityMask : in DWORD_PTR)
                      return BOOL;
#pragma convention(SetProcessAffinityMask,system);
#pragma import(SetProcessAffinityMask,'SetProcessAffinityMask','kernel32.dll');

procedure GetProcessHandleCount(
    hProcess        : in t_HANDLE; 
    pdwHandleCount  : out DWORD )
                      return BOOL;
#pragma convention(GetProcessHandleCount,system);
#pragma import(GetProcessHandleCount,'GetProcessHandleCount','kernel32.dll');

procedure GetProcessTimes(
    hProcess        : in t_HANDLE; 
    lpCreationTime  : out _FILETIME; 
    lpExitTime      : out _FILETIME; 
    lpKernelTime    : out _FILETIME; 
    lpUserTime      : out _FILETIME)
                      return BOOL;
#pragma convention(GetProcessTimes,system);
#pragma import(GetProcessTimes,'GetProcessTimes','kernel32.dll');

procedure GetProcessIoCounters(
    hProcess        : in t_HANDLE; 
    lpIoCounters    : out IO_COUNTERS )
                      return BOOL;
#pragma convention(GetProcessIoCounters,system);
#pragma import(GetProcessIoCounters,'GetProcessIoCounters','kernel32.dll');

procedure GetProcessWorkingSetSize(
    hProcess        : in t_HANDLE; 
    lpMinimumWorkingSetSize : out ULONG_PTR ; 
    lpMaximumWorkingSetSize : out ULONG_PTR )
                      return BOOL;
#pragma convention(GetProcessWorkingSetSize,system);
#pragma import(GetProcessWorkingSetSize,'GetProcessWorkingSetSize','kernel32.dll');

procedure GetProcessWorkingSetSizeEx(
    hProcess        : in t_HANDLE; 
    lpMinimumWorkingSetSize : out ULONG_PTR ; 
    lpMaximumWorkingSetSize : out ULONG_PTR ; 
    Flags           : out DWORD )
                      return BOOL;
#pragma convention(GetProcessWorkingSetSizeEx,system);
#pragma import(GetProcessWorkingSetSizeEx,'GetProcessWorkingSetSizeEx','kernel32.dll');

procedure SetProcessWorkingSetSize(
    hProcess        : in t_HANDLE; 
    dwMinimumWorkingSetSize : in SIZE_T; 
    dwMaximumWorkingSetSize : in SIZE_T)
                      return BOOL;
#pragma convention(SetProcessWorkingSetSize,system);
#pragma import(SetProcessWorkingSetSize,'SetProcessWorkingSetSize','kernel32.dll');

procedure SetProcessWorkingSetSizeEx(
    hProcess        : in t_HANDLE; 
    dwMinimumWorkingSetSize : in SIZE_T; 
    dwMaximumWorkingSetSize : in SIZE_T; 
    Flags           : in DWORD)
                      return BOOL;
#pragma convention(SetProcessWorkingSetSizeEx,system);
#pragma import(SetProcessWorkingSetSizeEx,'SetProcessWorkingSetSizeEx','kernel32.dll');

procedure OpenProcess(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    dwProcessId     : in DWORD)
                      return t_HANDLE;
#pragma convention(OpenProcess,system);
#pragma import(OpenProcess,'OpenProcess','kernel32.dll');

procedure GetCurrentProcess
                      return t_HANDLE;
#pragma convention(GetCurrentProcess,system);
#pragma import(GetCurrentProcess,'GetCurrentProcess','kernel32.dll');

procedure GetCurrentProcessId
                      return DWORD;
#pragma convention(GetCurrentProcessId,system);
#pragma import(GetCurrentProcessId,'GetCurrentProcessId','kernel32.dll');

procedure ExitProcess(
    uExitCode       : in UINT);
#pragma convention(ExitProcess,system);
#pragma import(ExitProcess,'ExitProcess','kernel32.dll');

procedure TerminateProcess(
    hProcess        : in t_HANDLE; 
    uExitCode       : in UINT)
                      return BOOL;
#pragma convention(TerminateProcess,system);
#pragma import(TerminateProcess,'TerminateProcess','kernel32.dll');

procedure GetExitCodeProcess(
    hProcess        : in t_HANDLE; 
    lpExitCode      : out DWORD )
                      return BOOL;
#pragma convention(GetExitCodeProcess,system);
#pragma import(GetExitCodeProcess,'GetExitCodeProcess','kernel32.dll');

type
t_005=signed 32;

procedure FatalExit(
    ExitCode        : in t_005);
#pragma convention(FatalExit,system);
#pragma import(FatalExit,'FatalExit','kernel32.dll');

procedure GetEnvironmentStrings
                      return LPSTR;
#pragma convention(GetEnvironmentStrings,system);
#pragma import(GetEnvironmentStrings,'GetEnvironmentStrings','kernel32.dll');

procedure GetEnvironmentStringsW
                      return LPWSTR;
#pragma convention(GetEnvironmentStringsW,system);
#pragma import(GetEnvironmentStringsW,'GetEnvironmentStringsW','kernel32.dll');

#if #declared UNICODE; then;
#template GetEnvironmentStrings;
  GetEnvironmentStringsW 
#end GetEnvironmentStrings;
#else;
#template GetEnvironmentStringsA;
  GetEnvironmentStrings 
#end GetEnvironmentStringsA;
#end if;

procedure SetEnvironmentStringsA(
    NewEnvironment  : in LPSTR)
                      return BOOL;
#pragma convention(SetEnvironmentStringsA,system);
#pragma import(SetEnvironmentStringsA,'SetEnvironmentStringsA','kernel32.dll');

procedure SetEnvironmentStringsW(
    NewEnvironment  : in LPWSTR)
                      return BOOL;
#pragma convention(SetEnvironmentStringsW,system);
#pragma import(SetEnvironmentStringsW,'SetEnvironmentStringsW','kernel32.dll');

#if #declared UNICODE; then;
#template SetEnvironmentStrings;
  SetEnvironmentStringsW 
#end SetEnvironmentStrings;
#else;
#template SetEnvironmentStrings;
  SetEnvironmentStringsA 
#end SetEnvironmentStrings;
#end if;

procedure FreeEnvironmentStringsA(
    _001            : in LPSTR)
                      return BOOL;
#pragma convention(FreeEnvironmentStringsA,system);
#pragma import(FreeEnvironmentStringsA,'FreeEnvironmentStringsA','kernel32.dll');

procedure FreeEnvironmentStringsW(
    _001            : in LPWSTR)
                      return BOOL;
#pragma convention(FreeEnvironmentStringsW,system);
#pragma import(FreeEnvironmentStringsW,'FreeEnvironmentStringsW','kernel32.dll');

#if #declared UNICODE; then;
#template FreeEnvironmentStrings;
  FreeEnvironmentStringsW 
#end FreeEnvironmentStrings;
#else;
#template FreeEnvironmentStrings;
  FreeEnvironmentStringsA 
#end FreeEnvironmentStrings;
#end if;

type
t_006=^ULONG_PTR for machine_pointer use true;

procedure RaiseException(
    dwExceptionCode : in DWORD; 
    dwExceptionFlags : in DWORD; 
    nNumberOfArguments : in DWORD; 
    lpArguments     : in t_006);
#pragma convention(RaiseException,system);
#pragma import(RaiseException,'RaiseException','kernel32.dll');

type
t_007=^_EXCEPTION_POINTERS for machine_pointer use true;

procedure UnhandledExceptionFilter(
    ExceptionInfo   : in t_007)
                      return LONG;
#pragma convention(UnhandledExceptionFilter,system);
#pragma import(UnhandledExceptionFilter,'UnhandledExceptionFilter','kernel32.dll');

type
t_008=^_EXCEPTION_POINTERS for machine_pointer use true;

PTOP_LEVEL_EXCEPTION_FILTER = ^procedure (
    ExceptionInfo   : t_008)
                      return LONG for machine_pointer use true;
type
LPTOP_LEVEL_EXCEPTION_FILTER = PTOP_LEVEL_EXCEPTION_FILTER;
procedure SetUnhandledExceptionFilter(
    lpTopLevelExceptionFilter : in LPTOP_LEVEL_EXCEPTION_FILTER)
                      return LPTOP_LEVEL_EXCEPTION_FILTER;
#pragma convention(SetUnhandledExceptionFilter,system);
#pragma import(SetUnhandledExceptionFilter,'SetUnhandledExceptionFilter','kernel32.dll');

-- 
--  Fiber creation flags
-- 
const
  FIBER_FLAG_FLOAT_SWITCH= $01;

procedure CreateFiber(
    dwStackSize     : in SIZE_T; 
    lpStartAddress  : in LPFIBER_START_ROUTINE; 
    lpParameter     : in LPVOID)
                      return LPVOID;
#pragma convention(CreateFiber,system);
#pragma import(CreateFiber,'CreateFiber','kernel32.dll');

procedure CreateFiberEx(
    dwStackCommitSize : SIZE_T; 
    dwStackReserveSize : SIZE_T; 
    dwFlags         : DWORD; 
    lpStartAddress  : LPFIBER_START_ROUTINE; 
    lpParameter     : LPVOID)
                      return LPVOID;
#pragma convention(CreateFiberEx,system);
#pragma import(CreateFiberEx,'CreateFiberEx','kernel32.dll');

procedure DeleteFiber(
    lpFiber         : in LPVOID);
#pragma convention(DeleteFiber,system);
#pragma import(DeleteFiber,'DeleteFiber','kernel32.dll');

procedure ConvertThreadToFiber(
    lpParameter     : in LPVOID)
                      return LPVOID;
#pragma convention(ConvertThreadToFiber,system);
#pragma import(ConvertThreadToFiber,'ConvertThreadToFiber','kernel32.dll');

procedure ConvertThreadToFiberEx(
    lpParameter     : in LPVOID; 
    dwFlags         : in DWORD)
                      return LPVOID;
#pragma convention(ConvertThreadToFiberEx,system);
#pragma import(ConvertThreadToFiberEx,'ConvertThreadToFiberEx','kernel32.dll');

procedure ConvertFiberToThread
                      return BOOL;
#pragma convention(ConvertFiberToThread,system);
#pragma import(ConvertFiberToThread,'ConvertFiberToThread','kernel32.dll');

procedure SwitchToFiber(
    lpFiber         : in LPVOID);
#pragma convention(SwitchToFiber,system);
#pragma import(SwitchToFiber,'SwitchToFiber','kernel32.dll');

procedure SwitchToThread
                      return BOOL;
#pragma convention(SwitchToThread,system);
#pragma import(SwitchToThread,'SwitchToThread','kernel32.dll');

procedure CreateThread(
    lpThreadAttributes : in LPSECURITY_ATTRIBUTES; 
    dwStackSize     : in SIZE_T; 
    lpStartAddress  : in LPTHREAD_START_ROUTINE; 
    lpParameter     : in LPVOID; 
    dwCreationFlags : in DWORD; 
    lpThreadId      : out DWORD )
                      return t_HANDLE;
#pragma convention(CreateThread,system);
#pragma import(CreateThread,'CreateThread','kernel32.dll');

procedure CreateRemoteThread(
    hProcess        : in t_HANDLE; 
    lpThreadAttributes : in LPSECURITY_ATTRIBUTES; 
    dwStackSize     : in SIZE_T; 
    lpStartAddress  : in LPTHREAD_START_ROUTINE; 
    lpParameter     : in LPVOID; 
    dwCreationFlags : in DWORD; 
    lpThreadId      : out DWORD )
                      return t_HANDLE;
#pragma convention(CreateRemoteThread,system);
#pragma import(CreateRemoteThread,'CreateRemoteThread','kernel32.dll');

procedure GetCurrentThread
                      return t_HANDLE;
#pragma convention(GetCurrentThread,system);
#pragma import(GetCurrentThread,'GetCurrentThread','kernel32.dll');

procedure GetCurrentThreadId
                      return DWORD;
#pragma convention(GetCurrentThreadId,system);
#pragma import(GetCurrentThreadId,'GetCurrentThreadId','kernel32.dll');

procedure GetProcessIdOfThread(
    Thread          : t_HANDLE)
                      return DWORD;
#pragma convention(GetProcessIdOfThread,system);
#pragma import(GetProcessIdOfThread,'GetProcessIdOfThread','kernel32.dll');

procedure GetThreadId(
    Thread          : t_HANDLE)
                      return DWORD;
#pragma convention(GetThreadId,system);
#pragma import(GetThreadId,'GetThreadId','kernel32.dll');

procedure GetProcessId(
    Process         : t_HANDLE)
                      return DWORD;
#pragma convention(GetProcessId,system);
#pragma import(GetProcessId,'GetProcessId','kernel32.dll');

procedure GetCurrentProcessorNumber
                      return DWORD;
#pragma convention(GetCurrentProcessorNumber,system);
#pragma import(GetCurrentProcessorNumber,'GetCurrentProcessorNumber','kernel32.dll');

procedure SetThreadAffinityMask(
    hThread         : in t_HANDLE; 
    dwThreadAffinityMask : in DWORD_PTR)
                      return DWORD_PTR;
#pragma convention(SetThreadAffinityMask,system);
#pragma import(SetThreadAffinityMask,'SetThreadAffinityMask','kernel32.dll');

procedure SetThreadIdealProcessor(
    hThread         : in t_HANDLE; 
    dwIdealProcessor : in DWORD)
                      return DWORD;
#pragma convention(SetThreadIdealProcessor,system);
#pragma import(SetThreadIdealProcessor,'SetThreadIdealProcessor','kernel32.dll');

procedure SetProcessPriorityBoost(
    hProcess        : in t_HANDLE; 
    bDisablePriorityBoost : in BOOL)
                      return BOOL;
#pragma convention(SetProcessPriorityBoost,system);
#pragma import(SetProcessPriorityBoost,'SetProcessPriorityBoost','kernel32.dll');

procedure GetProcessPriorityBoost(
    hProcess        : in t_HANDLE; 
    pDisablePriorityBoost : out BOOL )
                      return BOOL;
#pragma convention(GetProcessPriorityBoost,system);
#pragma import(GetProcessPriorityBoost,'GetProcessPriorityBoost','kernel32.dll');

procedure RequestWakeupLatency(
    latency         : in LATENCY_TIME)
                      return BOOL;
#pragma convention(RequestWakeupLatency,system);
#pragma import(RequestWakeupLatency,'RequestWakeupLatency','kernel32.dll');

procedure IsSystemResumeAutomatic
                      return BOOL;
#pragma convention(IsSystemResumeAutomatic,system);
#pragma import(IsSystemResumeAutomatic,'IsSystemResumeAutomatic','kernel32.dll');

procedure OpenThread(
    dwDesiredAccess : DWORD; 
    bInheritHandle  : BOOL; 
    dwThreadId      : DWORD)
                      return t_HANDLE;
#pragma convention(OpenThread,system);
#pragma import(OpenThread,'OpenThread','kernel32.dll');

type
t_009=signed 32;

procedure SetThreadPriority(
    hThread         : in t_HANDLE; 
    nPriority       : in t_009)
                      return BOOL;
#pragma convention(SetThreadPriority,system);
#pragma import(SetThreadPriority,'SetThreadPriority','kernel32.dll');

procedure SetThreadPriorityBoost(
    hThread         : in t_HANDLE; 
    bDisablePriorityBoost : in BOOL)
                      return BOOL;
#pragma convention(SetThreadPriorityBoost,system);
#pragma import(SetThreadPriorityBoost,'SetThreadPriorityBoost','kernel32.dll');

procedure GetThreadPriorityBoost(
    hThread         : in t_HANDLE; 
    pDisablePriorityBoost : out BOOL )
                      return BOOL;
#pragma convention(GetThreadPriorityBoost,system);
#pragma import(GetThreadPriorityBoost,'GetThreadPriorityBoost','kernel32.dll');

type
  t_010 = signed 32;

procedure GetThreadPriority(
    hThread         : in t_HANDLE)
                      return t_010;
#pragma convention(GetThreadPriority,system);
#pragma import(GetThreadPriority,'GetThreadPriority','kernel32.dll');

procedure GetThreadTimes(
    hThread         : in t_HANDLE; 
    lpCreationTime  : out _FILETIME; 
    lpExitTime      : out _FILETIME; 
    lpKernelTime    : out _FILETIME; 
    lpUserTime      : out _FILETIME)
                      return BOOL;
#pragma convention(GetThreadTimes,system);
#pragma import(GetThreadTimes,'GetThreadTimes','kernel32.dll');

procedure GetThreadIOPendingFlag(
    hThread         : in t_HANDLE; 
    lpIOIsPending   : out BOOL )
                      return BOOL;
#pragma convention(GetThreadIOPendingFlag,system);
#pragma import(GetThreadIOPendingFlag,'GetThreadIOPendingFlag','kernel32.dll');

procedure ExitThread(
    dwExitCode      : in DWORD);
#pragma convention(ExitThread,system);
#pragma import(ExitThread,'ExitThread','kernel32.dll');

procedure TerminateThread(
    hThread         : in t_HANDLE; 
    dwExitCode      : in DWORD)
                      return BOOL;
#pragma convention(TerminateThread,system);
#pragma import(TerminateThread,'TerminateThread','kernel32.dll');

procedure GetExitCodeThread(
    hThread         : in t_HANDLE; 
    lpExitCode      : out DWORD )
                      return BOOL;
#pragma convention(GetExitCodeThread,system);
#pragma import(GetExitCodeThread,'GetExitCodeThread','kernel32.dll');

procedure GetThreadSelectorEntry(
    hThread         : in t_HANDLE; 
    dwSelector      : in DWORD; 
    lpSelectorEntry : out {!}LPLDT_ENTRY)
                      return BOOL;
#pragma convention(GetThreadSelectorEntry,system);
#pragma import(GetThreadSelectorEntry,'GetThreadSelectorEntry','kernel32.dll');

procedure SetThreadExecutionState(
    esFlags         : in EXECUTION_STATE)
                      return EXECUTION_STATE;
#pragma convention(SetThreadExecutionState,system);
#pragma import(SetThreadExecutionState,'SetThreadExecutionState','kernel32.dll');

procedure GetLastError
                      return DWORD;
#pragma convention(GetLastError,system);
#pragma import(GetLastError,'GetLastError','kernel32.dll');

procedure SetLastError(
    dwErrCode       : in DWORD);
#pragma convention(SetLastError,system);
#pragma import(SetLastError,'SetLastError','kernel32.dll');

--  RC warns because "WINBASE_DECLARE_RESTORE_LAST_ERROR" is a bit long.
-- #if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)
procedure GetOverlappedResult(
    hFile           : in t_HANDLE; 
    lpOverlapped    : in p_OVERLAPPED; 
    lpNumberOfBytesTransferred : out DWORD ; 
    bWait           : in BOOL)
                      return BOOL;
#pragma convention(GetOverlappedResult,system);
#pragma import(GetOverlappedResult,'GetOverlappedResult','kernel32.dll');

procedure CreateIoCompletionPort(
    FileHandle      : in t_HANDLE; 
    ExistingCompletionPort : in t_HANDLE; 
    CompletionKey   : in ULONG_PTR; 
    NumberOfConcurrentThreads : in DWORD)
                      return t_HANDLE;
#pragma convention(CreateIoCompletionPort,system);
#pragma import(CreateIoCompletionPort,'CreateIoCompletionPort','kernel32.dll');

procedure GetQueuedCompletionStatus(
    CompletionPort  : in t_HANDLE; 
    lpNumberOfBytesTransferred : out DWORD ; 
    lpCompletionKey : out ULONG_PTR; 
    lpOverlapped    : out p_OVERLAPPED; 
    dwMilliseconds  : in DWORD)
                      return BOOL;
#pragma convention(GetQueuedCompletionStatus,system);
#pragma import(GetQueuedCompletionStatus,'GetQueuedCompletionStatus','kernel32.dll');

procedure PostQueuedCompletionStatus(
    CompletionPort  : in t_HANDLE; 
    dwNumberOfBytesTransferred : in DWORD; 
    dwCompletionKey : in ULONG_PTR; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(PostQueuedCompletionStatus,system);
#pragma import(PostQueuedCompletionStatus,'PostQueuedCompletionStatus','kernel32.dll');

const
  SEM_FAILCRITICALERRORS= $01;

const
  SEM_NOGPFAULTERRORBOX= $02;

const
  SEM_NOALIGNMENTFAULTEXCEPT= $04;

const
  SEM_NOOPENFILEERRORBOX= $8000;

procedure SetErrorMode(
    uMode           : in UINT)
                      return UINT;
#pragma convention(SetErrorMode,system);
#pragma import(SetErrorMode,'SetErrorMode','kernel32.dll');

procedure ReadProcessMemory(
    hProcess        : in t_HANDLE; 
    lpBaseAddress   : in LPCVOID; 
    lpBuffer        : out unchecked ; 
    nSize           : in SIZE_T; 
    lpNumberOfBytesRead : out SIZE_T)
                      return BOOL;
#pragma convention(ReadProcessMemory,system);
#pragma import(ReadProcessMemory,'ReadProcessMemory','kernel32.dll');

procedure WriteProcessMemory(
    hProcess        : in t_HANDLE; 
    lpBaseAddress   : in LPVOID; 
    lpBuffer        : in LPCVOID; 
    nSize           : in SIZE_T; 
    lpNumberOfBytesWritten : out SIZE_T)
                      return BOOL;
#pragma convention(WriteProcessMemory,system);
#pragma import(WriteProcessMemory,'WriteProcessMemory','kernel32.dll');

procedure GetThreadContext(
    hThread         : in t_HANDLE; 
    lpContext       : in out {!}p_CONTEXT)
                      return BOOL;
#pragma convention(GetThreadContext,system);
#pragma import(GetThreadContext,'GetThreadContext','kernel32.dll');

type
t_011=^CONTEXT for machine_pointer use true;

procedure SetThreadContext(
    hThread         : in t_HANDLE; 
    lpContext       : in t_011)
                      return BOOL;
#pragma convention(SetThreadContext,system);
#pragma import(SetThreadContext,'SetThreadContext','kernel32.dll');

procedure SuspendThread(
    hThread         : in t_HANDLE)
                      return DWORD;
#pragma convention(SuspendThread,system);
#pragma import(SuspendThread,'SuspendThread','kernel32.dll');

procedure ResumeThread(
    hThread         : in t_HANDLE)
                      return DWORD;
#pragma convention(ResumeThread,system);
#pragma import(ResumeThread,'ResumeThread','kernel32.dll');

type
PAPCFUNC          = ^procedure (
    dwParam         : ULONG_PTR) for machine_pointer use true;
procedure QueueUserAPC(
    pfnAPC          : in PAPCFUNC; 
    hThread         : in t_HANDLE; 
    dwData          : in ULONG_PTR)
                      return DWORD;
#pragma convention(QueueUserAPC,system);
#pragma import(QueueUserAPC,'QueueUserAPC','kernel32.dll');

procedure IsDebuggerPresent
                      return BOOL;
#pragma convention(IsDebuggerPresent,system);
#pragma import(IsDebuggerPresent,'IsDebuggerPresent','kernel32.dll');

procedure CheckRemoteDebuggerPresent(
    hProcess        : in t_HANDLE; 
    pbDebuggerPresent : out BOOL )
                      return BOOL;
#pragma convention(CheckRemoteDebuggerPresent,system);
#pragma import(CheckRemoteDebuggerPresent,'CheckRemoteDebuggerPresent','kernel32.dll');

procedure DebugBreak;
#pragma convention(DebugBreak,system);
#pragma import(DebugBreak,'DebugBreak','kernel32.dll');

procedure WaitForDebugEvent(
    lpDebugEvent    : in LPDEBUG_EVENT; 
    dwMilliseconds  : in DWORD)
                      return BOOL;
#pragma convention(WaitForDebugEvent,system);
#pragma import(WaitForDebugEvent,'WaitForDebugEvent','kernel32.dll');

procedure ContinueDebugEvent(
    dwProcessId     : in DWORD; 
    dwThreadId      : in DWORD; 
    dwContinueStatus : in DWORD)
                      return BOOL;
#pragma convention(ContinueDebugEvent,system);
#pragma import(ContinueDebugEvent,'ContinueDebugEvent','kernel32.dll');

procedure DebugActiveProcess(
    dwProcessId     : in DWORD)
                      return BOOL;
#pragma convention(DebugActiveProcess,system);
#pragma import(DebugActiveProcess,'DebugActiveProcess','kernel32.dll');

procedure DebugActiveProcessStop(
    dwProcessId     : in DWORD)
                      return BOOL;
#pragma convention(DebugActiveProcessStop,system);
#pragma import(DebugActiveProcessStop,'DebugActiveProcessStop','kernel32.dll');

procedure DebugSetProcessKillOnExit(
    KillOnExit      : in BOOL)
                      return BOOL;
#pragma convention(DebugSetProcessKillOnExit,system);
#pragma import(DebugSetProcessKillOnExit,'DebugSetProcessKillOnExit','kernel32.dll');

procedure DebugBreakProcess(
    Process         : in t_HANDLE)
                      return BOOL;
#pragma convention(DebugBreakProcess,system);
#pragma import(DebugBreakProcess,'DebugBreakProcess','kernel32.dll');

procedure InitializeCriticalSection(
    lpCriticalSection : out {!}LPCRITICAL_SECTION);
#pragma convention(InitializeCriticalSection,system);
#pragma import(InitializeCriticalSection,'InitializeCriticalSection','kernel32.dll');

procedure EnterCriticalSection(
    lpCriticalSection : in out {!}LPCRITICAL_SECTION);
#pragma convention(EnterCriticalSection,system);
#pragma import(EnterCriticalSection,'EnterCriticalSection','kernel32.dll');

procedure LeaveCriticalSection(
    lpCriticalSection : in out {!}LPCRITICAL_SECTION);
#pragma convention(LeaveCriticalSection,system);
#pragma import(LeaveCriticalSection,'LeaveCriticalSection','kernel32.dll');

procedure InitializeCriticalSectionAndSpinCount(
    lpCriticalSection : in out {!}LPCRITICAL_SECTION; 
    dwSpinCount     : in DWORD)
                      return BOOL;
#pragma convention(InitializeCriticalSectionAndSpinCount,system);
#pragma import(InitializeCriticalSectionAndSpinCount,'InitializeCriticalSectionAndSpinCount','kernel32.dll');

procedure SetCriticalSectionSpinCount(
    lpCriticalSection : in out {!}LPCRITICAL_SECTION; 
    dwSpinCount     : in DWORD)
                      return DWORD;
#pragma convention(SetCriticalSectionSpinCount,system);
#pragma import(SetCriticalSectionSpinCount,'SetCriticalSectionSpinCount','kernel32.dll');

procedure TryEnterCriticalSection(
    lpCriticalSection : in out {!}LPCRITICAL_SECTION)
                      return BOOL;
#pragma convention(TryEnterCriticalSection,system);
#pragma import(TryEnterCriticalSection,'TryEnterCriticalSection','kernel32.dll');

procedure DeleteCriticalSection(
    lpCriticalSection : in out {!}LPCRITICAL_SECTION);
#pragma convention(DeleteCriticalSection,system);
#pragma import(DeleteCriticalSection,'DeleteCriticalSection','kernel32.dll');

procedure SetEvent(
    hEvent          : in t_HANDLE)
                      return BOOL;
#pragma convention(SetEvent,system);
#pragma import(SetEvent,'SetEvent','kernel32.dll');

procedure ResetEvent(
    hEvent          : in t_HANDLE)
                      return BOOL;
#pragma convention(ResetEvent,system);
#pragma import(ResetEvent,'ResetEvent','kernel32.dll');

procedure PulseEvent(
    hEvent          : in t_HANDLE)
                      return BOOL;
#pragma convention(PulseEvent,system);
#pragma import(PulseEvent,'PulseEvent','kernel32.dll');

type
t_012=signed 32 ;

procedure ReleaseSemaphore(
    hSemaphore      : in t_HANDLE; 
    lReleaseCount   : in LONG; 
    lpPreviousCount : out t_012)
                      return BOOL;
#pragma convention(ReleaseSemaphore,system);
#pragma import(ReleaseSemaphore,'ReleaseSemaphore','kernel32.dll');

procedure ReleaseMutex(
    hMutex          : in t_HANDLE)
                      return BOOL;
#pragma convention(ReleaseMutex,system);
#pragma import(ReleaseMutex,'ReleaseMutex','kernel32.dll');

procedure WaitForSingleObject(
    hHandle         : in t_HANDLE; 
    dwMilliseconds  : in DWORD)
                      return DWORD;
#pragma convention(WaitForSingleObject,system);
#pragma import(WaitForSingleObject,'WaitForSingleObject','kernel32.dll');

type
t_013=^t_HANDLE for machine_pointer use true;

procedure WaitForMultipleObjects(
    nCount          : in DWORD; 
    lpHandles       : in t_013; 
    bWaitAll        : in BOOL; 
    dwMilliseconds  : in DWORD)
                      return DWORD;
#pragma convention(WaitForMultipleObjects,system);
#pragma import(WaitForMultipleObjects,'WaitForMultipleObjects','kernel32.dll');

procedure Sleep(
    dwMilliseconds  : in DWORD);
#pragma convention(Sleep,system);
#pragma import(Sleep,'Sleep','kernel32.dll');

procedure LoadResource(
    hModule         : in t_HMODULE; 
    hResInfo        : in HRSRC)
                      return t_HGLOBAL;
#pragma convention(LoadResource,system);
#pragma import(LoadResource,'LoadResource','kernel32.dll');

procedure SizeofResource(
    hModule         : in t_HMODULE; 
    hResInfo        : in HRSRC)
                      return DWORD;
#pragma convention(SizeofResource,system);
#pragma import(SizeofResource,'SizeofResource','kernel32.dll');

procedure GlobalDeleteAtom(
    nAtom           : in ATOM)
                      return ATOM;
#pragma convention(GlobalDeleteAtom,system);
#pragma import(GlobalDeleteAtom,'GlobalDeleteAtom','kernel32.dll');

procedure InitAtomTable(
    nSize           : in DWORD)
                      return BOOL;
#pragma convention(InitAtomTable,system);
#pragma import(InitAtomTable,'InitAtomTable','kernel32.dll');

procedure DeleteAtom(
    nAtom           : in ATOM)
                      return ATOM;
#pragma convention(DeleteAtom,system);
#pragma import(DeleteAtom,'DeleteAtom','kernel32.dll');

procedure SetHandleCount(
    uNumber         : in UINT)
                      return UINT;
#pragma convention(SetHandleCount,system);
#pragma import(SetHandleCount,'SetHandleCount','kernel32.dll');

procedure GetLogicalDrives
                      return DWORD;
#pragma convention(GetLogicalDrives,system);
#pragma import(GetLogicalDrives,'GetLogicalDrives','kernel32.dll');

procedure LockFile(
    hFile           : in t_HANDLE; 
    dwFileOffsetLow : in DWORD; 
    dwFileOffsetHigh : in DWORD; 
    nNumberOfBytesToLockLow : in DWORD; 
    nNumberOfBytesToLockHigh : in DWORD)
                      return BOOL;
#pragma convention(LockFile,system);
#pragma import(LockFile,'LockFile','kernel32.dll');

procedure UnlockFile(
    hFile           : in t_HANDLE; 
    dwFileOffsetLow : in DWORD; 
    dwFileOffsetHigh : in DWORD; 
    nNumberOfBytesToUnlockLow : in DWORD; 
    nNumberOfBytesToUnlockHigh : in DWORD)
                      return BOOL;
#pragma convention(UnlockFile,system);
#pragma import(UnlockFile,'UnlockFile','kernel32.dll');

procedure LockFileEx(
    hFile           : in t_HANDLE; 
    dwFlags         : in DWORD; 
    dwReserved      : in DWORD; 
    nNumberOfBytesToLockLow : in DWORD; 
    nNumberOfBytesToLockHigh : in DWORD; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(LockFileEx,system);
#pragma import(LockFileEx,'LockFileEx','kernel32.dll');

const
  LOCKFILE_FAIL_IMMEDIATELY= $01;

const
  LOCKFILE_EXCLUSIVE_LOCK= $02;

procedure UnlockFileEx(
    hFile           : in t_HANDLE; 
    dwReserved      : in DWORD; 
    nNumberOfBytesToUnlockLow : in DWORD; 
    nNumberOfBytesToUnlockHigh : in DWORD; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(UnlockFileEx,system);
#pragma import(UnlockFileEx,'UnlockFileEx','kernel32.dll');

type
  _BY_HANDLE_FILE_INFORMATION = record
dwFileAttributes : DWORD;
ftCreationTime  : t_FILETIME;
ftLastAccessTime : t_FILETIME;
ftLastWriteTime : t_FILETIME;
dwVolumeSerialNumber : DWORD;
nFileSizeHigh   : DWORD;
nFileSizeLow    : DWORD;
nNumberOfLinks  : DWORD;
nFileIndexHigh  : DWORD;
nFileIndexLow   : DWORD;
  end record;
  BY_HANDLE_FILE_INFORMATION = _BY_HANDLE_FILE_INFORMATION;
  PBY_HANDLE_FILE_INFORMATION = ^_BY_HANDLE_FILE_INFORMATION;
  LPBY_HANDLE_FILE_INFORMATION = ^_BY_HANDLE_FILE_INFORMATION;

procedure GetFileInformationByHandle(
    hFile           : in t_HANDLE; 
    lpFileInformation : out _BY_HANDLE_FILE_INFORMATION)
                      return BOOL;
#pragma convention(GetFileInformationByHandle,system);
#pragma import(GetFileInformationByHandle,'GetFileInformationByHandle','kernel32.dll');

procedure GetFileType(
    hFile           : in t_HANDLE)
                      return DWORD;
#pragma convention(GetFileType,system);
#pragma import(GetFileType,'GetFileType','kernel32.dll');

procedure GetFileSize(
    hFile           : in t_HANDLE; 
    lpFileSizeHigh  : in PDWORD)
                      return DWORD;
#pragma convention(GetFileSize,system);
#pragma import(GetFileSize,'GetFileSize','kernel32.dll');

procedure GetFileSizeEx(
    hFile           : t_HANDLE; 
    lpFileSize      : PLARGE_INTEGER)
                      return BOOL;
#pragma convention(GetFileSizeEx,system);
#pragma import(GetFileSizeEx,'GetFileSizeEx','kernel32.dll');

procedure GetStdHandle(
    nStdHandle      : in DWORD)
                      return t_HANDLE;
#pragma convention(GetStdHandle,system);
#pragma import(GetStdHandle,'GetStdHandle','kernel32.dll');

procedure SetStdHandle(
    nStdHandle      : in DWORD; 
    hHandle         : in t_HANDLE)
                      return BOOL;
#pragma convention(SetStdHandle,system);
#pragma import(SetStdHandle,'SetStdHandle','kernel32.dll');

procedure WriteFile(
    hFile           : in t_HANDLE; 
    lpBuffer        : in LPCVOID; 
    nNumberOfBytesToWrite : in DWORD; 
    lpNumberOfBytesWritten : out DWORD ; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(WriteFile,system);
#pragma import(WriteFile,'WriteFile','kernel32.dll');

procedure ReadFile(
    hFile           : in t_HANDLE; 
    lpBuffer        : out unchecked ; 
    nNumberOfBytesToRead : in DWORD; 
    lpNumberOfBytesRead : out DWORD ; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(ReadFile,system);
#pragma import(ReadFile,'ReadFile','kernel32.dll');

procedure FlushFileBuffers(
    hFile           : in t_HANDLE)
                      return BOOL;
#pragma convention(FlushFileBuffers,system);
#pragma import(FlushFileBuffers,'FlushFileBuffers','kernel32.dll');

procedure DeviceIoControl(
    hDevice         : in t_HANDLE; 
    dwIoControlCode : in DWORD; 
    lpInBuffer      : in LPVOID; 
    nInBufferSize   : in DWORD; 
    lpOutBuffer     : out unchecked ; 
    nOutBufferSize  : in DWORD; 
    lpBytesReturned : out DWORD ; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(DeviceIoControl,system);
#pragma import(DeviceIoControl,'DeviceIoControl','kernel32.dll');

procedure RequestDeviceWakeup(
    hDevice         : in t_HANDLE)
                      return BOOL;
#pragma convention(RequestDeviceWakeup,system);
#pragma import(RequestDeviceWakeup,'RequestDeviceWakeup','kernel32.dll');

procedure CancelDeviceWakeupRequest(
    hDevice         : in t_HANDLE)
                      return BOOL;
#pragma convention(CancelDeviceWakeupRequest,system);
#pragma import(CancelDeviceWakeupRequest,'CancelDeviceWakeupRequest','kernel32.dll');

procedure GetDevicePowerState(
    hDevice         : in t_HANDLE; 
    pfOn            : out BOOL)
                      return BOOL;
#pragma convention(GetDevicePowerState,system);
#pragma import(GetDevicePowerState,'GetDevicePowerState','kernel32.dll');

procedure SetMessageWaitingIndicator(
    hMsgIndicator   : in t_HANDLE; 
    ulMsgCount      : in ULONG)
                      return BOOL;
#pragma convention(SetMessageWaitingIndicator,system);
#pragma import(SetMessageWaitingIndicator,'SetMessageWaitingIndicator','kernel32.dll');

procedure SetEndOfFile(
    hFile           : in t_HANDLE)
                      return BOOL;
#pragma convention(SetEndOfFile,system);
#pragma import(SetEndOfFile,'SetEndOfFile','kernel32.dll');

procedure SetFilePointer(
    hFile           : in t_HANDLE; 
    lDistanceToMove : in LONG; 
    lpDistanceToMoveHigh : in PLONG; 
    dwMoveMethod    : in DWORD)
                      return DWORD;
#pragma convention(SetFilePointer,system);
#pragma import(SetFilePointer,'SetFilePointer','kernel32.dll');

procedure SetFilePointerEx(
    hFile           : t_HANDLE; 
    liDistanceToMove : LARGE_INTEGER; 
    lpNewFilePointer : PLARGE_INTEGER; 
    dwMoveMethod    : DWORD)
                      return BOOL;
#pragma convention(SetFilePointerEx,system);
#pragma import(SetFilePointerEx,'SetFilePointerEx','kernel32.dll');

procedure FindClose(
    hFindFile       : in out {!}t_HANDLE)
                      return BOOL;
#pragma convention(FindClose,system);
#pragma import(FindClose,'FindClose','kernel32.dll');

procedure GetFileTime(
    hFile           : in t_HANDLE; 
    lpCreationTime  : out _FILETIME; 
    lpLastAccessTime : out _FILETIME; 
    lpLastWriteTime : out _FILETIME)
                      return BOOL;
#pragma convention(GetFileTime,system);
#pragma import(GetFileTime,'GetFileTime','kernel32.dll');

type
t_014=^t_FILETIME for machine_pointer use true;

t_015=^t_FILETIME for machine_pointer use true;

t_016=^t_FILETIME for machine_pointer use true;

procedure SetFileTime(
    hFile           : in t_HANDLE; 
    lpCreationTime  : in t_014; 
    lpLastAccessTime : in t_015; 
    lpLastWriteTime : in t_016)
                      return BOOL;
#pragma convention(SetFileTime,system);
#pragma import(SetFileTime,'SetFileTime','kernel32.dll');

procedure SetFileValidData(
    hFile           : in t_HANDLE; 
    ValidDataLength : in LONGLONG)
                      return BOOL;
#pragma convention(SetFileValidData,system);
#pragma import(SetFileValidData,'SetFileValidData','kernel32.dll');

procedure SetFileShortNameA(
    hFile           : in t_HANDLE; 
    lpShortName     : in LPCSTR)
                      return BOOL;
#pragma convention(SetFileShortNameA,system);
#pragma import(SetFileShortNameA,'SetFileShortNameA','kernel32.dll');

procedure SetFileShortNameW(
    hFile           : in t_HANDLE; 
    lpShortName     : in LPCWSTR)
                      return BOOL;
#pragma convention(SetFileShortNameW,system);
#pragma import(SetFileShortNameW,'SetFileShortNameW','kernel32.dll');

#if #declared UNICODE; then;
#template SetFileShortName;
  SetFileShortNameW 
#end SetFileShortName;
#else;
#template SetFileShortName;
  SetFileShortNameA 
#end SetFileShortName;
#end if;

procedure CloseHandle(
    hObject         : in t_HANDLE)
                      return BOOL;
#pragma convention(CloseHandle,system);
#pragma import(CloseHandle,'CloseHandle','kernel32.dll');

procedure DuplicateHandle(
    hSourceProcessHandle : in t_HANDLE; 
    hSourceHandle   : in t_HANDLE; 
    hTargetProcessHandle : in t_HANDLE; 
    lpTargetHandle  : out winnt.t_HANDLE ; 
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    dwOptions       : in DWORD)
                      return BOOL;
#pragma convention(DuplicateHandle,system);
#pragma import(DuplicateHandle,'DuplicateHandle','kernel32.dll');

procedure GetHandleInformation(
    hObject         : in t_HANDLE; 
    lpdwFlags       : out DWORD )
                      return BOOL;
#pragma convention(GetHandleInformation,system);
#pragma import(GetHandleInformation,'GetHandleInformation','kernel32.dll');

procedure SetHandleInformation(
    hObject         : in t_HANDLE; 
    dwMask          : in DWORD; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(SetHandleInformation,system);
#pragma import(SetHandleInformation,'SetHandleInformation','kernel32.dll');

const
  HANDLE_FLAG_INHERIT= $01;

const
  HANDLE_FLAG_PROTECT_FROM_CLOSE= $02;

const
  HINSTANCE_ERROR   = 32;

procedure LoadModule(
    lpModuleName    : in LPCSTR; 
    lpParameterBlock : in LPVOID)
                      return DWORD;
#pragma convention(LoadModule,system);
#pragma import(LoadModule,'LoadModule','kernel32.dll');

procedure WinExec(
    lpCmdLine       : in LPCSTR; 
    uCmdShow        : in UINT)
                      return UINT;
#pragma convention(WinExec,system);
#pragma import(WinExec,'WinExec','kernel32.dll');

procedure ClearCommBreak(
    hFile           : in t_HANDLE)
                      return BOOL;
#pragma convention(ClearCommBreak,system);
#pragma import(ClearCommBreak,'ClearCommBreak','kernel32.dll');

procedure ClearCommError(
    hFile           : in t_HANDLE; 
    lpErrors        : out DWORD ; 
    lpStat          : out _COMSTAT)
                      return BOOL;
#pragma convention(ClearCommError,system);
#pragma import(ClearCommError,'ClearCommError','kernel32.dll');

procedure SetupComm(
    hFile           : in t_HANDLE; 
    dwInQueue       : in DWORD; 
    dwOutQueue      : in DWORD)
                      return BOOL;
#pragma convention(SetupComm,system);
#pragma import(SetupComm,'SetupComm','kernel32.dll');

procedure EscapeCommFunction(
    hFile           : in t_HANDLE; 
    dwFunc          : in DWORD)
                      return BOOL;
#pragma convention(EscapeCommFunction,system);
#pragma import(EscapeCommFunction,'EscapeCommFunction','kernel32.dll');

procedure GetCommConfig(
    hCommDev        : in t_HANDLE; 
    lpCC            : out _COMMCONFIG; 
    lpdwSize        : in out DWORD )
                      return BOOL;
#pragma convention(GetCommConfig,system);
#pragma import(GetCommConfig,'GetCommConfig','kernel32.dll');

procedure GetCommMask(
    hFile           : in t_HANDLE; 
    lpEvtMask       : out DWORD )
                      return BOOL;
#pragma convention(GetCommMask,system);
#pragma import(GetCommMask,'GetCommMask','kernel32.dll');

procedure GetCommProperties(
    hFile           : in t_HANDLE; 
    lpCommProp      : out _COMMPROP)
                      return BOOL;
#pragma convention(GetCommProperties,system);
#pragma import(GetCommProperties,'GetCommProperties','kernel32.dll');

procedure GetCommModemStatus(
    hFile           : in t_HANDLE; 
    lpModemStat     : out DWORD )
                      return BOOL;
#pragma convention(GetCommModemStatus,system);
#pragma import(GetCommModemStatus,'GetCommModemStatus','kernel32.dll');

procedure GetCommState(
    hFile           : in t_HANDLE; 
    lpDCB           : out _DCB)
                      return BOOL;
#pragma convention(GetCommState,system);
#pragma import(GetCommState,'GetCommState','kernel32.dll');

procedure GetCommTimeouts(
    hFile           : in t_HANDLE; 
    lpCommTimeouts  : out _COMMTIMEOUTS)
                      return BOOL;
#pragma convention(GetCommTimeouts,system);
#pragma import(GetCommTimeouts,'GetCommTimeouts','kernel32.dll');

procedure PurgeComm(
    hFile           : in t_HANDLE; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(PurgeComm,system);
#pragma import(PurgeComm,'PurgeComm','kernel32.dll');

procedure SetCommBreak(
    hFile           : in t_HANDLE)
                      return BOOL;
#pragma convention(SetCommBreak,system);
#pragma import(SetCommBreak,'SetCommBreak','kernel32.dll');

procedure SetCommConfig(
    hCommDev        : in t_HANDLE; 
    lpCC            : in LPCOMMCONFIG; 
    dwSize          : in DWORD)
                      return BOOL;
#pragma convention(SetCommConfig,system);
#pragma import(SetCommConfig,'SetCommConfig','kernel32.dll');

procedure SetCommMask(
    hFile           : in t_HANDLE; 
    dwEvtMask       : in DWORD)
                      return BOOL;
#pragma convention(SetCommMask,system);
#pragma import(SetCommMask,'SetCommMask','kernel32.dll');

procedure SetCommState(
    hFile           : in t_HANDLE; 
    lpDCB           : in p_DCB)
                      return BOOL;
#pragma convention(SetCommState,system);
#pragma import(SetCommState,'SetCommState','kernel32.dll');

procedure SetCommTimeouts(
    hFile           : in t_HANDLE; 
    lpCommTimeouts  : in p_COMMTIMEOUTS)
                      return BOOL;
#pragma convention(SetCommTimeouts,system);
#pragma import(SetCommTimeouts,'SetCommTimeouts','kernel32.dll');

type
t_017=character 8;

procedure TransmitCommChar(
    hFile           : in t_HANDLE; 
    cChar           : in t_017)
                      return BOOL;
#pragma convention(TransmitCommChar,system);
#pragma import(TransmitCommChar,'TransmitCommChar','kernel32.dll');

procedure WaitCommEvent(
    hFile           : in t_HANDLE; 
    lpEvtMask       : out DWORD ; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(WaitCommEvent,system);
#pragma import(WaitCommEvent,'WaitCommEvent','kernel32.dll');

procedure SetTapePosition(
    hDevice         : in t_HANDLE; 
    dwPositionMethod : in DWORD; 
    dwPartition     : in DWORD; 
    dwOffsetLow     : in DWORD; 
    dwOffsetHigh    : in DWORD; 
    bImmediate      : in BOOL)
                      return DWORD;
#pragma convention(SetTapePosition,system);
#pragma import(SetTapePosition,'SetTapePosition','kernel32.dll');

procedure GetTapePosition(
    hDevice         : in t_HANDLE; 
    dwPositionType  : in DWORD; 
    lpdwPartition   : out DWORD ; 
    lpdwOffsetLow   : out DWORD ; 
    lpdwOffsetHigh  : out DWORD )
                      return DWORD;
#pragma convention(GetTapePosition,system);
#pragma import(GetTapePosition,'GetTapePosition','kernel32.dll');

procedure PrepareTape(
    hDevice         : in t_HANDLE; 
    dwOperation     : in DWORD; 
    bImmediate      : in BOOL)
                      return DWORD;
#pragma convention(PrepareTape,system);
#pragma import(PrepareTape,'PrepareTape','kernel32.dll');

procedure EraseTape(
    hDevice         : in t_HANDLE; 
    dwEraseType     : in DWORD; 
    bImmediate      : in BOOL)
                      return DWORD;
#pragma convention(EraseTape,system);
#pragma import(EraseTape,'EraseTape','kernel32.dll');

procedure CreateTapePartition(
    hDevice         : in t_HANDLE; 
    dwPartitionMethod : in DWORD; 
    dwCount         : in DWORD; 
    dwSize          : in DWORD)
                      return DWORD;
#pragma convention(CreateTapePartition,system);
#pragma import(CreateTapePartition,'CreateTapePartition','kernel32.dll');

procedure WriteTapemark(
    hDevice         : in t_HANDLE; 
    dwTapemarkType  : in DWORD; 
    dwTapemarkCount : in DWORD; 
    bImmediate      : in BOOL)
                      return DWORD;
#pragma convention(WriteTapemark,system);
#pragma import(WriteTapemark,'WriteTapemark','kernel32.dll');

procedure GetTapeStatus(
    hDevice         : in t_HANDLE)
                      return DWORD;
#pragma convention(GetTapeStatus,system);
#pragma import(GetTapeStatus,'GetTapeStatus','kernel32.dll');

procedure GetTapeParameters(
    hDevice         : in t_HANDLE; 
    dwOperation     : in DWORD; 
    lpdwSize        : out DWORD ; 
    lpTapeInformation : out unchecked )
                      return DWORD;
#pragma convention(GetTapeParameters,system);
#pragma import(GetTapeParameters,'GetTapeParameters','kernel32.dll');

const
  GET_TAPE_MEDIA_INFORMATION= 0;

const
  GET_TAPE_DRIVE_INFORMATION= 1;

procedure SetTapeParameters(
    hDevice         : in t_HANDLE; 
    dwOperation     : in DWORD; 
    lpTapeInformation : in LPVOID)
                      return DWORD;
#pragma convention(SetTapeParameters,system);
#pragma import(SetTapeParameters,'SetTapeParameters','kernel32.dll');

const
  SET_TAPE_MEDIA_INFORMATION= 0;

const
  SET_TAPE_DRIVE_INFORMATION= 1;

procedure Beep(
    dwFreq          : in DWORD; 
    dwDuration      : in DWORD)
                      return BOOL;
#pragma convention(Beep,system);
#pragma import(Beep,'Beep','kernel32.dll');

type
t_018=signed 32;

t_019=signed 32;

t_020=signed 32;

  t_021 = signed 32;

procedure MulDiv(
    nNumber         : in t_018; 
    nNumerator      : in t_019; 
    nDenominator    : in t_020)
                      return t_021;
#pragma convention(MulDiv,system);
#pragma import(MulDiv,'MulDiv','kernel32.dll');

procedure GetSystemTime(
    lpSystemTime    : out _SYSTEMTIME);
#pragma convention(GetSystemTime,system);
#pragma import(GetSystemTime,'GetSystemTime','kernel32.dll');

procedure GetSystemTimeAsFileTime(
    lpSystemTimeAsFileTime : out _FILETIME);
#pragma convention(GetSystemTimeAsFileTime,system);
#pragma import(GetSystemTimeAsFileTime,'GetSystemTimeAsFileTime','kernel32.dll');

type
t_022=^t_SYSTEMTIME for machine_pointer use true;

procedure SetSystemTime(
    lpSystemTime    : in t_022)
                      return BOOL;
#pragma convention(SetSystemTime,system);
#pragma import(SetSystemTime,'SetSystemTime','kernel32.dll');

procedure GetLocalTime(
    lpSystemTime    : out _SYSTEMTIME);
#pragma convention(GetLocalTime,system);
#pragma import(GetLocalTime,'GetLocalTime','kernel32.dll');

type
t_023=^t_SYSTEMTIME for machine_pointer use true;

procedure SetLocalTime(
    lpSystemTime    : in t_023)
                      return BOOL;
#pragma convention(SetLocalTime,system);
#pragma import(SetLocalTime,'SetLocalTime','kernel32.dll');

procedure GetSystemInfo(
    lpSystemInfo    : out _SYSTEM_INFO);
#pragma convention(GetSystemInfo,system);
#pragma import(GetSystemInfo,'GetSystemInfo','kernel32.dll');

procedure GetSystemRegistryQuota(
    pdwQuotaAllowed : out DWORD ; 
    pdwQuotaUsed    : out DWORD )
                      return BOOL;
#pragma convention(GetSystemRegistryQuota,system);
#pragma import(GetSystemRegistryQuota,'GetSystemRegistryQuota','kernel32.dll');

procedure GetSystemTimes(
    lpIdleTime      : p_FILETIME; 
    lpKernelTime    : p_FILETIME; 
    lpUserTime      : p_FILETIME)
                      return BOOL;
#pragma convention(GetSystemTimes,system);
#pragma import(GetSystemTimes,'GetSystemTimes','kernel32.dll');

procedure GetNativeSystemInfo(
    lpSystemInfo    : out _SYSTEM_INFO);
#pragma convention(GetNativeSystemInfo,system);
#pragma import(GetNativeSystemInfo,'GetNativeSystemInfo','kernel32.dll');

procedure IsProcessorFeaturePresent(
    ProcessorFeature : in DWORD)
                      return BOOL;
#pragma convention(IsProcessorFeaturePresent,system);
#pragma import(IsProcessorFeaturePresent,'IsProcessorFeaturePresent','kernel32.dll');

type
  _TIME_ZONE_INFORMATION = record
Bias            : LONG;
StandardName    : array 0..31 of WCHAR;
StandardDate    : t_SYSTEMTIME;
StandardBias    : LONG;
DaylightName    : array 0..31 of WCHAR;
DaylightDate    : t_SYSTEMTIME;
DaylightBias    : LONG;
  end record;
  TIME_ZONE_INFORMATION = _TIME_ZONE_INFORMATION;
  PTIME_ZONE_INFORMATION = ^_TIME_ZONE_INFORMATION;
  LPTIME_ZONE_INFORMATION = ^_TIME_ZONE_INFORMATION;

procedure SystemTimeToTzSpecificLocalTime(
    lpTimeZoneInformation : in LPTIME_ZONE_INFORMATION; 
    lpUniversalTime : in p_SYSTEMTIME; 
    lpLocalTime     : out _SYSTEMTIME)
                      return BOOL;
#pragma convention(SystemTimeToTzSpecificLocalTime,system);
#pragma import(SystemTimeToTzSpecificLocalTime,'SystemTimeToTzSpecificLocalTime','kernel32.dll');

procedure TzSpecificLocalTimeToSystemTime(
    lpTimeZoneInformation : in LPTIME_ZONE_INFORMATION; 
    lpLocalTime     : in p_SYSTEMTIME; 
    lpUniversalTime : out _SYSTEMTIME)
                      return BOOL;
#pragma convention(TzSpecificLocalTimeToSystemTime,system);
#pragma import(TzSpecificLocalTimeToSystemTime,'TzSpecificLocalTimeToSystemTime','kernel32.dll');

procedure GetTimeZoneInformation(
    lpTimeZoneInformation : out _TIME_ZONE_INFORMATION)
                      return DWORD;
#pragma convention(GetTimeZoneInformation,system);
#pragma import(GetTimeZoneInformation,'GetTimeZoneInformation','kernel32.dll');

type
t_024=^TIME_ZONE_INFORMATION for machine_pointer use true;

procedure SetTimeZoneInformation(
    lpTimeZoneInformation : in t_024)
                      return BOOL;
#pragma convention(SetTimeZoneInformation,system);
#pragma import(SetTimeZoneInformation,'SetTimeZoneInformation','kernel32.dll');

-- 
--  Routines to convert back and forth between system time and file time
-- 
type
t_025=^t_SYSTEMTIME for machine_pointer use true;

procedure SystemTimeToFileTime(
    lpSystemTime    : in t_025; 
    lpFileTime      : out _FILETIME)
                      return BOOL;
#pragma convention(SystemTimeToFileTime,system);
#pragma import(SystemTimeToFileTime,'SystemTimeToFileTime','kernel32.dll');

type
t_026=^t_FILETIME for machine_pointer use true;

procedure FileTimeToLocalFileTime(
    lpFileTime      : in t_026; 
    lpLocalFileTime : out _FILETIME)
                      return BOOL;
#pragma convention(FileTimeToLocalFileTime,system);
#pragma import(FileTimeToLocalFileTime,'FileTimeToLocalFileTime','kernel32.dll');

type
t_027=^t_FILETIME for machine_pointer use true;

procedure LocalFileTimeToFileTime(
    lpLocalFileTime : in t_027; 
    lpFileTime      : out _FILETIME)
                      return BOOL;
#pragma convention(LocalFileTimeToFileTime,system);
#pragma import(LocalFileTimeToFileTime,'LocalFileTimeToFileTime','kernel32.dll');

type
t_028=^t_FILETIME for machine_pointer use true;

procedure FileTimeToSystemTime(
    lpFileTime      : in t_028; 
    lpSystemTime    : out _SYSTEMTIME)
                      return BOOL;
#pragma convention(FileTimeToSystemTime,system);
#pragma import(FileTimeToSystemTime,'FileTimeToSystemTime','kernel32.dll');

type
t_029=^t_FILETIME for machine_pointer use true;

t_030=^t_FILETIME for machine_pointer use true;

procedure CompareFileTime(
    lpFileTime1     : in t_029; 
    lpFileTime2     : in t_030)
                      return LONG;
#pragma convention(CompareFileTime,system);
#pragma import(CompareFileTime,'CompareFileTime','kernel32.dll');

type
t_031=^t_FILETIME for machine_pointer use true;

procedure FileTimeToDosDateTime(
    lpFileTime      : in t_031; 
    lpFatDate       : out WORD ; 
    lpFatTime       : out WORD )
                      return BOOL;
#pragma convention(FileTimeToDosDateTime,system);
#pragma import(FileTimeToDosDateTime,'FileTimeToDosDateTime','kernel32.dll');

procedure DosDateTimeToFileTime(
    wFatDate        : in WORD; 
    wFatTime        : in WORD; 
    lpFileTime      : out _FILETIME)
                      return BOOL;
#pragma convention(DosDateTimeToFileTime,system);
#pragma import(DosDateTimeToFileTime,'DosDateTimeToFileTime','kernel32.dll');

procedure GetTickCount
                      return DWORD;
#pragma convention(GetTickCount,system);
#pragma import(GetTickCount,'GetTickCount','kernel32.dll');

procedure SetSystemTimeAdjustment(
    dwTimeAdjustment : in DWORD; 
    bTimeAdjustmentDisabled : in BOOL)
                      return BOOL;
#pragma convention(SetSystemTimeAdjustment,system);
#pragma import(SetSystemTimeAdjustment,'SetSystemTimeAdjustment','kernel32.dll');

procedure GetSystemTimeAdjustment(
    lpTimeAdjustment : out DWORD ; 
    lpTimeIncrement : out DWORD ; 
    lpTimeAdjustmentDisabled : out BOOL )
                      return BOOL;
#pragma convention(GetSystemTimeAdjustment,system);
#pragma import(GetSystemTimeAdjustment,'GetSystemTimeAdjustment','kernel32.dll');

type
t_032=^va_list for machine_pointer use true;

procedure FormatMessageA(
    dwFlags         : in DWORD; 
    lpSource        : in LPCVOID; 
    dwMessageId     : in DWORD; 
    dwLanguageId    : in DWORD; 
    lpBuffer        : out CHARSTR ; 
    nSize           : in DWORD; 
    Arguments       : in t_032)
                      return DWORD;
#pragma convention(FormatMessageA,system);
#pragma import(FormatMessageA,'FormatMessageA','kernel32.dll');

type
t_033=^va_list for machine_pointer use true;

procedure FormatMessageW(
    dwFlags         : in DWORD; 
    lpSource        : in LPCVOID; 
    dwMessageId     : in DWORD; 
    dwLanguageId    : in DWORD; 
    lpBuffer        : out WCHARSTR ; 
    nSize           : in DWORD; 
    Arguments       : in t_033)
                      return DWORD;
#pragma convention(FormatMessageW,system);
#pragma import(FormatMessageW,'FormatMessageW','kernel32.dll');

#if #declared UNICODE; then;
#template FormatMessage;
  FormatMessageW 
#end FormatMessage;
#else;
#template FormatMessage;
  FormatMessageA 
#end FormatMessage;
#end if;

const
  FORMAT_MESSAGE_ALLOCATE_BUFFER= $0100;

const
  FORMAT_MESSAGE_IGNORE_INSERTS= $0200;

const
  FORMAT_MESSAGE_FROM_STRING= $0400;

const
  FORMAT_MESSAGE_FROM_HMODULE= $0800;

const
  FORMAT_MESSAGE_FROM_SYSTEM= $1000;

const
  FORMAT_MESSAGE_ARGUMENT_ARRAY= $2000;

const
  FORMAT_MESSAGE_MAX_WIDTH_MASK= $FF;

procedure CreatePipe(
    hReadPipe       : out t_HANDLE ; 
    hWritePipe      : out t_HANDLE ; 
    lpPipeAttributes : in LPSECURITY_ATTRIBUTES; 
    nSize           : in DWORD)
                      return BOOL;
#pragma convention(CreatePipe,system);
#pragma import(CreatePipe,'CreatePipe','kernel32.dll');

procedure ConnectNamedPipe(
    hNamedPipe      : in t_HANDLE; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(ConnectNamedPipe,system);
#pragma import(ConnectNamedPipe,'ConnectNamedPipe','kernel32.dll');

procedure DisconnectNamedPipe(
    hNamedPipe      : in t_HANDLE)
                      return BOOL;
#pragma convention(DisconnectNamedPipe,system);
#pragma import(DisconnectNamedPipe,'DisconnectNamedPipe','kernel32.dll');

procedure SetNamedPipeHandleState(
    hNamedPipe      : in t_HANDLE; 
    lpMode          : in LPDWORD; 
    lpMaxCollectionCount : in LPDWORD; 
    lpCollectDataTimeout : in LPDWORD)
                      return BOOL;
#pragma convention(SetNamedPipeHandleState,system);
#pragma import(SetNamedPipeHandleState,'SetNamedPipeHandleState','kernel32.dll');

procedure GetNamedPipeInfo(
    hNamedPipe      : in t_HANDLE; 
    lpFlags         : in LPDWORD; 
    lpOutBufferSize : out DWORD ; 
    lpInBufferSize  : out DWORD ; 
    lpMaxInstances  : out DWORD )
                      return BOOL;
#pragma convention(GetNamedPipeInfo,system);
#pragma import(GetNamedPipeInfo,'GetNamedPipeInfo','kernel32.dll');

procedure PeekNamedPipe(
    hNamedPipe      : in t_HANDLE; 
    lpBuffer        : out unchecked ; 
    nBufferSize     : in DWORD; 
    lpBytesRead     : out DWORD ; 
    lpTotalBytesAvail : out DWORD ; 
    lpBytesLeftThisMessage : out DWORD )
                      return BOOL;
#pragma convention(PeekNamedPipe,system);
#pragma import(PeekNamedPipe,'PeekNamedPipe','kernel32.dll');

procedure TransactNamedPipe(
    hNamedPipe      : in t_HANDLE; 
    lpInBuffer      : in LPVOID; 
    nInBufferSize   : in DWORD; 
    lpOutBuffer     : out unchecked ; 
    nOutBufferSize  : in DWORD; 
    lpBytesRead     : out DWORD ; 
    lpOverlapped    : in p_OVERLAPPED)
                      return BOOL;
#pragma convention(TransactNamedPipe,system);
#pragma import(TransactNamedPipe,'TransactNamedPipe','kernel32.dll');

procedure CreateMailslotA(
    lpName          : in LPCSTR; 
    nMaxMessageSize : in DWORD; 
    lReadTimeout    : in DWORD; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return t_HANDLE;
#pragma convention(CreateMailslotA,system);
#pragma import(CreateMailslotA,'CreateMailslotA','kernel32.dll');

procedure CreateMailslotW(
    lpName          : in LPCWSTR; 
    nMaxMessageSize : in DWORD; 
    lReadTimeout    : in DWORD; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return t_HANDLE;
#pragma convention(CreateMailslotW,system);
#pragma import(CreateMailslotW,'CreateMailslotW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateMailslot;
  CreateMailslotW 
#end CreateMailslot;
#else;
#template CreateMailslot;
  CreateMailslotA 
#end CreateMailslot;
#end if;

procedure GetMailslotInfo(
    hMailslot       : in t_HANDLE; 
    lpMaxMessageSize : in LPDWORD; 
    lpNextSize      : in LPDWORD; 
    lpMessageCount  : in LPDWORD; 
    lpReadTimeout   : in LPDWORD)
                      return BOOL;
#pragma convention(GetMailslotInfo,system);
#pragma import(GetMailslotInfo,'GetMailslotInfo','kernel32.dll');

procedure SetMailslotInfo(
    hMailslot       : in t_HANDLE; 
    lReadTimeout    : in DWORD)
                      return BOOL;
#pragma convention(SetMailslotInfo,system);
#pragma import(SetMailslotInfo,'SetMailslotInfo','kernel32.dll');

procedure MapViewOfFile(
    hFileMappingObject : in t_HANDLE; 
    dwDesiredAccess : in DWORD; 
    dwFileOffsetHigh : in DWORD; 
    dwFileOffsetLow : in DWORD; 
    dwNumberOfBytesToMap : in SIZE_T)
                      return LPVOID;
#pragma convention(MapViewOfFile,system);
#pragma import(MapViewOfFile,'MapViewOfFile','kernel32.dll');

procedure FlushViewOfFile(
    lpBaseAddress   : in LPCVOID; 
    dwNumberOfBytesToFlush : in SIZE_T)
                      return BOOL;
#pragma convention(FlushViewOfFile,system);
#pragma import(FlushViewOfFile,'FlushViewOfFile','kernel32.dll');

procedure UnmapViewOfFile(
    lpBaseAddress   : in LPCVOID)
                      return BOOL;
#pragma convention(UnmapViewOfFile,system);
#pragma import(UnmapViewOfFile,'UnmapViewOfFile','kernel32.dll');

-- 
--  File Encryption API
-- 
procedure EncryptFileA(
    lpFileName      : in LPCSTR)
                      return BOOL;
#pragma convention(EncryptFileA,system);
#pragma import(EncryptFileA,'EncryptFileA','advapi32.dll');

procedure EncryptFileW(
    lpFileName      : in LPCWSTR)
                      return BOOL;
#pragma convention(EncryptFileW,system);
#pragma import(EncryptFileW,'EncryptFileW','advapi32.dll');

#if #declared UNICODE; then;
#template EncryptFile;
  EncryptFileW 
#end EncryptFile;
#else;
#template EncryptFile;
  EncryptFileA 
#end EncryptFile;
#end if;

procedure DecryptFileA(
    lpFileName      : in LPCSTR; 
    dwReserved      : in DWORD)
                      return BOOL;
#pragma convention(DecryptFileA,system);
#pragma import(DecryptFileA,'DecryptFileA','advapi32.dll');

procedure DecryptFileW(
    lpFileName      : in LPCWSTR; 
    dwReserved      : in DWORD)
                      return BOOL;
#pragma convention(DecryptFileW,system);
#pragma import(DecryptFileW,'DecryptFileW','advapi32.dll');

#if #declared UNICODE; then;
#template DecryptFile;
  DecryptFileW 
#end DecryptFile;
#else;
#template DecryptFile;
  DecryptFileA 
#end DecryptFile;
#end if;

-- 
--  Encryption Status Value
-- 
const
  FILE_ENCRYPTABLE  = 0;

const
  FILE_IS_ENCRYPTED = 1;

const
  FILE_SYSTEM_ATTR  = 2;

const
  FILE_ROOT_DIR     = 3;

const
  FILE_SYSTEM_DIR   = 4;

const
  FILE_UNKNOWN      = 5;

const
  FILE_SYSTEM_NOT_SUPPORT= 6;

const
  FILE_USER_DISALLOWED= 7;

const
  FILE_READ_ONLY    = 8;

const
  FILE_DIR_DISALLOWED= 9;

procedure FileEncryptionStatusA(
    lpFileName      : LPCSTR; 
    lpStatus        : LPDWORD)
                      return BOOL;
#pragma convention(FileEncryptionStatusA,system);
#pragma import(FileEncryptionStatusA,'FileEncryptionStatusA','advapi32.dll');

procedure FileEncryptionStatusW(
    lpFileName      : LPCWSTR; 
    lpStatus        : LPDWORD)
                      return BOOL;
#pragma convention(FileEncryptionStatusW,system);
#pragma import(FileEncryptionStatusW,'FileEncryptionStatusW','advapi32.dll');

#if #declared UNICODE; then;
#template FileEncryptionStatus;
  FileEncryptionStatusW 
#end FileEncryptionStatus;
#else;
#template FileEncryptionStatus;
  FileEncryptionStatusA 
#end FileEncryptionStatus;
#end if;

-- 
--  Currently defined recovery flags
-- 
type
PFE_EXPORT_FUNC   = ^procedure (
    pbData          : PBYTE;
    pvCallbackContext : PVOID;
    ulLength        : ULONG)
                      return DWORD for machine_pointer use true;
type
PFE_IMPORT_FUNC   = ^procedure (
    pbData          : PBYTE;
    pvCallbackContext : PVOID;
    ulLength        : PULONG)
                      return DWORD for machine_pointer use true;
-- 
--  OpenRaw flag values
-- 
type
t_034=^PVOID for machine_pointer use true;

procedure OpenEncryptedFileRawA(
    lpFileName      : in LPCSTR; 
    ulFlags         : in ULONG; 
    pvContext       : in t_034)
                      return DWORD;
#pragma convention(OpenEncryptedFileRawA,system);
#pragma import(OpenEncryptedFileRawA,'OpenEncryptedFileRawA','advapi32.dll');

type
t_035=^PVOID for machine_pointer use true;

procedure OpenEncryptedFileRawW(
    lpFileName      : in LPCWSTR; 
    ulFlags         : in ULONG; 
    pvContext       : in t_035)
                      return DWORD;
#pragma convention(OpenEncryptedFileRawW,system);
#pragma import(OpenEncryptedFileRawW,'OpenEncryptedFileRawW','advapi32.dll');

#if #declared UNICODE; then;
#template OpenEncryptedFileRaw;
  OpenEncryptedFileRawW 
#end OpenEncryptedFileRaw;
#else;
#template OpenEncryptedFileRaw;
  OpenEncryptedFileRawA 
#end OpenEncryptedFileRaw;
#end if;

procedure ReadEncryptedFileRaw(
    pfExportCallback : in PFE_EXPORT_FUNC; 
    pvCallbackContext : in PVOID; 
    pvContext       : in PVOID)
                      return DWORD;
#pragma convention(ReadEncryptedFileRaw,system);
#pragma import(ReadEncryptedFileRaw,'ReadEncryptedFileRaw','advapi32.dll');

procedure WriteEncryptedFileRaw(
    pfImportCallback : in PFE_IMPORT_FUNC; 
    pvCallbackContext : in PVOID; 
    pvContext       : in PVOID)
                      return DWORD;
#pragma convention(WriteEncryptedFileRaw,system);
#pragma import(WriteEncryptedFileRaw,'WriteEncryptedFileRaw','advapi32.dll');

procedure CloseEncryptedFileRaw(
    pvContext       : in PVOID);
#pragma convention(CloseEncryptedFileRaw,system);
#pragma import(CloseEncryptedFileRaw,'CloseEncryptedFileRaw','advapi32.dll');

-- 
--  _l Compat Functions
-- 
type
  t_036 = signed 32;

procedure lstrcmpA(
    lpString1       : in LPCSTR; 
    lpString2       : in LPCSTR)
                      return t_036;
#pragma convention(lstrcmpA,system);
#pragma import(lstrcmpA,'lstrcmpA','kernel32.dll');

type
  t_037 = signed 32;

procedure lstrcmpW(
    lpString1       : in LPCWSTR; 
    lpString2       : in LPCWSTR)
                      return t_037;
#pragma convention(lstrcmpW,system);
#pragma import(lstrcmpW,'lstrcmpW','kernel32.dll');

#if #declared UNICODE; then;
#template lstrcmp;
  lstrcmpW 
#end lstrcmp;
#else;
#template lstrcmp;
  lstrcmpA 
#end lstrcmp;
#end if;

type
  t_038 = signed 32;

procedure lstrcmpiA(
    lpString1       : in LPCSTR; 
    lpString2       : in LPCSTR)
                      return t_038;
#pragma convention(lstrcmpiA,system);
#pragma import(lstrcmpiA,'lstrcmpiA','kernel32.dll');

type
  t_039 = signed 32;

procedure lstrcmpiW(
    lpString1       : in LPCWSTR; 
    lpString2       : in LPCWSTR)
                      return t_039;
#pragma convention(lstrcmpiW,system);
#pragma import(lstrcmpiW,'lstrcmpiW','kernel32.dll');

#if #declared UNICODE; then;
#template lstrcmpi;
  lstrcmpiW 
#end lstrcmpi;
#else;
#template lstrcmpi;
  lstrcmpiA 
#end lstrcmpi;
#end if;

type
t_040=signed 32;

procedure lstrcpynA(
    lpString1       : out CHARSTR ; 
    lpString2       : in LPCSTR; 
    iMaxLength      : in t_040)
                      return LPSTR;
#pragma convention(lstrcpynA,system);
#pragma import(lstrcpynA,'lstrcpynA','kernel32.dll');

type
t_041=signed 32;

procedure lstrcpynW(
    lpString1       : out WCHARSTR ; 
    lpString2       : in LPCWSTR; 
    iMaxLength      : in t_041)
                      return LPWSTR;
#pragma convention(lstrcpynW,system);
#pragma import(lstrcpynW,'lstrcpynW','kernel32.dll');

#if #declared UNICODE; then;
#template lstrcpyn;
  lstrcpynW 
#end lstrcpyn;
#else;
#template lstrcpyn;
  lstrcpynA 
#end lstrcpyn;
#end if;

procedure lstrcpyA(
    lpString1       : out CHARSTR ; 
    lpString2       : in LPCSTR)
                      return LPSTR;
#pragma convention(lstrcpyA,system);
#pragma import(lstrcpyA,'lstrcpyA','kernel32.dll');

procedure lstrcpyW(
    lpString1       : out WCHARSTR ; 
    lpString2       : in LPCWSTR)
                      return LPWSTR;
#pragma convention(lstrcpyW,system);
#pragma import(lstrcpyW,'lstrcpyW','kernel32.dll');

#if #declared UNICODE; then;
#template lstrcpy;
  lstrcpyW 
#end lstrcpy;
#else;
#template lstrcpy;
  lstrcpyA 
#end lstrcpy;
#end if;

procedure lstrcatA(
    lpString1       : in out CHARSTR ; 
    lpString2       : in LPCSTR)
                      return LPSTR;
#pragma convention(lstrcatA,system);
#pragma import(lstrcatA,'lstrcatA','kernel32.dll');

procedure lstrcatW(
    lpString1       : in out WCHARSTR ; 
    lpString2       : in LPCWSTR)
                      return LPWSTR;
#pragma convention(lstrcatW,system);
#pragma import(lstrcatW,'lstrcatW','kernel32.dll');

#if #declared UNICODE; then;
#template lstrcat;
  lstrcatW 
#end lstrcat;
#else;
#template lstrcat;
  lstrcatA 
#end lstrcat;
#end if;

type
  t_042 = signed 32;

procedure lstrlenA(
    lpString        : in LPCSTR)
                      return t_042;
#pragma convention(lstrlenA,system);
#pragma import(lstrlenA,'lstrlenA','kernel32.dll');

type
  t_043 = signed 32;

procedure lstrlenW(
    lpString        : in LPCWSTR)
                      return t_043;
#pragma convention(lstrlenW,system);
#pragma import(lstrlenW,'lstrlenW','kernel32.dll');

#if #declared UNICODE; then;
#template lstrlen;
  lstrlenW 
#end lstrlen;
#else;
#template lstrlen;
  lstrlenA 
#end lstrlen;
#end if;

procedure OpenFile(
    lpFileName      : in LPCSTR; 
    lpReOpenBuff    : out _OFSTRUCT; 
    uStyle          : in UINT)
                      return t_HFILE;
#pragma convention(OpenFile,system);
#pragma import(OpenFile,'OpenFile','kernel32.dll');

type
t_044=signed 32;

procedure _lopen(
    lpPathName      : in LPCSTR; 
    iReadWrite      : in t_044)
                      return t_HFILE;
#pragma convention(_lopen,system);
#pragma import(_lopen,'_lopen','kernel32.dll');

type
t_045=signed 32;

procedure _lcreat(
    lpPathName      : in LPCSTR; 
    iAttribute      : in t_045)
                      return t_HFILE;
#pragma convention(_lcreat,system);
#pragma import(_lcreat,'_lcreat','kernel32.dll');

procedure _lread(
    hFile           : in t_HFILE; 
    lpBuffer        : out unchecked ; 
    uBytes          : in UINT)
                      return UINT;
#pragma convention(_lread,system);
#pragma import(_lread,'_lread','kernel32.dll');

procedure _lwrite(
    hFile           : in t_HFILE; 
    lpBuffer        : in LPCSTR; 
    uBytes          : in UINT)
                      return UINT;
#pragma convention(_lwrite,system);
#pragma import(_lwrite,'_lwrite','kernel32.dll');

type
t_046=signed 32;

  t_047 = signed 32;

procedure _hread(
    hFile           : in t_HFILE; 
    lpBuffer        : out unchecked ; 
    lBytes          : in t_046)
                      return t_047;
#pragma convention(_hread,system);
#pragma import(_hread,'_hread','kernel32.dll');

type
t_048=signed 32;

  t_049 = signed 32;

procedure _hwrite(
    hFile           : in t_HFILE; 
    lpBuffer        : in LPCSTR; 
    lBytes          : in t_048)
                      return t_049;
#pragma convention(_hwrite,system);
#pragma import(_hwrite,'_hwrite','kernel32.dll');

procedure _lclose(
    hFile           : in out {!}t_HFILE)
                      return t_HFILE;
#pragma convention(_lclose,system);
#pragma import(_lclose,'_lclose','kernel32.dll');

type
t_050=signed 32;

procedure _llseek(
    hFile           : in t_HFILE; 
    lOffset         : in LONG; 
    iOrigin         : in t_050)
                      return LONG;
#pragma convention(_llseek,system);
#pragma import(_llseek,'_llseek','kernel32.dll');

type
t_051=^unchecked for machine_pointer use true;

t_052=signed 32;

t_053=signed 32 ;

procedure IsTextUnicode(
    lpBuffer        : in t_051; 
    cb              : in t_052; 
    lpi             : in out t_053)
                      return BOOL;
#pragma convention(IsTextUnicode,system);
#pragma import(IsTextUnicode,'IsTextUnicode','advapi32.dll');

type
PFLS_CALLBACK_FUNCTION = ^procedure (
    lpFlsData       : in PVOID) for machine_pointer use true;
procedure FlsAlloc(
    lpCallback      : in {out optional} PFLS_CALLBACK_FUNCTION)
                      return DWORD;
#pragma convention(FlsAlloc,system);
#pragma import(FlsAlloc,'FlsAlloc','kernel32.dll');

procedure FlsGetValue(
    dwFlsIndex      : in DWORD)
                      return PVOID;
#pragma convention(FlsGetValue,system);
#pragma import(FlsGetValue,'FlsGetValue','kernel32.dll');

procedure FlsSetValue(
    dwFlsIndex      : in DWORD; 
    lpFlsData       : in PVOID)
                      return BOOL;
#pragma convention(FlsSetValue,system);
#pragma import(FlsSetValue,'FlsSetValue','kernel32.dll');

procedure FlsFree(
    dwFlsIndex      : in DWORD)
                      return BOOL;
#pragma convention(FlsFree,system);
#pragma import(FlsFree,'FlsFree','kernel32.dll');

procedure TlsAlloc
                      return DWORD;
#pragma convention(TlsAlloc,system);
#pragma import(TlsAlloc,'TlsAlloc','kernel32.dll');

procedure TlsGetValue(
    dwTlsIndex      : in DWORD)
                      return LPVOID;
#pragma convention(TlsGetValue,system);
#pragma import(TlsGetValue,'TlsGetValue','kernel32.dll');

procedure TlsSetValue(
    dwTlsIndex      : in DWORD; 
    lpTlsValue      : in LPVOID)
                      return BOOL;
#pragma convention(TlsSetValue,system);
#pragma import(TlsSetValue,'TlsSetValue','kernel32.dll');

procedure TlsFree(
    dwTlsIndex      : in DWORD)
                      return BOOL;
#pragma convention(TlsFree,system);
#pragma import(TlsFree,'TlsFree','kernel32.dll');

type
LPOVERLAPPED_COMPLETION_ROUTINE = ^procedure (
    dwErrorCode     : DWORD;
    dwNumberOfBytesTransfered : DWORD;
    lpOverlapped    : p_OVERLAPPED) for machine_pointer use true;
procedure SleepEx(
    dwMilliseconds  : in DWORD; 
    bAlertable      : in BOOL)
                      return DWORD;
#pragma convention(SleepEx,system);
#pragma import(SleepEx,'SleepEx','kernel32.dll');

procedure WaitForSingleObjectEx(
    hHandle         : in t_HANDLE; 
    dwMilliseconds  : in DWORD; 
    bAlertable      : in BOOL)
                      return DWORD;
#pragma convention(WaitForSingleObjectEx,system);
#pragma import(WaitForSingleObjectEx,'WaitForSingleObjectEx','kernel32.dll');

type
t_054=^t_HANDLE for machine_pointer use true;

procedure WaitForMultipleObjectsEx(
    nCount          : in DWORD; 
    lpHandles       : in t_054; 
    bWaitAll        : in BOOL; 
    dwMilliseconds  : in DWORD; 
    bAlertable      : in BOOL)
                      return DWORD;
#pragma convention(WaitForMultipleObjectsEx,system);
#pragma import(WaitForMultipleObjectsEx,'WaitForMultipleObjectsEx','kernel32.dll');

procedure SignalObjectAndWait(
    hObjectToSignal : in t_HANDLE; 
    hObjectToWaitOn : in t_HANDLE; 
    dwMilliseconds  : in DWORD; 
    bAlertable      : in BOOL)
                      return DWORD;
#pragma convention(SignalObjectAndWait,system);
#pragma import(SignalObjectAndWait,'SignalObjectAndWait','kernel32.dll');

procedure ReadFileEx(
    hFile           : in t_HANDLE; 
    lpBuffer        : out unchecked ; 
    nNumberOfBytesToRead : in DWORD; 
    lpOverlapped    : in p_OVERLAPPED; 
    lpCompletionRoutine : in LPOVERLAPPED_COMPLETION_ROUTINE)
                      return BOOL;
#pragma convention(ReadFileEx,system);
#pragma import(ReadFileEx,'ReadFileEx','kernel32.dll');

procedure WriteFileEx(
    hFile           : in t_HANDLE; 
    lpBuffer        : in LPCVOID; 
    nNumberOfBytesToWrite : in DWORD; 
    lpOverlapped    : in p_OVERLAPPED; 
    lpCompletionRoutine : in LPOVERLAPPED_COMPLETION_ROUTINE)
                      return BOOL;
#pragma convention(WriteFileEx,system);
#pragma import(WriteFileEx,'WriteFileEx','kernel32.dll');

procedure BackupRead(
    hFile           : in t_HANDLE; 
    lpBuffer        : out BYTE ; 
    nNumberOfBytesToRead : in DWORD; 
    lpNumberOfBytesRead : out DWORD ; 
    bAbort          : in BOOL; 
    bProcessSecurity : in BOOL; 
    lpContext       : out LPVOID)
                      return BOOL;
#pragma convention(BackupRead,system);
#pragma import(BackupRead,'BackupRead','kernel32.dll');

type
t_055=^LPVOID for machine_pointer use true;

procedure BackupSeek(
    hFile           : in t_HANDLE; 
    dwLowBytesToSeek : in DWORD; 
    dwHighBytesToSeek : in DWORD; 
    lpdwLowByteSeeked : out DWORD ; 
    lpdwHighByteSeeked : out DWORD ; 
    lpContext       : in t_055)
                      return BOOL;
#pragma convention(BackupSeek,system);
#pragma import(BackupSeek,'BackupSeek','kernel32.dll');

procedure BackupWrite(
    hFile           : in t_HANDLE; 
    lpBuffer        : in LPBYTE; 
    nNumberOfBytesToWrite : in DWORD; 
    lpNumberOfBytesWritten : out DWORD ; 
    bAbort          : in BOOL; 
    bProcessSecurity : in BOOL; 
    lpContext       : out LPVOID)
                      return BOOL;
#pragma convention(BackupWrite,system);
#pragma import(BackupWrite,'BackupWrite','kernel32.dll');

-- 
--  Stream id structure
-- 
type
  _WIN32_STREAM_ID  = record
dwStreamId      : DWORD;
dwStreamAttributes : DWORD;
Size            : LARGE_INTEGER;
dwStreamNameSize : DWORD;
cStreamName     : array 0..ANYSIZE_ARRAY-1 of WCHAR;
  end record;
  WIN32_STREAM_ID   = _WIN32_STREAM_ID;
  LPWIN32_STREAM_ID = ^_WIN32_STREAM_ID;

-- 
--  Stream Ids
-- 
const
  BACKUP_INVALID    = $00;

const
  BACKUP_DATA       = $01;

const
  BACKUP_EA_DATA    = $02;

const
  BACKUP_SECURITY_DATA= $03;

const
  BACKUP_ALTERNATE_DATA= $04;

const
  BACKUP_LINK       = $05;

const
  BACKUP_PROPERTY_DATA= $06;

const
  BACKUP_OBJECT_ID  = $07;

const
  BACKUP_REPARSE_DATA= $08;

const
  BACKUP_SPARSE_BLOCK= $09;

-- 
--  Stream Attributes
-- 
const
  STREAM_NORMAL_ATTRIBUTE= $00;

const
  STREAM_MODIFIED_WHEN_READ= $01;

const
  STREAM_CONTAINS_SECURITY= $02;

const
  STREAM_CONTAINS_PROPERTIES= $04;

const
  STREAM_SPARSE_ATTRIBUTE= $08;

-- 
--  Dual Mode API below this line. Dual Mode Structures also included.
-- 
const
  STARTF_USESHOWWINDOW= $01;

const
  STARTF_USESIZE    = $02;

const
  STARTF_USEPOSITION= $04;

const
  STARTF_USECOUNTCHARS= $08;

const
  STARTF_USEFILLATTRIBUTE= $10;

const
  STARTF_RUNFULLSCREEN= $20;

const
  STARTF_FORCEONFEEDBACK= $40;

const
  STARTF_FORCEOFFFEEDBACK= $80;

const
  STARTF_USESTDHANDLES= $0100;

const
  STARTF_USEHOTKEY  = $0200;

type
  _STARTUPINFOA     = record
cb              : DWORD;
lpReserved      : LPSTR;
lpDesktop       : LPSTR;
lpTitle         : LPSTR;
dwX             : DWORD;
dwY             : DWORD;
dwXSize         : DWORD;
dwYSize         : DWORD;
dwXCountChars   : DWORD;
dwYCountChars   : DWORD;
dwFillAttribute : DWORD;
dwFlags         : DWORD;
wShowWindow     : WORD;
cbReserved2     : WORD;
lpReserved2     : LPBYTE;
hStdInput       : t_HANDLE;
hStdOutput      : t_HANDLE;
hStdError       : t_HANDLE;
  end record;
  STARTUPINFOA      = _STARTUPINFOA;
  LPSTARTUPINFOA    = ^_STARTUPINFOA;

type
  _STARTUPINFOW     = record
cb              : DWORD;
lpReserved      : LPWSTR;
lpDesktop       : LPWSTR;
lpTitle         : LPWSTR;
dwX             : DWORD;
dwY             : DWORD;
dwXSize         : DWORD;
dwYSize         : DWORD;
dwXCountChars   : DWORD;
dwYCountChars   : DWORD;
dwFillAttribute : DWORD;
dwFlags         : DWORD;
wShowWindow     : WORD;
cbReserved2     : WORD;
lpReserved2     : LPBYTE;
hStdInput       : t_HANDLE;
hStdOutput      : t_HANDLE;
hStdError       : t_HANDLE;
  end record;
  STARTUPINFOW      = _STARTUPINFOW;
  LPSTARTUPINFOW    = ^_STARTUPINFOW;

#if #declared UNICODE; then;
type
STARTUPINFO       = STARTUPINFOW;
type
LPSTARTUPINFO     = LPSTARTUPINFOW;
#else;
type
STARTUPINFO       = STARTUPINFOA;
type
LPSTARTUPINFO     = LPSTARTUPINFOA;
#end if;

const
  SHUTDOWN_NORETRY  = $01;

type
  _WIN32_FIND_DATAA = record
dwFileAttributes : DWORD;
ftCreationTime  : t_FILETIME;
ftLastAccessTime : t_FILETIME;
ftLastWriteTime : t_FILETIME;
nFileSizeHigh   : DWORD;
nFileSizeLow    : DWORD;
dwReserved0     : DWORD;
dwReserved1     : DWORD;
cFileName       : aliased array 0..MAX_PATH-1 of CHAR;
cAlternateFileName : array 0..13 of CHAR;
  end record;
  WIN32_FIND_DATAA  = _WIN32_FIND_DATAA;
  PWIN32_FIND_DATAA = ^_WIN32_FIND_DATAA;
  LPWIN32_FIND_DATAA = ^_WIN32_FIND_DATAA;

type
  _WIN32_FIND_DATAW = record
dwFileAttributes : DWORD;
ftCreationTime  : t_FILETIME;
ftLastAccessTime : t_FILETIME;
ftLastWriteTime : t_FILETIME;
nFileSizeHigh   : DWORD;
nFileSizeLow    : DWORD;
dwReserved0     : DWORD;
dwReserved1     : DWORD;
cFileName       : aliased array 0..MAX_PATH-1 of WCHAR;
cAlternateFileName : array 0..13 of WCHAR;
  end record;
  WIN32_FIND_DATAW  = _WIN32_FIND_DATAW;
  PWIN32_FIND_DATAW = ^_WIN32_FIND_DATAW;
  LPWIN32_FIND_DATAW = ^_WIN32_FIND_DATAW;

#if #declared UNICODE; then;
type
WIN32_FIND_DATA   = WIN32_FIND_DATAW;
type
PWIN32_FIND_DATA  = PWIN32_FIND_DATAW;
type
LPWIN32_FIND_DATA = LPWIN32_FIND_DATAW;
#else;
type
WIN32_FIND_DATA   = WIN32_FIND_DATAA;
type
PWIN32_FIND_DATA  = PWIN32_FIND_DATAA;
type
LPWIN32_FIND_DATA = LPWIN32_FIND_DATAA;
#end if;

type
  _WIN32_FILE_ATTRIBUTE_DATA = record
dwFileAttributes : DWORD;
ftCreationTime  : t_FILETIME;
ftLastAccessTime : t_FILETIME;
ftLastWriteTime : t_FILETIME;
nFileSizeHigh   : DWORD;
nFileSizeLow    : DWORD;
  end record;
  WIN32_FILE_ATTRIBUTE_DATA = _WIN32_FILE_ATTRIBUTE_DATA;
  LPWIN32_FILE_ATTRIBUTE_DATA = ^_WIN32_FILE_ATTRIBUTE_DATA;

procedure CreateMutexA(
    lpMutexAttributes : in LPSECURITY_ATTRIBUTES; 
    bInitialOwner   : in BOOL; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(CreateMutexA,system);
#pragma import(CreateMutexA,'CreateMutexA','kernel32.dll');

procedure CreateMutexW(
    lpMutexAttributes : in LPSECURITY_ATTRIBUTES; 
    bInitialOwner   : in BOOL; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(CreateMutexW,system);
#pragma import(CreateMutexW,'CreateMutexW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateMutex;
  CreateMutexW 
#end CreateMutex;
#else;
#template CreateMutex;
  CreateMutexA 
#end CreateMutex;
#end if;

procedure OpenMutexA(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(OpenMutexA,system);
#pragma import(OpenMutexA,'OpenMutexA','kernel32.dll');

procedure OpenMutexW(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(OpenMutexW,system);
#pragma import(OpenMutexW,'OpenMutexW','kernel32.dll');

#if #declared UNICODE; then;
#template OpenMutex;
  OpenMutexW 
#end OpenMutex;
#else;
#template OpenMutex;
  OpenMutexA 
#end OpenMutex;
#end if;

procedure CreateEventA(
    lpEventAttributes : in LPSECURITY_ATTRIBUTES; 
    bManualReset    : in BOOL; 
    bInitialState   : in BOOL; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(CreateEventA,system);
#pragma import(CreateEventA,'CreateEventA','kernel32.dll');

procedure CreateEventW(
    lpEventAttributes : in LPSECURITY_ATTRIBUTES; 
    bManualReset    : in BOOL; 
    bInitialState   : in BOOL; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(CreateEventW,system);
#pragma import(CreateEventW,'CreateEventW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateEvent;
  CreateEventW 
#end CreateEvent;
#else;
#template CreateEvent;
  CreateEventA 
#end CreateEvent;
#end if;

procedure OpenEventA(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(OpenEventA,system);
#pragma import(OpenEventA,'OpenEventA','kernel32.dll');

procedure OpenEventW(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(OpenEventW,system);
#pragma import(OpenEventW,'OpenEventW','kernel32.dll');

#if #declared UNICODE; then;
#template OpenEvent;
  OpenEventW 
#end OpenEvent;
#else;
#template OpenEvent;
  OpenEventA 
#end OpenEvent;
#end if;

procedure CreateSemaphoreA(
    lpSemaphoreAttributes : in LPSECURITY_ATTRIBUTES; 
    lInitialCount   : in LONG; 
    lMaximumCount   : in LONG; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(CreateSemaphoreA,system);
#pragma import(CreateSemaphoreA,'CreateSemaphoreA','kernel32.dll');

procedure CreateSemaphoreW(
    lpSemaphoreAttributes : in LPSECURITY_ATTRIBUTES; 
    lInitialCount   : in LONG; 
    lMaximumCount   : in LONG; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(CreateSemaphoreW,system);
#pragma import(CreateSemaphoreW,'CreateSemaphoreW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateSemaphore;
  CreateSemaphoreW 
#end CreateSemaphore;
#else;
#template CreateSemaphore;
  CreateSemaphoreA 
#end CreateSemaphore;
#end if;

procedure OpenSemaphoreA(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(OpenSemaphoreA,system);
#pragma import(OpenSemaphoreA,'OpenSemaphoreA','kernel32.dll');

procedure OpenSemaphoreW(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(OpenSemaphoreW,system);
#pragma import(OpenSemaphoreW,'OpenSemaphoreW','kernel32.dll');

#if #declared UNICODE; then;
#template OpenSemaphore;
  OpenSemaphoreW 
#end OpenSemaphore;
#else;
#template OpenSemaphore;
  OpenSemaphoreA 
#end OpenSemaphore;
#end if;

type
PTIMERAPCROUTINE  = ^procedure (
    lpArgToCompletionRoutine : LPVOID;
    dwTimerLowValue : DWORD;
    dwTimerHighValue : DWORD) for machine_pointer use true;
procedure CreateWaitableTimerA(
    lpTimerAttributes : in LPSECURITY_ATTRIBUTES; 
    bManualReset    : in BOOL; 
    lpTimerName     : in LPCSTR)
                      return t_HANDLE;
#pragma convention(CreateWaitableTimerA,system);
#pragma import(CreateWaitableTimerA,'CreateWaitableTimerA','kernel32.dll');

procedure CreateWaitableTimerW(
    lpTimerAttributes : in LPSECURITY_ATTRIBUTES; 
    bManualReset    : in BOOL; 
    lpTimerName     : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(CreateWaitableTimerW,system);
#pragma import(CreateWaitableTimerW,'CreateWaitableTimerW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateWaitableTimer;
  CreateWaitableTimerW 
#end CreateWaitableTimer;
#else;
#template CreateWaitableTimer;
  CreateWaitableTimerA 
#end CreateWaitableTimer;
#end if;

procedure OpenWaitableTimerA(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpTimerName     : in LPCSTR)
                      return t_HANDLE;
#pragma convention(OpenWaitableTimerA,system);
#pragma import(OpenWaitableTimerA,'OpenWaitableTimerA','kernel32.dll');

procedure OpenWaitableTimerW(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpTimerName     : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(OpenWaitableTimerW,system);
#pragma import(OpenWaitableTimerW,'OpenWaitableTimerW','kernel32.dll');

#if #declared UNICODE; then;
#template OpenWaitableTimer;
  OpenWaitableTimerW 
#end OpenWaitableTimer;
#else;
#template OpenWaitableTimer;
  OpenWaitableTimerA 
#end OpenWaitableTimer;
#end if;

type
t_058=^LARGE_INTEGER for machine_pointer use true;

procedure SetWaitableTimer(
    hTimer          : in t_HANDLE; 
    lpDueTime       : in t_058; 
    lPeriod         : in LONG; 
    pfnCompletionRoutine : in PTIMERAPCROUTINE; 
    lpArgToCompletionRoutine : in LPVOID; 
    fResume         : in BOOL)
                      return BOOL;
#pragma convention(SetWaitableTimer,system);
#pragma import(SetWaitableTimer,'SetWaitableTimer','kernel32.dll');

procedure CancelWaitableTimer(
    hTimer          : in t_HANDLE)
                      return BOOL;
#pragma convention(CancelWaitableTimer,system);
#pragma import(CancelWaitableTimer,'CancelWaitableTimer','kernel32.dll');

procedure CreateFileMappingA(
    hFile           : in t_HANDLE; 
    lpFileMappingAttributes : in LPSECURITY_ATTRIBUTES; 
    flProtect       : in DWORD; 
    dwMaximumSizeHigh : in DWORD; 
    dwMaximumSizeLow : in DWORD; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(CreateFileMappingA,system);
#pragma import(CreateFileMappingA,'CreateFileMappingA','kernel32.dll');

procedure CreateFileMappingW(
    hFile           : in t_HANDLE; 
    lpFileMappingAttributes : in LPSECURITY_ATTRIBUTES; 
    flProtect       : in DWORD; 
    dwMaximumSizeHigh : in DWORD; 
    dwMaximumSizeLow : in DWORD; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(CreateFileMappingW,system);
#pragma import(CreateFileMappingW,'CreateFileMappingW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateFileMapping;
  CreateFileMappingW 
#end CreateFileMapping;
#else;
#template CreateFileMapping;
  CreateFileMappingA 
#end CreateFileMapping;
#end if;

procedure OpenFileMappingA(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(OpenFileMappingA,system);
#pragma import(OpenFileMappingA,'OpenFileMappingA','kernel32.dll');

procedure OpenFileMappingW(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(OpenFileMappingW,system);
#pragma import(OpenFileMappingW,'OpenFileMappingW','kernel32.dll');

#if #declared UNICODE; then;
#template OpenFileMapping;
  OpenFileMappingW 
#end OpenFileMapping;
#else;
#template OpenFileMapping;
  OpenFileMappingA 
#end OpenFileMapping;
#end if;

procedure GetLogicalDriveStringsA(
    nBufferLength   : in DWORD; 
    lpBuffer        : out CHARSTR )
                      return DWORD;
#pragma convention(GetLogicalDriveStringsA,system);
#pragma import(GetLogicalDriveStringsA,'GetLogicalDriveStringsA','kernel32.dll');

procedure GetLogicalDriveStringsW(
    nBufferLength   : in DWORD; 
    lpBuffer        : out WCHARSTR )
                      return DWORD;
#pragma convention(GetLogicalDriveStringsW,system);
#pragma import(GetLogicalDriveStringsW,'GetLogicalDriveStringsW','kernel32.dll');

#if #declared UNICODE; then;
#template GetLogicalDriveStrings;
  GetLogicalDriveStringsW 
#end GetLogicalDriveStrings;
#else;
#template GetLogicalDriveStrings;
  GetLogicalDriveStringsA 
#end GetLogicalDriveStrings;
#end if;

type
_MEMORY_RESOURCE_NOTIFICATION_TYPE= enum
    LowMemoryResourceNotification;
    HighMemoryResourceNotification;
  end enum for size use 4;
  MEMORY_RESOURCE_NOTIFICATION_TYPE = _MEMORY_RESOURCE_NOTIFICATION_TYPE;
procedure CreateMemoryResourceNotification(
    NotificationType : in MEMORY_RESOURCE_NOTIFICATION_TYPE)
                      return t_HANDLE;
#pragma convention(CreateMemoryResourceNotification,system);
#pragma import(CreateMemoryResourceNotification,'CreateMemoryResourceNotification','kernel32.dll');

procedure QueryMemoryResourceNotification(
    ResourceNotificationHandle : in t_HANDLE; 
    ResourceState   : out BOOL )
                      return BOOL;
#pragma convention(QueryMemoryResourceNotification,system);
#pragma import(QueryMemoryResourceNotification,'QueryMemoryResourceNotification','kernel32.dll');

procedure LoadLibraryA(
    lpLibFileName   : in LPCSTR)
                      return t_HMODULE;
#pragma convention(LoadLibraryA,system);
#pragma import(LoadLibraryA,'LoadLibraryA','kernel32.dll');

procedure LoadLibraryW(
    lpLibFileName   : in LPCWSTR)
                      return t_HMODULE;
#pragma convention(LoadLibraryW,system);
#pragma import(LoadLibraryW,'LoadLibraryW','kernel32.dll');

#if #declared UNICODE; then;
#template LoadLibrary;
  LoadLibraryW 
#end LoadLibrary;
#else;
#template LoadLibrary;
  LoadLibraryA 
#end LoadLibrary;
#end if;

procedure LoadLibraryExA(
    lpLibFileName   : in LPCSTR; 
    hFile           : in t_HANDLE; 
    dwFlags         : in DWORD)
                      return t_HMODULE;
#pragma convention(LoadLibraryExA,system);
#pragma import(LoadLibraryExA,'LoadLibraryExA','kernel32.dll');

procedure LoadLibraryExW(
    lpLibFileName   : in LPCWSTR; 
    hFile           : in t_HANDLE; 
    dwFlags         : in DWORD)
                      return t_HMODULE;
#pragma convention(LoadLibraryExW,system);
#pragma import(LoadLibraryExW,'LoadLibraryExW','kernel32.dll');

#if #declared UNICODE; then;
#template LoadLibraryEx;
  LoadLibraryExW 
#end LoadLibraryEx;
#else;
#template LoadLibraryEx;
  LoadLibraryExA 
#end LoadLibraryEx;
#end if;

const
  DONT_RESOLVE_DLL_REFERENCES= $01;

const
  LOAD_LIBRARY_AS_DATAFILE= $02;

const
  LOAD_WITH_ALTERED_SEARCH_PATH= $08;

const
  LOAD_IGNORE_CODE_AUTHZ_LEVEL= $10;

procedure GetModuleFileNameA(
    hModule         : in t_HMODULE; 
    lpFilename      : out CHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetModuleFileNameA,system);
#pragma import(GetModuleFileNameA,'GetModuleFileNameA','kernel32.dll');

procedure GetModuleFileNameW(
    hModule         : in t_HMODULE; 
    lpFilename      : out WCHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetModuleFileNameW,system);
#pragma import(GetModuleFileNameW,'GetModuleFileNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetModuleFileName;
  GetModuleFileNameW 
#end GetModuleFileName;
#else;
#template GetModuleFileName;
  GetModuleFileNameA 
#end GetModuleFileName;
#end if;

procedure GetModuleHandleA(
    lpModuleName    : in LPCSTR)
                      return t_HMODULE;
#pragma convention(GetModuleHandleA,system);
#pragma import(GetModuleHandleA,'GetModuleHandleA','kernel32.dll');

procedure GetModuleHandleW(
    lpModuleName    : in LPCWSTR)
                      return t_HMODULE;
#pragma convention(GetModuleHandleW,system);
#pragma import(GetModuleHandleW,'GetModuleHandleW','kernel32.dll');

#if #declared UNICODE; then;
#template GetModuleHandle;
  GetModuleHandleW 
#end GetModuleHandle;
#else;
#template GetModuleHandle;
  GetModuleHandleA 
#end GetModuleHandle;
#end if;

type
PGET_MODULE_HANDLE_EXA = ^procedure (
    dwFlags         : in DWORD;
    lpModuleName    : in LPCSTR;
    phModule        : out t_HMODULE)
                      return BOOL for machine_pointer use true;
type
PGET_MODULE_HANDLE_EXW = ^procedure (
    dwFlags         : in DWORD;
    lpModuleName    : in LPCWSTR;
    phModule        : out t_HMODULE)
                      return BOOL for machine_pointer use true;
#if #declared UNICODE; then;
#template PGET_MODULE_HANDLE_EX;
  PGET_MODULE_HANDLE_EXW 
#end PGET_MODULE_HANDLE_EX;
#else;
#template PGET_MODULE_HANDLE_EX;
  PGET_MODULE_HANDLE_EXA 
#end PGET_MODULE_HANDLE_EX;
#end if;

procedure GetModuleHandleExA(
    dwFlags         : in DWORD; 
    lpModuleName    : in LPCSTR; 
    phModule        : out t_HMODULE)
                      return BOOL;
#pragma convention(GetModuleHandleExA,system);
#pragma import(GetModuleHandleExA,'GetModuleHandleExA','kernel32.dll');

procedure GetModuleHandleExW(
    dwFlags         : in DWORD; 
    lpModuleName    : in LPCWSTR; 
    phModule        : out t_HMODULE)
                      return BOOL;
#pragma convention(GetModuleHandleExW,system);
#pragma import(GetModuleHandleExW,'GetModuleHandleExW','kernel32.dll');

#if #declared UNICODE; then;
#template GetModuleHandleEx;
  GetModuleHandleExW 
#end GetModuleHandleEx;
#else;
#template GetModuleHandleEx;
  GetModuleHandleExA 
#end GetModuleHandleEx;
#end if;

procedure CreateProcessA(
    lpApplicationName : in LPCSTR; 
    lpCommandLine   : in LPSTR; 
    lpProcessAttributes : in LPSECURITY_ATTRIBUTES; 
    lpThreadAttributes : in LPSECURITY_ATTRIBUTES; 
    bInheritHandles : in BOOL; 
    dwCreationFlags : in DWORD; 
    lpEnvironment   : in LPVOID; 
    lpCurrentDirectory : in LPCSTR; 
    lpStartupInfo   : in LPSTARTUPINFOA; 
    lpProcessInformation : out _PROCESS_INFORMATION)
                      return BOOL;
#pragma convention(CreateProcessA,system);
#pragma import(CreateProcessA,'CreateProcessA','kernel32.dll');

procedure CreateProcessW(
    lpApplicationName : in LPCWSTR; 
    lpCommandLine   : in LPWSTR; 
    lpProcessAttributes : in LPSECURITY_ATTRIBUTES; 
    lpThreadAttributes : in LPSECURITY_ATTRIBUTES; 
    bInheritHandles : in BOOL; 
    dwCreationFlags : in DWORD; 
    lpEnvironment   : in LPVOID; 
    lpCurrentDirectory : in LPCWSTR; 
    lpStartupInfo   : in LPSTARTUPINFOW; 
    lpProcessInformation : out _PROCESS_INFORMATION)
                      return BOOL;
#pragma convention(CreateProcessW,system);
#pragma import(CreateProcessW,'CreateProcessW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateProcess;
  CreateProcessW 
#end CreateProcess;
#else;
#template CreateProcess;
  CreateProcessA 
#end CreateProcess;
#end if;

procedure SetProcessShutdownParameters(
    dwLevel         : in DWORD; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(SetProcessShutdownParameters,system);
#pragma import(SetProcessShutdownParameters,'SetProcessShutdownParameters','kernel32.dll');

procedure GetProcessShutdownParameters(
    lpdwLevel       : out DWORD ; 
    lpdwFlags       : out DWORD )
                      return BOOL;
#pragma convention(GetProcessShutdownParameters,system);
#pragma import(GetProcessShutdownParameters,'GetProcessShutdownParameters','kernel32.dll');

procedure GetProcessVersion(
    ProcessId       : in DWORD)
                      return DWORD;
#pragma convention(GetProcessVersion,system);
#pragma import(GetProcessVersion,'GetProcessVersion','kernel32.dll');

procedure FatalAppExitA(
    uAction         : in UINT; 
    lpMessageText   : in LPCSTR);
#pragma convention(FatalAppExitA,system);
#pragma import(FatalAppExitA,'FatalAppExitA','kernel32.dll');

procedure FatalAppExitW(
    uAction         : in UINT; 
    lpMessageText   : in LPCWSTR);
#pragma convention(FatalAppExitW,system);
#pragma import(FatalAppExitW,'FatalAppExitW','kernel32.dll');

#if #declared UNICODE; then;
#template FatalAppExit;
  FatalAppExitW 
#end FatalAppExit;
#else;
#template FatalAppExit;
  FatalAppExitA 
#end FatalAppExit;
#end if;

procedure GetStartupInfoA(
    lpStartupInfo   : out _STARTUPINFOA);
#pragma convention(GetStartupInfoA,system);
#pragma import(GetStartupInfoA,'GetStartupInfoA','kernel32.dll');

procedure GetStartupInfoW(
    lpStartupInfo   : out _STARTUPINFOW);
#pragma convention(GetStartupInfoW,system);
#pragma import(GetStartupInfoW,'GetStartupInfoW','kernel32.dll');

#if #declared UNICODE; then;
#template GetStartupInfo;
  GetStartupInfoW 
#end GetStartupInfo;
#else;
#template GetStartupInfo;
  GetStartupInfoA 
#end GetStartupInfo;
#end if;

procedure GetCommandLineA
                      return LPSTR;
#pragma convention(GetCommandLineA,system);
#pragma import(GetCommandLineA,'GetCommandLineA','kernel32.dll');

procedure GetCommandLineW
                      return LPWSTR;
#pragma convention(GetCommandLineW,system);
#pragma import(GetCommandLineW,'GetCommandLineW','kernel32.dll');

#if #declared UNICODE; then;
#template GetCommandLine;
  GetCommandLineW 
#end GetCommandLine;
#else;
#template GetCommandLine;
  GetCommandLineA 
#end GetCommandLine;
#end if;

procedure GetEnvironmentVariableA(
    lpName          : in LPCSTR; 
    lpBuffer        : out CHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetEnvironmentVariableA,system);
#pragma import(GetEnvironmentVariableA,'GetEnvironmentVariableA','kernel32.dll');

procedure GetEnvironmentVariableW(
    lpName          : in LPCWSTR; 
    lpBuffer        : in PWSTR; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetEnvironmentVariableW,system);
#pragma import(GetEnvironmentVariableW,'GetEnvironmentVariableW','kernel32.dll');

#if #declared UNICODE; then;
#template GetEnvironmentVariable;
  GetEnvironmentVariableW 
#end GetEnvironmentVariable;
#else;
#template GetEnvironmentVariable;
  GetEnvironmentVariableA 
#end GetEnvironmentVariable;
#end if;

procedure SetEnvironmentVariableA(
    lpName          : in LPCSTR; 
    lpValue         : in LPCSTR)
                      return BOOL;
#pragma convention(SetEnvironmentVariableA,system);
#pragma import(SetEnvironmentVariableA,'SetEnvironmentVariableA','kernel32.dll');

procedure SetEnvironmentVariableW(
    lpName          : in LPCWSTR; 
    lpValue         : in LPCWSTR)
                      return BOOL;
#pragma convention(SetEnvironmentVariableW,system);
#pragma import(SetEnvironmentVariableW,'SetEnvironmentVariableW','kernel32.dll');

#if #declared UNICODE; then;
#template SetEnvironmentVariable;
  SetEnvironmentVariableW 
#end SetEnvironmentVariable;
#else;
#template SetEnvironmentVariable;
  SetEnvironmentVariableA 
#end SetEnvironmentVariable;
#end if;

procedure ExpandEnvironmentStringsA(
    lpSrc           : in LPCSTR; 
    lpDst           : out CHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(ExpandEnvironmentStringsA,system);
#pragma import(ExpandEnvironmentStringsA,'ExpandEnvironmentStringsA','kernel32.dll');

procedure ExpandEnvironmentStringsW(
    lpSrc           : in LPCWSTR; 
    lpDst           : out WCHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(ExpandEnvironmentStringsW,system);
#pragma import(ExpandEnvironmentStringsW,'ExpandEnvironmentStringsW','kernel32.dll');

#if #declared UNICODE; then;
#template ExpandEnvironmentStrings;
  ExpandEnvironmentStringsW 
#end ExpandEnvironmentStrings;
#else;
#template ExpandEnvironmentStrings;
  ExpandEnvironmentStringsA 
#end ExpandEnvironmentStrings;
#end if;

procedure GetFirmwareEnvironmentVariableA(
    lpName          : in LPCSTR; 
    lpGuid          : in LPCSTR; 
    pBuffer         : out unchecked ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetFirmwareEnvironmentVariableA,system);
#pragma import(GetFirmwareEnvironmentVariableA,'GetFirmwareEnvironmentVariableA','kernel32.dll');

procedure GetFirmwareEnvironmentVariableW(
    lpName          : in LPCWSTR; 
    lpGuid          : in LPCWSTR; 
    pBuffer         : out unchecked ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetFirmwareEnvironmentVariableW,system);
#pragma import(GetFirmwareEnvironmentVariableW,'GetFirmwareEnvironmentVariableW','kernel32.dll');

#if #declared UNICODE; then;
#template GetFirmwareEnvironmentVariable;
  GetFirmwareEnvironmentVariableW 
#end GetFirmwareEnvironmentVariable;
#else;
#template GetFirmwareEnvironmentVariable;
  GetFirmwareEnvironmentVariableA 
#end GetFirmwareEnvironmentVariable;
#end if;

procedure SetFirmwareEnvironmentVariableA(
    lpName          : in LPCSTR; 
    lpGuid          : in LPCSTR; 
    pValue          : in PVOID; 
    nSize           : in DWORD)
                      return BOOL;
#pragma convention(SetFirmwareEnvironmentVariableA,system);
#pragma import(SetFirmwareEnvironmentVariableA,'SetFirmwareEnvironmentVariableA','kernel32.dll');

procedure SetFirmwareEnvironmentVariableW(
    lpName          : in LPCWSTR; 
    lpGuid          : in LPCWSTR; 
    pValue          : in PVOID; 
    nSize           : in DWORD)
                      return BOOL;
#pragma convention(SetFirmwareEnvironmentVariableW,system);
#pragma import(SetFirmwareEnvironmentVariableW,'SetFirmwareEnvironmentVariableW','kernel32.dll');

#if #declared UNICODE; then;
#template SetFirmwareEnvironmentVariable;
  SetFirmwareEnvironmentVariableW 
#end SetFirmwareEnvironmentVariable;
#else;
#template SetFirmwareEnvironmentVariable;
  SetFirmwareEnvironmentVariableA 
#end SetFirmwareEnvironmentVariable;
#end if;

procedure OutputDebugStringA(
    lpOutputString  : in LPCSTR);
#pragma convention(OutputDebugStringA,system);
#pragma import(OutputDebugStringA,'OutputDebugStringA','kernel32.dll');

procedure OutputDebugStringW(
    lpOutputString  : in LPCWSTR);
#pragma convention(OutputDebugStringW,system);
#pragma import(OutputDebugStringW,'OutputDebugStringW','kernel32.dll');

#if #declared UNICODE; then;
#template OutputDebugString;
  OutputDebugStringW 
#end OutputDebugString;
#else;
#template OutputDebugString;
  OutputDebugStringA 
#end OutputDebugString;
#end if;

procedure FindResourceA(
    hModule         : in t_HMODULE; 
    lpName          : in LPCSTR; 
    lpType          : in LPCSTR)
                      return HRSRC;
#pragma convention(FindResourceA,system);
#pragma import(FindResourceA,'FindResourceA','kernel32.dll');

procedure FindResourceW(
    hModule         : in t_HMODULE; 
    lpName          : in LPCWSTR; 
    lpType          : in LPCWSTR)
                      return HRSRC;
#pragma convention(FindResourceW,system);
#pragma import(FindResourceW,'FindResourceW','kernel32.dll');

#if #declared UNICODE; then;
#template FindResource;
  FindResourceW 
#end FindResource;
#else;
#template FindResource;
  FindResourceA 
#end FindResource;
#end if;

procedure FindResourceExA(
    hModule         : in t_HMODULE; 
    lpType          : in LPCSTR; 
    lpName          : in LPCSTR; 
    wLanguage       : in WORD)
                      return HRSRC;
#pragma convention(FindResourceExA,system);
#pragma import(FindResourceExA,'FindResourceExA','kernel32.dll');

procedure FindResourceExW(
    hModule         : in t_HMODULE; 
    lpType          : in LPCWSTR; 
    lpName          : in LPCWSTR; 
    wLanguage       : in WORD)
                      return HRSRC;
#pragma convention(FindResourceExW,system);
#pragma import(FindResourceExW,'FindResourceExW','kernel32.dll');

#if #declared UNICODE; then;
#template FindResourceEx;
  FindResourceExW 
#end FindResourceEx;
#else;
#template FindResourceEx;
  FindResourceExA 
#end FindResourceEx;
#end if;

type
ENUMRESTYPEPROCA  = FARPROC;
type
ENUMRESTYPEPROCW  = FARPROC;
#if #declared UNICODE; then;
type
ENUMRESTYPEPROC   = ENUMRESTYPEPROCW;
#else;
type
ENUMRESTYPEPROC   = ENUMRESTYPEPROCA;
#end if;

type
ENUMRESNAMEPROCA  = FARPROC;
type
ENUMRESNAMEPROCW  = FARPROC;
#if #declared UNICODE; then;
type
ENUMRESNAMEPROC   = ENUMRESNAMEPROCW;
#else;
type
ENUMRESNAMEPROC   = ENUMRESNAMEPROCA;
#end if;

type
ENUMRESLANGPROCA  = FARPROC;
type
ENUMRESLANGPROCW  = FARPROC;
#if #declared UNICODE; then;
type
ENUMRESLANGPROC   = ENUMRESLANGPROCW;
#else;
type
ENUMRESLANGPROC   = ENUMRESLANGPROCA;
#end if;

procedure EnumResourceTypesA(
    hModule         : in t_HMODULE; 
    lpEnumFunc      : in ENUMRESTYPEPROCA; 
    lParam          : in LONG_PTR)
                      return BOOL;
#pragma convention(EnumResourceTypesA,system);
#pragma import(EnumResourceTypesA,'EnumResourceTypesA','kernel32.dll');

procedure EnumResourceTypesW(
    hModule         : in t_HMODULE; 
    lpEnumFunc      : in ENUMRESTYPEPROCW; 
    lParam          : in LONG_PTR)
                      return BOOL;
#pragma convention(EnumResourceTypesW,system);
#pragma import(EnumResourceTypesW,'EnumResourceTypesW','kernel32.dll');

#if #declared UNICODE; then;
#template EnumResourceTypes;
  EnumResourceTypesW 
#end EnumResourceTypes;
#else;
#template EnumResourceTypes;
  EnumResourceTypesA 
#end EnumResourceTypes;
#end if;

procedure EnumResourceNamesA(
    hModule         : in t_HMODULE; 
    lpType          : in LPCSTR; 
    lpEnumFunc      : in ENUMRESNAMEPROCA; 
    lParam          : in LONG_PTR)
                      return BOOL;
#pragma convention(EnumResourceNamesA,system);
#pragma import(EnumResourceNamesA,'EnumResourceNamesA','kernel32.dll');

procedure EnumResourceNamesW(
    hModule         : in t_HMODULE; 
    lpType          : in LPCWSTR; 
    lpEnumFunc      : in ENUMRESNAMEPROCW; 
    lParam          : in LONG_PTR)
                      return BOOL;
#pragma convention(EnumResourceNamesW,system);
#pragma import(EnumResourceNamesW,'EnumResourceNamesW','kernel32.dll');

#if #declared UNICODE; then;
#template EnumResourceNames;
  EnumResourceNamesW 
#end EnumResourceNames;
#else;
#template EnumResourceNames;
  EnumResourceNamesA 
#end EnumResourceNames;
#end if;

procedure EnumResourceLanguagesA(
    hModule         : in t_HMODULE; 
    lpType          : in LPCSTR; 
    lpName          : in LPCSTR; 
    lpEnumFunc      : in ENUMRESLANGPROCA; 
    lParam          : in LONG_PTR)
                      return BOOL;
#pragma convention(EnumResourceLanguagesA,system);
#pragma import(EnumResourceLanguagesA,'EnumResourceLanguagesA','kernel32.dll');

procedure EnumResourceLanguagesW(
    hModule         : in t_HMODULE; 
    lpType          : in LPCWSTR; 
    lpName          : in LPCWSTR; 
    lpEnumFunc      : in ENUMRESLANGPROCW; 
    lParam          : in LONG_PTR)
                      return BOOL;
#pragma convention(EnumResourceLanguagesW,system);
#pragma import(EnumResourceLanguagesW,'EnumResourceLanguagesW','kernel32.dll');

#if #declared UNICODE; then;
#template EnumResourceLanguages;
  EnumResourceLanguagesW 
#end EnumResourceLanguages;
#else;
#template EnumResourceLanguages;
  EnumResourceLanguagesA 
#end EnumResourceLanguages;
#end if;

procedure BeginUpdateResourceA(
    pFileName       : in LPCSTR; 
    bDeleteExistingResources : in BOOL)
                      return t_HANDLE;
#pragma convention(BeginUpdateResourceA,system);
#pragma import(BeginUpdateResourceA,'BeginUpdateResourceA','kernel32.dll');

procedure BeginUpdateResourceW(
    pFileName       : in LPCWSTR; 
    bDeleteExistingResources : in BOOL)
                      return t_HANDLE;
#pragma convention(BeginUpdateResourceW,system);
#pragma import(BeginUpdateResourceW,'BeginUpdateResourceW','kernel32.dll');

#if #declared UNICODE; then;
#template BeginUpdateResource;
  BeginUpdateResourceW 
#end BeginUpdateResource;
#else;
#template BeginUpdateResource;
  BeginUpdateResourceA 
#end BeginUpdateResource;
#end if;

procedure UpdateResourceA(
    hUpdate         : in t_HANDLE; 
    lpType          : in LPCSTR; 
    lpName          : in LPCSTR; 
    wLanguage       : in WORD; 
    lpData          : in LPVOID; 
    cbData          : in DWORD)
                      return BOOL;
#pragma convention(UpdateResourceA,system);
#pragma import(UpdateResourceA,'UpdateResourceA','kernel32.dll');

procedure UpdateResourceW(
    hUpdate         : in t_HANDLE; 
    lpType          : in LPCWSTR; 
    lpName          : in LPCWSTR; 
    wLanguage       : in WORD; 
    lpData          : in LPVOID; 
    cbData          : in DWORD)
                      return BOOL;
#pragma convention(UpdateResourceW,system);
#pragma import(UpdateResourceW,'UpdateResourceW','kernel32.dll');

#if #declared UNICODE; then;
#template UpdateResource;
  UpdateResourceW 
#end UpdateResource;
#else;
#template UpdateResource;
  UpdateResourceA 
#end UpdateResource;
#end if;

procedure EndUpdateResourceA(
    hUpdate         : in t_HANDLE; 
    fDiscard        : in BOOL)
                      return BOOL;
#pragma convention(EndUpdateResourceA,system);
#pragma import(EndUpdateResourceA,'EndUpdateResourceA','kernel32.dll');

procedure EndUpdateResourceW(
    hUpdate         : in t_HANDLE; 
    fDiscard        : in BOOL)
                      return BOOL;
#pragma convention(EndUpdateResourceW,system);
#pragma import(EndUpdateResourceW,'EndUpdateResourceW','kernel32.dll');

#if #declared UNICODE; then;
#template EndUpdateResource;
  EndUpdateResourceW 
#end EndUpdateResource;
#else;
#template EndUpdateResource;
  EndUpdateResourceA 
#end EndUpdateResource;
#end if;

procedure GlobalAddAtomA(
    lpString        : in LPCSTR)
                      return ATOM;
#pragma convention(GlobalAddAtomA,system);
#pragma import(GlobalAddAtomA,'GlobalAddAtomA','kernel32.dll');

procedure GlobalAddAtomW(
    lpString        : in LPCWSTR)
                      return ATOM;
#pragma convention(GlobalAddAtomW,system);
#pragma import(GlobalAddAtomW,'GlobalAddAtomW','kernel32.dll');

#if #declared UNICODE; then;
#template GlobalAddAtom;
  GlobalAddAtomW 
#end GlobalAddAtom;
#else;
#template GlobalAddAtom;
  GlobalAddAtomA 
#end GlobalAddAtom;
#end if;

procedure GlobalFindAtomA(
    lpString        : in LPCSTR)
                      return ATOM;
#pragma convention(GlobalFindAtomA,system);
#pragma import(GlobalFindAtomA,'GlobalFindAtomA','kernel32.dll');

procedure GlobalFindAtomW(
    lpString        : in LPCWSTR)
                      return ATOM;
#pragma convention(GlobalFindAtomW,system);
#pragma import(GlobalFindAtomW,'GlobalFindAtomW','kernel32.dll');

#if #declared UNICODE; then;
#template GlobalFindAtom;
  GlobalFindAtomW 
#end GlobalFindAtom;
#else;
#template GlobalFindAtom;
  GlobalFindAtomA 
#end GlobalFindAtom;
#end if;

type
t_059=signed 32;

procedure GlobalGetAtomNameA(
    nAtom           : in ATOM; 
    lpBuffer        : out CHARSTR ; 
    nSize           : in t_059)
                      return UINT;
#pragma convention(GlobalGetAtomNameA,system);
#pragma import(GlobalGetAtomNameA,'GlobalGetAtomNameA','kernel32.dll');

type
t_060=signed 32;

procedure GlobalGetAtomNameW(
    nAtom           : in ATOM; 
    lpBuffer        : out WCHARSTR ; 
    nSize           : in t_060)
                      return UINT;
#pragma convention(GlobalGetAtomNameW,system);
#pragma import(GlobalGetAtomNameW,'GlobalGetAtomNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GlobalGetAtomName;
  GlobalGetAtomNameW 
#end GlobalGetAtomName;
#else;
#template GlobalGetAtomName;
  GlobalGetAtomNameA 
#end GlobalGetAtomName;
#end if;

procedure AddAtomA(
    lpString        : in LPCSTR)
                      return ATOM;
#pragma convention(AddAtomA,system);
#pragma import(AddAtomA,'AddAtomA','kernel32.dll');

procedure AddAtomW(
    lpString        : in LPCWSTR)
                      return ATOM;
#pragma convention(AddAtomW,system);
#pragma import(AddAtomW,'AddAtomW','kernel32.dll');

#if #declared UNICODE; then;
#template AddAtom;
  AddAtomW 
#end AddAtom;
#else;
#template AddAtom;
  AddAtomA 
#end AddAtom;
#end if;

procedure FindAtomA(
    lpString        : in LPCSTR)
                      return ATOM;
#pragma convention(FindAtomA,system);
#pragma import(FindAtomA,'FindAtomA','kernel32.dll');

procedure FindAtomW(
    lpString        : in LPCWSTR)
                      return ATOM;
#pragma convention(FindAtomW,system);
#pragma import(FindAtomW,'FindAtomW','kernel32.dll');

#if #declared UNICODE; then;
#template FindAtom;
  FindAtomW 
#end FindAtom;
#else;
#template FindAtom;
  FindAtomA 
#end FindAtom;
#end if;

type
t_061=signed 32;

procedure GetAtomNameA(
    nAtom           : in ATOM; 
    lpBuffer        : out CHARSTR ; 
    nSize           : in t_061)
                      return UINT;
#pragma convention(GetAtomNameA,system);
#pragma import(GetAtomNameA,'GetAtomNameA','kernel32.dll');

type
t_062=signed 32;

procedure GetAtomNameW(
    nAtom           : in ATOM; 
    lpBuffer        : out WCHARSTR ; 
    nSize           : in t_062)
                      return UINT;
#pragma convention(GetAtomNameW,system);
#pragma import(GetAtomNameW,'GetAtomNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetAtomName;
  GetAtomNameW 
#end GetAtomName;
#else;
#template GetAtomName;
  GetAtomNameA 
#end GetAtomName;
#end if;

procedure GetProfileIntA(
    lpAppName       : in LPCSTR; 
    lpKeyName       : in LPCSTR; 
    nDefault        : in INT)
                      return UINT;
#pragma convention(GetProfileIntA,system);
#pragma import(GetProfileIntA,'GetProfileIntA','kernel32.dll');

procedure GetProfileIntW(
    lpAppName       : in LPCWSTR; 
    lpKeyName       : in LPCWSTR; 
    nDefault        : in INT)
                      return UINT;
#pragma convention(GetProfileIntW,system);
#pragma import(GetProfileIntW,'GetProfileIntW','kernel32.dll');

#if #declared UNICODE; then;
#template GetProfileInt;
  GetProfileIntW 
#end GetProfileInt;
#else;
#template GetProfileInt;
  GetProfileIntA 
#end GetProfileInt;
#end if;

procedure GetProfileStringA(
    lpAppName       : in LPCSTR; 
    lpKeyName       : in LPCSTR; 
    lpDefault       : in LPCSTR; 
    lpReturnedString : out CHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetProfileStringA,system);
#pragma import(GetProfileStringA,'GetProfileStringA','kernel32.dll');

procedure GetProfileStringW(
    lpAppName       : in LPCWSTR; 
    lpKeyName       : in LPCWSTR; 
    lpDefault       : in LPCWSTR; 
    lpReturnedString : out WCHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetProfileStringW,system);
#pragma import(GetProfileStringW,'GetProfileStringW','kernel32.dll');

#if #declared UNICODE; then;
#template GetProfileString;
  GetProfileStringW 
#end GetProfileString;
#else;
#template GetProfileString;
  GetProfileStringA 
#end GetProfileString;
#end if;

procedure WriteProfileStringA(
    lpAppName       : in LPCSTR; 
    lpKeyName       : in LPCSTR; 
    lpString        : in LPCSTR)
                      return BOOL;
#pragma convention(WriteProfileStringA,system);
#pragma import(WriteProfileStringA,'WriteProfileStringA','kernel32.dll');

procedure WriteProfileStringW(
    lpAppName       : in LPCWSTR; 
    lpKeyName       : in LPCWSTR; 
    lpString        : in LPCWSTR)
                      return BOOL;
#pragma convention(WriteProfileStringW,system);
#pragma import(WriteProfileStringW,'WriteProfileStringW','kernel32.dll');

#if #declared UNICODE; then;
#template WriteProfileString;
  WriteProfileStringW 
#end WriteProfileString;
#else;
#template WriteProfileString;
  WriteProfileStringA 
#end WriteProfileString;
#end if;

procedure GetProfileSectionA(
    lpAppName       : in LPCSTR; 
    lpReturnedString : out CHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetProfileSectionA,system);
#pragma import(GetProfileSectionA,'GetProfileSectionA','kernel32.dll');

procedure GetProfileSectionW(
    lpAppName       : in LPCWSTR; 
    lpReturnedString : out WCHARSTR ; 
    nSize           : in DWORD)
                      return DWORD;
#pragma convention(GetProfileSectionW,system);
#pragma import(GetProfileSectionW,'GetProfileSectionW','kernel32.dll');

#if #declared UNICODE; then;
#template GetProfileSection;
  GetProfileSectionW 
#end GetProfileSection;
#else;
#template GetProfileSection;
  GetProfileSectionA 
#end GetProfileSection;
#end if;

procedure WriteProfileSectionA(
    lpAppName       : in LPCSTR; 
    lpString        : in LPCSTR)
                      return BOOL;
#pragma convention(WriteProfileSectionA,system);
#pragma import(WriteProfileSectionA,'WriteProfileSectionA','kernel32.dll');

procedure WriteProfileSectionW(
    lpAppName       : in LPCWSTR; 
    lpString        : in LPCWSTR)
                      return BOOL;
#pragma convention(WriteProfileSectionW,system);
#pragma import(WriteProfileSectionW,'WriteProfileSectionW','kernel32.dll');

#if #declared UNICODE; then;
#template WriteProfileSection;
  WriteProfileSectionW 
#end WriteProfileSection;
#else;
#template WriteProfileSection;
  WriteProfileSectionA 
#end WriteProfileSection;
#end if;

procedure GetPrivateProfileIntA(
    lpAppName       : in LPCSTR; 
    lpKeyName       : in LPCSTR; 
    nDefault        : in INT; 
    lpFileName      : in LPCSTR)
                      return UINT;
#pragma convention(GetPrivateProfileIntA,system);
#pragma import(GetPrivateProfileIntA,'GetPrivateProfileIntA','kernel32.dll');

procedure GetPrivateProfileIntW(
    lpAppName       : in LPCWSTR; 
    lpKeyName       : in LPCWSTR; 
    nDefault        : in INT; 
    lpFileName      : in LPCWSTR)
                      return UINT;
#pragma convention(GetPrivateProfileIntW,system);
#pragma import(GetPrivateProfileIntW,'GetPrivateProfileIntW','kernel32.dll');

#if #declared UNICODE; then;
#template GetPrivateProfileInt;
  GetPrivateProfileIntW 
#end GetPrivateProfileInt;
#else;
#template GetPrivateProfileInt;
  GetPrivateProfileIntA 
#end GetPrivateProfileInt;
#end if;

procedure GetPrivateProfileStringA(
    lpAppName       : in LPCSTR; 
    lpKeyName       : in LPCSTR; 
    lpDefault       : in LPCSTR; 
    lpReturnedString : out CHARSTR ; 
    nSize           : in DWORD; 
    lpFileName      : in LPCSTR)
                      return DWORD;
#pragma convention(GetPrivateProfileStringA,system);
#pragma import(GetPrivateProfileStringA,'GetPrivateProfileStringA','kernel32.dll');

procedure GetPrivateProfileStringW(
    lpAppName       : in LPCWSTR; 
    lpKeyName       : in LPCWSTR; 
    lpDefault       : in LPCWSTR; 
    lpReturnedString : out WCHARSTR ; 
    nSize           : in DWORD; 
    lpFileName      : in LPCWSTR)
                      return DWORD;
#pragma convention(GetPrivateProfileStringW,system);
#pragma import(GetPrivateProfileStringW,'GetPrivateProfileStringW','kernel32.dll');

#if #declared UNICODE; then;
#template GetPrivateProfileString;
  GetPrivateProfileStringW 
#end GetPrivateProfileString;
#else;
#template GetPrivateProfileString;
  GetPrivateProfileStringA 
#end GetPrivateProfileString;
#end if;

procedure WritePrivateProfileStringA(
    lpAppName       : in LPCSTR; 
    lpKeyName       : in LPCSTR; 
    lpString        : in LPCSTR; 
    lpFileName      : in LPCSTR)
                      return BOOL;
#pragma convention(WritePrivateProfileStringA,system);
#pragma import(WritePrivateProfileStringA,'WritePrivateProfileStringA','kernel32.dll');

procedure WritePrivateProfileStringW(
    lpAppName       : in LPCWSTR; 
    lpKeyName       : in LPCWSTR; 
    lpString        : in LPCWSTR; 
    lpFileName      : in LPCWSTR)
                      return BOOL;
#pragma convention(WritePrivateProfileStringW,system);
#pragma import(WritePrivateProfileStringW,'WritePrivateProfileStringW','kernel32.dll');

#if #declared UNICODE; then;
#template WritePrivateProfileString;
  WritePrivateProfileStringW 
#end WritePrivateProfileString;
#else;
#template WritePrivateProfileString;
  WritePrivateProfileStringA 
#end WritePrivateProfileString;
#end if;

procedure GetPrivateProfileSectionA(
    lpAppName       : in LPCSTR; 
    lpReturnedString : out CHARSTR ; 
    nSize           : in DWORD; 
    lpFileName      : in LPCSTR)
                      return DWORD;
#pragma convention(GetPrivateProfileSectionA,system);
#pragma import(GetPrivateProfileSectionA,'GetPrivateProfileSectionA','kernel32.dll');

procedure GetPrivateProfileSectionW(
    lpAppName       : in LPCWSTR; 
    lpReturnedString : out WCHARSTR ; 
    nSize           : in DWORD; 
    lpFileName      : in LPCWSTR)
                      return DWORD;
#pragma convention(GetPrivateProfileSectionW,system);
#pragma import(GetPrivateProfileSectionW,'GetPrivateProfileSectionW','kernel32.dll');

#if #declared UNICODE; then;
#template GetPrivateProfileSection;
  GetPrivateProfileSectionW 
#end GetPrivateProfileSection;
#else;
#template GetPrivateProfileSection;
  GetPrivateProfileSectionA 
#end GetPrivateProfileSection;
#end if;

procedure WritePrivateProfileSectionA(
    lpAppName       : in LPCSTR; 
    lpString        : in LPCSTR; 
    lpFileName      : in LPCSTR)
                      return BOOL;
#pragma convention(WritePrivateProfileSectionA,system);
#pragma import(WritePrivateProfileSectionA,'WritePrivateProfileSectionA','kernel32.dll');

procedure WritePrivateProfileSectionW(
    lpAppName       : in LPCWSTR; 
    lpString        : in LPCWSTR; 
    lpFileName      : in LPCWSTR)
                      return BOOL;
#pragma convention(WritePrivateProfileSectionW,system);
#pragma import(WritePrivateProfileSectionW,'WritePrivateProfileSectionW','kernel32.dll');

#if #declared UNICODE; then;
#template WritePrivateProfileSection;
  WritePrivateProfileSectionW 
#end WritePrivateProfileSection;
#else;
#template WritePrivateProfileSection;
  WritePrivateProfileSectionA 
#end WritePrivateProfileSection;
#end if;

procedure GetPrivateProfileSectionNamesA(
    lpszReturnBuffer : out CHARSTR ; 
    nSize           : in DWORD; 
    lpFileName      : in LPCSTR)
                      return DWORD;
#pragma convention(GetPrivateProfileSectionNamesA,system);
#pragma import(GetPrivateProfileSectionNamesA,'GetPrivateProfileSectionNamesA','kernel32.dll');

procedure GetPrivateProfileSectionNamesW(
    lpszReturnBuffer : out WCHARSTR ; 
    nSize           : in DWORD; 
    lpFileName      : in LPCWSTR)
                      return DWORD;
#pragma convention(GetPrivateProfileSectionNamesW,system);
#pragma import(GetPrivateProfileSectionNamesW,'GetPrivateProfileSectionNamesW','kernel32.dll');

#if #declared UNICODE; then;
#template GetPrivateProfileSectionNames;
  GetPrivateProfileSectionNamesW 
#end GetPrivateProfileSectionNames;
#else;
#template GetPrivateProfileSectionNames;
  GetPrivateProfileSectionNamesA 
#end GetPrivateProfileSectionNames;
#end if;

procedure GetPrivateProfileStructA(
    lpszSection     : in LPCSTR; 
    lpszKey         : in LPCSTR; 
    lpStruct        : out unchecked ; 
    uSizeStruct     : in UINT; 
    szFile          : in LPCSTR)
                      return BOOL;
#pragma convention(GetPrivateProfileStructA,system);
#pragma import(GetPrivateProfileStructA,'GetPrivateProfileStructA','kernel32.dll');

procedure GetPrivateProfileStructW(
    lpszSection     : in LPCWSTR; 
    lpszKey         : in LPCWSTR; 
    lpStruct        : out unchecked ; 
    uSizeStruct     : in UINT; 
    szFile          : in LPCWSTR)
                      return BOOL;
#pragma convention(GetPrivateProfileStructW,system);
#pragma import(GetPrivateProfileStructW,'GetPrivateProfileStructW','kernel32.dll');

#if #declared UNICODE; then;
#template GetPrivateProfileStruct;
  GetPrivateProfileStructW 
#end GetPrivateProfileStruct;
#else;
#template GetPrivateProfileStruct;
  GetPrivateProfileStructA 
#end GetPrivateProfileStruct;
#end if;

procedure WritePrivateProfileStructA(
    lpszSection     : in LPCSTR; 
    lpszKey         : in LPCSTR; 
    lpStruct        : in LPVOID; 
    uSizeStruct     : in UINT; 
    szFile          : in LPCSTR)
                      return BOOL;
#pragma convention(WritePrivateProfileStructA,system);
#pragma import(WritePrivateProfileStructA,'WritePrivateProfileStructA','kernel32.dll');

procedure WritePrivateProfileStructW(
    lpszSection     : in LPCWSTR; 
    lpszKey         : in LPCWSTR; 
    lpStruct        : in LPVOID; 
    uSizeStruct     : in UINT; 
    szFile          : in LPCWSTR)
                      return BOOL;
#pragma convention(WritePrivateProfileStructW,system);
#pragma import(WritePrivateProfileStructW,'WritePrivateProfileStructW','kernel32.dll');

#if #declared UNICODE; then;
#template WritePrivateProfileStruct;
  WritePrivateProfileStructW 
#end WritePrivateProfileStruct;
#else;
#template WritePrivateProfileStruct;
  WritePrivateProfileStructA 
#end WritePrivateProfileStruct;
#end if;

procedure GetDriveTypeA(
    lpRootPathName  : in LPCSTR)
                      return UINT;
#pragma convention(GetDriveTypeA,system);
#pragma import(GetDriveTypeA,'GetDriveTypeA','kernel32.dll');

procedure GetDriveTypeW(
    lpRootPathName  : in LPCWSTR)
                      return UINT;
#pragma convention(GetDriveTypeW,system);
#pragma import(GetDriveTypeW,'GetDriveTypeW','kernel32.dll');

#if #declared UNICODE; then;
#template GetDriveType;
  GetDriveTypeW 
#end GetDriveType;
#else;
#template GetDriveType;
  GetDriveTypeA 
#end GetDriveType;
#end if;

procedure GetSystemDirectoryA(
    lpBuffer        : out CHARSTR ; 
    uSize           : in UINT)
                      return UINT;
#pragma convention(GetSystemDirectoryA,system);
#pragma import(GetSystemDirectoryA,'GetSystemDirectoryA','kernel32.dll');

procedure GetSystemDirectoryW(
    lpBuffer        : out WCHARSTR ; 
    uSize           : in UINT)
                      return UINT;
#pragma convention(GetSystemDirectoryW,system);
#pragma import(GetSystemDirectoryW,'GetSystemDirectoryW','kernel32.dll');

#if #declared UNICODE; then;
#template GetSystemDirectory;
  GetSystemDirectoryW 
#end GetSystemDirectory;
#else;
#template GetSystemDirectory;
  GetSystemDirectoryA 
#end GetSystemDirectory;
#end if;

procedure GetTempPathA(
    nBufferLength   : in DWORD; 
    lpBuffer        : out CHARSTR )
                      return DWORD;
#pragma convention(GetTempPathA,system);
#pragma import(GetTempPathA,'GetTempPathA','kernel32.dll');

procedure GetTempPathW(
    nBufferLength   : in DWORD; 
    lpBuffer        : out WCHARSTR )
                      return DWORD;
#pragma convention(GetTempPathW,system);
#pragma import(GetTempPathW,'GetTempPathW','kernel32.dll');

#if #declared UNICODE; then;
#template GetTempPath;
  GetTempPathW 
#end GetTempPath;
#else;
#template GetTempPath;
  GetTempPathA 
#end GetTempPath;
#end if;

procedure GetTempFileNameA(
    lpPathName      : in LPCSTR; 
    lpPrefixString  : in LPCSTR; 
    uUnique         : in UINT; 
    lpTempFileName  : out CHARSTR )
                      return UINT;
#pragma convention(GetTempFileNameA,system);
#pragma import(GetTempFileNameA,'GetTempFileNameA','kernel32.dll');

procedure GetTempFileNameW(
    lpPathName      : in LPCWSTR; 
    lpPrefixString  : in LPCWSTR; 
    uUnique         : in UINT; 
    lpTempFileName  : out WCHARSTR )
                      return UINT;
#pragma convention(GetTempFileNameW,system);
#pragma import(GetTempFileNameW,'GetTempFileNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetTempFileName;
  GetTempFileNameW 
#end GetTempFileName;
#else;
#template GetTempFileName;
  GetTempFileNameA 
#end GetTempFileName;
#end if;

procedure GetWindowsDirectoryA(
    lpBuffer        : out CHARSTR ; 
    uSize           : in UINT)
                      return UINT;
#pragma convention(GetWindowsDirectoryA,system);
#pragma import(GetWindowsDirectoryA,'GetWindowsDirectoryA','kernel32.dll');

procedure GetWindowsDirectoryW(
    lpBuffer        : out WCHARSTR ; 
    uSize           : in UINT)
                      return UINT;
#pragma convention(GetWindowsDirectoryW,system);
#pragma import(GetWindowsDirectoryW,'GetWindowsDirectoryW','kernel32.dll');

#if #declared UNICODE; then;
#template GetWindowsDirectory;
  GetWindowsDirectoryW 
#end GetWindowsDirectory;
#else;
#template GetWindowsDirectory;
  GetWindowsDirectoryA 
#end GetWindowsDirectory;
#end if;

procedure GetSystemWindowsDirectoryA(
    lpBuffer        : out CHARSTR ; 
    uSize           : in UINT)
                      return UINT;
#pragma convention(GetSystemWindowsDirectoryA,system);
#pragma import(GetSystemWindowsDirectoryA,'GetSystemWindowsDirectoryA','kernel32.dll');

procedure GetSystemWindowsDirectoryW(
    lpBuffer        : out WCHARSTR ; 
    uSize           : in UINT)
                      return UINT;
#pragma convention(GetSystemWindowsDirectoryW,system);
#pragma import(GetSystemWindowsDirectoryW,'GetSystemWindowsDirectoryW','kernel32.dll');

#if #declared UNICODE; then;
#template GetSystemWindowsDirectory;
  GetSystemWindowsDirectoryW 
#end GetSystemWindowsDirectory;
#else;
#template GetSystemWindowsDirectory;
  GetSystemWindowsDirectoryA 
#end GetSystemWindowsDirectory;
#end if;

--  RC warns because "WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY" is a bit long.
procedure GetSystemWow64DirectoryA(
    lpBuffer        : out CHARSTR ; 
    uSize           : in UINT)
                      return UINT;
#pragma convention(GetSystemWow64DirectoryA,system);
#pragma import(GetSystemWow64DirectoryA,'GetSystemWow64DirectoryA','kernel32.dll');

procedure GetSystemWow64DirectoryW(
    lpBuffer        : out WCHARSTR ; 
    uSize           : in UINT)
                      return UINT;
#pragma convention(GetSystemWow64DirectoryW,system);
#pragma import(GetSystemWow64DirectoryW,'GetSystemWow64DirectoryW','kernel32.dll');

#if #declared UNICODE; then;
#template GetSystemWow64Directory;
  GetSystemWow64DirectoryW 
#end GetSystemWow64Directory;
#else;
#template GetSystemWow64Directory;
  GetSystemWow64DirectoryA 
#end GetSystemWow64Directory;
#end if;

procedure Wow64EnableWow64FsRedirection(
    Wow64FsEnableRedirection : in BOOLEAN)
                      return BOOLEAN;
#pragma convention(Wow64EnableWow64FsRedirection,system);
#pragma import(Wow64EnableWow64FsRedirection,'Wow64EnableWow64FsRedirection','kernel32.dll');

-- 
--  for GetProcAddress
-- 
type
PGET_SYSTEM_WOW64_DIRECTORY_A = ^procedure (
    lpBuffer        : out CHARSTR ;
    uSize           : UINT)
                      return UINT for machine_pointer use true;
type
PGET_SYSTEM_WOW64_DIRECTORY_W = ^procedure (
    lpBuffer        : out WCHARSTR ;
    uSize           : UINT)
                      return UINT for machine_pointer use true;
-- 
--  GetProcAddress only accepts GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A,
--  GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A.
--  The others are if you want to use the strings in some other way.
-- 
#if #declared UNICODE; then;
#template GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A;
  'GetSystemWow64DirectoryW'
#end GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A;
#template GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W;
  L 'GetSystemWow64DirectoryW'
#end GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W;
#template GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T;
  {TEXT(quote)} __TEXT(quote) ( 'GetSystemWow64DirectoryW') 
#end GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T;
#else;
#template GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A;
  'GetSystemWow64DirectoryA'
#end GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A;
#template GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W;
  L 'GetSystemWow64DirectoryA'
#end GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W;
#template GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T;
  {TEXT(quote)} __TEXT(quote) ( 'GetSystemWow64DirectoryA') 
#end GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T;
#end if;

procedure SetCurrentDirectoryA(
    lpPathName      : in LPCSTR)
                      return BOOL;
#pragma convention(SetCurrentDirectoryA,system);
#pragma import(SetCurrentDirectoryA,'SetCurrentDirectoryA','kernel32.dll');

procedure SetCurrentDirectoryW(
    lpPathName      : in LPCWSTR)
                      return BOOL;
#pragma convention(SetCurrentDirectoryW,system);
#pragma import(SetCurrentDirectoryW,'SetCurrentDirectoryW','kernel32.dll');

#if #declared UNICODE; then;
#template SetCurrentDirectory;
  SetCurrentDirectoryW 
#end SetCurrentDirectory;
#else;
#template SetCurrentDirectory;
  SetCurrentDirectoryA 
#end SetCurrentDirectory;
#end if;

procedure GetCurrentDirectoryA(
    nBufferLength   : in DWORD; 
    lpBuffer        : out CHARSTR )
                      return DWORD;
#pragma convention(GetCurrentDirectoryA,system);
#pragma import(GetCurrentDirectoryA,'GetCurrentDirectoryA','kernel32.dll');

procedure GetCurrentDirectoryW(
    nBufferLength   : in DWORD; 
    lpBuffer        : out WCHARSTR )
                      return DWORD;
#pragma convention(GetCurrentDirectoryW,system);
#pragma import(GetCurrentDirectoryW,'GetCurrentDirectoryW','kernel32.dll');

#if #declared UNICODE; then;
#template GetCurrentDirectory;
  GetCurrentDirectoryW 
#end GetCurrentDirectory;
#else;
#template GetCurrentDirectory;
  GetCurrentDirectoryA 
#end GetCurrentDirectory;
#end if;

procedure GetDiskFreeSpaceA(
    lpRootPathName  : in LPCSTR; 
    lpSectorsPerCluster : out DWORD ; 
    lpBytesPerSector : out DWORD ; 
    lpNumberOfFreeClusters : out DWORD ; 
    lpTotalNumberOfClusters : out DWORD )
                      return BOOL;
#pragma convention(GetDiskFreeSpaceA,system);
#pragma import(GetDiskFreeSpaceA,'GetDiskFreeSpaceA','kernel32.dll');

procedure GetDiskFreeSpaceW(
    lpRootPathName  : in LPCWSTR; 
    lpSectorsPerCluster : out DWORD ; 
    lpBytesPerSector : out DWORD ; 
    lpNumberOfFreeClusters : out DWORD ; 
    lpTotalNumberOfClusters : out DWORD )
                      return BOOL;
#pragma convention(GetDiskFreeSpaceW,system);
#pragma import(GetDiskFreeSpaceW,'GetDiskFreeSpaceW','kernel32.dll');

#if #declared UNICODE; then;
#template GetDiskFreeSpace;
  GetDiskFreeSpaceW 
#end GetDiskFreeSpace;
#else;
#template GetDiskFreeSpace;
  GetDiskFreeSpaceA 
#end GetDiskFreeSpace;
#end if;

procedure GetDiskFreeSpaceExA(
    lpDirectoryName : in LPCSTR; 
    lpFreeBytesAvailableToCaller : out ULARGE_INTEGER ; 
    lpTotalNumberOfBytes : out ULARGE_INTEGER ; 
    lpTotalNumberOfFreeBytes : out ULARGE_INTEGER )
                      return BOOL;
#pragma convention(GetDiskFreeSpaceExA,system);
#pragma import(GetDiskFreeSpaceExA,'GetDiskFreeSpaceExA','kernel32.dll');

procedure GetDiskFreeSpaceExW(
    lpDirectoryName : in LPCWSTR; 
    lpFreeBytesAvailableToCaller : out ULARGE_INTEGER ; 
    lpTotalNumberOfBytes : out ULARGE_INTEGER ; 
    lpTotalNumberOfFreeBytes : out ULARGE_INTEGER )
                      return BOOL;
#pragma convention(GetDiskFreeSpaceExW,system);
#pragma import(GetDiskFreeSpaceExW,'GetDiskFreeSpaceExW','kernel32.dll');

#if #declared UNICODE; then;
#template GetDiskFreeSpaceEx;
  GetDiskFreeSpaceExW 
#end GetDiskFreeSpaceEx;
#else;
#template GetDiskFreeSpaceEx;
  GetDiskFreeSpaceExA 
#end GetDiskFreeSpaceEx;
#end if;

procedure CreateDirectoryA(
    lpPathName      : in LPCSTR; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return BOOL;
#pragma convention(CreateDirectoryA,system);
#pragma import(CreateDirectoryA,'CreateDirectoryA','kernel32.dll');

procedure CreateDirectoryW(
    lpPathName      : in LPCWSTR; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return BOOL;
#pragma convention(CreateDirectoryW,system);
#pragma import(CreateDirectoryW,'CreateDirectoryW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateDirectory;
  CreateDirectoryW 
#end CreateDirectory;
#else;
#template CreateDirectory;
  CreateDirectoryA 
#end CreateDirectory;
#end if;

procedure CreateDirectoryExA(
    lpTemplateDirectory : in LPCSTR; 
    lpNewDirectory  : in LPCSTR; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return BOOL;
#pragma convention(CreateDirectoryExA,system);
#pragma import(CreateDirectoryExA,'CreateDirectoryExA','kernel32.dll');

procedure CreateDirectoryExW(
    lpTemplateDirectory : in LPCWSTR; 
    lpNewDirectory  : in LPCWSTR; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return BOOL;
#pragma convention(CreateDirectoryExW,system);
#pragma import(CreateDirectoryExW,'CreateDirectoryExW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateDirectoryEx;
  CreateDirectoryExW 
#end CreateDirectoryEx;
#else;
#template CreateDirectoryEx;
  CreateDirectoryExA 
#end CreateDirectoryEx;
#end if;

procedure RemoveDirectoryA(
    lpPathName      : in LPCSTR)
                      return BOOL;
#pragma convention(RemoveDirectoryA,system);
#pragma import(RemoveDirectoryA,'RemoveDirectoryA','kernel32.dll');

procedure RemoveDirectoryW(
    lpPathName      : in LPCWSTR)
                      return BOOL;
#pragma convention(RemoveDirectoryW,system);
#pragma import(RemoveDirectoryW,'RemoveDirectoryW','kernel32.dll');

#if #declared UNICODE; then;
#template RemoveDirectory;
  RemoveDirectoryW 
#end RemoveDirectory;
#else;
#template RemoveDirectory;
  RemoveDirectoryA 
#end RemoveDirectory;
#end if;

procedure GetFullPathNameA(
    lpFileName      : in LPCSTR; 
    nBufferLength   : in DWORD; 
    lpBuffer        : out CHARSTR ; 
    lpFilePart      : out LPSTR)
                      return DWORD;
#pragma convention(GetFullPathNameA,system);
#pragma import(GetFullPathNameA,'GetFullPathNameA','kernel32.dll');

procedure GetFullPathNameW(
    lpFileName      : in LPCWSTR; 
    nBufferLength   : in DWORD; 
    lpBuffer        : out WCHARSTR ; 
    lpFilePart      : out LPWSTR)
                      return DWORD;
#pragma convention(GetFullPathNameW,system);
#pragma import(GetFullPathNameW,'GetFullPathNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetFullPathName;
  GetFullPathNameW 
#end GetFullPathName;
#else;
#template GetFullPathName;
  GetFullPathNameA 
#end GetFullPathName;
#end if;

const
  DDD_RAW_TARGET_PATH= $01;

const
  DDD_REMOVE_DEFINITION= $02;

const
  DDD_EXACT_MATCH_ON_REMOVE= $04;

const
  DDD_NO_BROADCAST_SYSTEM= $08;

const
  DDD_LUID_BROADCAST_DRIVE= $10;

procedure DefineDosDeviceA(
    dwFlags         : in DWORD; 
    lpDeviceName    : in LPCSTR; 
    lpTargetPath    : in LPCSTR)
                      return BOOL;
#pragma convention(DefineDosDeviceA,system);
#pragma import(DefineDosDeviceA,'DefineDosDeviceA','kernel32.dll');

procedure DefineDosDeviceW(
    dwFlags         : in DWORD; 
    lpDeviceName    : in LPCWSTR; 
    lpTargetPath    : in LPCWSTR)
                      return BOOL;
#pragma convention(DefineDosDeviceW,system);
#pragma import(DefineDosDeviceW,'DefineDosDeviceW','kernel32.dll');

#if #declared UNICODE; then;
#template DefineDosDevice;
  DefineDosDeviceW 
#end DefineDosDevice;
#else;
#template DefineDosDevice;
  DefineDosDeviceA 
#end DefineDosDevice;
#end if;

procedure QueryDosDeviceA(
    lpDeviceName    : in LPCSTR; 
    lpTargetPath    : out CHARSTR ; 
    ucchMax         : in DWORD)
                      return DWORD;
#pragma convention(QueryDosDeviceA,system);
#pragma import(QueryDosDeviceA,'QueryDosDeviceA','kernel32.dll');

procedure QueryDosDeviceW(
    lpDeviceName    : in LPCWSTR; 
    lpTargetPath    : out WCHARSTR ; 
    ucchMax         : in DWORD)
                      return DWORD;
#pragma convention(QueryDosDeviceW,system);
#pragma import(QueryDosDeviceW,'QueryDosDeviceW','kernel32.dll');

#if #declared UNICODE; then;
#template QueryDosDevice;
  QueryDosDeviceW 
#end QueryDosDevice;
#else;
#template QueryDosDevice;
  QueryDosDeviceA 
#end QueryDosDevice;
#end if;

procedure CreateFileA(
    lpFileName      : in LPCSTR; 
    dwDesiredAccess : in DWORD; 
    dwShareMode     : in DWORD; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES; 
    dwCreationDisposition : in DWORD; 
    dwFlagsAndAttributes : in DWORD; 
    hTemplateFile   : in t_HANDLE)
                      return t_HANDLE;
#pragma convention(CreateFileA,system);
#pragma import(CreateFileA,'CreateFileA','kernel32.dll');

procedure CreateFileW(
    lpFileName      : in LPCWSTR; 
    dwDesiredAccess : in DWORD; 
    dwShareMode     : in DWORD; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES; 
    dwCreationDisposition : in DWORD; 
    dwFlagsAndAttributes : in DWORD; 
    hTemplateFile   : in t_HANDLE)
                      return t_HANDLE;
#pragma convention(CreateFileW,system);
#pragma import(CreateFileW,'CreateFileW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateFile;
  CreateFileW 
#end CreateFile;
#else;
#template CreateFile;
  CreateFileA 
#end CreateFile;
#end if;

procedure SetFileAttributesA(
    lpFileName      : in LPCSTR; 
    dwFileAttributes : in DWORD)
                      return BOOL;
#pragma convention(SetFileAttributesA,system);
#pragma import(SetFileAttributesA,'SetFileAttributesA','kernel32.dll');

procedure SetFileAttributesW(
    lpFileName      : in LPCWSTR; 
    dwFileAttributes : in DWORD)
                      return BOOL;
#pragma convention(SetFileAttributesW,system);
#pragma import(SetFileAttributesW,'SetFileAttributesW','kernel32.dll');

#if #declared UNICODE; then;
#template SetFileAttributes;
  SetFileAttributesW 
#end SetFileAttributes;
#else;
#template SetFileAttributes;
  SetFileAttributesA 
#end SetFileAttributes;
#end if;

procedure GetFileAttributesA(
    lpFileName      : in LPCSTR)
                      return DWORD;
#pragma convention(GetFileAttributesA,system);
#pragma import(GetFileAttributesA,'GetFileAttributesA','kernel32.dll');

procedure GetFileAttributesW(
    lpFileName      : in LPCWSTR)
                      return DWORD;
#pragma convention(GetFileAttributesW,system);
#pragma import(GetFileAttributesW,'GetFileAttributesW','kernel32.dll');

#if #declared UNICODE; then;
#template GetFileAttributes;
  GetFileAttributesW 
#end GetFileAttributes;
#else;
#template GetFileAttributes;
  GetFileAttributesA 
#end GetFileAttributes;
#end if;

type
_GET_FILEEX_INFO_LEVELS= enum
    GetFileExInfoStandard;
    GetFileExMaxInfoLevel;
  end enum for size use 4;
  GET_FILEEX_INFO_LEVELS = _GET_FILEEX_INFO_LEVELS;
procedure GetFileAttributesExA(
    lpFileName      : in LPCSTR; 
    fInfoLevelId    : in GET_FILEEX_INFO_LEVELS; 
    lpFileInformation : out unchecked )
                      return BOOL;
#pragma convention(GetFileAttributesExA,system);
#pragma import(GetFileAttributesExA,'GetFileAttributesExA','kernel32.dll');

procedure GetFileAttributesExW(
    lpFileName      : in LPCWSTR; 
    fInfoLevelId    : in GET_FILEEX_INFO_LEVELS; 
    lpFileInformation : out unchecked )
                      return BOOL;
#pragma convention(GetFileAttributesExW,system);
#pragma import(GetFileAttributesExW,'GetFileAttributesExW','kernel32.dll');

#if #declared UNICODE; then;
#template GetFileAttributesEx;
  GetFileAttributesExW 
#end GetFileAttributesEx;
#else;
#template GetFileAttributesEx;
  GetFileAttributesExA 
#end GetFileAttributesEx;
#end if;

procedure GetCompressedFileSizeA(
    lpFileName      : in LPCSTR; 
    lpFileSizeHigh  : out DWORD )
                      return DWORD;
#pragma convention(GetCompressedFileSizeA,system);
#pragma import(GetCompressedFileSizeA,'GetCompressedFileSizeA','kernel32.dll');

procedure GetCompressedFileSizeW(
    lpFileName      : in LPCWSTR; 
    lpFileSizeHigh  : out DWORD )
                      return DWORD;
#pragma convention(GetCompressedFileSizeW,system);
#pragma import(GetCompressedFileSizeW,'GetCompressedFileSizeW','kernel32.dll');

#if #declared UNICODE; then;
#template GetCompressedFileSize;
  GetCompressedFileSizeW 
#end GetCompressedFileSize;
#else;
#template GetCompressedFileSize;
  GetCompressedFileSizeA 
#end GetCompressedFileSize;
#end if;

procedure DeleteFileA(
    lpFileName      : in LPCSTR)
                      return BOOL;
#pragma convention(DeleteFileA,system);
#pragma import(DeleteFileA,'DeleteFileA','kernel32.dll');

procedure DeleteFileW(
    lpFileName      : in LPCWSTR)
                      return BOOL;
#pragma convention(DeleteFileW,system);
#pragma import(DeleteFileW,'DeleteFileW','kernel32.dll');

#if #declared UNICODE; then;
#template DeleteFile;
  DeleteFileW 
#end DeleteFile;
#else;
#template DeleteFile;
  DeleteFileA 
#end DeleteFile;
#end if;

procedure CheckNameLegalDOS8Dot3A(
    lpName          : in LPCSTR; 
    lpOemName       : out {out optional} CHARSTR ; 
    OemNameSize     : in {out optional} DWORD; 
    pbNameContainsSpaces : out {out optional} BOOL ; 
    pbNameLegal     : out BOOL )
                      return BOOL;
#pragma convention(CheckNameLegalDOS8Dot3A,system);
#pragma import(CheckNameLegalDOS8Dot3A,'CheckNameLegalDOS8Dot3A','kernel32.dll');

procedure CheckNameLegalDOS8Dot3W(
    lpName          : in LPCWSTR; 
    lpOemName       : out {out optional} CHARSTR ; 
    OemNameSize     : in {out optional} DWORD; 
    pbNameContainsSpaces : out {out optional} BOOL ; 
    pbNameLegal     : out BOOL )
                      return BOOL;
#pragma convention(CheckNameLegalDOS8Dot3W,system);
#pragma import(CheckNameLegalDOS8Dot3W,'CheckNameLegalDOS8Dot3W','kernel32.dll');

#if #declared UNICODE; then;
#template CheckNameLegalDOS8Dot3;
  CheckNameLegalDOS8Dot3W 
#end CheckNameLegalDOS8Dot3;
#else;
#template CheckNameLegalDOS8Dot3;
  CheckNameLegalDOS8Dot3A 
#end CheckNameLegalDOS8Dot3;
#end if;

type
_FINDEX_INFO_LEVELS= enum
    FindExInfoStandard;
    FindExInfoMaxInfoLevel;
  end enum for size use 4;
  FINDEX_INFO_LEVELS = _FINDEX_INFO_LEVELS;
type
_FINDEX_SEARCH_OPS= enum
    FindExSearchNameMatch;
    FindExSearchLimitToDirectories;
    FindExSearchLimitToDevices;
    FindExSearchMaxSearchOp;
  end enum for size use 4;
  FINDEX_SEARCH_OPS = _FINDEX_SEARCH_OPS;
const
  FIND_FIRST_EX_CASE_SENSITIVE= $01;

procedure FindFirstFileExA(
    lpFileName      : in LPCSTR; 
    fInfoLevelId    : in FINDEX_INFO_LEVELS; 
    lpFindFileData  : out unchecked ; 
    fSearchOp       : in FINDEX_SEARCH_OPS; 
    lpSearchFilter  : in LPVOID; 
    dwAdditionalFlags : in DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstFileExA,system);
#pragma import(FindFirstFileExA,'FindFirstFileExA','kernel32.dll');

procedure FindFirstFileExW(
    lpFileName      : in LPCWSTR; 
    fInfoLevelId    : in FINDEX_INFO_LEVELS; 
    lpFindFileData  : out unchecked ; 
    fSearchOp       : in FINDEX_SEARCH_OPS; 
    lpSearchFilter  : in LPVOID; 
    dwAdditionalFlags : in DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstFileExW,system);
#pragma import(FindFirstFileExW,'FindFirstFileExW','kernel32.dll');

#if #declared UNICODE; then;
#template FindFirstFileEx;
  FindFirstFileExW 
#end FindFirstFileEx;
#else;
#template FindFirstFileEx;
  FindFirstFileExA 
#end FindFirstFileEx;
#end if;

procedure FindFirstFileA(
    lpFileName      : in LPCSTR; 
    lpFindFileData  : out _WIN32_FIND_DATAA)
                      return t_HANDLE;
#pragma convention(FindFirstFileA,system);
#pragma import(FindFirstFileA,'FindFirstFileA','kernel32.dll');

procedure FindFirstFileW(
    lpFileName      : in LPCWSTR; 
    lpFindFileData  : out _WIN32_FIND_DATAW)
                      return t_HANDLE;
#pragma convention(FindFirstFileW,system);
#pragma import(FindFirstFileW,'FindFirstFileW','kernel32.dll');

#if #declared UNICODE; then;
#template FindFirstFile;
  FindFirstFileW 
#end FindFirstFile;
#else;
#template FindFirstFile;
  FindFirstFileA 
#end FindFirstFile;
#end if;

procedure FindNextFileA(
    hFindFile       : in t_HANDLE; 
    lpFindFileData  : out _WIN32_FIND_DATAA)
                      return BOOL;
#pragma convention(FindNextFileA,system);
#pragma import(FindNextFileA,'FindNextFileA','kernel32.dll');

procedure FindNextFileW(
    hFindFile       : in t_HANDLE; 
    lpFindFileData  : out _WIN32_FIND_DATAW)
                      return BOOL;
#pragma convention(FindNextFileW,system);
#pragma import(FindNextFileW,'FindNextFileW','kernel32.dll');

#if #declared UNICODE; then;
#template FindNextFile;
  FindNextFileW 
#end FindNextFile;
#else;
#template FindNextFile;
  FindNextFileA 
#end FindNextFile;
#end if;

procedure SearchPathA(
    lpPath          : in LPCSTR; 
    lpFileName      : in LPCSTR; 
    lpExtension     : in LPCSTR; 
    nBufferLength   : in DWORD; 
    lpBuffer        : out CHARSTR ; 
    lpFilePart      : out LPSTR)
                      return DWORD;
#pragma convention(SearchPathA,system);
#pragma import(SearchPathA,'SearchPathA','kernel32.dll');

procedure SearchPathW(
    lpPath          : in LPCWSTR; 
    lpFileName      : in LPCWSTR; 
    lpExtension     : in LPCWSTR; 
    nBufferLength   : in DWORD; 
    lpBuffer        : out WCHARSTR ; 
    lpFilePart      : out LPWSTR)
                      return DWORD;
#pragma convention(SearchPathW,system);
#pragma import(SearchPathW,'SearchPathW','kernel32.dll');

#if #declared UNICODE; then;
#template SearchPath;
  SearchPathW 
#end SearchPath;
#else;
#template SearchPath;
  SearchPathA 
#end SearchPath;
#end if;

procedure CopyFileA(
    lpExistingFileName : in LPCSTR; 
    lpNewFileName   : in LPCSTR; 
    bFailIfExists   : in BOOL)
                      return BOOL;
#pragma convention(CopyFileA,system);
#pragma import(CopyFileA,'CopyFileA','kernel32.dll');

procedure CopyFileW(
    lpExistingFileName : in LPCWSTR; 
    lpNewFileName   : in LPCWSTR; 
    bFailIfExists   : in BOOL)
                      return BOOL;
#pragma convention(CopyFileW,system);
#pragma import(CopyFileW,'CopyFileW','kernel32.dll');

#if #declared UNICODE; then;
#template CopyFile;
  CopyFileW 
#end CopyFile;
#else;
#template CopyFile;
  CopyFileA 
#end CopyFile;
#end if;

type
LPPROGRESS_ROUTINE = ^procedure (
    TotalFileSize   : LARGE_INTEGER;
    TotalBytesTransferred : LARGE_INTEGER;
    StreamSize      : LARGE_INTEGER;
    StreamBytesTransferred : LARGE_INTEGER;
    dwStreamNumber  : DWORD;
    dwCallbackReason : DWORD;
    hSourceFile     : t_HANDLE;
    hDestinationFile : t_HANDLE;
    lpData          : {out optional} LPVOID)
                      return DWORD for machine_pointer use true;
procedure CopyFileExA(
    lpExistingFileName : in LPCSTR; 
    lpNewFileName   : in LPCSTR; 
    lpProgressRoutine : in {out optional} LPPROGRESS_ROUTINE; 
    lpData          : in {out optional} LPVOID; 
    pbCancel        : in {out optional} LPBOOL; 
    dwCopyFlags     : in DWORD)
                      return BOOL;
#pragma convention(CopyFileExA,system);
#pragma import(CopyFileExA,'CopyFileExA','kernel32.dll');

procedure CopyFileExW(
    lpExistingFileName : in LPCWSTR; 
    lpNewFileName   : in LPCWSTR; 
    lpProgressRoutine : in {out optional} LPPROGRESS_ROUTINE; 
    lpData          : in {out optional} LPVOID; 
    pbCancel        : in {out optional} LPBOOL; 
    dwCopyFlags     : in DWORD)
                      return BOOL;
#pragma convention(CopyFileExW,system);
#pragma import(CopyFileExW,'CopyFileExW','kernel32.dll');

#if #declared UNICODE; then;
#template CopyFileEx;
  CopyFileExW 
#end CopyFileEx;
#else;
#template CopyFileEx;
  CopyFileExA 
#end CopyFileEx;
#end if;

procedure MoveFileA(
    lpExistingFileName : in LPCSTR; 
    lpNewFileName   : in LPCSTR)
                      return BOOL;
#pragma convention(MoveFileA,system);
#pragma import(MoveFileA,'MoveFileA','kernel32.dll');

procedure MoveFileW(
    lpExistingFileName : in LPCWSTR; 
    lpNewFileName   : in LPCWSTR)
                      return BOOL;
#pragma convention(MoveFileW,system);
#pragma import(MoveFileW,'MoveFileW','kernel32.dll');

#if #declared UNICODE; then;
#template MoveFile;
  MoveFileW 
#end MoveFile;
#else;
#template MoveFile;
  MoveFileA 
#end MoveFile;
#end if;

procedure MoveFileExA(
    lpExistingFileName : in LPCSTR; 
    lpNewFileName   : in LPCSTR; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(MoveFileExA,system);
#pragma import(MoveFileExA,'MoveFileExA','kernel32.dll');

procedure MoveFileExW(
    lpExistingFileName : in LPCWSTR; 
    lpNewFileName   : in LPCWSTR; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(MoveFileExW,system);
#pragma import(MoveFileExW,'MoveFileExW','kernel32.dll');

#if #declared UNICODE; then;
#template MoveFileEx;
  MoveFileExW 
#end MoveFileEx;
#else;
#template MoveFileEx;
  MoveFileExA 
#end MoveFileEx;
#end if;

procedure MoveFileWithProgressA(
    lpExistingFileName : in LPCSTR; 
    lpNewFileName   : in LPCSTR; 
    lpProgressRoutine : in {out optional} LPPROGRESS_ROUTINE; 
    lpData          : in {out optional} LPVOID; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(MoveFileWithProgressA,system);
#pragma import(MoveFileWithProgressA,'MoveFileWithProgressA','kernel32.dll');

procedure MoveFileWithProgressW(
    lpExistingFileName : in LPCWSTR; 
    lpNewFileName   : in LPCWSTR; 
    lpProgressRoutine : in {out optional} LPPROGRESS_ROUTINE; 
    lpData          : in {out optional} LPVOID; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(MoveFileWithProgressW,system);
#pragma import(MoveFileWithProgressW,'MoveFileWithProgressW','kernel32.dll');

#if #declared UNICODE; then;
#template MoveFileWithProgress;
  MoveFileWithProgressW 
#end MoveFileWithProgress;
#else;
#template MoveFileWithProgress;
  MoveFileWithProgressA 
#end MoveFileWithProgress;
#end if;

const
  MOVEFILE_REPLACE_EXISTING= $01;

const
  MOVEFILE_COPY_ALLOWED= $02;

const
  MOVEFILE_DELAY_UNTIL_REBOOT= $04;

const
  MOVEFILE_WRITE_THROUGH= $08;

const
  MOVEFILE_CREATE_HARDLINK= $10;

const
  MOVEFILE_FAIL_IF_NOT_TRACKABLE= $20;

procedure ReplaceFileA(
    lpReplacedFileName : LPCSTR; 
    lpReplacementFileName : LPCSTR; 
    lpBackupFileName : LPCSTR; 
    dwReplaceFlags  : DWORD; 
    lpExclude       : LPVOID; 
    lpReserved      : LPVOID)
                      return BOOL;
#pragma convention(ReplaceFileA,system);
#pragma import(ReplaceFileA,'ReplaceFileA','kernel32.dll');

procedure ReplaceFileW(
    lpReplacedFileName : LPCWSTR; 
    lpReplacementFileName : LPCWSTR; 
    lpBackupFileName : LPCWSTR; 
    dwReplaceFlags  : DWORD; 
    lpExclude       : LPVOID; 
    lpReserved      : LPVOID)
                      return BOOL;
#pragma convention(ReplaceFileW,system);
#pragma import(ReplaceFileW,'ReplaceFileW','kernel32.dll');

#if #declared UNICODE; then;
#template ReplaceFile;
  ReplaceFileW 
#end ReplaceFile;
#else;
#template ReplaceFile;
  ReplaceFileA 
#end ReplaceFile;
#end if;

-- 
--  API call to create hard links.
-- 
procedure CreateHardLinkA(
    lpFileName      : in LPCSTR; 
    lpExistingFileName : in LPCSTR; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return BOOL;
#pragma convention(CreateHardLinkA,system);
#pragma import(CreateHardLinkA,'CreateHardLinkA','kernel32.dll');

procedure CreateHardLinkW(
    lpFileName      : in LPCWSTR; 
    lpExistingFileName : in LPCWSTR; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return BOOL;
#pragma convention(CreateHardLinkW,system);
#pragma import(CreateHardLinkW,'CreateHardLinkW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateHardLink;
  CreateHardLinkW 
#end CreateHardLink;
#else;
#template CreateHardLink;
  CreateHardLinkA 
#end CreateHardLink;
#end if;

-- 
--  API call to enumerate for streams within a file
-- 
type
_STREAM_INFO_LEVELS= enum
    FindStreamInfoStandard;
    FindStreamInfoMaxInfoLevel;
  end enum for size use 4;
  STREAM_INFO_LEVELS = _STREAM_INFO_LEVELS;
type
  _WIN32_FIND_STREAM_DATA = record
StreamSize      : LARGE_INTEGER;
cStreamName     : array 0..35 of WCHAR;
  end record;
  WIN32_FIND_STREAM_DATA = _WIN32_FIND_STREAM_DATA;
  PWIN32_FIND_STREAM_DATA = ^_WIN32_FIND_STREAM_DATA;

procedure FindFirstStreamW(
    lpFileName      : LPCWSTR; 
    InfoLevel       : STREAM_INFO_LEVELS; 
    lpFindStreamData : LPVOID; 
    dwFlags         : DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstStreamW,system);
#pragma import(FindFirstStreamW,'FindFirstStreamW','kernel32.dll');

procedure FindNextStreamW(
    hFindStream     : t_HANDLE; 
    lpFindStreamData : LPVOID)
                      return BOOL;
#pragma convention(FindNextStreamW,system);
#pragma import(FindNextStreamW,'FindNextStreamW','kernel32.dll');

procedure CreateNamedPipeA(
    lpName          : in LPCSTR; 
    dwOpenMode      : in DWORD; 
    dwPipeMode      : in DWORD; 
    nMaxInstances   : in DWORD; 
    nOutBufferSize  : in DWORD; 
    nInBufferSize   : in DWORD; 
    nDefaultTimeOut : in DWORD; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return t_HANDLE;
#pragma convention(CreateNamedPipeA,system);
#pragma import(CreateNamedPipeA,'CreateNamedPipeA','kernel32.dll');

procedure CreateNamedPipeW(
    lpName          : in LPCWSTR; 
    dwOpenMode      : in DWORD; 
    dwPipeMode      : in DWORD; 
    nMaxInstances   : in DWORD; 
    nOutBufferSize  : in DWORD; 
    nInBufferSize   : in DWORD; 
    nDefaultTimeOut : in DWORD; 
    lpSecurityAttributes : in LPSECURITY_ATTRIBUTES)
                      return t_HANDLE;
#pragma convention(CreateNamedPipeW,system);
#pragma import(CreateNamedPipeW,'CreateNamedPipeW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateNamedPipe;
  CreateNamedPipeW 
#end CreateNamedPipe;
#else;
#template CreateNamedPipe;
  CreateNamedPipeA 
#end CreateNamedPipe;
#end if;

procedure GetNamedPipeHandleStateA(
    hNamedPipe      : in t_HANDLE; 
    lpState         : out DWORD ; 
    lpCurInstances  : out DWORD ; 
    lpMaxCollectionCount : out DWORD ; 
    lpCollectDataTimeout : out DWORD ; 
    lpUserName      : out CHARSTR ; 
    nMaxUserNameSize : in DWORD)
                      return BOOL;
#pragma convention(GetNamedPipeHandleStateA,system);
#pragma import(GetNamedPipeHandleStateA,'GetNamedPipeHandleStateA','kernel32.dll');

procedure GetNamedPipeHandleStateW(
    hNamedPipe      : in t_HANDLE; 
    lpState         : out DWORD ; 
    lpCurInstances  : out DWORD ; 
    lpMaxCollectionCount : out DWORD ; 
    lpCollectDataTimeout : out DWORD ; 
    lpUserName      : out WCHARSTR ; 
    nMaxUserNameSize : in DWORD)
                      return BOOL;
#pragma convention(GetNamedPipeHandleStateW,system);
#pragma import(GetNamedPipeHandleStateW,'GetNamedPipeHandleStateW','kernel32.dll');

#if #declared UNICODE; then;
#template GetNamedPipeHandleState;
  GetNamedPipeHandleStateW 
#end GetNamedPipeHandleState;
#else;
#template GetNamedPipeHandleState;
  GetNamedPipeHandleStateA 
#end GetNamedPipeHandleState;
#end if;

procedure CallNamedPipeA(
    lpNamedPipeName : in LPCSTR; 
    lpInBuffer      : in LPVOID; 
    nInBufferSize   : in DWORD; 
    lpOutBuffer     : out unchecked ; 
    nOutBufferSize  : in DWORD; 
    lpBytesRead     : out DWORD ; 
    nTimeOut        : in DWORD)
                      return BOOL;
#pragma convention(CallNamedPipeA,system);
#pragma import(CallNamedPipeA,'CallNamedPipeA','kernel32.dll');

procedure CallNamedPipeW(
    lpNamedPipeName : in LPCWSTR; 
    lpInBuffer      : in LPVOID; 
    nInBufferSize   : in DWORD; 
    lpOutBuffer     : out unchecked ; 
    nOutBufferSize  : in DWORD; 
    lpBytesRead     : out DWORD ; 
    nTimeOut        : in DWORD)
                      return BOOL;
#pragma convention(CallNamedPipeW,system);
#pragma import(CallNamedPipeW,'CallNamedPipeW','kernel32.dll');

#if #declared UNICODE; then;
#template CallNamedPipe;
  CallNamedPipeW 
#end CallNamedPipe;
#else;
#template CallNamedPipe;
  CallNamedPipeA 
#end CallNamedPipe;
#end if;

procedure WaitNamedPipeA(
    lpNamedPipeName : in LPCSTR; 
    nTimeOut        : in DWORD)
                      return BOOL;
#pragma convention(WaitNamedPipeA,system);
#pragma import(WaitNamedPipeA,'WaitNamedPipeA','kernel32.dll');

procedure WaitNamedPipeW(
    lpNamedPipeName : in LPCWSTR; 
    nTimeOut        : in DWORD)
                      return BOOL;
#pragma convention(WaitNamedPipeW,system);
#pragma import(WaitNamedPipeW,'WaitNamedPipeW','kernel32.dll');

#if #declared UNICODE; then;
#template WaitNamedPipe;
  WaitNamedPipeW 
#end WaitNamedPipe;
#else;
#template WaitNamedPipe;
  WaitNamedPipeA 
#end WaitNamedPipe;
#end if;

procedure SetVolumeLabelA(
    lpRootPathName  : in LPCSTR; 
    lpVolumeName    : in LPCSTR)
                      return BOOL;
#pragma convention(SetVolumeLabelA,system);
#pragma import(SetVolumeLabelA,'SetVolumeLabelA','kernel32.dll');

procedure SetVolumeLabelW(
    lpRootPathName  : in LPCWSTR; 
    lpVolumeName    : in LPCWSTR)
                      return BOOL;
#pragma convention(SetVolumeLabelW,system);
#pragma import(SetVolumeLabelW,'SetVolumeLabelW','kernel32.dll');

#if #declared UNICODE; then;
#template SetVolumeLabel;
  SetVolumeLabelW 
#end SetVolumeLabel;
#else;
#template SetVolumeLabel;
  SetVolumeLabelA 
#end SetVolumeLabel;
#end if;

procedure SetFileApisToOEM;
#pragma convention(SetFileApisToOEM,system);
#pragma import(SetFileApisToOEM,'SetFileApisToOEM','kernel32.dll');

procedure SetFileApisToANSI;
#pragma convention(SetFileApisToANSI,system);
#pragma import(SetFileApisToANSI,'SetFileApisToANSI','kernel32.dll');

procedure AreFileApisANSI
                      return BOOL;
#pragma convention(AreFileApisANSI,system);
#pragma import(AreFileApisANSI,'AreFileApisANSI','kernel32.dll');

procedure GetVolumeInformationA(
    lpRootPathName  : in LPCSTR; 
    lpVolumeNameBuffer : out CHARSTR ; 
    nVolumeNameSize : in DWORD; 
    lpVolumeSerialNumber : out DWORD ; 
    lpMaximumComponentLength : out DWORD ; 
    lpFileSystemFlags : out DWORD ; 
    lpFileSystemNameBuffer : out CHARSTR ; 
    nFileSystemNameSize : in DWORD)
                      return BOOL;
#pragma convention(GetVolumeInformationA,system);
#pragma import(GetVolumeInformationA,'GetVolumeInformationA','kernel32.dll');

procedure GetVolumeInformationW(
    lpRootPathName  : in LPCWSTR; 
    lpVolumeNameBuffer : out WCHARSTR ; 
    nVolumeNameSize : in DWORD; 
    lpVolumeSerialNumber : out DWORD ; 
    lpMaximumComponentLength : out DWORD ; 
    lpFileSystemFlags : out DWORD ; 
    lpFileSystemNameBuffer : out WCHARSTR ; 
    nFileSystemNameSize : in DWORD)
                      return BOOL;
#pragma convention(GetVolumeInformationW,system);
#pragma import(GetVolumeInformationW,'GetVolumeInformationW','kernel32.dll');

#if #declared UNICODE; then;
#template GetVolumeInformation;
  GetVolumeInformationW 
#end GetVolumeInformation;
#else;
#template GetVolumeInformation;
  GetVolumeInformationA 
#end GetVolumeInformation;
#end if;

procedure CancelIo(
    hFile           : in t_HANDLE)
                      return BOOL;
#pragma convention(CancelIo,system);
#pragma import(CancelIo,'CancelIo','kernel32.dll');

-- 
--  Event logging APIs
-- 
procedure ClearEventLogA(
    hEventLog       : in t_HANDLE; 
    lpBackupFileName : in LPCSTR)
                      return BOOL;
#pragma convention(ClearEventLogA,system);
#pragma import(ClearEventLogA,'ClearEventLogA','advapi32.dll');

procedure ClearEventLogW(
    hEventLog       : in t_HANDLE; 
    lpBackupFileName : in LPCWSTR)
                      return BOOL;
#pragma convention(ClearEventLogW,system);
#pragma import(ClearEventLogW,'ClearEventLogW','advapi32.dll');

#if #declared UNICODE; then;
#template ClearEventLog;
  ClearEventLogW 
#end ClearEventLog;
#else;
#template ClearEventLog;
  ClearEventLogA 
#end ClearEventLog;
#end if;

procedure BackupEventLogA(
    hEventLog       : in t_HANDLE; 
    lpBackupFileName : in LPCSTR)
                      return BOOL;
#pragma convention(BackupEventLogA,system);
#pragma import(BackupEventLogA,'BackupEventLogA','advapi32.dll');

procedure BackupEventLogW(
    hEventLog       : in t_HANDLE; 
    lpBackupFileName : in LPCWSTR)
                      return BOOL;
#pragma convention(BackupEventLogW,system);
#pragma import(BackupEventLogW,'BackupEventLogW','advapi32.dll');

#if #declared UNICODE; then;
#template BackupEventLog;
  BackupEventLogW 
#end BackupEventLog;
#else;
#template BackupEventLog;
  BackupEventLogA 
#end BackupEventLog;
#end if;

procedure CloseEventLog(
    hEventLog       : in out {!}t_HANDLE)
                      return BOOL;
#pragma convention(CloseEventLog,system);
#pragma import(CloseEventLog,'CloseEventLog','advapi32.dll');

procedure DeregisterEventSource(
    hEventLog       : in out {!}t_HANDLE)
                      return BOOL;
#pragma convention(DeregisterEventSource,system);
#pragma import(DeregisterEventSource,'DeregisterEventSource','advapi32.dll');

procedure NotifyChangeEventLog(
    hEventLog       : in t_HANDLE; 
    hEvent          : in t_HANDLE)
                      return BOOL;
#pragma convention(NotifyChangeEventLog,system);
#pragma import(NotifyChangeEventLog,'NotifyChangeEventLog','advapi32.dll');

procedure GetNumberOfEventLogRecords(
    hEventLog       : in t_HANDLE; 
    NumberOfRecords : out DWORD )
                      return BOOL;
#pragma convention(GetNumberOfEventLogRecords,system);
#pragma import(GetNumberOfEventLogRecords,'GetNumberOfEventLogRecords','advapi32.dll');

procedure GetOldestEventLogRecord(
    hEventLog       : in t_HANDLE; 
    OldestRecord    : out DWORD )
                      return BOOL;
#pragma convention(GetOldestEventLogRecord,system);
#pragma import(GetOldestEventLogRecord,'GetOldestEventLogRecord','advapi32.dll');

procedure OpenEventLogA(
    lpUNCServerName : in LPCSTR; 
    lpSourceName    : in LPCSTR)
                      return t_HANDLE;
#pragma convention(OpenEventLogA,system);
#pragma import(OpenEventLogA,'OpenEventLogA','advapi32.dll');

procedure OpenEventLogW(
    lpUNCServerName : in LPCWSTR; 
    lpSourceName    : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(OpenEventLogW,system);
#pragma import(OpenEventLogW,'OpenEventLogW','advapi32.dll');

#if #declared UNICODE; then;
#template OpenEventLog;
  OpenEventLogW 
#end OpenEventLog;
#else;
#template OpenEventLog;
  OpenEventLogA 
#end OpenEventLog;
#end if;

procedure RegisterEventSourceA(
    lpUNCServerName : in LPCSTR; 
    lpSourceName    : in LPCSTR)
                      return t_HANDLE;
#pragma convention(RegisterEventSourceA,system);
#pragma import(RegisterEventSourceA,'RegisterEventSourceA','advapi32.dll');

procedure RegisterEventSourceW(
    lpUNCServerName : in LPCWSTR; 
    lpSourceName    : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(RegisterEventSourceW,system);
#pragma import(RegisterEventSourceW,'RegisterEventSourceW','advapi32.dll');

#if #declared UNICODE; then;
#template RegisterEventSource;
  RegisterEventSourceW 
#end RegisterEventSource;
#else;
#template RegisterEventSource;
  RegisterEventSourceA 
#end RegisterEventSource;
#end if;

procedure OpenBackupEventLogA(
    lpUNCServerName : in LPCSTR; 
    lpFileName      : in LPCSTR)
                      return t_HANDLE;
#pragma convention(OpenBackupEventLogA,system);
#pragma import(OpenBackupEventLogA,'OpenBackupEventLogA','advapi32.dll');

procedure OpenBackupEventLogW(
    lpUNCServerName : in LPCWSTR; 
    lpFileName      : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(OpenBackupEventLogW,system);
#pragma import(OpenBackupEventLogW,'OpenBackupEventLogW','advapi32.dll');

#if #declared UNICODE; then;
#template OpenBackupEventLog;
  OpenBackupEventLogW 
#end OpenBackupEventLog;
#else;
#template OpenBackupEventLog;
  OpenBackupEventLogA 
#end OpenBackupEventLog;
#end if;

procedure ReadEventLogA(
    hEventLog       : in t_HANDLE; 
    dwReadFlags     : in DWORD; 
    dwRecordOffset  : in DWORD; 
    lpBuffer        : out unchecked ; 
    nNumberOfBytesToRead : in DWORD; 
    pnBytesRead     : out DWORD; 
    pnMinNumberOfBytesNeeded : out DWORD)
                      return BOOL;
#pragma convention(ReadEventLogA,system);
#pragma import(ReadEventLogA,'ReadEventLogA','advapi32.dll');

procedure ReadEventLogW(
    hEventLog       : in t_HANDLE; 
    dwReadFlags     : in DWORD; 
    dwRecordOffset  : in DWORD; 
    lpBuffer        : out unchecked ; 
    nNumberOfBytesToRead : in DWORD; 
    pnBytesRead     : out DWORD; 
    pnMinNumberOfBytesNeeded : out DWORD)
                      return BOOL;
#pragma convention(ReadEventLogW,system);
#pragma import(ReadEventLogW,'ReadEventLogW','advapi32.dll');

#if #declared UNICODE; then;
#template ReadEventLog;
  ReadEventLogW 
#end ReadEventLog;
#else;
#template ReadEventLog;
  ReadEventLogA 
#end ReadEventLog;
#end if;

type
t_063=^LPCSTR for machine_pointer use true;

procedure ReportEventA(
    hEventLog       : in t_HANDLE; 
    wType           : in WORD; 
    wCategory       : in WORD; 
    dwEventID       : in DWORD; 
    lpUserSid       : in p_SID; 
    wNumStrings     : in WORD; 
    dwDataSize      : in DWORD; 
    lpStrings       : in t_063; 
    lpRawData       : in LPVOID)
                      return BOOL;
#pragma convention(ReportEventA,system);
#pragma import(ReportEventA,'ReportEventA','advapi32.dll');

type
t_064=^LPCWSTR for machine_pointer use true;

procedure ReportEventW(
    hEventLog       : in t_HANDLE; 
    wType           : in WORD; 
    wCategory       : in WORD; 
    dwEventID       : in DWORD; 
    lpUserSid       : in p_SID; 
    wNumStrings     : in WORD; 
    dwDataSize      : in DWORD; 
    lpStrings       : in t_064; 
    lpRawData       : in LPVOID)
                      return BOOL;
#pragma convention(ReportEventW,system);
#pragma import(ReportEventW,'ReportEventW','advapi32.dll');

#if #declared UNICODE; then;
#template ReportEvent;
  ReportEventW 
#end ReportEvent;
#else;
#template ReportEvent;
  ReportEventA 
#end ReportEvent;
#end if;

const
  EVENTLOG_FULL_INFO= 0;

type
  _EVENTLOG_FULL_INFORMATION = record
dwFull          : DWORD;
  end record;
  EVENTLOG_FULL_INFORMATION = _EVENTLOG_FULL_INFORMATION;
  LPEVENTLOG_FULL_INFORMATION = ^_EVENTLOG_FULL_INFORMATION;

procedure GetEventLogInformation(
    hEventLog       : in t_HANDLE; 
    dwInfoLevel     : in DWORD; 
    lpBuffer        : out unchecked ; 
    cbBufSize       : in DWORD; 
    pcbBytesNeeded  : out DWORD )
                      return BOOL;
#pragma convention(GetEventLogInformation,system);
#pragma import(GetEventLogInformation,'GetEventLogInformation','advapi32.dll');

-- 
-- 
--  Security APIs
-- 
procedure DuplicateToken(
    ExistingTokenHandle : in t_HANDLE; 
    ImpersonationLevel : in SECURITY_IMPERSONATION_LEVEL; 
    DuplicateTokenHandle : out t_HANDLE )
                      return BOOL;
#pragma convention(DuplicateToken,system);
#pragma import(DuplicateToken,'DuplicateToken','advapi32.dll');

procedure GetKernelObjectSecurity(
    Handle          : in t_HANDLE; 
    RequestedInformation : in SECURITY_INFORMATION; 
    pSecurityDescriptor : out {!}PSECURITY_DESCRIPTOR; 
    nLength         : in DWORD; 
    lpnLengthNeeded : out DWORD )
                      return BOOL;
#pragma convention(GetKernelObjectSecurity,system);
#pragma import(GetKernelObjectSecurity,'GetKernelObjectSecurity','advapi32.dll');

procedure ImpersonateNamedPipeClient(
    hNamedPipe      : in t_HANDLE)
                      return BOOL;
#pragma convention(ImpersonateNamedPipeClient,system);
#pragma import(ImpersonateNamedPipeClient,'ImpersonateNamedPipeClient','advapi32.dll');

procedure ImpersonateSelf(
    ImpersonationLevel : in SECURITY_IMPERSONATION_LEVEL)
                      return BOOL;
#pragma convention(ImpersonateSelf,system);
#pragma import(ImpersonateSelf,'ImpersonateSelf','advapi32.dll');

procedure RevertToSelf
                      return BOOL;
#pragma convention(RevertToSelf,system);
#pragma import(RevertToSelf,'RevertToSelf','advapi32.dll');

procedure SetThreadToken(
    Thread          : in PHANDLE; 
    Token           : in t_HANDLE)
                      return BOOL;
#pragma convention(SetThreadToken,system);
#pragma import(SetThreadToken,'SetThreadToken','advapi32.dll');

procedure AccessCheck(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    ClientToken     : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    PrivilegeSet    : out _PRIVILEGE_SET; 
    PrivilegeSetLength : in LPDWORD; 
    GrantedAccess   : out DWORD ; 
    AccessStatus    : out BOOL )
                      return BOOL;
#pragma convention(AccessCheck,system);
#pragma import(AccessCheck,'AccessCheck','advapi32.dll');

procedure AccessCheckByType(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    PrincipalSelfSid : in p_SID; 
    ClientToken     : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    ObjectTypeList  : out _OBJECT_TYPE_LIST; 
    ObjectTypeListLength : in DWORD; 
    GenericMapping  : out GENERIC_MAPPING ; 
    PrivilegeSet    : out _PRIVILEGE_SET; 
    PrivilegeSetLength : out DWORD ; 
    GrantedAccess   : out DWORD ; 
    AccessStatus    : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckByType,system);
#pragma import(AccessCheckByType,'AccessCheckByType','advapi32.dll');

procedure AccessCheckByTypeResultList(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    PrincipalSelfSid : in p_SID; 
    ClientToken     : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    ObjectTypeList  : out _OBJECT_TYPE_LIST; 
    ObjectTypeListLength : in DWORD; 
    GenericMapping  : out GENERIC_MAPPING ; 
    PrivilegeSet    : out _PRIVILEGE_SET; 
    PrivilegeSetLength : out DWORD ; 
    GrantedAccessList : out DWORD ; 
    AccessStatusList : out DWORD )
                      return BOOL;
#pragma convention(AccessCheckByTypeResultList,system);
#pragma import(AccessCheckByTypeResultList,'AccessCheckByTypeResultList','advapi32.dll');

procedure OpenProcessToken(
    ProcessHandle   : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    TokenHandle     : out t_HANDLE )
                      return BOOL;
#pragma convention(OpenProcessToken,system);
#pragma import(OpenProcessToken,'OpenProcessToken','advapi32.dll');

procedure OpenThreadToken(
    ThreadHandle    : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    OpenAsSelf      : in BOOL; 
    TokenHandle     : out t_HANDLE )
                      return BOOL;
#pragma convention(OpenThreadToken,system);
#pragma import(OpenThreadToken,'OpenThreadToken','advapi32.dll');

procedure GetTokenInformation(
    TokenHandle     : in t_HANDLE; 
    TokenInformationClass : in TOKEN_INFORMATION_CLASS; 
    TokenInformation : out unchecked ; 
    TokenInformationLength : in DWORD; 
    ReturnLength    : out DWORD )
                      return BOOL;
#pragma convention(GetTokenInformation,system);
#pragma import(GetTokenInformation,'GetTokenInformation','advapi32.dll');

procedure SetTokenInformation(
    TokenHandle     : in t_HANDLE; 
    TokenInformationClass : in TOKEN_INFORMATION_CLASS; 
    TokenInformation : in LPVOID; 
    TokenInformationLength : in DWORD)
                      return BOOL;
#pragma convention(SetTokenInformation,system);
#pragma import(SetTokenInformation,'SetTokenInformation','advapi32.dll');

procedure AdjustTokenPrivileges(
    TokenHandle     : in t_HANDLE; 
    DisableAllPrivileges : in BOOL; 
    NewState        : in PTOKEN_PRIVILEGES; 
    BufferLength    : in DWORD; 
    PreviousState   : out _TOKEN_PRIVILEGES; 
    ReturnLength    : out DWORD )
                      return BOOL;
#pragma convention(AdjustTokenPrivileges,system);
#pragma import(AdjustTokenPrivileges,'AdjustTokenPrivileges','advapi32.dll');

procedure AdjustTokenGroups(
    TokenHandle     : in t_HANDLE; 
    ResetToDefault  : in BOOL; 
    NewState        : in PTOKEN_GROUPS; 
    BufferLength    : in DWORD; 
    PreviousState   : out _TOKEN_GROUPS; 
    ReturnLength    : out DWORD )
                      return BOOL;
#pragma convention(AdjustTokenGroups,system);
#pragma import(AdjustTokenGroups,'AdjustTokenGroups','advapi32.dll');

procedure PrivilegeCheck(
    ClientToken     : in t_HANDLE; 
    RequiredPrivileges : in PPRIVILEGE_SET; 
    pfResult        : out BOOL )
                      return BOOL;
#pragma convention(PrivilegeCheck,system);
#pragma import(PrivilegeCheck,'PrivilegeCheck','advapi32.dll');

procedure AccessCheckAndAuditAlarmA(
    SubsystemName   : in LPCSTR; 
    HandleId        : in LPVOID; 
    ObjectTypeName  : in LPSTR; 
    ObjectName      : in LPSTR; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    DesiredAccess   : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    ObjectCreation  : in BOOL; 
    GrantedAccess   : out DWORD ; 
    AccessStatus    : out BOOL ; 
    pfGenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckAndAuditAlarmA,system);
#pragma import(AccessCheckAndAuditAlarmA,'AccessCheckAndAuditAlarmA','advapi32.dll');

procedure AccessCheckAndAuditAlarmW(
    SubsystemName   : in LPCWSTR; 
    HandleId        : in LPVOID; 
    ObjectTypeName  : in LPWSTR; 
    ObjectName      : in LPWSTR; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    DesiredAccess   : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    ObjectCreation  : in BOOL; 
    GrantedAccess   : out DWORD ; 
    AccessStatus    : out BOOL ; 
    pfGenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckAndAuditAlarmW,system);
#pragma import(AccessCheckAndAuditAlarmW,'AccessCheckAndAuditAlarmW','advapi32.dll');

#if #declared UNICODE; then;
#template AccessCheckAndAuditAlarm;
  AccessCheckAndAuditAlarmW 
#end AccessCheckAndAuditAlarm;
#else;
#template AccessCheckAndAuditAlarm;
  AccessCheckAndAuditAlarmA 
#end AccessCheckAndAuditAlarm;
#end if;

procedure AccessCheckByTypeAndAuditAlarmA(
    SubsystemName   : in LPCSTR; 
    HandleId        : in LPVOID; 
    ObjectTypeName  : in LPCSTR; 
    ObjectName      : in LPCSTR; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    PrincipalSelfSid : in p_SID; 
    DesiredAccess   : in DWORD; 
    AuditType       : in AUDIT_EVENT_TYPE; 
    Flags           : in DWORD; 
    ObjectTypeList  : in POBJECT_TYPE_LIST; 
    ObjectTypeListLength : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    ObjectCreation  : in BOOL; 
    GrantedAccess   : out DWORD ; 
    AccessStatus    : out BOOL ; 
    pfGenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckByTypeAndAuditAlarmA,system);
#pragma import(AccessCheckByTypeAndAuditAlarmA,'AccessCheckByTypeAndAuditAlarmA','advapi32.dll');

procedure AccessCheckByTypeAndAuditAlarmW(
    SubsystemName   : in LPCWSTR; 
    HandleId        : in LPVOID; 
    ObjectTypeName  : in LPCWSTR; 
    ObjectName      : in LPCWSTR; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    PrincipalSelfSid : in p_SID; 
    DesiredAccess   : in DWORD; 
    AuditType       : in AUDIT_EVENT_TYPE; 
    Flags           : in DWORD; 
    ObjectTypeList  : in POBJECT_TYPE_LIST; 
    ObjectTypeListLength : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    ObjectCreation  : in BOOL; 
    GrantedAccess   : out DWORD ; 
    AccessStatus    : out BOOL ; 
    pfGenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckByTypeAndAuditAlarmW,system);
#pragma import(AccessCheckByTypeAndAuditAlarmW,'AccessCheckByTypeAndAuditAlarmW','advapi32.dll');

#if #declared UNICODE; then;
#template AccessCheckByTypeAndAuditAlarm;
  AccessCheckByTypeAndAuditAlarmW 
#end AccessCheckByTypeAndAuditAlarm;
#else;
#template AccessCheckByTypeAndAuditAlarm;
  AccessCheckByTypeAndAuditAlarmA 
#end AccessCheckByTypeAndAuditAlarm;
#end if;

procedure AccessCheckByTypeResultListAndAuditAlarmA(
    SubsystemName   : in LPCSTR; 
    HandleId        : in LPVOID; 
    ObjectTypeName  : in LPCSTR; 
    ObjectName      : in LPCSTR; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    PrincipalSelfSid : in p_SID; 
    DesiredAccess   : in DWORD; 
    AuditType       : in AUDIT_EVENT_TYPE; 
    Flags           : in DWORD; 
    ObjectTypeList  : in POBJECT_TYPE_LIST; 
    ObjectTypeListLength : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    ObjectCreation  : in BOOL; 
    GrantedAccess   : out DWORD ; 
    AccessStatusList : out DWORD ; 
    pfGenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckByTypeResultListAndAuditAlarmA,system);
#pragma import(AccessCheckByTypeResultListAndAuditAlarmA,'AccessCheckByTypeResultListAndAuditAlarmA','advapi32.dll');

procedure AccessCheckByTypeResultListAndAuditAlarmW(
    SubsystemName   : in LPCWSTR; 
    HandleId        : in LPVOID; 
    ObjectTypeName  : in LPCWSTR; 
    ObjectName      : in LPCWSTR; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    PrincipalSelfSid : in p_SID; 
    DesiredAccess   : in DWORD; 
    AuditType       : in AUDIT_EVENT_TYPE; 
    Flags           : in DWORD; 
    ObjectTypeList  : in POBJECT_TYPE_LIST; 
    ObjectTypeListLength : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    ObjectCreation  : in BOOL; 
    GrantedAccess   : out DWORD ; 
    AccessStatusList : out DWORD ; 
    pfGenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckByTypeResultListAndAuditAlarmW,system);
#pragma import(AccessCheckByTypeResultListAndAuditAlarmW,'AccessCheckByTypeResultListAndAuditAlarmW','advapi32.dll');

#if #declared UNICODE; then;
#template AccessCheckByTypeResultListAndAuditAlarm;
  AccessCheckByTypeResultListAndAuditAlarmW 
#end AccessCheckByTypeResultListAndAuditAlarm;
#else;
#template AccessCheckByTypeResultListAndAuditAlarm;
  AccessCheckByTypeResultListAndAuditAlarmA 
#end AccessCheckByTypeResultListAndAuditAlarm;
#end if;

procedure AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    SubsystemName   : in LPCSTR; 
    HandleId        : in LPVOID; 
    ClientToken     : in t_HANDLE; 
    ObjectTypeName  : in LPCSTR; 
    ObjectName      : in LPCSTR; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    PrincipalSelfSid : in p_SID; 
    DesiredAccess   : in DWORD; 
    AuditType       : in AUDIT_EVENT_TYPE; 
    Flags           : in DWORD; 
    ObjectTypeList  : in POBJECT_TYPE_LIST; 
    ObjectTypeListLength : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    ObjectCreation  : in BOOL; 
    GrantedAccess   : out DWORD ; 
    AccessStatusList : out DWORD ; 
    pfGenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckByTypeResultListAndAuditAlarmByHandleA,system);
#pragma import(AccessCheckByTypeResultListAndAuditAlarmByHandleA,'AccessCheckByTypeResultListAndAuditAlarmByHandleA','advapi32.dll');

procedure AccessCheckByTypeResultListAndAuditAlarmByHandleW(
    SubsystemName   : in LPCWSTR; 
    HandleId        : in LPVOID; 
    ClientToken     : in t_HANDLE; 
    ObjectTypeName  : in LPCWSTR; 
    ObjectName      : in LPCWSTR; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    PrincipalSelfSid : in p_SID; 
    DesiredAccess   : in DWORD; 
    AuditType       : in AUDIT_EVENT_TYPE; 
    Flags           : in DWORD; 
    ObjectTypeList  : in POBJECT_TYPE_LIST; 
    ObjectTypeListLength : in DWORD; 
    GenericMapping  : in PGENERIC_MAPPING; 
    ObjectCreation  : in BOOL; 
    GrantedAccess   : out DWORD ; 
    AccessStatusList : out DWORD ; 
    pfGenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(AccessCheckByTypeResultListAndAuditAlarmByHandleW,system);
#pragma import(AccessCheckByTypeResultListAndAuditAlarmByHandleW,'AccessCheckByTypeResultListAndAuditAlarmByHandleW','advapi32.dll');

#if #declared UNICODE; then;
#template AccessCheckByTypeResultListAndAuditAlarmByHandle;
  AccessCheckByTypeResultListAndAuditAlarmByHandleW 
#end AccessCheckByTypeResultListAndAuditAlarmByHandle;
#else;
#template AccessCheckByTypeResultListAndAuditAlarmByHandle;
  AccessCheckByTypeResultListAndAuditAlarmByHandleA 
#end AccessCheckByTypeResultListAndAuditAlarmByHandle;
#end if;

procedure ObjectOpenAuditAlarmA(
    SubsystemName   : in LPCSTR; 
    HandleId        : in LPVOID; 
    ObjectTypeName  : in LPSTR; 
    ObjectName      : in LPSTR; 
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    ClientToken     : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    GrantedAccess   : in DWORD; 
    Privileges      : in PPRIVILEGE_SET; 
    ObjectCreation  : in BOOL; 
    AccessGranted   : in BOOL; 
    GenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(ObjectOpenAuditAlarmA,system);
#pragma import(ObjectOpenAuditAlarmA,'ObjectOpenAuditAlarmA','advapi32.dll');

procedure ObjectOpenAuditAlarmW(
    SubsystemName   : in LPCWSTR; 
    HandleId        : in LPVOID; 
    ObjectTypeName  : in LPWSTR; 
    ObjectName      : in LPWSTR; 
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    ClientToken     : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    GrantedAccess   : in DWORD; 
    Privileges      : in PPRIVILEGE_SET; 
    ObjectCreation  : in BOOL; 
    AccessGranted   : in BOOL; 
    GenerateOnClose : out BOOL )
                      return BOOL;
#pragma convention(ObjectOpenAuditAlarmW,system);
#pragma import(ObjectOpenAuditAlarmW,'ObjectOpenAuditAlarmW','advapi32.dll');

#if #declared UNICODE; then;
#template ObjectOpenAuditAlarm;
  ObjectOpenAuditAlarmW 
#end ObjectOpenAuditAlarm;
#else;
#template ObjectOpenAuditAlarm;
  ObjectOpenAuditAlarmA 
#end ObjectOpenAuditAlarm;
#end if;

procedure ObjectPrivilegeAuditAlarmA(
    SubsystemName   : in LPCSTR; 
    HandleId        : in LPVOID; 
    ClientToken     : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    Privileges      : in PPRIVILEGE_SET; 
    AccessGranted   : in BOOL)
                      return BOOL;
#pragma convention(ObjectPrivilegeAuditAlarmA,system);
#pragma import(ObjectPrivilegeAuditAlarmA,'ObjectPrivilegeAuditAlarmA','advapi32.dll');

procedure ObjectPrivilegeAuditAlarmW(
    SubsystemName   : in LPCWSTR; 
    HandleId        : in LPVOID; 
    ClientToken     : in t_HANDLE; 
    DesiredAccess   : in DWORD; 
    Privileges      : in PPRIVILEGE_SET; 
    AccessGranted   : in BOOL)
                      return BOOL;
#pragma convention(ObjectPrivilegeAuditAlarmW,system);
#pragma import(ObjectPrivilegeAuditAlarmW,'ObjectPrivilegeAuditAlarmW','advapi32.dll');

#if #declared UNICODE; then;
#template ObjectPrivilegeAuditAlarm;
  ObjectPrivilegeAuditAlarmW 
#end ObjectPrivilegeAuditAlarm;
#else;
#template ObjectPrivilegeAuditAlarm;
  ObjectPrivilegeAuditAlarmA 
#end ObjectPrivilegeAuditAlarm;
#end if;

procedure ObjectCloseAuditAlarmA(
    SubsystemName   : in LPCSTR; 
    HandleId        : in LPVOID; 
    GenerateOnClose : in BOOL)
                      return BOOL;
#pragma convention(ObjectCloseAuditAlarmA,system);
#pragma import(ObjectCloseAuditAlarmA,'ObjectCloseAuditAlarmA','advapi32.dll');

procedure ObjectCloseAuditAlarmW(
    SubsystemName   : in LPCWSTR; 
    HandleId        : in LPVOID; 
    GenerateOnClose : in BOOL)
                      return BOOL;
#pragma convention(ObjectCloseAuditAlarmW,system);
#pragma import(ObjectCloseAuditAlarmW,'ObjectCloseAuditAlarmW','advapi32.dll');

#if #declared UNICODE; then;
#template ObjectCloseAuditAlarm;
  ObjectCloseAuditAlarmW 
#end ObjectCloseAuditAlarm;
#else;
#template ObjectCloseAuditAlarm;
  ObjectCloseAuditAlarmA 
#end ObjectCloseAuditAlarm;
#end if;

procedure ObjectDeleteAuditAlarmA(
    SubsystemName   : in LPCSTR; 
    HandleId        : in LPVOID; 
    GenerateOnClose : in BOOL)
                      return BOOL;
#pragma convention(ObjectDeleteAuditAlarmA,system);
#pragma import(ObjectDeleteAuditAlarmA,'ObjectDeleteAuditAlarmA','advapi32.dll');

procedure ObjectDeleteAuditAlarmW(
    SubsystemName   : in LPCWSTR; 
    HandleId        : in LPVOID; 
    GenerateOnClose : in BOOL)
                      return BOOL;
#pragma convention(ObjectDeleteAuditAlarmW,system);
#pragma import(ObjectDeleteAuditAlarmW,'ObjectDeleteAuditAlarmW','advapi32.dll');

#if #declared UNICODE; then;
#template ObjectDeleteAuditAlarm;
  ObjectDeleteAuditAlarmW 
#end ObjectDeleteAuditAlarm;
#else;
#template ObjectDeleteAuditAlarm;
  ObjectDeleteAuditAlarmA 
#end ObjectDeleteAuditAlarm;
#end if;

procedure PrivilegedServiceAuditAlarmA(
    SubsystemName   : in LPCSTR; 
    ServiceName     : in LPCSTR; 
    ClientToken     : in t_HANDLE; 
    Privileges      : in PPRIVILEGE_SET; 
    AccessGranted   : in BOOL)
                      return BOOL;
#pragma convention(PrivilegedServiceAuditAlarmA,system);
#pragma import(PrivilegedServiceAuditAlarmA,'PrivilegedServiceAuditAlarmA','advapi32.dll');

procedure PrivilegedServiceAuditAlarmW(
    SubsystemName   : in LPCWSTR; 
    ServiceName     : in LPCWSTR; 
    ClientToken     : in t_HANDLE; 
    Privileges      : in PPRIVILEGE_SET; 
    AccessGranted   : in BOOL)
                      return BOOL;
#pragma convention(PrivilegedServiceAuditAlarmW,system);
#pragma import(PrivilegedServiceAuditAlarmW,'PrivilegedServiceAuditAlarmW','advapi32.dll');

#if #declared UNICODE; then;
#template PrivilegedServiceAuditAlarm;
  PrivilegedServiceAuditAlarmW 
#end PrivilegedServiceAuditAlarm;
#else;
#template PrivilegedServiceAuditAlarm;
  PrivilegedServiceAuditAlarmA 
#end PrivilegedServiceAuditAlarm;
#end if;

procedure IsWellKnownSid(
    pSid            : in p_SID; 
    WellKnownSidType : in WELL_KNOWN_SID_TYPE)
                      return BOOL;
#pragma convention(IsWellKnownSid,system);
#pragma import(IsWellKnownSid,'IsWellKnownSid','advapi32.dll');

procedure CreateWellKnownSid(
    WellKnownSidType : in WELL_KNOWN_SID_TYPE; 
    DomainSid       : in {out optional} p_SID; 
    pSid            : out {!}p_SID; 
    cbSid           : in out DWORD)
                      return BOOL;
#pragma convention(CreateWellKnownSid,system);
#pragma import(CreateWellKnownSid,'CreateWellKnownSid','advapi32.dll');

procedure EqualDomainSid(
    pSid1           : in p_SID; 
    pSid2           : in p_SID; 
    pfEqual         : out BOOL)
                      return BOOL;
#pragma convention(EqualDomainSid,system);
#pragma import(EqualDomainSid,'EqualDomainSid','advapi32.dll');

procedure GetWindowsAccountDomainSid(
    pSid            : in p_SID; 
    ppDomainSid     : out {out optional} {!}p_SID; 
    cbSid           : in out DWORD)
                      return BOOL;
#pragma convention(GetWindowsAccountDomainSid,system);
#pragma import(GetWindowsAccountDomainSid,'GetWindowsAccountDomainSid','advapi32.dll');

procedure IsValidSid(
    pSid            : in p_SID)
                      return BOOL;
#pragma convention(IsValidSid,system);
#pragma import(IsValidSid,'IsValidSid','advapi32.dll');

procedure EqualSid(
    pSid1           : in p_SID; 
    pSid2           : in p_SID)
                      return BOOL;
#pragma convention(EqualSid,system);
#pragma import(EqualSid,'EqualSid','advapi32.dll');

procedure EqualPrefixSid(
    pSid1           : p_SID; 
    pSid2           : p_SID)
                      return BOOL;
#pragma convention(EqualPrefixSid,system);
#pragma import(EqualPrefixSid,'EqualPrefixSid','advapi32.dll');

procedure GetSidLengthRequired(
    nSubAuthorityCount : in UCHAR)
                      return DWORD;
#pragma convention(GetSidLengthRequired,system);
#pragma import(GetSidLengthRequired,'GetSidLengthRequired','advapi32.dll');

procedure AllocateAndInitializeSid(
    pIdentifierAuthority : in PSID_IDENTIFIER_AUTHORITY; 
    nSubAuthorityCount : in BYTE; 
    nSubAuthority0  : in DWORD; 
    nSubAuthority1  : in DWORD; 
    nSubAuthority2  : in DWORD; 
    nSubAuthority3  : in DWORD; 
    nSubAuthority4  : in DWORD; 
    nSubAuthority5  : in DWORD; 
    nSubAuthority6  : in DWORD; 
    nSubAuthority7  : in DWORD; 
    pSid            : out p_SID)
                      return BOOL;
#pragma convention(AllocateAndInitializeSid,system);
#pragma import(AllocateAndInitializeSid,'AllocateAndInitializeSid','advapi32.dll');

procedure FreeSid(
    pSid            : in p_SID)
                      return PVOID;
#pragma convention(FreeSid,system);
#pragma import(FreeSid,'FreeSid','advapi32.dll');

procedure InitializeSid(
    Sid             : out {!}p_SID; 
    pIdentifierAuthority : in PSID_IDENTIFIER_AUTHORITY; 
    nSubAuthorityCount : in BYTE)
                      return BOOL;
#pragma convention(InitializeSid,system);
#pragma import(InitializeSid,'InitializeSid','advapi32.dll');

procedure GetSidIdentifierAuthority(
    pSid            : in p_SID)
                      return PSID_IDENTIFIER_AUTHORITY;
#pragma convention(GetSidIdentifierAuthority,system);
#pragma import(GetSidIdentifierAuthority,'GetSidIdentifierAuthority','advapi32.dll');

procedure GetSidSubAuthority(
    pSid            : in p_SID; 
    nSubAuthority   : in DWORD)
                      return PDWORD;
#pragma convention(GetSidSubAuthority,system);
#pragma import(GetSidSubAuthority,'GetSidSubAuthority','advapi32.dll');

procedure GetSidSubAuthorityCount(
    pSid            : in p_SID)
                      return PUCHAR;
#pragma convention(GetSidSubAuthorityCount,system);
#pragma import(GetSidSubAuthorityCount,'GetSidSubAuthorityCount','advapi32.dll');

procedure GetLengthSid(
    pSid            : in p_SID)
                      return DWORD;
#pragma convention(GetLengthSid,system);
#pragma import(GetLengthSid,'GetLengthSid','advapi32.dll');

procedure CopySid(
    nDestinationSidLength : in DWORD; 
    pDestinationSid : out {!}p_SID; 
    pSourceSid      : in p_SID)
                      return BOOL;
#pragma convention(CopySid,system);
#pragma import(CopySid,'CopySid','advapi32.dll');

procedure AreAllAccessesGranted(
    GrantedAccess   : in DWORD; 
    DesiredAccess   : in DWORD)
                      return BOOL;
#pragma convention(AreAllAccessesGranted,system);
#pragma import(AreAllAccessesGranted,'AreAllAccessesGranted','advapi32.dll');

procedure AreAnyAccessesGranted(
    GrantedAccess   : in DWORD; 
    DesiredAccess   : in DWORD)
                      return BOOL;
#pragma convention(AreAnyAccessesGranted,system);
#pragma import(AreAnyAccessesGranted,'AreAnyAccessesGranted','advapi32.dll');

procedure MapGenericMask(
    AccessMask      : out DWORD ; 
    GenericMapping  : in PGENERIC_MAPPING);
#pragma convention(MapGenericMask,system);
#pragma import(MapGenericMask,'MapGenericMask','advapi32.dll');

procedure IsValidAcl(
    pAcl            : in p_ACL)
                      return BOOL;
#pragma convention(IsValidAcl,system);
#pragma import(IsValidAcl,'IsValidAcl','advapi32.dll');

procedure InitializeAcl(
    pAcl            : out ACL ; 
    nAclLength      : in DWORD; 
    dwAclRevision   : in DWORD)
                      return BOOL;
#pragma convention(InitializeAcl,system);
#pragma import(InitializeAcl,'InitializeAcl','advapi32.dll');

procedure GetAclInformation(
    pAcl            : in p_ACL; 
    pAclInformation : out unchecked ; 
    nAclInformationLength : in DWORD; 
    dwAclInformationClass : in ACL_INFORMATION_CLASS)
                      return BOOL;
#pragma convention(GetAclInformation,system);
#pragma import(GetAclInformation,'GetAclInformation','advapi32.dll');

procedure SetAclInformation(
    pAcl            : in p_ACL; 
    pAclInformation : in LPVOID; 
    nAclInformationLength : in DWORD; 
    dwAclInformationClass : in ACL_INFORMATION_CLASS)
                      return BOOL;
#pragma convention(SetAclInformation,system);
#pragma import(SetAclInformation,'SetAclInformation','advapi32.dll');

procedure AddAce(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    dwStartingAceIndex : in DWORD; 
    pAceList        : in LPVOID; 
    nAceListLength  : in DWORD)
                      return BOOL;
#pragma convention(AddAce,system);
#pragma import(AddAce,'AddAce','advapi32.dll');

procedure DeleteAce(
    pAcl            : in out ACL ; 
    dwAceIndex      : in DWORD)
                      return BOOL;
#pragma convention(DeleteAce,system);
#pragma import(DeleteAce,'DeleteAce','advapi32.dll');

procedure GetAce(
    pAcl            : in p_ACL; 
    dwAceIndex      : in DWORD; 
    pAce            : out LPVOID)
                      return BOOL;
#pragma convention(GetAce,system);
#pragma import(GetAce,'GetAce','advapi32.dll');

procedure AddAccessAllowedAce(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    AccessMask      : in DWORD; 
    pSid            : in p_SID)
                      return BOOL;
#pragma convention(AddAccessAllowedAce,system);
#pragma import(AddAccessAllowedAce,'AddAccessAllowedAce','advapi32.dll');

procedure AddAccessAllowedAceEx(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    AceFlags        : in DWORD; 
    AccessMask      : in DWORD; 
    pSid            : in p_SID)
                      return BOOL;
#pragma convention(AddAccessAllowedAceEx,system);
#pragma import(AddAccessAllowedAceEx,'AddAccessAllowedAceEx','advapi32.dll');

procedure AddAccessDeniedAce(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    AccessMask      : in DWORD; 
    pSid            : in p_SID)
                      return BOOL;
#pragma convention(AddAccessDeniedAce,system);
#pragma import(AddAccessDeniedAce,'AddAccessDeniedAce','advapi32.dll');

procedure AddAccessDeniedAceEx(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    AceFlags        : in DWORD; 
    AccessMask      : in DWORD; 
    pSid            : in p_SID)
                      return BOOL;
#pragma convention(AddAccessDeniedAceEx,system);
#pragma import(AddAccessDeniedAceEx,'AddAccessDeniedAceEx','advapi32.dll');

procedure AddAuditAccessAce(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    dwAccessMask    : in DWORD; 
    pSid            : in p_SID; 
    bAuditSuccess   : in BOOL; 
    bAuditFailure   : in BOOL)
                      return BOOL;
#pragma convention(AddAuditAccessAce,system);
#pragma import(AddAuditAccessAce,'AddAuditAccessAce','advapi32.dll');

procedure AddAuditAccessAceEx(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    AceFlags        : in DWORD; 
    dwAccessMask    : in DWORD; 
    pSid            : in p_SID; 
    bAuditSuccess   : in BOOL; 
    bAuditFailure   : in BOOL)
                      return BOOL;
#pragma convention(AddAuditAccessAceEx,system);
#pragma import(AddAuditAccessAceEx,'AddAuditAccessAceEx','advapi32.dll');

type
t_065=^t_GUID for machine_pointer use true;

t_066=^t_GUID for machine_pointer use true;

procedure AddAccessAllowedObjectAce(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    AceFlags        : in DWORD; 
    AccessMask      : in DWORD; 
    ObjectTypeGuid  : in t_065; 
    InheritedObjectTypeGuid : in t_066; 
    pSid            : in p_SID)
                      return BOOL;
#pragma convention(AddAccessAllowedObjectAce,system);
#pragma import(AddAccessAllowedObjectAce,'AddAccessAllowedObjectAce','advapi32.dll');

type
t_067=^t_GUID for machine_pointer use true;

t_068=^t_GUID for machine_pointer use true;

procedure AddAccessDeniedObjectAce(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    AceFlags        : in DWORD; 
    AccessMask      : in DWORD; 
    ObjectTypeGuid  : in t_067; 
    InheritedObjectTypeGuid : in t_068; 
    pSid            : in p_SID)
                      return BOOL;
#pragma convention(AddAccessDeniedObjectAce,system);
#pragma import(AddAccessDeniedObjectAce,'AddAccessDeniedObjectAce','advapi32.dll');

type
t_069=^t_GUID for machine_pointer use true;

t_070=^t_GUID for machine_pointer use true;

procedure AddAuditAccessObjectAce(
    pAcl            : in out ACL ; 
    dwAceRevision   : in DWORD; 
    AceFlags        : in DWORD; 
    AccessMask      : in DWORD; 
    ObjectTypeGuid  : in t_069; 
    InheritedObjectTypeGuid : in t_070; 
    pSid            : in p_SID; 
    bAuditSuccess   : in BOOL; 
    bAuditFailure   : in BOOL)
                      return BOOL;
#pragma convention(AddAuditAccessObjectAce,system);
#pragma import(AddAuditAccessObjectAce,'AddAuditAccessObjectAce','advapi32.dll');

procedure FindFirstFreeAce(
    pAcl            : in p_ACL; 
    pAce            : out LPVOID)
                      return BOOL;
#pragma convention(FindFirstFreeAce,system);
#pragma import(FindFirstFreeAce,'FindFirstFreeAce','advapi32.dll');

procedure InitializeSecurityDescriptor(
    pSecurityDescriptor : out {!}PSECURITY_DESCRIPTOR; 
    dwRevision      : in DWORD)
                      return BOOL;
#pragma convention(InitializeSecurityDescriptor,system);
#pragma import(InitializeSecurityDescriptor,'InitializeSecurityDescriptor','advapi32.dll');

procedure IsValidSecurityDescriptor(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR)
                      return BOOL;
#pragma convention(IsValidSecurityDescriptor,system);
#pragma import(IsValidSecurityDescriptor,'IsValidSecurityDescriptor','advapi32.dll');

procedure GetSecurityDescriptorLength(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR)
                      return DWORD;
#pragma convention(GetSecurityDescriptorLength,system);
#pragma import(GetSecurityDescriptorLength,'GetSecurityDescriptorLength','advapi32.dll');

procedure GetSecurityDescriptorControl(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    pControl        : out WORD ; 
    lpdwRevision    : out DWORD )
                      return BOOL;
#pragma convention(GetSecurityDescriptorControl,system);
#pragma import(GetSecurityDescriptorControl,'GetSecurityDescriptorControl','advapi32.dll');

procedure SetSecurityDescriptorControl(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    ControlBitsOfInterest : in SECURITY_DESCRIPTOR_CONTROL; 
    ControlBitsToSet : in SECURITY_DESCRIPTOR_CONTROL)
                      return BOOL;
#pragma convention(SetSecurityDescriptorControl,system);
#pragma import(SetSecurityDescriptorControl,'SetSecurityDescriptorControl','advapi32.dll');

procedure SetSecurityDescriptorDacl(
    pSecurityDescriptor : in out {!}PSECURITY_DESCRIPTOR; 
    bDaclPresent    : in BOOL; 
    pDacl           : in p_ACL; 
    bDaclDefaulted  : in BOOL)
                      return BOOL;
#pragma convention(SetSecurityDescriptorDacl,system);
#pragma import(SetSecurityDescriptorDacl,'SetSecurityDescriptorDacl','advapi32.dll');

procedure GetSecurityDescriptorDacl(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    lpbDaclPresent  : out BOOL ; 
    pDacl           : out p_ACL; 
    lpbDaclDefaulted : out BOOL )
                      return BOOL;
#pragma convention(GetSecurityDescriptorDacl,system);
#pragma import(GetSecurityDescriptorDacl,'GetSecurityDescriptorDacl','advapi32.dll');

procedure SetSecurityDescriptorSacl(
    pSecurityDescriptor : in out {!}PSECURITY_DESCRIPTOR; 
    bSaclPresent    : in BOOL; 
    pSacl           : in p_ACL; 
    bSaclDefaulted  : in BOOL)
                      return BOOL;
#pragma convention(SetSecurityDescriptorSacl,system);
#pragma import(SetSecurityDescriptorSacl,'SetSecurityDescriptorSacl','advapi32.dll');

procedure GetSecurityDescriptorSacl(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    lpbSaclPresent  : out BOOL ; 
    pSacl           : out p_ACL; 
    lpbSaclDefaulted : out BOOL )
                      return BOOL;
#pragma convention(GetSecurityDescriptorSacl,system);
#pragma import(GetSecurityDescriptorSacl,'GetSecurityDescriptorSacl','advapi32.dll');

procedure SetSecurityDescriptorOwner(
    pSecurityDescriptor : in out {!}PSECURITY_DESCRIPTOR; 
    pOwner          : in p_SID; 
    bOwnerDefaulted : in BOOL)
                      return BOOL;
#pragma convention(SetSecurityDescriptorOwner,system);
#pragma import(SetSecurityDescriptorOwner,'SetSecurityDescriptorOwner','advapi32.dll');

procedure GetSecurityDescriptorOwner(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    pOwner          : out p_SID; 
    lpbOwnerDefaulted : out BOOL )
                      return BOOL;
#pragma convention(GetSecurityDescriptorOwner,system);
#pragma import(GetSecurityDescriptorOwner,'GetSecurityDescriptorOwner','advapi32.dll');

procedure SetSecurityDescriptorGroup(
    pSecurityDescriptor : in out {!}PSECURITY_DESCRIPTOR; 
    pGroup          : in p_SID; 
    bGroupDefaulted : in BOOL)
                      return BOOL;
#pragma convention(SetSecurityDescriptorGroup,system);
#pragma import(SetSecurityDescriptorGroup,'SetSecurityDescriptorGroup','advapi32.dll');

procedure GetSecurityDescriptorGroup(
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    pGroup          : out p_SID; 
    lpbGroupDefaulted : out BOOL )
                      return BOOL;
#pragma convention(GetSecurityDescriptorGroup,system);
#pragma import(GetSecurityDescriptorGroup,'GetSecurityDescriptorGroup','advapi32.dll');

procedure SetSecurityDescriptorRMControl(
    SecurityDescriptor : in out {!}PSECURITY_DESCRIPTOR; 
    RMControl       : in {out optional} PUCHAR)
                      return DWORD;
#pragma convention(SetSecurityDescriptorRMControl,system);
#pragma import(SetSecurityDescriptorRMControl,'SetSecurityDescriptorRMControl','advapi32.dll');

procedure GetSecurityDescriptorRMControl(
    SecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    RMControl       : out UCHAR )
                      return DWORD;
#pragma convention(GetSecurityDescriptorRMControl,system);
#pragma import(GetSecurityDescriptorRMControl,'GetSecurityDescriptorRMControl','advapi32.dll');

procedure CreatePrivateObjectSecurity(
    ParentDescriptor : in PSECURITY_DESCRIPTOR; 
    CreatorDescriptor : in PSECURITY_DESCRIPTOR; 
    NewDescriptor   : out PSECURITY_DESCRIPTOR; 
    IsDirectoryObject : in BOOL; 
    Token           : in t_HANDLE; 
    GenericMapping  : in PGENERIC_MAPPING)
                      return BOOL;
#pragma convention(CreatePrivateObjectSecurity,system);
#pragma import(CreatePrivateObjectSecurity,'CreatePrivateObjectSecurity','advapi32.dll');

type
t_071=^t_GUID for machine_pointer use true;

procedure ConvertToAutoInheritPrivateObjectSecurity(
    ParentDescriptor : in PSECURITY_DESCRIPTOR; 
    CurrentSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    NewSecurityDescriptor : out PSECURITY_DESCRIPTOR; 
    ObjectType      : in t_071; 
    IsDirectoryObject : in BOOLEAN; 
    GenericMapping  : in PGENERIC_MAPPING)
                      return BOOL;
#pragma convention(ConvertToAutoInheritPrivateObjectSecurity,system);
#pragma import(ConvertToAutoInheritPrivateObjectSecurity,'ConvertToAutoInheritPrivateObjectSecurity','advapi32.dll');

type
t_072=^t_GUID for machine_pointer use true;

procedure CreatePrivateObjectSecurityEx(
    ParentDescriptor : in PSECURITY_DESCRIPTOR; 
    CreatorDescriptor : in PSECURITY_DESCRIPTOR; 
    NewDescriptor   : out PSECURITY_DESCRIPTOR; 
    ObjectType      : in {out optional} t_072; 
    IsContainerObject : in BOOL; 
    AutoInheritFlags : in ULONG; 
    Token           : in t_HANDLE; 
    GenericMapping  : in PGENERIC_MAPPING)
                      return BOOL;
#pragma convention(CreatePrivateObjectSecurityEx,system);
#pragma import(CreatePrivateObjectSecurityEx,'CreatePrivateObjectSecurityEx','advapi32.dll');

type
t_073=^^t_GUID for machine_pointer use true;

procedure CreatePrivateObjectSecurityWithMultipleInheritance(
    ParentDescriptor : in PSECURITY_DESCRIPTOR; 
    CreatorDescriptor : in PSECURITY_DESCRIPTOR; 
    NewDescriptor   : out PSECURITY_DESCRIPTOR; 
    ObjectTypes     : in {out optional} t_073; 
    GuidCount       : in ULONG; 
    IsContainerObject : in BOOL; 
    AutoInheritFlags : in ULONG; 
    Token           : in t_HANDLE; 
    GenericMapping  : in PGENERIC_MAPPING)
                      return BOOL;
#pragma convention(CreatePrivateObjectSecurityWithMultipleInheritance,system);
#pragma import(CreatePrivateObjectSecurityWithMultipleInheritance,'CreatePrivateObjectSecurityWithMultipleInheritance','advapi32.dll');

procedure SetPrivateObjectSecurity(
    SecurityInformation : in SECURITY_INFORMATION; 
    ModificationDescriptor : in PSECURITY_DESCRIPTOR; 
    ObjectsSecurityDescriptor : out PSECURITY_DESCRIPTOR; 
    GenericMapping  : in PGENERIC_MAPPING; 
    Token           : in t_HANDLE)
                      return BOOL;
#pragma convention(SetPrivateObjectSecurity,system);
#pragma import(SetPrivateObjectSecurity,'SetPrivateObjectSecurity','advapi32.dll');

procedure SetPrivateObjectSecurityEx(
    SecurityInformation : in SECURITY_INFORMATION; 
    ModificationDescriptor : in PSECURITY_DESCRIPTOR; 
    ObjectsSecurityDescriptor : out PSECURITY_DESCRIPTOR; 
    AutoInheritFlags : in ULONG; 
    GenericMapping  : in PGENERIC_MAPPING; 
    Token           : in {out optional} t_HANDLE)
                      return BOOL;
#pragma convention(SetPrivateObjectSecurityEx,system);
#pragma import(SetPrivateObjectSecurityEx,'SetPrivateObjectSecurityEx','advapi32.dll');

procedure GetPrivateObjectSecurity(
    ObjectDescriptor : in PSECURITY_DESCRIPTOR; 
    SecurityInformation : in SECURITY_INFORMATION; 
    ResultantDescriptor : out {!}PSECURITY_DESCRIPTOR; 
    DescriptorLength : in DWORD; 
    ReturnLength    : out DWORD )
                      return BOOL;
#pragma convention(GetPrivateObjectSecurity,system);
#pragma import(GetPrivateObjectSecurity,'GetPrivateObjectSecurity','advapi32.dll');

procedure DestroyPrivateObjectSecurity(
    ObjectDescriptor : in out PSECURITY_DESCRIPTOR)
                      return BOOL;
#pragma convention(DestroyPrivateObjectSecurity,system);
#pragma import(DestroyPrivateObjectSecurity,'DestroyPrivateObjectSecurity','advapi32.dll');

procedure MakeSelfRelativeSD(
    pAbsoluteSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    pSelfRelativeSecurityDescriptor : out {!}PSECURITY_DESCRIPTOR; 
    lpdwBufferLength : out DWORD )
                      return BOOL;
#pragma convention(MakeSelfRelativeSD,system);
#pragma import(MakeSelfRelativeSD,'MakeSelfRelativeSD','advapi32.dll');

procedure MakeAbsoluteSD(
    pSelfRelativeSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    pAbsoluteSecurityDescriptor : out {!}PSECURITY_DESCRIPTOR; 
    lpdwAbsoluteSecurityDescriptorSize : out DWORD ; 
    pDacl           : out ACL ; 
    lpdwDaclSize    : out DWORD ; 
    pSacl           : out ACL ; 
    lpdwSaclSize    : out DWORD ; 
    pOwner          : out {!}p_SID; 
    lpdwOwnerSize   : out DWORD ; 
    pPrimaryGroup   : out {!}p_SID; 
    lpdwPrimaryGroupSize : out DWORD )
                      return BOOL;
#pragma convention(MakeAbsoluteSD,system);
#pragma import(MakeAbsoluteSD,'MakeAbsoluteSD','advapi32.dll');

procedure MakeAbsoluteSD2(
    pSelfRelativeSecurityDescriptor : in PSECURITY_DESCRIPTOR; 
    lpdwBufferSize  : out DWORD )
                      return BOOL;
#pragma convention(MakeAbsoluteSD2,system);
#pragma import(MakeAbsoluteSD2,'MakeAbsoluteSD2','advapi32.dll');

procedure SetFileSecurityA(
    lpFileName      : in LPCSTR; 
    SecurityInformation : in SECURITY_INFORMATION; 
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR)
                      return BOOL;
#pragma convention(SetFileSecurityA,system);
#pragma import(SetFileSecurityA,'SetFileSecurityA','advapi32.dll');

procedure SetFileSecurityW(
    lpFileName      : in LPCWSTR; 
    SecurityInformation : in SECURITY_INFORMATION; 
    pSecurityDescriptor : in PSECURITY_DESCRIPTOR)
                      return BOOL;
#pragma convention(SetFileSecurityW,system);
#pragma import(SetFileSecurityW,'SetFileSecurityW','advapi32.dll');

#if #declared UNICODE; then;
#template SetFileSecurity;
  SetFileSecurityW 
#end SetFileSecurity;
#else;
#template SetFileSecurity;
  SetFileSecurityA 
#end SetFileSecurity;
#end if;

procedure GetFileSecurityA(
    lpFileName      : in LPCSTR; 
    RequestedInformation : in SECURITY_INFORMATION; 
    pSecurityDescriptor : out {!}PSECURITY_DESCRIPTOR; 
    nLength         : in DWORD; 
    lpnLengthNeeded : out DWORD )
                      return BOOL;
#pragma convention(GetFileSecurityA,system);
#pragma import(GetFileSecurityA,'GetFileSecurityA','advapi32.dll');

procedure GetFileSecurityW(
    lpFileName      : in LPCWSTR; 
    RequestedInformation : in SECURITY_INFORMATION; 
    pSecurityDescriptor : out {!}PSECURITY_DESCRIPTOR; 
    nLength         : in DWORD; 
    lpnLengthNeeded : out DWORD )
                      return BOOL;
#pragma convention(GetFileSecurityW,system);
#pragma import(GetFileSecurityW,'GetFileSecurityW','advapi32.dll');

#if #declared UNICODE; then;
#template GetFileSecurity;
  GetFileSecurityW 
#end GetFileSecurity;
#else;
#template GetFileSecurity;
  GetFileSecurityA 
#end GetFileSecurity;
#end if;

procedure SetKernelObjectSecurity(
    Handle          : in t_HANDLE; 
    SecurityInformation : in SECURITY_INFORMATION; 
    SecurityDescriptor : in PSECURITY_DESCRIPTOR)
                      return BOOL;
#pragma convention(SetKernelObjectSecurity,system);
#pragma import(SetKernelObjectSecurity,'SetKernelObjectSecurity','advapi32.dll');

procedure FindFirstChangeNotificationA(
    lpPathName      : in LPCSTR; 
    bWatchSubtree   : in BOOL; 
    dwNotifyFilter  : in DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstChangeNotificationA,system);
#pragma import(FindFirstChangeNotificationA,'FindFirstChangeNotificationA','kernel32.dll');

procedure FindFirstChangeNotificationW(
    lpPathName      : in LPCWSTR; 
    bWatchSubtree   : in BOOL; 
    dwNotifyFilter  : in DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstChangeNotificationW,system);
#pragma import(FindFirstChangeNotificationW,'FindFirstChangeNotificationW','kernel32.dll');

#if #declared UNICODE; then;
#template FindFirstChangeNotification;
  FindFirstChangeNotificationW 
#end FindFirstChangeNotification;
#else;
#template FindFirstChangeNotification;
  FindFirstChangeNotificationA 
#end FindFirstChangeNotification;
#end if;

procedure FindNextChangeNotification(
    hChangeHandle   : in t_HANDLE)
                      return BOOL;
#pragma convention(FindNextChangeNotification,system);
#pragma import(FindNextChangeNotification,'FindNextChangeNotification','kernel32.dll');

procedure FindCloseChangeNotification(
    hChangeHandle   : in t_HANDLE)
                      return BOOL;
#pragma convention(FindCloseChangeNotification,system);
#pragma import(FindCloseChangeNotification,'FindCloseChangeNotification','kernel32.dll');

procedure ReadDirectoryChangesW(
    hDirectory      : in t_HANDLE; 
    lpBuffer        : in out unchecked ; 
    nBufferLength   : in DWORD; 
    bWatchSubtree   : in BOOL; 
    dwNotifyFilter  : in DWORD; 
    lpBytesReturned : out DWORD ; 
    lpOverlapped    : in p_OVERLAPPED; 
    lpCompletionRoutine : in LPOVERLAPPED_COMPLETION_ROUTINE)
                      return BOOL;
#pragma convention(ReadDirectoryChangesW,system);
#pragma import(ReadDirectoryChangesW,'ReadDirectoryChangesW','kernel32.dll');

procedure VirtualLock(
    lpAddress       : in LPVOID; 
    dwSize          : in SIZE_T)
                      return BOOL;
#pragma convention(VirtualLock,system);
#pragma import(VirtualLock,'VirtualLock','kernel32.dll');

procedure VirtualUnlock(
    lpAddress       : in LPVOID; 
    dwSize          : in SIZE_T)
                      return BOOL;
#pragma convention(VirtualUnlock,system);
#pragma import(VirtualUnlock,'VirtualUnlock','kernel32.dll');

procedure MapViewOfFileEx(
    hFileMappingObject : in t_HANDLE; 
    dwDesiredAccess : in DWORD; 
    dwFileOffsetHigh : in DWORD; 
    dwFileOffsetLow : in DWORD; 
    dwNumberOfBytesToMap : in SIZE_T; 
    lpBaseAddress   : in LPVOID)
                      return LPVOID;
#pragma convention(MapViewOfFileEx,system);
#pragma import(MapViewOfFileEx,'MapViewOfFileEx','kernel32.dll');

procedure SetPriorityClass(
    hProcess        : in t_HANDLE; 
    dwPriorityClass : in DWORD)
                      return BOOL;
#pragma convention(SetPriorityClass,system);
#pragma import(SetPriorityClass,'SetPriorityClass','kernel32.dll');

procedure GetPriorityClass(
    hProcess        : in t_HANDLE)
                      return DWORD;
#pragma convention(GetPriorityClass,system);
#pragma import(GetPriorityClass,'GetPriorityClass','kernel32.dll');

type
t_074=^unchecked for machine_pointer use true;

procedure IsBadReadPtr(
    lp              : in t_074; 
    ucb             : in UINT_PTR)
                      return BOOL;
#pragma convention(IsBadReadPtr,system);
#pragma import(IsBadReadPtr,'IsBadReadPtr','kernel32.dll');

procedure IsBadWritePtr(
    lp              : in LPVOID; 
    ucb             : in UINT_PTR)
                      return BOOL;
#pragma convention(IsBadWritePtr,system);
#pragma import(IsBadWritePtr,'IsBadWritePtr','kernel32.dll');

type
t_075=^unchecked for machine_pointer use true;

procedure IsBadHugeReadPtr(
    lp              : in t_075; 
    ucb             : in UINT_PTR)
                      return BOOL;
#pragma convention(IsBadHugeReadPtr,system);
#pragma import(IsBadHugeReadPtr,'IsBadHugeReadPtr','kernel32.dll');

procedure IsBadHugeWritePtr(
    lp              : in LPVOID; 
    ucb             : in UINT_PTR)
                      return BOOL;
#pragma convention(IsBadHugeWritePtr,system);
#pragma import(IsBadHugeWritePtr,'IsBadHugeWritePtr','kernel32.dll');

procedure IsBadCodePtr(
    lpfn            : in FARPROC)
                      return BOOL;
#pragma convention(IsBadCodePtr,system);
#pragma import(IsBadCodePtr,'IsBadCodePtr','kernel32.dll');

procedure IsBadStringPtrA(
    lpsz            : in LPCSTR; 
    ucchMax         : in UINT_PTR)
                      return BOOL;
#pragma convention(IsBadStringPtrA,system);
#pragma import(IsBadStringPtrA,'IsBadStringPtrA','kernel32.dll');

procedure IsBadStringPtrW(
    lpsz            : in LPCWSTR; 
    ucchMax         : in UINT_PTR)
                      return BOOL;
#pragma convention(IsBadStringPtrW,system);
#pragma import(IsBadStringPtrW,'IsBadStringPtrW','kernel32.dll');

#if #declared UNICODE; then;
#template IsBadStringPtr;
  IsBadStringPtrW 
#end IsBadStringPtr;
#else;
#template IsBadStringPtr;
  IsBadStringPtrA 
#end IsBadStringPtr;
#end if;

procedure LookupAccountSidA(
    lpSystemName    : in LPCSTR; 
    Sid             : in p_SID; 
    Name            : out CHARSTR ; 
    cchName         : in out DWORD ; 
    ReferencedDomainName : out CHARSTR ; 
    cchReferencedDomainName : in out DWORD ; 
    peUse           : out _SID_NAME_USE)
                      return BOOL;
#pragma convention(LookupAccountSidA,system);
#pragma import(LookupAccountSidA,'LookupAccountSidA','advapi32.dll');

procedure LookupAccountSidW(
    lpSystemName    : in LPCWSTR; 
    Sid             : in p_SID; 
    Name            : out WCHARSTR ; 
    cchName         : in out DWORD ; 
    ReferencedDomainName : out WCHARSTR ; 
    cchReferencedDomainName : in out DWORD ; 
    peUse           : out _SID_NAME_USE)
                      return BOOL;
#pragma convention(LookupAccountSidW,system);
#pragma import(LookupAccountSidW,'LookupAccountSidW','advapi32.dll');

#if #declared UNICODE; then;
#template LookupAccountSid;
  LookupAccountSidW 
#end LookupAccountSid;
#else;
#template LookupAccountSid;
  LookupAccountSidA 
#end LookupAccountSid;
#end if;

procedure LookupAccountNameA(
    lpSystemName    : in LPCSTR; 
    lpAccountName   : in LPCSTR; 
    Sid             : out {!}p_SID; 
    cbSid           : in out DWORD ; 
    ReferencedDomainName : out CHARSTR ; 
    cchReferencedDomainName : in out DWORD ; 
    peUse           : out _SID_NAME_USE)
                      return BOOL;
#pragma convention(LookupAccountNameA,system);
#pragma import(LookupAccountNameA,'LookupAccountNameA','advapi32.dll');

procedure LookupAccountNameW(
    lpSystemName    : in LPCWSTR; 
    lpAccountName   : in LPCWSTR; 
    Sid             : out {!}p_SID; 
    cbSid           : in out DWORD ; 
    ReferencedDomainName : out WCHARSTR ; 
    cchReferencedDomainName : in out DWORD ; 
    peUse           : out _SID_NAME_USE)
                      return BOOL;
#pragma convention(LookupAccountNameW,system);
#pragma import(LookupAccountNameW,'LookupAccountNameW','advapi32.dll');

#if #declared UNICODE; then;
#template LookupAccountName;
  LookupAccountNameW 
#end LookupAccountName;
#else;
#template LookupAccountName;
  LookupAccountNameA 
#end LookupAccountName;
#end if;

procedure LookupPrivilegeValueA(
    lpSystemName    : in LPCSTR; 
    lpName          : in LPCSTR; 
    lpLuid          : out _LUID)
                      return BOOL;
#pragma convention(LookupPrivilegeValueA,system);
#pragma import(LookupPrivilegeValueA,'LookupPrivilegeValueA','advapi32.dll');

procedure LookupPrivilegeValueW(
    lpSystemName    : in LPCWSTR; 
    lpName          : in LPCWSTR; 
    lpLuid          : out _LUID)
                      return BOOL;
#pragma convention(LookupPrivilegeValueW,system);
#pragma import(LookupPrivilegeValueW,'LookupPrivilegeValueW','advapi32.dll');

#if #declared UNICODE; then;
#template LookupPrivilegeValue;
  LookupPrivilegeValueW 
#end LookupPrivilegeValue;
#else;
#template LookupPrivilegeValue;
  LookupPrivilegeValueA 
#end LookupPrivilegeValue;
#end if;

procedure LookupPrivilegeNameA(
    lpSystemName    : in LPCSTR; 
    lpLuid          : in PLUID; 
    lpName          : out CHARSTR ; 
    cbName          : in out DWORD )
                      return BOOL;
#pragma convention(LookupPrivilegeNameA,system);
#pragma import(LookupPrivilegeNameA,'LookupPrivilegeNameA','advapi32.dll');

procedure LookupPrivilegeNameW(
    lpSystemName    : in LPCWSTR; 
    lpLuid          : in PLUID; 
    lpName          : out WCHARSTR ; 
    cbName          : in out DWORD )
                      return BOOL;
#pragma convention(LookupPrivilegeNameW,system);
#pragma import(LookupPrivilegeNameW,'LookupPrivilegeNameW','advapi32.dll');

#if #declared UNICODE; then;
#template LookupPrivilegeName;
  LookupPrivilegeNameW 
#end LookupPrivilegeName;
#else;
#template LookupPrivilegeName;
  LookupPrivilegeNameA 
#end LookupPrivilegeName;
#end if;

procedure LookupPrivilegeDisplayNameA(
    lpSystemName    : in LPCSTR; 
    lpName          : in LPCSTR; 
    lpDisplayName   : out CHARSTR ; 
    cbDisplayName   : in out DWORD ; 
    lpLanguageId    : out DWORD )
                      return BOOL;
#pragma convention(LookupPrivilegeDisplayNameA,system);
#pragma import(LookupPrivilegeDisplayNameA,'LookupPrivilegeDisplayNameA','advapi32.dll');

procedure LookupPrivilegeDisplayNameW(
    lpSystemName    : in LPCWSTR; 
    lpName          : in LPCWSTR; 
    lpDisplayName   : out WCHARSTR ; 
    cbDisplayName   : in out DWORD ; 
    lpLanguageId    : out DWORD )
                      return BOOL;
#pragma convention(LookupPrivilegeDisplayNameW,system);
#pragma import(LookupPrivilegeDisplayNameW,'LookupPrivilegeDisplayNameW','advapi32.dll');

#if #declared UNICODE; then;
#template LookupPrivilegeDisplayName;
  LookupPrivilegeDisplayNameW 
#end LookupPrivilegeDisplayName;
#else;
#template LookupPrivilegeDisplayName;
  LookupPrivilegeDisplayNameA 
#end LookupPrivilegeDisplayName;
#end if;

procedure AllocateLocallyUniqueId(
    Luid            : out _LUID)
                      return BOOL;
#pragma convention(AllocateLocallyUniqueId,system);
#pragma import(AllocateLocallyUniqueId,'AllocateLocallyUniqueId','advapi32.dll');

procedure BuildCommDCBA(
    lpDef           : in LPCSTR; 
    lpDCB           : out _DCB)
                      return BOOL;
#pragma convention(BuildCommDCBA,system);
#pragma import(BuildCommDCBA,'BuildCommDCBA','kernel32.dll');

procedure BuildCommDCBW(
    lpDef           : in LPCWSTR; 
    lpDCB           : out _DCB)
                      return BOOL;
#pragma convention(BuildCommDCBW,system);
#pragma import(BuildCommDCBW,'BuildCommDCBW','kernel32.dll');

#if #declared UNICODE; then;
#template BuildCommDCB;
  BuildCommDCBW 
#end BuildCommDCB;
#else;
#template BuildCommDCB;
  BuildCommDCBA 
#end BuildCommDCB;
#end if;

procedure BuildCommDCBAndTimeoutsA(
    lpDef           : in LPCSTR; 
    lpDCB           : out _DCB; 
    lpCommTimeouts  : in p_COMMTIMEOUTS)
                      return BOOL;
#pragma convention(BuildCommDCBAndTimeoutsA,system);
#pragma import(BuildCommDCBAndTimeoutsA,'BuildCommDCBAndTimeoutsA','kernel32.dll');

procedure BuildCommDCBAndTimeoutsW(
    lpDef           : in LPCWSTR; 
    lpDCB           : out _DCB; 
    lpCommTimeouts  : in p_COMMTIMEOUTS)
                      return BOOL;
#pragma convention(BuildCommDCBAndTimeoutsW,system);
#pragma import(BuildCommDCBAndTimeoutsW,'BuildCommDCBAndTimeoutsW','kernel32.dll');

#if #declared UNICODE; then;
#template BuildCommDCBAndTimeouts;
  BuildCommDCBAndTimeoutsW 
#end BuildCommDCBAndTimeouts;
#else;
#template BuildCommDCBAndTimeouts;
  BuildCommDCBAndTimeoutsA 
#end BuildCommDCBAndTimeouts;
#end if;

procedure CommConfigDialogA(
    lpszName        : in LPCSTR; 
    hWnd            : in t_HWND; 
    lpCC            : in out _COMMCONFIG)
                      return BOOL;
#pragma convention(CommConfigDialogA,system);
#pragma import(CommConfigDialogA,'CommConfigDialogA','kernel32.dll');

procedure CommConfigDialogW(
    lpszName        : in LPCWSTR; 
    hWnd            : in t_HWND; 
    lpCC            : in out _COMMCONFIG)
                      return BOOL;
#pragma convention(CommConfigDialogW,system);
#pragma import(CommConfigDialogW,'CommConfigDialogW','kernel32.dll');

#if #declared UNICODE; then;
#template CommConfigDialog;
  CommConfigDialogW 
#end CommConfigDialog;
#else;
#template CommConfigDialog;
  CommConfigDialogA 
#end CommConfigDialog;
#end if;

procedure GetDefaultCommConfigA(
    lpszName        : in LPCSTR; 
    lpCC            : out _COMMCONFIG; 
    lpdwSize        : in out DWORD )
                      return BOOL;
#pragma convention(GetDefaultCommConfigA,system);
#pragma import(GetDefaultCommConfigA,'GetDefaultCommConfigA','kernel32.dll');

procedure GetDefaultCommConfigW(
    lpszName        : in LPCWSTR; 
    lpCC            : out _COMMCONFIG; 
    lpdwSize        : in out DWORD )
                      return BOOL;
#pragma convention(GetDefaultCommConfigW,system);
#pragma import(GetDefaultCommConfigW,'GetDefaultCommConfigW','kernel32.dll');

#if #declared UNICODE; then;
#template GetDefaultCommConfig;
  GetDefaultCommConfigW 
#end GetDefaultCommConfig;
#else;
#template GetDefaultCommConfig;
  GetDefaultCommConfigA 
#end GetDefaultCommConfig;
#end if;

procedure SetDefaultCommConfigA(
    lpszName        : in LPCSTR; 
    lpCC            : in LPCOMMCONFIG; 
    dwSize          : in DWORD)
                      return BOOL;
#pragma convention(SetDefaultCommConfigA,system);
#pragma import(SetDefaultCommConfigA,'SetDefaultCommConfigA','kernel32.dll');

procedure SetDefaultCommConfigW(
    lpszName        : in LPCWSTR; 
    lpCC            : in LPCOMMCONFIG; 
    dwSize          : in DWORD)
                      return BOOL;
#pragma convention(SetDefaultCommConfigW,system);
#pragma import(SetDefaultCommConfigW,'SetDefaultCommConfigW','kernel32.dll');

#if #declared UNICODE; then;
#template SetDefaultCommConfig;
  SetDefaultCommConfigW 
#end SetDefaultCommConfig;
#else;
#template SetDefaultCommConfig;
  SetDefaultCommConfigA 
#end SetDefaultCommConfig;
#end if;

const
  MAX_COMPUTERNAME_LENGTH= 15;

procedure GetComputerNameA(
    lpBuffer        : out CHARSTR ; 
    nSize           : in out DWORD )
                      return BOOL;
#pragma convention(GetComputerNameA,system);
#pragma import(GetComputerNameA,'GetComputerNameA','kernel32.dll');

procedure GetComputerNameW(
    lpBuffer        : out WCHARSTR ; 
    nSize           : in out DWORD )
                      return BOOL;
#pragma convention(GetComputerNameW,system);
#pragma import(GetComputerNameW,'GetComputerNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetComputerName;
  GetComputerNameW 
#end GetComputerName;
#else;
#template GetComputerName;
  GetComputerNameA 
#end GetComputerName;
#end if;

procedure SetComputerNameA(
    lpComputerName  : in LPCSTR)
                      return BOOL;
#pragma convention(SetComputerNameA,system);
#pragma import(SetComputerNameA,'SetComputerNameA','kernel32.dll');

procedure SetComputerNameW(
    lpComputerName  : in LPCWSTR)
                      return BOOL;
#pragma convention(SetComputerNameW,system);
#pragma import(SetComputerNameW,'SetComputerNameW','kernel32.dll');

#if #declared UNICODE; then;
#template SetComputerName;
  SetComputerNameW 
#end SetComputerName;
#else;
#template SetComputerName;
  SetComputerNameA 
#end SetComputerName;
#end if;

type
_COMPUTER_NAME_FORMAT= enum
    ComputerNameNetBIOS;
    ComputerNameDnsHostname;
    ComputerNameDnsDomain;
    ComputerNameDnsFullyQualified;
    ComputerNamePhysicalNetBIOS;
    ComputerNamePhysicalDnsHostname;
    ComputerNamePhysicalDnsDomain;
    ComputerNamePhysicalDnsFullyQualified;
    ComputerNameMax;
  end enum for size use 4;
  COMPUTER_NAME_FORMAT = _COMPUTER_NAME_FORMAT;
procedure GetComputerNameExA(
    NameType        : in COMPUTER_NAME_FORMAT; 
    lpBuffer        : out CHARSTR ; 
    nSize           : in out DWORD )
                      return BOOL;
#pragma convention(GetComputerNameExA,system);
#pragma import(GetComputerNameExA,'GetComputerNameExA','kernel32.dll');

procedure GetComputerNameExW(
    NameType        : in COMPUTER_NAME_FORMAT; 
    lpBuffer        : out WCHARSTR ; 
    nSize           : in out DWORD )
                      return BOOL;
#pragma convention(GetComputerNameExW,system);
#pragma import(GetComputerNameExW,'GetComputerNameExW','kernel32.dll');

#if #declared UNICODE; then;
#template GetComputerNameEx;
  GetComputerNameExW 
#end GetComputerNameEx;
#else;
#template GetComputerNameEx;
  GetComputerNameExA 
#end GetComputerNameEx;
#end if;

procedure SetComputerNameExA(
    NameType        : in COMPUTER_NAME_FORMAT; 
    lpBuffer        : in LPCSTR)
                      return BOOL;
#pragma convention(SetComputerNameExA,system);
#pragma import(SetComputerNameExA,'SetComputerNameExA','kernel32.dll');

procedure SetComputerNameExW(
    NameType        : in COMPUTER_NAME_FORMAT; 
    lpBuffer        : in LPCWSTR)
                      return BOOL;
#pragma convention(SetComputerNameExW,system);
#pragma import(SetComputerNameExW,'SetComputerNameExW','kernel32.dll');

#if #declared UNICODE; then;
#template SetComputerNameEx;
  SetComputerNameExW 
#end SetComputerNameEx;
#else;
#template SetComputerNameEx;
  SetComputerNameExA 
#end SetComputerNameEx;
#end if;

procedure DnsHostnameToComputerNameA(
    Hostname        : in LPCSTR; 
    ComputerName    : out CHARSTR ; 
    nSize           : in out DWORD )
                      return BOOL;
#pragma convention(DnsHostnameToComputerNameA,system);
#pragma import(DnsHostnameToComputerNameA,'DnsHostnameToComputerNameA','kernel32.dll');

procedure DnsHostnameToComputerNameW(
    Hostname        : in LPCWSTR; 
    ComputerName    : out WCHARSTR ; 
    nSize           : in out DWORD )
                      return BOOL;
#pragma convention(DnsHostnameToComputerNameW,system);
#pragma import(DnsHostnameToComputerNameW,'DnsHostnameToComputerNameW','kernel32.dll');

#if #declared UNICODE; then;
#template DnsHostnameToComputerName;
  DnsHostnameToComputerNameW 
#end DnsHostnameToComputerName;
#else;
#template DnsHostnameToComputerName;
  DnsHostnameToComputerNameA 
#end DnsHostnameToComputerName;
#end if;

procedure GetUserNameA(
    lpBuffer        : out CHARSTR ; 
    nSize           : in out DWORD )
                      return BOOL;
#pragma convention(GetUserNameA,system);
#pragma import(GetUserNameA,'GetUserNameA','advapi32.dll');

procedure GetUserNameW(
    lpBuffer        : out WCHARSTR ; 
    nSize           : in out DWORD )
                      return BOOL;
#pragma convention(GetUserNameW,system);
#pragma import(GetUserNameW,'GetUserNameW','advapi32.dll');

#if #declared UNICODE; then;
#template GetUserName;
  GetUserNameW 
#end GetUserName;
#else;
#template GetUserName;
  GetUserNameA 
#end GetUserName;
#end if;

-- 
--  Logon Support APIs
-- 
const
  LOGON32_LOGON_INTERACTIVE= 2;

const
  LOGON32_LOGON_NETWORK= 3;

const
  LOGON32_LOGON_BATCH= 4;

const
  LOGON32_LOGON_SERVICE= 5;

const
  LOGON32_LOGON_UNLOCK= 7;

const
  LOGON32_LOGON_NETWORK_CLEARTEXT= 8;

const
  LOGON32_LOGON_NEW_CREDENTIALS= 9;

const
  LOGON32_PROVIDER_DEFAULT= 0;

const
  LOGON32_PROVIDER_WINNT35= 1;

const
  LOGON32_PROVIDER_WINNT40= 2;

const
  LOGON32_PROVIDER_WINNT50= 3;

procedure LogonUserA(
    lpszUsername    : in LPCSTR; 
    lpszDomain      : in LPCSTR; 
    lpszPassword    : in LPCSTR; 
    dwLogonType     : in DWORD; 
    dwLogonProvider : in DWORD; 
    phToken         : out t_HANDLE )
                      return BOOL;
#pragma convention(LogonUserA,system);
#pragma import(LogonUserA,'LogonUserA','advapi32.dll');

procedure LogonUserW(
    lpszUsername    : in LPCWSTR; 
    lpszDomain      : in LPCWSTR; 
    lpszPassword    : in LPCWSTR; 
    dwLogonType     : in DWORD; 
    dwLogonProvider : in DWORD; 
    phToken         : out t_HANDLE )
                      return BOOL;
#pragma convention(LogonUserW,system);
#pragma import(LogonUserW,'LogonUserW','advapi32.dll');

#if #declared UNICODE; then;
#template LogonUser;
  LogonUserW 
#end LogonUser;
#else;
#template LogonUser;
  LogonUserA 
#end LogonUser;
#end if;

procedure LogonUserExA(
    lpszUsername    : in LPCSTR; 
    lpszDomain      : in LPCSTR; 
    lpszPassword    : in LPCSTR; 
    dwLogonType     : in DWORD; 
    dwLogonProvider : in DWORD; 
    phToken         : out {out optional} t_HANDLE ; 
    ppLogonSid      : out {out optional} p_SID; 
    ppProfileBuffer : out {out optional} PVOID; 
    pdwProfileLength : out {out optional} DWORD ; 
    pQuotaLimits    : out {out optional} _QUOTA_LIMITS)
                      return BOOL;
#pragma convention(LogonUserExA,system);
#pragma import(LogonUserExA,'LogonUserExA','advapi32.dll');

procedure LogonUserExW(
    lpszUsername    : in LPCWSTR; 
    lpszDomain      : in LPCWSTR; 
    lpszPassword    : in LPCWSTR; 
    dwLogonType     : in DWORD; 
    dwLogonProvider : in DWORD; 
    phToken         : out {out optional} t_HANDLE ; 
    ppLogonSid      : out {out optional} p_SID; 
    ppProfileBuffer : out {out optional} PVOID; 
    pdwProfileLength : out {out optional} DWORD ; 
    pQuotaLimits    : out {out optional} _QUOTA_LIMITS)
                      return BOOL;
#pragma convention(LogonUserExW,system);
#pragma import(LogonUserExW,'LogonUserExW','advapi32.dll');

#if #declared UNICODE; then;
#template LogonUserEx;
  LogonUserExW 
#end LogonUserEx;
#else;
#template LogonUserEx;
  LogonUserExA 
#end LogonUserEx;
#end if;

procedure ImpersonateLoggedOnUser(
    hToken          : in t_HANDLE)
                      return BOOL;
#pragma convention(ImpersonateLoggedOnUser,system);
#pragma import(ImpersonateLoggedOnUser,'ImpersonateLoggedOnUser','advapi32.dll');

procedure CreateProcessAsUserA(
    hToken          : in t_HANDLE; 
    lpApplicationName : in LPCSTR; 
    lpCommandLine   : in LPSTR; 
    lpProcessAttributes : in LPSECURITY_ATTRIBUTES; 
    lpThreadAttributes : in LPSECURITY_ATTRIBUTES; 
    bInheritHandles : in BOOL; 
    dwCreationFlags : in DWORD; 
    lpEnvironment   : in LPVOID; 
    lpCurrentDirectory : in LPCSTR; 
    lpStartupInfo   : in LPSTARTUPINFOA; 
    lpProcessInformation : out _PROCESS_INFORMATION)
                      return BOOL;
#pragma convention(CreateProcessAsUserA,system);
#pragma import(CreateProcessAsUserA,'CreateProcessAsUserA','advapi32.dll');

procedure CreateProcessAsUserW(
    hToken          : in t_HANDLE; 
    lpApplicationName : in LPCWSTR; 
    lpCommandLine   : in LPWSTR; 
    lpProcessAttributes : in LPSECURITY_ATTRIBUTES; 
    lpThreadAttributes : in LPSECURITY_ATTRIBUTES; 
    bInheritHandles : in BOOL; 
    dwCreationFlags : in DWORD; 
    lpEnvironment   : in LPVOID; 
    lpCurrentDirectory : in LPCWSTR; 
    lpStartupInfo   : in LPSTARTUPINFOW; 
    lpProcessInformation : out _PROCESS_INFORMATION)
                      return BOOL;
#pragma convention(CreateProcessAsUserW,system);
#pragma import(CreateProcessAsUserW,'CreateProcessAsUserW','advapi32.dll');

#if #declared UNICODE; then;
#template CreateProcessAsUser;
  CreateProcessAsUserW 
#end CreateProcessAsUser;
#else;
#template CreateProcessAsUser;
  CreateProcessAsUserA 
#end CreateProcessAsUser;
#end if;

-- 
--  LogonFlags
-- 
const
  LOGON_WITH_PROFILE= $01;

const
  LOGON_NETCREDENTIALS_ONLY= $02;

const
  LOGON_ZERO_PASSWORD_BUFFER= $80000000;

procedure CreateProcessWithLogonW(
    lpUsername      : LPCWSTR; 
    lpDomain        : LPCWSTR; 
    lpPassword      : LPCWSTR; 
    dwLogonFlags    : DWORD; 
    lpApplicationName : LPCWSTR; 
    lpCommandLine   : LPWSTR; 
    dwCreationFlags : DWORD; 
    lpEnvironment   : LPVOID; 
    lpCurrentDirectory : LPCWSTR; 
    lpStartupInfo   : LPSTARTUPINFOW; 
    lpProcessInformation : LPPROCESS_INFORMATION)
                      return BOOL;
#pragma convention(CreateProcessWithLogonW,system);
#pragma import(CreateProcessWithLogonW,'CreateProcessWithLogonW','advapi32.dll');

procedure CreateProcessWithTokenW(
    hToken          : t_HANDLE; 
    dwLogonFlags    : DWORD; 
    lpApplicationName : LPCWSTR; 
    lpCommandLine   : LPWSTR; 
    dwCreationFlags : DWORD; 
    lpEnvironment   : LPVOID; 
    lpCurrentDirectory : LPCWSTR; 
    lpStartupInfo   : LPSTARTUPINFOW; 
    lpProcessInformation : LPPROCESS_INFORMATION)
                      return BOOL;
#pragma convention(CreateProcessWithTokenW,system);
#pragma import(CreateProcessWithTokenW,'CreateProcessWithTokenW','advapi32.dll');

procedure ImpersonateAnonymousToken(
    ThreadHandle    : in t_HANDLE)
                      return BOOL;
#pragma convention(ImpersonateAnonymousToken,system);
#pragma import(ImpersonateAnonymousToken,'ImpersonateAnonymousToken','advapi32.dll');

procedure DuplicateTokenEx(
    hExistingToken  : in t_HANDLE; 
    dwDesiredAccess : in DWORD; 
    lpTokenAttributes : in LPSECURITY_ATTRIBUTES; 
    ImpersonationLevel : in SECURITY_IMPERSONATION_LEVEL; 
    TokenType       : in TOKEN_TYPE; 
    phNewToken      : out t_HANDLE )
                      return BOOL;
#pragma convention(DuplicateTokenEx,system);
#pragma import(DuplicateTokenEx,'DuplicateTokenEx','advapi32.dll');

procedure CreateRestrictedToken(
    ExistingTokenHandle : in t_HANDLE; 
    Flags           : in DWORD; 
    DisableSidCount : in DWORD; 
    SidsToDisable   : in {out optional} PSID_AND_ATTRIBUTES; 
    DeletePrivilegeCount : in DWORD; 
    PrivilegesToDelete : in {out optional} PLUID_AND_ATTRIBUTES; 
    RestrictedSidCount : in DWORD; 
    SidsToRestrict  : in {out optional} PSID_AND_ATTRIBUTES; 
    NewTokenHandle  : out t_HANDLE )
                      return BOOL;
#pragma convention(CreateRestrictedToken,system);
#pragma import(CreateRestrictedToken,'CreateRestrictedToken','advapi32.dll');

procedure IsTokenRestricted(
    TokenHandle     : in t_HANDLE)
                      return BOOL;
#pragma convention(IsTokenRestricted,system);
#pragma import(IsTokenRestricted,'IsTokenRestricted','advapi32.dll');

procedure IsTokenUntrusted(
    TokenHandle     : in t_HANDLE)
                      return BOOL;
#pragma convention(IsTokenUntrusted,system);
#pragma import(IsTokenUntrusted,'IsTokenUntrusted','advapi32.dll');

procedure CheckTokenMembership(
    TokenHandle     : in {out optional} t_HANDLE; 
    SidToCheck      : in p_SID; 
    IsMember        : out BOOL )
                      return BOOL;
#pragma convention(CheckTokenMembership,system);
#pragma import(CheckTokenMembership,'CheckTokenMembership','advapi32.dll');

-- 
--  Thread pool API's
-- 
type
WAITORTIMERCALLBACK = WAITORTIMERCALLBACKFUNC;
procedure RegisterWaitForSingleObject(
    phNewWaitObject : PHANDLE; 
    hObject         : t_HANDLE; 
    Callback        : WAITORTIMERCALLBACK; 
    Context         : PVOID; 
    dwMilliseconds  : ULONG; 
    dwFlags         : ULONG)
                      return BOOL;
#pragma convention(RegisterWaitForSingleObject,system);
#pragma import(RegisterWaitForSingleObject,'RegisterWaitForSingleObject','kernel32.dll');

procedure RegisterWaitForSingleObjectEx(
    hObject         : t_HANDLE; 
    Callback        : WAITORTIMERCALLBACK; 
    Context         : PVOID; 
    dwMilliseconds  : ULONG; 
    dwFlags         : ULONG)
                      return t_HANDLE;
#pragma convention(RegisterWaitForSingleObjectEx,system);
#pragma import(RegisterWaitForSingleObjectEx,'RegisterWaitForSingleObjectEx','kernel32.dll');

procedure UnregisterWait(
    WaitHandle      : t_HANDLE)
                      return BOOL;
#pragma convention(UnregisterWait,system);
#pragma import(UnregisterWait,'UnregisterWait','kernel32.dll');

procedure UnregisterWaitEx(
    WaitHandle      : t_HANDLE; 
    CompletionEvent : t_HANDLE)
                      return BOOL;
#pragma convention(UnregisterWaitEx,system);
#pragma import(UnregisterWaitEx,'UnregisterWaitEx','kernel32.dll');

procedure QueueUserWorkItem(
    Function        : LPTHREAD_START_ROUTINE; 
    Context         : PVOID; 
    Flags           : ULONG)
                      return BOOL;
#pragma convention(QueueUserWorkItem,system);
#pragma import(QueueUserWorkItem,'QueueUserWorkItem','kernel32.dll');

procedure BindIoCompletionCallback(
    FileHandle      : t_HANDLE; 
    Function        : LPOVERLAPPED_COMPLETION_ROUTINE; 
    Flags           : ULONG)
                      return BOOL;
#pragma convention(BindIoCompletionCallback,system);
#pragma import(BindIoCompletionCallback,'BindIoCompletionCallback','kernel32.dll');

procedure CreateTimerQueue
                      return t_HANDLE;
#pragma convention(CreateTimerQueue,system);
#pragma import(CreateTimerQueue,'CreateTimerQueue','kernel32.dll');

procedure CreateTimerQueueTimer(
    phNewTimer      : PHANDLE; 
    TimerQueue      : t_HANDLE; 
    Callback        : WAITORTIMERCALLBACK; 
    Parameter       : PVOID; 
    DueTime         : DWORD; 
    Period          : DWORD; 
    Flags           : ULONG)
                      return BOOL;
#pragma convention(CreateTimerQueueTimer,system);
#pragma import(CreateTimerQueueTimer,'CreateTimerQueueTimer','kernel32.dll');

procedure ChangeTimerQueueTimer(
    TimerQueue      : t_HANDLE; 
    Timer           : t_HANDLE; 
    DueTime         : ULONG; 
    Period          : ULONG)
                      return BOOL;
#pragma convention(ChangeTimerQueueTimer,system);
#pragma import(ChangeTimerQueueTimer,'ChangeTimerQueueTimer','kernel32.dll');

procedure DeleteTimerQueueTimer(
    TimerQueue      : t_HANDLE; 
    Timer           : t_HANDLE; 
    CompletionEvent : t_HANDLE)
                      return BOOL;
#pragma convention(DeleteTimerQueueTimer,system);
#pragma import(DeleteTimerQueueTimer,'DeleteTimerQueueTimer','kernel32.dll');

procedure DeleteTimerQueueEx(
    TimerQueue      : t_HANDLE; 
    CompletionEvent : t_HANDLE)
                      return BOOL;
#pragma convention(DeleteTimerQueueEx,system);
#pragma import(DeleteTimerQueueEx,'DeleteTimerQueueEx','kernel32.dll');

procedure SetTimerQueueTimer(
    TimerQueue      : t_HANDLE; 
    Callback        : WAITORTIMERCALLBACK; 
    Parameter       : PVOID; 
    DueTime         : DWORD; 
    Period          : DWORD; 
    PreferIo        : BOOL)
                      return t_HANDLE;
#pragma convention(SetTimerQueueTimer,system);
#pragma import(SetTimerQueueTimer,'SetTimerQueueTimer','kernel32.dll');

procedure CancelTimerQueueTimer(
    TimerQueue      : t_HANDLE; 
    Timer           : t_HANDLE)
                      return BOOL;
#pragma convention(CancelTimerQueueTimer,system);
#pragma import(CancelTimerQueueTimer,'CancelTimerQueueTimer','kernel32.dll');

procedure DeleteTimerQueue(
    TimerQueue      : t_HANDLE)
                      return BOOL;
#pragma convention(DeleteTimerQueue,system);
#pragma import(DeleteTimerQueue,'DeleteTimerQueue','kernel32.dll');

-- 
--  Plug-and-Play API's
-- 
const
  HW_PROFILE_GUIDLEN= 39;

const
  MAX_PROFILE_LEN   = 80;

type
  tagHW_PROFILE_INFOA = record
dwDockInfo      : DWORD;
szHwProfileGuid : array 0..HW_PROFILE_GUIDLEN-1 of CHAR;
szHwProfileName : array 0..MAX_PROFILE_LEN-1 of CHAR;
  end record;
  HW_PROFILE_INFOA  = tagHW_PROFILE_INFOA;
  LPHW_PROFILE_INFOA = ^tagHW_PROFILE_INFOA;

type
  tagHW_PROFILE_INFOW = record
dwDockInfo      : DWORD;
szHwProfileGuid : array 0..HW_PROFILE_GUIDLEN-1 of WCHAR;
szHwProfileName : array 0..MAX_PROFILE_LEN-1 of WCHAR;
  end record;
  HW_PROFILE_INFOW  = tagHW_PROFILE_INFOW;
  LPHW_PROFILE_INFOW = ^tagHW_PROFILE_INFOW;

#if #declared UNICODE; then;
type
HW_PROFILE_INFO   = HW_PROFILE_INFOW;
type
LPHW_PROFILE_INFO = LPHW_PROFILE_INFOW;
#else;
type
HW_PROFILE_INFO   = HW_PROFILE_INFOA;
type
LPHW_PROFILE_INFO = LPHW_PROFILE_INFOA;
#end if;

procedure GetCurrentHwProfileA(
    lpHwProfileInfo : out tagHW_PROFILE_INFOA)
                      return BOOL;
#pragma convention(GetCurrentHwProfileA,system);
#pragma import(GetCurrentHwProfileA,'GetCurrentHwProfileA','advapi32.dll');

procedure GetCurrentHwProfileW(
    lpHwProfileInfo : out tagHW_PROFILE_INFOW)
                      return BOOL;
#pragma convention(GetCurrentHwProfileW,system);
#pragma import(GetCurrentHwProfileW,'GetCurrentHwProfileW','advapi32.dll');

#if #declared UNICODE; then;
#template GetCurrentHwProfile;
  GetCurrentHwProfileW 
#end GetCurrentHwProfile;
#else;
#template GetCurrentHwProfile;
  GetCurrentHwProfileA 
#end GetCurrentHwProfile;
#end if;

-- 
--  Performance counter API's
-- 
procedure QueryPerformanceCounter(
    lpPerformanceCount : out LARGE_INTEGER)
                      return BOOL;
#pragma convention(QueryPerformanceCounter,system);
#pragma import(QueryPerformanceCounter,'QueryPerformanceCounter','kernel32.dll');

procedure QueryPerformanceFrequency(
    lpFrequency     : out LARGE_INTEGER)
                      return BOOL;
#pragma convention(QueryPerformanceFrequency,system);
#pragma import(QueryPerformanceFrequency,'QueryPerformanceFrequency','kernel32.dll');

procedure GetVersionExA(
    lpVersionInformation : in out _OSVERSIONINFOA)
                      return BOOL;
#pragma convention(GetVersionExA,system);
#pragma import(GetVersionExA,'GetVersionExA','kernel32.dll');

procedure GetVersionExW(
    lpVersionInformation : in out _OSVERSIONINFOW)
                      return BOOL;
#pragma convention(GetVersionExW,system);
#pragma import(GetVersionExW,'GetVersionExW','kernel32.dll');

#if #declared UNICODE; then;
#template GetVersionEx;
  GetVersionExW 
#end GetVersionEx;
#else;
#template GetVersionEx;
  GetVersionExA 
#end GetVersionEx;
#end if;

procedure VerifyVersionInfoA(
    lpVersionInformation : in LPOSVERSIONINFOEXA; 
    dwTypeMask      : in DWORD; 
    dwlConditionMask : in DWORDLONG)
                      return BOOL;
#pragma convention(VerifyVersionInfoA,system);
#pragma import(VerifyVersionInfoA,'VerifyVersionInfoA','kernel32.dll');

procedure VerifyVersionInfoW(
    lpVersionInformation : in LPOSVERSIONINFOEXW; 
    dwTypeMask      : in DWORD; 
    dwlConditionMask : in DWORDLONG)
                      return BOOL;
#pragma convention(VerifyVersionInfoW,system);
#pragma import(VerifyVersionInfoW,'VerifyVersionInfoW','kernel32.dll');

#if #declared UNICODE; then;
#template VerifyVersionInfo;
  VerifyVersionInfoW 
#end VerifyVersionInfo;
#else;
#template VerifyVersionInfo;
  VerifyVersionInfoA 
#end VerifyVersionInfo;
#end if;

--  DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
--  API functions.
-- 
#separate winerror;
-- /* Abnormal termination codes 
const
  TC_NORMAL         = 0;

const
  TC_HARDERR        = 1;

const
  TC_GP_TRAP        = 2;

const
  TC_SIGNAL         = 3;

-- 
--  Power Management APIs
-- 
const
  AC_LINE_OFFLINE   = $00;

const
  AC_LINE_ONLINE    = $01;

const
  AC_LINE_BACKUP_POWER= $02;

const
  AC_LINE_UNKNOWN   = $FF;

const
  BATTERY_FLAG_HIGH = $01;

const
  BATTERY_FLAG_LOW  = $02;

const
  BATTERY_FLAG_CRITICAL= $04;

const
  BATTERY_FLAG_CHARGING= $08;

const
  BATTERY_FLAG_NO_BATTERY= $80;

const
  BATTERY_FLAG_UNKNOWN= $FF;

const
  BATTERY_PERCENTAGE_UNKNOWN= $FF;

const
  BATTERY_LIFE_UNKNOWN= $FFFFFFFF;

type
  _SYSTEM_POWER_STATUS = record
ACLineStatus    : BYTE;
BatteryFlag     : BYTE;
BatteryLifePercent : BYTE;
Reserved1       : BYTE;
BatteryLifeTime : DWORD;
BatteryFullLifeTime : DWORD;
  end record;
  SYSTEM_POWER_STATUS = _SYSTEM_POWER_STATUS;
  LPSYSTEM_POWER_STATUS = ^_SYSTEM_POWER_STATUS;

procedure GetSystemPowerStatus(
    lpSystemPowerStatus : out _SYSTEM_POWER_STATUS)
                      return BOOL;
#pragma convention(GetSystemPowerStatus,system);
#pragma import(GetSystemPowerStatus,'GetSystemPowerStatus','kernel32.dll');

procedure SetSystemPowerState(
    fSuspend        : in BOOL; 
    fForce          : in BOOL)
                      return BOOL;
#pragma convention(SetSystemPowerState,system);
#pragma import(SetSystemPowerState,'SetSystemPowerState','kernel32.dll');

-- 
--  Very Large Memory API Subset
-- 
procedure AllocateUserPhysicalPages(
    hProcess        : in t_HANDLE; 
    NumberOfPages   : in out ULONG_PTR; 
    PageArray       : out ULONG_PTR)
                      return BOOL;
#pragma convention(AllocateUserPhysicalPages,system);
#pragma import(AllocateUserPhysicalPages,'AllocateUserPhysicalPages','kernel32.dll');

procedure FreeUserPhysicalPages(
    hProcess        : in t_HANDLE; 
    NumberOfPages   : in out ULONG_PTR; 
    PageArray       : in PULONG_PTR)
                      return BOOL;
#pragma convention(FreeUserPhysicalPages,system);
#pragma import(FreeUserPhysicalPages,'FreeUserPhysicalPages','kernel32.dll');

procedure MapUserPhysicalPages(
    VirtualAddress  : in PVOID; 
    NumberOfPages   : in ULONG_PTR; 
    PageArray       : in {out optional} PULONG_PTR)
                      return BOOL;
#pragma convention(MapUserPhysicalPages,system);
#pragma import(MapUserPhysicalPages,'MapUserPhysicalPages','kernel32.dll');

type
t_076=^PVOID for machine_pointer use true;

procedure MapUserPhysicalPagesScatter(
    VirtualAddresses : in t_076; 
    NumberOfPages   : in ULONG_PTR; 
    PageArray       : in {out optional} PULONG_PTR)
                      return BOOL;
#pragma convention(MapUserPhysicalPagesScatter,system);
#pragma import(MapUserPhysicalPagesScatter,'MapUserPhysicalPagesScatter','kernel32.dll');

procedure CreateJobObjectA(
    lpJobAttributes : in LPSECURITY_ATTRIBUTES; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(CreateJobObjectA,system);
#pragma import(CreateJobObjectA,'CreateJobObjectA','kernel32.dll');

procedure CreateJobObjectW(
    lpJobAttributes : in LPSECURITY_ATTRIBUTES; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(CreateJobObjectW,system);
#pragma import(CreateJobObjectW,'CreateJobObjectW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateJobObject;
  CreateJobObjectW 
#end CreateJobObject;
#else;
#template CreateJobObject;
  CreateJobObjectA 
#end CreateJobObject;
#end if;

procedure OpenJobObjectA(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCSTR)
                      return t_HANDLE;
#pragma convention(OpenJobObjectA,system);
#pragma import(OpenJobObjectA,'OpenJobObjectA','kernel32.dll');

procedure OpenJobObjectW(
    dwDesiredAccess : in DWORD; 
    bInheritHandle  : in BOOL; 
    lpName          : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(OpenJobObjectW,system);
#pragma import(OpenJobObjectW,'OpenJobObjectW','kernel32.dll');

#if #declared UNICODE; then;
#template OpenJobObject;
  OpenJobObjectW 
#end OpenJobObject;
#else;
#template OpenJobObject;
  OpenJobObjectA 
#end OpenJobObject;
#end if;

procedure AssignProcessToJobObject(
    hJob            : in t_HANDLE; 
    hProcess        : in t_HANDLE)
                      return BOOL;
#pragma convention(AssignProcessToJobObject,system);
#pragma import(AssignProcessToJobObject,'AssignProcessToJobObject','kernel32.dll');

procedure TerminateJobObject(
    hJob            : in t_HANDLE; 
    uExitCode       : in UINT)
                      return BOOL;
#pragma convention(TerminateJobObject,system);
#pragma import(TerminateJobObject,'TerminateJobObject','kernel32.dll');

procedure QueryInformationJobObject(
    hJob            : in t_HANDLE; 
    JobObjectInformationClass : in JOBOBJECTINFOCLASS; 
    lpJobObjectInformation : out unchecked ; 
    cbJobObjectInformationLength : in DWORD; 
    lpReturnLength  : out DWORD )
                      return BOOL;
#pragma convention(QueryInformationJobObject,system);
#pragma import(QueryInformationJobObject,'QueryInformationJobObject','kernel32.dll');

procedure SetInformationJobObject(
    hJob            : in t_HANDLE; 
    JobObjectInformationClass : in JOBOBJECTINFOCLASS; 
    lpJobObjectInformation : in LPVOID; 
    cbJobObjectInformationLength : in DWORD)
                      return BOOL;
#pragma convention(SetInformationJobObject,system);
#pragma import(SetInformationJobObject,'SetInformationJobObject','kernel32.dll');

procedure IsProcessInJob(
    ProcessHandle   : in t_HANDLE; 
    JobHandle       : in t_HANDLE; 
    _Result         : out BOOL )
                      return BOOL;
#pragma convention(IsProcessInJob,system);
#pragma import(IsProcessInJob,'IsProcessInJob','kernel32.dll');

procedure CreateJobSet(
    NumJob          : in ULONG; 
    UserJobSet      : in PJOB_SET_ARRAY; 
    Flags           : in ULONG)
                      return BOOL;
#pragma convention(CreateJobSet,system);
#pragma import(CreateJobSet,'CreateJobSet','kernel32.dll');

procedure AddVectoredExceptionHandler(
    FirstHandler    : in ULONG; 
    VectoredHandler : in PVECTORED_EXCEPTION_HANDLER)
                      return PVOID;
#pragma convention(AddVectoredExceptionHandler,system);
#pragma import(AddVectoredExceptionHandler,'AddVectoredExceptionHandler','kernel32.dll');

procedure RemoveVectoredExceptionHandler(
    VectoredHandlerHandle : in PVOID)
                      return ULONG;
#pragma convention(RemoveVectoredExceptionHandler,system);
#pragma import(RemoveVectoredExceptionHandler,'RemoveVectoredExceptionHandler','kernel32.dll');

-- 
--  New Volume Mount Point API.
-- 
procedure FindFirstVolumeA(
    lpszVolumeName  : LPSTR; 
    cchBufferLength : DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstVolumeA,system);
#pragma import(FindFirstVolumeA,'FindFirstVolumeA','kernel32.dll');

procedure FindFirstVolumeW(
    lpszVolumeName  : LPWSTR; 
    cchBufferLength : DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstVolumeW,system);
#pragma import(FindFirstVolumeW,'FindFirstVolumeW','kernel32.dll');

#if #declared UNICODE; then;
#template FindFirstVolume;
  FindFirstVolumeW 
#end FindFirstVolume;
#else;
#template FindFirstVolume;
  FindFirstVolumeA 
#end FindFirstVolume;
#end if;

procedure FindNextVolumeA(
    hFindVolume     : t_HANDLE; 
    lpszVolumeName  : LPSTR; 
    cchBufferLength : DWORD)
                      return BOOL;
#pragma convention(FindNextVolumeA,system);
#pragma import(FindNextVolumeA,'FindNextVolumeA','kernel32.dll');

procedure FindNextVolumeW(
    hFindVolume     : t_HANDLE; 
    lpszVolumeName  : LPWSTR; 
    cchBufferLength : DWORD)
                      return BOOL;
#pragma convention(FindNextVolumeW,system);
#pragma import(FindNextVolumeW,'FindNextVolumeW','kernel32.dll');

#if #declared UNICODE; then;
#template FindNextVolume;
  FindNextVolumeW 
#end FindNextVolume;
#else;
#template FindNextVolume;
  FindNextVolumeA 
#end FindNextVolume;
#end if;

procedure FindVolumeClose(
    hFindVolume     : t_HANDLE)
                      return BOOL;
#pragma convention(FindVolumeClose,system);
#pragma import(FindVolumeClose,'FindVolumeClose','kernel32.dll');

procedure FindFirstVolumeMountPointA(
    lpszRootPathName : LPCSTR; 
    lpszVolumeMountPoint : LPSTR; 
    cchBufferLength : DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstVolumeMountPointA,system);
#pragma import(FindFirstVolumeMountPointA,'FindFirstVolumeMountPointA','kernel32.dll');

procedure FindFirstVolumeMountPointW(
    lpszRootPathName : LPCWSTR; 
    lpszVolumeMountPoint : LPWSTR; 
    cchBufferLength : DWORD)
                      return t_HANDLE;
#pragma convention(FindFirstVolumeMountPointW,system);
#pragma import(FindFirstVolumeMountPointW,'FindFirstVolumeMountPointW','kernel32.dll');

#if #declared UNICODE; then;
#template FindFirstVolumeMountPoint;
  FindFirstVolumeMountPointW 
#end FindFirstVolumeMountPoint;
#else;
#template FindFirstVolumeMountPoint;
  FindFirstVolumeMountPointA 
#end FindFirstVolumeMountPoint;
#end if;

procedure FindNextVolumeMountPointA(
    hFindVolumeMountPoint : t_HANDLE; 
    lpszVolumeMountPoint : LPSTR; 
    cchBufferLength : DWORD)
                      return BOOL;
#pragma convention(FindNextVolumeMountPointA,system);
#pragma import(FindNextVolumeMountPointA,'FindNextVolumeMountPointA','kernel32.dll');

procedure FindNextVolumeMountPointW(
    hFindVolumeMountPoint : t_HANDLE; 
    lpszVolumeMountPoint : LPWSTR; 
    cchBufferLength : DWORD)
                      return BOOL;
#pragma convention(FindNextVolumeMountPointW,system);
#pragma import(FindNextVolumeMountPointW,'FindNextVolumeMountPointW','kernel32.dll');

#if #declared UNICODE; then;
#template FindNextVolumeMountPoint;
  FindNextVolumeMountPointW 
#end FindNextVolumeMountPoint;
#else;
#template FindNextVolumeMountPoint;
  FindNextVolumeMountPointA 
#end FindNextVolumeMountPoint;
#end if;

procedure FindVolumeMountPointClose(
    hFindVolumeMountPoint : t_HANDLE)
                      return BOOL;
#pragma convention(FindVolumeMountPointClose,system);
#pragma import(FindVolumeMountPointClose,'FindVolumeMountPointClose','kernel32.dll');

procedure SetVolumeMountPointA(
    lpszVolumeMountPoint : LPCSTR; 
    lpszVolumeName  : LPCSTR)
                      return BOOL;
#pragma convention(SetVolumeMountPointA,system);
#pragma import(SetVolumeMountPointA,'SetVolumeMountPointA','kernel32.dll');

procedure SetVolumeMountPointW(
    lpszVolumeMountPoint : LPCWSTR; 
    lpszVolumeName  : LPCWSTR)
                      return BOOL;
#pragma convention(SetVolumeMountPointW,system);
#pragma import(SetVolumeMountPointW,'SetVolumeMountPointW','kernel32.dll');

#if #declared UNICODE; then;
#template SetVolumeMountPoint;
  SetVolumeMountPointW 
#end SetVolumeMountPoint;
#else;
#template SetVolumeMountPoint;
  SetVolumeMountPointA 
#end SetVolumeMountPoint;
#end if;

procedure DeleteVolumeMountPointA(
    lpszVolumeMountPoint : LPCSTR)
                      return BOOL;
#pragma convention(DeleteVolumeMountPointA,system);
#pragma import(DeleteVolumeMountPointA,'DeleteVolumeMountPointA','kernel32.dll');

procedure DeleteVolumeMountPointW(
    lpszVolumeMountPoint : LPCWSTR)
                      return BOOL;
#pragma convention(DeleteVolumeMountPointW,system);
#pragma import(DeleteVolumeMountPointW,'DeleteVolumeMountPointW','kernel32.dll');

#if #declared UNICODE; then;
#template DeleteVolumeMountPoint;
  DeleteVolumeMountPointW 
#end DeleteVolumeMountPoint;
#else;
#template DeleteVolumeMountPoint;
  DeleteVolumeMountPointA 
#end DeleteVolumeMountPoint;
#end if;

procedure GetVolumeNameForVolumeMountPointA(
    lpszVolumeMountPoint : LPCSTR; 
    lpszVolumeName  : LPSTR; 
    cchBufferLength : DWORD)
                      return BOOL;
#pragma convention(GetVolumeNameForVolumeMountPointA,system);
#pragma import(GetVolumeNameForVolumeMountPointA,'GetVolumeNameForVolumeMountPointA','kernel32.dll');

procedure GetVolumeNameForVolumeMountPointW(
    lpszVolumeMountPoint : LPCWSTR; 
    lpszVolumeName  : LPWSTR; 
    cchBufferLength : DWORD)
                      return BOOL;
#pragma convention(GetVolumeNameForVolumeMountPointW,system);
#pragma import(GetVolumeNameForVolumeMountPointW,'GetVolumeNameForVolumeMountPointW','kernel32.dll');

#if #declared UNICODE; then;
#template GetVolumeNameForVolumeMountPoint;
  GetVolumeNameForVolumeMountPointW 
#end GetVolumeNameForVolumeMountPoint;
#else;
#template GetVolumeNameForVolumeMountPoint;
  GetVolumeNameForVolumeMountPointA 
#end GetVolumeNameForVolumeMountPoint;
#end if;

procedure GetVolumePathNameA(
    lpszFileName    : LPCSTR; 
    lpszVolumePathName : LPSTR; 
    cchBufferLength : DWORD)
                      return BOOL;
#pragma convention(GetVolumePathNameA,system);
#pragma import(GetVolumePathNameA,'GetVolumePathNameA','kernel32.dll');

procedure GetVolumePathNameW(
    lpszFileName    : LPCWSTR; 
    lpszVolumePathName : LPWSTR; 
    cchBufferLength : DWORD)
                      return BOOL;
#pragma convention(GetVolumePathNameW,system);
#pragma import(GetVolumePathNameW,'GetVolumePathNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetVolumePathName;
  GetVolumePathNameW 
#end GetVolumePathName;
#else;
#template GetVolumePathName;
  GetVolumePathNameA 
#end GetVolumePathName;
#end if;

procedure GetVolumePathNamesForVolumeNameA(
    lpszVolumeName  : LPCSTR; 
    lpszVolumePathNames : LPSTR; 
    cchBufferLength : DWORD; 
    lpcchReturnLength : PDWORD)
                      return BOOL;
#pragma convention(GetVolumePathNamesForVolumeNameA,system);
#pragma import(GetVolumePathNamesForVolumeNameA,'GetVolumePathNamesForVolumeNameA','kernel32.dll');

procedure GetVolumePathNamesForVolumeNameW(
    lpszVolumeName  : LPCWSTR; 
    lpszVolumePathNames : LPWSTR; 
    cchBufferLength : DWORD; 
    lpcchReturnLength : PDWORD)
                      return BOOL;
#pragma convention(GetVolumePathNamesForVolumeNameW,system);
#pragma import(GetVolumePathNamesForVolumeNameW,'GetVolumePathNamesForVolumeNameW','kernel32.dll');

#if #declared UNICODE; then;
#template GetVolumePathNamesForVolumeName;
  GetVolumePathNamesForVolumeNameW 
#end GetVolumePathNamesForVolumeName;
#else;
#template GetVolumePathNamesForVolumeName;
  GetVolumePathNamesForVolumeNameA 
#end GetVolumePathNamesForVolumeName;
#end if;

type
  tagACTCTXA        = record
cbSize          : ULONG;
dwFlags         : DWORD;
lpSource        : LPCSTR;
wProcessorArchitecture : USHORT;
wLangId         : LANGID;
lpAssemblyDirectory : LPCSTR;
lpResourceName  : LPCSTR;
lpApplicationName : LPCSTR;
hModule         : t_HMODULE;
  end record;
  ACTCTXA           = tagACTCTXA;
  PACTCTXA          = ^tagACTCTXA;

type
  tagACTCTXW        = record
cbSize          : ULONG;
dwFlags         : DWORD;
lpSource        : LPCWSTR;
wProcessorArchitecture : USHORT;
wLangId         : LANGID;
lpAssemblyDirectory : LPCWSTR;
lpResourceName  : LPCWSTR;
lpApplicationName : LPCWSTR;
hModule         : t_HMODULE;
  end record;
  ACTCTXW           = tagACTCTXW;
  PACTCTXW          = ^tagACTCTXW;

#if #declared UNICODE; then;
type
ACTCTX            = ACTCTXW;
type
PACTCTX           = PACTCTXW;
#else;
type
ACTCTX            = ACTCTXA;
type
PACTCTX           = PACTCTXA;
#end if;

type
PCACTCTXA         = ^ACTCTXA for machine_pointer use true;
type
PCACTCTXW         = ^ACTCTXW for machine_pointer use true;
#if #declared UNICODE; then;
type
PCACTCTX          = PCACTCTXW;
#else;
type
PCACTCTX          = PCACTCTXA;
#end if;

procedure CreateActCtxA(
    pActCtx         : PCACTCTXA)
                      return t_HANDLE;
#pragma convention(CreateActCtxA,system);
#pragma import(CreateActCtxA,'CreateActCtxA','kernel32.dll');

procedure CreateActCtxW(
    pActCtx         : PCACTCTXW)
                      return t_HANDLE;
#pragma convention(CreateActCtxW,system);
#pragma import(CreateActCtxW,'CreateActCtxW','kernel32.dll');

#if #declared UNICODE; then;
#template CreateActCtx;
  CreateActCtxW 
#end CreateActCtx;
#else;
#template CreateActCtx;
  CreateActCtxA 
#end CreateActCtx;
#end if;

procedure AddRefActCtx(
    hActCtx         : t_HANDLE);
#pragma convention(AddRefActCtx,system);
#pragma import(AddRefActCtx,'AddRefActCtx','kernel32.dll');

procedure ReleaseActCtx(
    hActCtx         : t_HANDLE);
#pragma convention(ReleaseActCtx,system);
#pragma import(ReleaseActCtx,'ReleaseActCtx','kernel32.dll');

procedure ZombifyActCtx(
    hActCtx         : t_HANDLE)
                      return BOOL;
#pragma convention(ZombifyActCtx,system);
#pragma import(ZombifyActCtx,'ZombifyActCtx','kernel32.dll');

type
t_077=^ULONG_PTR for machine_pointer use true;

procedure ActivateActCtx(
    hActCtx         : t_HANDLE; 
    lpCookie        : t_077)
                      return BOOL;
#pragma convention(ActivateActCtx,system);
#pragma import(ActivateActCtx,'ActivateActCtx','kernel32.dll');

procedure DeactivateActCtx(
    dwFlags         : DWORD; 
    ulCookie        : ULONG_PTR)
                      return BOOL;
#pragma convention(DeactivateActCtx,system);
#pragma import(DeactivateActCtx,'DeactivateActCtx','kernel32.dll');

type
t_078=^t_HANDLE for machine_pointer use true;

procedure GetCurrentActCtx(
    lphActCtx       : t_078)
                      return BOOL;
#pragma convention(GetCurrentActCtx,system);
#pragma import(GetCurrentActCtx,'GetCurrentActCtx','kernel32.dll');

type
  tagACTCTX_SECTION_KEYED_DATA_2600 = record
cbSize          : ULONG;
ulDataFormatVersion : ULONG;
lpData          : PVOID;
ulLength        : ULONG;
lpSectionGlobalData : PVOID;
ulSectionGlobalDataLength : ULONG;
lpSectionBase   : PVOID;
ulSectionTotalLength : ULONG;
hActCtx         : t_HANDLE;
ulAssemblyRosterIndex : ULONG;
  end record;
  ACTCTX_SECTION_KEYED_DATA_2600 = tagACTCTX_SECTION_KEYED_DATA_2600;
  PACTCTX_SECTION_KEYED_DATA_2600 = ^tagACTCTX_SECTION_KEYED_DATA_2600;

type
PCACTCTX_SECTION_KEYED_DATA_2600 = ^ACTCTX_SECTION_KEYED_DATA_2600 for machine_pointer use true;
type
  tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = record
lpInformation   : PVOID;
lpSectionBase   : PVOID;
ulSectionLength : ULONG;
lpSectionGlobalDataBase : PVOID;
ulSectionGlobalDataLength : ULONG;
  end record;
  ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
  PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = ^tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

type
PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = ^ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA for machine_pointer use true;
type
  tagACTCTX_SECTION_KEYED_DATA = record
cbSize          : ULONG;
ulDataFormatVersion : ULONG;
lpData          : PVOID;
ulLength        : ULONG;
lpSectionGlobalData : PVOID;
ulSectionGlobalDataLength : ULONG;
lpSectionBase   : PVOID;
ulSectionTotalLength : ULONG;
hActCtx         : t_HANDLE;
ulAssemblyRosterIndex : ULONG;
ulFlags         : ULONG;
AssemblyMetadata : ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
  end record;
  ACTCTX_SECTION_KEYED_DATA = tagACTCTX_SECTION_KEYED_DATA;
  PACTCTX_SECTION_KEYED_DATA = ^tagACTCTX_SECTION_KEYED_DATA;

type
PCACTCTX_SECTION_KEYED_DATA = ^ACTCTX_SECTION_KEYED_DATA for machine_pointer use true;
type
t_079=^t_GUID for machine_pointer use true;

procedure FindActCtxSectionStringA(
    dwFlags         : DWORD; 
    lpExtensionGuid : in t_079; 
    ulSectionId     : ULONG; 
    lpStringToFind  : LPCSTR; 
    ReturnedData    : PACTCTX_SECTION_KEYED_DATA)
                      return BOOL;
#pragma convention(FindActCtxSectionStringA,system);
#pragma import(FindActCtxSectionStringA,'FindActCtxSectionStringA','kernel32.dll');

type
t_080=^t_GUID for machine_pointer use true;

procedure FindActCtxSectionStringW(
    dwFlags         : DWORD; 
    lpExtensionGuid : in t_080; 
    ulSectionId     : ULONG; 
    lpStringToFind  : LPCWSTR; 
    ReturnedData    : PACTCTX_SECTION_KEYED_DATA)
                      return BOOL;
#pragma convention(FindActCtxSectionStringW,system);
#pragma import(FindActCtxSectionStringW,'FindActCtxSectionStringW','kernel32.dll');

#if #declared UNICODE; then;
#template FindActCtxSectionString;
  FindActCtxSectionStringW 
#end FindActCtxSectionString;
#else;
#template FindActCtxSectionString;
  FindActCtxSectionStringA 
#end FindActCtxSectionString;
#end if;

type
t_081=^t_GUID for machine_pointer use true;

t_082=^t_GUID for machine_pointer use true;

procedure FindActCtxSectionGuid(
    dwFlags         : DWORD; 
    lpExtensionGuid : in t_081; 
    ulSectionId     : ULONG; 
    lpGuidToFind    : in t_082; 
    ReturnedData    : PACTCTX_SECTION_KEYED_DATA)
                      return BOOL;
#pragma convention(FindActCtxSectionGuid,system);
#pragma import(FindActCtxSectionGuid,'FindActCtxSectionGuid','kernel32.dll');

-- /* RC complains about long symbols in #ifs 
type
  _ACTIVATION_CONTEXT_BASIC_INFORMATION = record
hActCtx         : t_HANDLE;
dwFlags         : DWORD;
  end record;
  ACTIVATION_CONTEXT_BASIC_INFORMATION = _ACTIVATION_CONTEXT_BASIC_INFORMATION;
  PACTIVATION_CONTEXT_BASIC_INFORMATION = ^_ACTIVATION_CONTEXT_BASIC_INFORMATION;

type
  PCACTIVATION_CONTEXT_BASIC_INFORMATION = ^const _ACTIVATION_CONTEXT_BASIC_INFORMATION;
const
  ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED= 1;

-- 
--  switch (ulInfoClass)
-- 
--  case ActivationContextBasicInformation:
--  pvSubInstance == NULL
--  pvBuffer is of type PACTIVATION_CONTEXT_BASIC_INFORMATION
-- 
--  case ActivationContextDetailedInformation:
--  pvSubInstance == NULL
--  pvBuffer is of type PACTIVATION_CONTEXT_DETAILED_INFORMATION
-- 
--  case AssemblyDetailedInformationInActivationContext:
--  pvSubInstance is of type PULONG
--  *pvSubInstance < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
--  pvBuffer is of type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
-- 
--  case FileInformationInAssemblyOfAssemblyInActivationContext:
--  pvSubInstance is of type PACTIVATION_CONTEXT_QUERY_INDEX
--  pvSubInstance->ulAssemblyIndex < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
--  pvSubInstance->ulFileIndexInAssembly < ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION::ulFileCount
--  pvBuffer is of type PASSEMBLY_FILE_DETAILED_INFORMATION
-- 
--  String are placed after the structs.
-- 
procedure QueryActCtxW(
    dwFlags         : in DWORD; 
    hActCtx         : in t_HANDLE; 
    pvSubInstance   : in PVOID; 
    ulInfoClass     : in ULONG; 
    pvBuffer        : out unchecked ; 
    cbBuffer        : in {out optional} SIZE_T; 
    pcbWrittenOrRequired : out {out optional} SIZE_T)
                      return BOOL;
#pragma convention(QueryActCtxW,system);
#pragma import(QueryActCtxW,'QueryActCtxW','kernel32.dll');

type
PQUERYACTCTXW_FUNC = ^procedure (
    dwFlags         : in DWORD;
    hActCtx         : in t_HANDLE;
    pvSubInstance   : in PVOID;
    ulInfoClass     : in ULONG;
    pvBuffer        : out unchecked ;
    cbBuffer        : in {out optional} SIZE_T;
    pcbWrittenOrRequired : out {out optional} SIZE_T)
                      return BOOL for machine_pointer use true;
procedure ProcessIdToSessionId(
    dwProcessId     : in DWORD; 
    pSessionId      : out DWORD)
                      return BOOL;
#pragma convention(ProcessIdToSessionId,system);
#pragma import(ProcessIdToSessionId,'ProcessIdToSessionId','kernel32.dll');

procedure WTSGetActiveConsoleSessionId
                      return DWORD;
#pragma convention(WTSGetActiveConsoleSessionId,system);
#pragma import(WTSGetActiveConsoleSessionId,'WTSGetActiveConsoleSessionId','kernel32.dll');

procedure IsWow64Process(
    hProcess        : t_HANDLE; 
    Wow64Process    : PBOOL)
                      return BOOL;
#pragma convention(IsWow64Process,system);
#pragma import(IsWow64Process,'IsWow64Process','kernel32.dll');

procedure GetLogicalProcessorInformation(
    Buffer          : PSYSTEM_LOGICAL_PROCESSOR_INFORMATION; 
    ReturnedLength  : PDWORD)
                      return BOOL;
#pragma convention(GetLogicalProcessorInformation,system);
#pragma import(GetLogicalProcessorInformation,'GetLogicalProcessorInformation','kernel32.dll');

-- 
--  NUMA Information routines.
-- 
procedure GetNumaHighestNodeNumber(
    HighestNodeNumber : PULONG)
                      return BOOL;
#pragma convention(GetNumaHighestNodeNumber,system);
#pragma import(GetNumaHighestNodeNumber,'GetNumaHighestNodeNumber','kernel32.dll');

procedure GetNumaProcessorNode(
    Processor       : UCHAR; 
    NodeNumber      : PUCHAR)
                      return BOOL;
#pragma convention(GetNumaProcessorNode,system);
#pragma import(GetNumaProcessorNode,'GetNumaProcessorNode','kernel32.dll');

procedure GetNumaNodeProcessorMask(
    Node            : UCHAR; 
    ProcessorMask   : PULONGLONG)
                      return BOOL;
#pragma convention(GetNumaNodeProcessorMask,system);
#pragma import(GetNumaNodeProcessorMask,'GetNumaNodeProcessorMask','kernel32.dll');

procedure GetNumaAvailableMemoryNode(
    Node            : UCHAR; 
    AvailableBytes  : PULONGLONG)
                      return BOOL;
#pragma convention(GetNumaAvailableMemoryNode,system);
#pragma import(GetNumaAvailableMemoryNode,'GetNumaAvailableMemoryNode','kernel32.dll');

-- /* RC complains about long symbols in #ifs 

end winbase;
