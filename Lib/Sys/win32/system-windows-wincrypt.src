----------------------------------------------------------------------------------------------------
module wincrypt =
-- Win32 API Binding
-- Translation to Flex Copyright (C) 2003-2004 A && L soft
----------------------------------------------------------------------------------------------------

with
    windef,winnt,basetsd,guiddef,winbase;

-- +---------------------------------------------------------------------------
-- 
--  Microsoft Windows
--  Copyright (C) Microsoft Corporation, 1992-1999.
-- 
--  File: wincrypt.h
-- 
--  Contents: Cryptographic API Prototypes and Definitions
-- 
-- ----------------------------------------------------------------------------
-- #pragma  warning(push)
-- #pragma  warning(disable:4201) /* Nameless struct/union */
-- #pragma  once
-- 
--  Algorithm IDs and Flags
-- 
--  ALG_ID crackers
--  Algorithm classes
--  Algorithm types
--  Generic sub-ids
--  Some RSA sub-ids
const
  ALG_SID_RSA_ANY   = 0;

const
  ALG_SID_RSA_PKCS  = 1;

const
  ALG_SID_RSA_MSATWORK= 2;

const
  ALG_SID_RSA_ENTRUST= 3;

const
  ALG_SID_RSA_PGP   = 4;

--  Some DSS sub-ids
-- 
const
  ALG_SID_DSS_ANY   = 0;

const
  ALG_SID_DSS_PKCS  = 1;

const
  ALG_SID_DSS_DMS   = 2;

--  Block cipher sub ids
--  DES sub_ids
const
  ALG_SID_DES       = 1;

const
  ALG_SID_3DES      = 3;

const
  ALG_SID_DESX      = 4;

const
  ALG_SID_IDEA      = 5;

const
  ALG_SID_CAST      = 6;

const
  ALG_SID_SAFERSK64 = 7;

const
  ALG_SID_SAFERSK128= 8;

const
  ALG_SID_3DES_112  = 9;

const
  ALG_SID_CYLINK_MEK= 12;

const
  ALG_SID_RC5       = 13;

const
  ALG_SID_AES_128   = 14;

const
  ALG_SID_AES_192   = 15;

const
  ALG_SID_AES_256   = 16;

const
  ALG_SID_AES       = 17;

--  Fortezza sub-ids
const
  ALG_SID_SKIPJACK  = 10;

const
  ALG_SID_TEK       = 11;

--  KP_MODE
const
  CRYPT_MODE_CBCI   = 6;

const
  CRYPT_MODE_CFBP   = 7;

const
  CRYPT_MODE_OFBP   = 8;

const
  CRYPT_MODE_CBCOFM = 9;

const
  CRYPT_MODE_CBCOFMI= 10;

--  RC2 sub-ids
const
  ALG_SID_RC2       = 2;

--  Stream cipher sub-ids
const
  ALG_SID_RC4       = 1;

const
  ALG_SID_SEAL      = 2;

--  Diffie-Hellman sub-ids
const
  ALG_SID_DH_SANDF  = 1;

const
  ALG_SID_DH_EPHEM  = 2;

const
  ALG_SID_AGREED_KEY_ANY= 3;

const
  ALG_SID_KEA       = 4;

--  Hash sub ids
const
  ALG_SID_MD2       = 1;

const
  ALG_SID_MD4       = 2;

const
  ALG_SID_MD5       = 3;

const
  ALG_SID_SHA       = 4;

const
  ALG_SID_SHA1      = 4;

const
  ALG_SID_MAC       = 5;

const
  ALG_SID_RIPEMD    = 6;

const
  ALG_SID_RIPEMD160 = 7;

const
  ALG_SID_SSL3SHAMD5= 8;

const
  ALG_SID_HMAC      = 9;

const
  ALG_SID_TLS1PRF   = 10;

const
  ALG_SID_HASH_REPLACE_OWF= 11;

const
  ALG_SID_SHA_256   = 12;

const
  ALG_SID_SHA_384   = 13;

const
  ALG_SID_SHA_512   = 14;

--  secure channel sub ids
const
  ALG_SID_SSL3_MASTER= 1;

const
  ALG_SID_SCHANNEL_MASTER_HASH= 2;

const
  ALG_SID_SCHANNEL_MAC_KEY= 3;

const
  ALG_SID_PCT1_MASTER= 4;

const
  ALG_SID_SSL2_MASTER= 5;

const
  ALG_SID_TLS1_MASTER= 6;

const
  ALG_SID_SCHANNEL_ENC_KEY= 7;

--  Our silly example sub-id
const
  ALG_SID_EXAMPLE   = 80;

type
ALG_ID            = unsigned 32;
--  algorithm identifier definitions
type
t_HCRYPTPROV      = ULONG_PTR;
type
HCRYPTKEY         = ULONG_PTR;
type
HCRYPTHASH        = ULONG_PTR;
--  dwFlags definitions for CryptAcquireContext
const
  CRYPT_VERIFYCONTEXT= $F0000000;

const
  CRYPT_NEWKEYSET   = $08;

const
  CRYPT_DELETEKEYSET= $10;

const
  CRYPT_MACHINE_KEYSET= $20;

const
  CRYPT_SILENT      = $40;

--  dwFlag definitions for CryptGenKey
const
  CRYPT_EXPORTABLE  = $01;

const
  CRYPT_USER_PROTECTED= $02;

const
  CRYPT_CREATE_SALT = $04;

const
  CRYPT_UPDATE_KEY  = $08;

const
  CRYPT_NO_SALT     = $10;

const
  CRYPT_PREGEN      = $40;

const
  CRYPT_RECIPIENT   = $10;

const
  CRYPT_INITIATOR   = $40;

const
  CRYPT_ONLINE      = $80;

const
  CRYPT_SF          = $0100;

const
  CRYPT_CREATE_IV   = $0200;

const
  CRYPT_KEK         = $0400;

const
  CRYPT_DATA_KEY    = $0800;

const
  CRYPT_VOLATILE    = $1000;

const
  CRYPT_SGCKEY      = $2000;

const
  CRYPT_ARCHIVABLE  = $4000;

const
  RSA1024BIT_KEY    = $4000000;

--  dwFlags definitions for CryptDeriveKey
const
  CRYPT_SERVER      = $0400;

const
  KEY_LENGTH_MASK   = $FFFF0000;

--  dwFlag definitions for CryptExportKey
const
  CRYPT_Y_ONLY      = $01;

const
  CRYPT_SSL2_FALLBACK= $02;

const
  CRYPT_DESTROYKEY  = $04;

const
  CRYPT_OAEP        = $40;

--  CryptExportKey, CryptImportKey,
--  CryptEncrypt and CryptDecrypt
const
  CRYPT_BLOB_VER3   = $80;

const
  CRYPT_IPSEC_HMAC_KEY= $0100;

--  dwFlags definitions for CryptDecrypt
--  See also CRYPT_OAEP, above.
--  Note, the following flag is not supported for CryptEncrypt
const
  CRYPT_DECRYPT_RSA_NO_PADDING_CHECK= $20;

--  dwFlags definitions for CryptCreateHash
const
  CRYPT_SECRETDIGEST= $01;

--  dwFlags definitions for CryptHashData
const
  CRYPT_OWF_REPL_LM_HASH= $01;

--  dwFlags definitions for CryptHashSessionKey
const
  CRYPT_LITTLE_ENDIAN= $01;

--  dwFlags definitions for CryptSignHash and CryptVerifySignature
const
  CRYPT_NOHASHOID   = $01;

const
  CRYPT_TYPE2_FORMAT= $02;

const
  CRYPT_X931_FORMAT = $04;

--  dwFlag definitions for CryptSetProviderEx and CryptGetDefaultProvider
const
  CRYPT_MACHINE_DEFAULT= $01;

const
  CRYPT_USER_DEFAULT= $02;

const
  CRYPT_DELETE_DEFAULT= $04;

--  exported key blob definitions
const
  SIMPLEBLOB        = $01;

const
  PUBLICKEYBLOB     = $06;

const
  PRIVATEKEYBLOB    = $07;

const
  PLAINTEXTKEYBLOB  = $08;

const
  OPAQUEKEYBLOB     = $09;

const
  PUBLICKEYBLOBEX   = $0A;

const
  SYMMETRICWRAPKEYBLOB= $0B;

const
  AT_KEYEXCHANGE    = 1;

const
  AT_SIGNATURE      = 2;

const
  CRYPT_USERDATA    = 1;

--  dwParam
const
  KP_IV             = 1;

const
  KP_SALT           = 2;

const
  KP_PADDING        = 3;

const
  KP_MODE           = 4;

const
  KP_MODE_BITS      = 5;

const
  KP_PERMISSIONS    = 6;

const
  KP_ALGID          = 7;

const
  KP_BLOCKLEN       = 8;

const
  KP_KEYLEN         = 9;

const
  KP_SALT_EX        = 10;

const
  KP_P              = 11;

const
  KP_G              = 12;

const
  KP_Q              = 13;

const
  KP_X              = 14;

const
  KP_Y              = 15;

const
  KP_RA             = 16;

const
  KP_RB             = 17;

const
  KP_INFO           = 18;

const
  KP_EFFECTIVE_KEYLEN= 19;

const
  KP_SCHANNEL_ALG   = 20;

const
  KP_CLIENT_RANDOM  = 21;

const
  KP_SERVER_RANDOM  = 22;

const
  KP_RP             = 23;

const
  KP_PRECOMP_MD5    = 24;

const
  KP_PRECOMP_SHA    = 25;

const
  KP_CERTIFICATE    = 26;

const
  KP_CLEAR_KEY      = 27;

const
  KP_PUB_EX_LEN     = 28;

const
  KP_PUB_EX_VAL     = 29;

const
  KP_KEYVAL         = 30;

const
  KP_ADMIN_PIN      = 31;

const
  KP_KEYEXCHANGE_PIN= 32;

const
  KP_SIGNATURE_PIN  = 33;

const
  KP_PREHASH        = 34;

const
  KP_ROUNDS         = 35;

const
  KP_OAEP_PARAMS    = 36;

const
  KP_CMS_KEY_INFO   = 37;

const
  KP_CMS_DH_KEY_INFO= 38;

const
  KP_PUB_PARAMS     = 39;

const
  KP_VERIFY_PARAMS  = 40;

const
  KP_HIGHEST_VERSION= 41;

const
  KP_GET_USE_COUNT  = 42;

--  KP_PADDING
const
  PKCS5_PADDING     = 1;

const
  RANDOM_PADDING    = 2;

const
  ZERO_PADDING      = 3;

--  KP_MODE
const
  CRYPT_MODE_CBC    = 1;

const
  CRYPT_MODE_ECB    = 2;

const
  CRYPT_MODE_OFB    = 3;

const
  CRYPT_MODE_CFB    = 4;

const
  CRYPT_MODE_CTS    = 5;

--  KP_PERMISSIONS
const
  CRYPT_ENCRYPT     = $01;

const
  CRYPT_DECRYPT     = $02;

const
  CRYPT_EXPORT      = $04;

const
  CRYPT_READ        = $08;

const
  CRYPT_WRITE       = $10;

const
  CRYPT_MAC         = $20;

const
  CRYPT_EXPORT_KEY  = $40;

const
  CRYPT_IMPORT_KEY  = $80;

const
  CRYPT_ARCHIVE     = $0100;

const
  HP_ALGID          = $01;

const
  HP_HASHVAL        = $02;

const
  HP_HASHSIZE       = $04;

const
  HP_HMAC_INFO      = $05;

const
  HP_TLS1PRF_LABEL  = $06;

const
  HP_TLS1PRF_SEED   = $07;

-- 
--  CryptGetProvParam
-- 
const
  PP_ENUMALGS       = 1;

const
  PP_ENUMCONTAINERS = 2;

const
  PP_IMPTYPE        = 3;

const
  PP_NAME           = 4;

const
  PP_VERSION        = 5;

const
  PP_CONTAINER      = 6;

const
  PP_CHANGE_PASSWORD= 7;

const
  PP_KEYSET_SEC_DESCR= 8;

const
  PP_CERTCHAIN      = 9;

const
  PP_KEY_TYPE_SUBTYPE= 10;

const
  PP_PROVTYPE       = 16;

const
  PP_KEYSTORAGE     = 17;

const
  PP_APPLI_CERT     = 18;

const
  PP_SYM_KEYSIZE    = 19;

const
  PP_SESSION_KEYSIZE= 20;

const
  PP_UI_PROMPT      = 21;

const
  PP_ENUMALGS_EX    = 22;

const
  PP_ENUMMANDROOTS  = 25;

const
  PP_ENUMELECTROOTS = 26;

const
  PP_KEYSET_TYPE    = 27;

const
  PP_ADMIN_PIN      = 31;

const
  PP_KEYEXCHANGE_PIN= 32;

const
  PP_SIGNATURE_PIN  = 33;

const
  PP_SIG_KEYSIZE_INC= 34;

const
  PP_KEYX_KEYSIZE_INC= 35;

const
  PP_UNIQUE_CONTAINER= 36;

const
  PP_SGC_INFO       = 37;

const
  PP_USE_HARDWARE_RNG= 38;

const
  PP_KEYSPEC        = 39;

const
  PP_ENUMEX_SIGNING_PROT= 40;

const
  PP_CRYPT_COUNT_KEY_USE= 41;

const
  CRYPT_FIRST       = 1;

const
  CRYPT_NEXT        = 2;

const
  CRYPT_SGC_ENUM    = 4;

const
  CRYPT_IMPL_HARDWARE= 1;

const
  CRYPT_IMPL_SOFTWARE= 2;

const
  CRYPT_IMPL_MIXED  = 3;

const
  CRYPT_IMPL_UNKNOWN= 4;

const
  CRYPT_IMPL_REMOVABLE= 8;

--  key storage flags
const
  CRYPT_SEC_DESCR   = $01;

const
  CRYPT_PSTORE      = $02;

const
  CRYPT_UI_PROMPT   = $04;

--  protocol flags
const
  CRYPT_FLAG_PCT1   = $01;

const
  CRYPT_FLAG_SSL2   = $02;

const
  CRYPT_FLAG_SSL3   = $04;

const
  CRYPT_FLAG_TLS1   = $08;

const
  CRYPT_FLAG_IPSEC  = $10;

const
  CRYPT_FLAG_SIGNING= $20;

--  SGC flags
const
  CRYPT_SGC         = $01;

const
  CRYPT_FASTSGC     = $02;

-- 
--  CryptSetProvParam
-- 
const
  PP_CLIENT_HWND    = 1;

const
  PP_CONTEXT_INFO   = 11;

const
  PP_KEYEXCHANGE_KEYSIZE= 12;

const
  PP_SIGNATURE_KEYSIZE= 13;

const
  PP_KEYEXCHANGE_ALG= 14;

const
  PP_SIGNATURE_ALG  = 15;

const
  PP_DELETEKEY      = 24;

const
  PROV_RSA_FULL     = 1;

const
  PROV_RSA_SIG      = 2;

const
  PROV_DSS          = 3;

const
  PROV_FORTEZZA     = 4;

const
  PROV_MS_EXCHANGE  = 5;

const
  PROV_SSL          = 6;

const
  PROV_RSA_SCHANNEL = 12;

const
  PROV_DSS_DH       = 13;

const
  PROV_EC_ECDSA_SIG = 14;

const
  PROV_EC_ECNRA_SIG = 15;

const
  PROV_EC_ECDSA_FULL= 16;

const
  PROV_EC_ECNRA_FULL= 17;

const
  PROV_DH_SCHANNEL  = 18;

const
  PROV_SPYRUS_LYNKS = 20;

const
  PROV_RNG          = 21;

const
  PROV_INTEL_SEC    = 22;

const
  PROV_REPLACE_OWF  = 23;

const
  PROV_RSA_AES      = 24;

-- 
--  Provider friendly names
-- 
#if #declared UNICODE; then;
#template MS_DEF_PROV;
  L 'Microsoft Base Cryptographic Provider v1.0'
#end MS_DEF_PROV;
#else;
#template MS_DEF_PROV;
  'Microsoft Base Cryptographic Provider v1.0'
#end MS_DEF_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_ENHANCED_PROV;
  L 'Microsoft Enhanced Cryptographic Provider v1.0'
#end MS_ENHANCED_PROV;
#else;
#template MS_ENHANCED_PROV;
  'Microsoft Enhanced Cryptographic Provider v1.0'
#end MS_ENHANCED_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_STRONG_PROV;
  L 'Microsoft Strong Cryptographic Provider'
#end MS_STRONG_PROV;
#else;
#template MS_STRONG_PROV;
  'Microsoft Strong Cryptographic Provider'
#end MS_STRONG_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_DEF_RSA_SIG_PROV;
  L 'Microsoft RSA Signature Cryptographic Provider'
#end MS_DEF_RSA_SIG_PROV;
#else;
#template MS_DEF_RSA_SIG_PROV;
  'Microsoft RSA Signature Cryptographic Provider'
#end MS_DEF_RSA_SIG_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_DEF_RSA_SCHANNEL_PROV;
  L 'Microsoft RSA SChannel Cryptographic Provider'
#end MS_DEF_RSA_SCHANNEL_PROV;
#else;
#template MS_DEF_RSA_SCHANNEL_PROV;
  'Microsoft RSA SChannel Cryptographic Provider'
#end MS_DEF_RSA_SCHANNEL_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_DEF_DSS_PROV;
  L 'Microsoft Base DSS Cryptographic Provider'
#end MS_DEF_DSS_PROV;
#else;
#template MS_DEF_DSS_PROV;
  'Microsoft Base DSS Cryptographic Provider'
#end MS_DEF_DSS_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_DEF_DSS_DH_PROV;
  L 'Microsoft Base DSS and Diffie-Hellman Cryptographic Provider'
#end MS_DEF_DSS_DH_PROV;
#else;
#template MS_DEF_DSS_DH_PROV;
  'Microsoft Base DSS and Diffie-Hellman Cryptographic Provider'
#end MS_DEF_DSS_DH_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_ENH_DSS_DH_PROV;
  L 'Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider'
#end MS_ENH_DSS_DH_PROV;
#else;
#template MS_ENH_DSS_DH_PROV;
  'Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider'
#end MS_ENH_DSS_DH_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_DEF_DH_SCHANNEL_PROV;
  L 'Microsoft DH SChannel Cryptographic Provider'
#end MS_DEF_DH_SCHANNEL_PROV;
#else;
#template MS_DEF_DH_SCHANNEL_PROV;
  'Microsoft DH SChannel Cryptographic Provider'
#end MS_DEF_DH_SCHANNEL_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_SCARD_PROV;
  L 'Microsoft Base Smart Card Crypto Provider'
#end MS_SCARD_PROV;
#else;
#template MS_SCARD_PROV;
  'Microsoft Base Smart Card Crypto Provider'
#end MS_SCARD_PROV;
#end if;

#if #declared UNICODE; then;
#template MS_ENH_RSA_AES_PROV;
  L 'Microsoft Enhanced RSA and AES Cryptographic Provider'
#end MS_ENH_RSA_AES_PROV;
#else;
#template MS_ENH_RSA_AES_PROV;
  'Microsoft Enhanced RSA and AES Cryptographic Provider'
#end MS_ENH_RSA_AES_PROV;
#end if;

const
  MAXUIDLEN         = 64;

--  Exponentiation Offload Reg Location
-- 
--  Registry key in which the following private key-related
--  values are created.
-- 
-- 
--  Registry value for controlling Data Protection API (DPAPI) UI settings.
-- 
const
  dwFORCE_KEY_PROTECTION_DISABLED= $00;

const
  dwFORCE_KEY_PROTECTION_USER_SELECT= $01;

const
  dwFORCE_KEY_PROTECTION_HIGH= $02;

-- 
--  Registry values for enabling and controlling the caching (and timeout)
--  of private keys. This feature is useful only for UI-protected private
--  keys.
-- 
--  Note that in Windows 2000 and later, private keys, once read from storage,
--  are cached in the associated HCRYPTPROV structure for subsequent use.
-- 
--  In Server 2003 and XP SP1, new key caching behavior is available. Keys
--  that have been read from storage and cached may now be considered "stale"
--  if a period of time has elapsed since the key was last used. This forces
--  the key to be re-read from storage (which will make the DPAPI UI appear 
--  again).
-- 
--  To enable the new behavior, create the registry DWORD value 
--  szKEY_CACHE_ENABLED and set it to 1. The registry DWORD value
--  szKEY_CACHE_SECONDS must also be created and set to the number of seconds
--  that a cached private key may still be considered usable. 
-- 
const
  CUR_BLOB_VERSION  = 2;

--  structure for use with CryptSetKeyParam for CMS keys
--  DO NOT USE THIS STRUCTURE!!!!!
type
  _CMS_KEY_INFO     = record
dwVersion       : DWORD;
Algid           : ALG_ID;
pbOID           : ^BYTE;
cbOID           : DWORD;
  end record;
  CMS_KEY_INFO      = _CMS_KEY_INFO;
  PCMS_KEY_INFO     = ^_CMS_KEY_INFO;

--  structure for use with CryptSetHashParam with CALG_HMAC
type
  _HMAC_Info        = record
HashAlgid       : ALG_ID;
pbInnerString   : ^BYTE;
cbInnerString   : DWORD;
pbOuterString   : ^BYTE;
cbOuterString   : DWORD;
  end record;
  HMAC_INFO         = _HMAC_Info;
  PHMAC_INFO        = ^_HMAC_Info;

--  structure for use with CryptSetKeyParam with KP_SCHANNEL_ALG
type
  _SCHANNEL_ALG     = record
dwUse           : DWORD;
Algid           : ALG_ID;
cBits           : DWORD;
dwFlags         : DWORD;
dwReserved      : DWORD;
  end record;
  SCHANNEL_ALG      = _SCHANNEL_ALG;
  PSCHANNEL_ALG     = ^_SCHANNEL_ALG;

--  uses of algortihms for SCHANNEL_ALG structure
const
  SCHANNEL_MAC_KEY  = $00;

const
  SCHANNEL_ENC_KEY  = $01;

--  uses of dwFlags SCHANNEL_ALG structure
const
  INTERNATIONAL_USAGE= $01;

type
  _PROV_ENUMALGS    = record
aiAlgid         : ALG_ID;
dwBitLen        : DWORD;
dwNameLen       : DWORD;
szName          : array 0..19 of CHAR;
  end record;
  PROV_ENUMALGS     = _PROV_ENUMALGS;

type
  _PROV_ENUMALGS_EX = record
aiAlgid         : ALG_ID;
dwDefaultLen    : DWORD;
dwMinLen        : DWORD;
dwMaxLen        : DWORD;
dwProtocols     : DWORD;
dwNameLen       : DWORD;
szName          : array 0..19 of CHAR;
dwLongNameLen   : DWORD;
szLongName      : array 0..39 of CHAR;
  end record;
  PROV_ENUMALGS_EX  = _PROV_ENUMALGS_EX;

type
  _PUBLICKEYSTRUC   = record
bType           : BYTE;
bVersion        : BYTE;
reserved        : WORD;
aiKeyAlg        : ALG_ID;
  end record;
  BLOBHEADER        = _PUBLICKEYSTRUC;
  PUBLICKEYSTRUC    = _PUBLICKEYSTRUC;

type
  _RSAPUBKEY        = record
magic           : DWORD;
bitlen          : DWORD;
pubexp          : DWORD;
  end record;
  RSAPUBKEY         = _RSAPUBKEY;

type
  _PUBKEY           = record
magic           : DWORD;
bitlen          : DWORD;
  end record;
  DHPUBKEY          = _PUBKEY;
  DSSPUBKEY         = _PUBKEY;
  KEAPUBKEY         = _PUBKEY;
  TEKPUBKEY         = _PUBKEY;

type
  _DSSSEED          = record
counter         : DWORD;
seed            : array 0..19 of BYTE;
  end record;
  t_DSSSEED         = _DSSSEED;

type
  _PUBKEYVER3       = record
magic           : DWORD;
bitlenP         : DWORD;
bitlenQ         : DWORD;
bitlenJ         : DWORD;
DSSSeed         : t_DSSSEED;
  end record;
  DHPUBKEY_VER3     = _PUBKEYVER3;
  DSSPUBKEY_VER3    = _PUBKEYVER3;

type
  _PRIVKEYVER3      = record
magic           : DWORD;
bitlenP         : DWORD;
bitlenQ         : DWORD;
bitlenJ         : DWORD;
bitlenX         : DWORD;
DSSSeed         : t_DSSSEED;
  end record;
  DHPRIVKEY_VER3    = _PRIVKEYVER3;
  DSSPRIVKEY_VER3   = _PRIVKEYVER3;

type
  _KEY_TYPE_SUBTYPE = record
dwKeySpec       : DWORD;
_Type           : t_GUID;
Subtype         : t_GUID;
  end record;
  KEY_TYPE_SUBTYPE  = _KEY_TYPE_SUBTYPE;
  PKEY_TYPE_SUBTYPE = ^_KEY_TYPE_SUBTYPE;

type
  _CERT_FORTEZZA_DATA_PROP = record
SerialNumber    : array 0..7 of character 8;
CertIndex       : signed 32;
CertLabel       : array 0..35 of character 8;
  end record;
  CERT_FORTEZZA_DATA_PROP = _CERT_FORTEZZA_DATA_PROP;

-- +-------------------------------------------------------------------------
--  CRYPTOAPI BLOB definitions
-- --------------------------------------------------------------------------
type
  _CRYPTOAPI_BLOB   = record
cbData          : DWORD;
pbData          : ^BYTE;
  end record;
  CRYPT_INTEGER_BLOB = _CRYPTOAPI_BLOB;
  PCRYPT_INTEGER_BLOB = ^_CRYPTOAPI_BLOB;
  CRYPT_UINT_BLOB   = _CRYPTOAPI_BLOB;
  PCRYPT_UINT_BLOB  = ^_CRYPTOAPI_BLOB;
  CRYPT_OBJID_BLOB  = _CRYPTOAPI_BLOB;
  PCRYPT_OBJID_BLOB = ^_CRYPTOAPI_BLOB;
  CERT_NAME_BLOB    = _CRYPTOAPI_BLOB;
  PCERT_NAME_BLOB   = ^_CRYPTOAPI_BLOB;
  CERT_RDN_VALUE_BLOB = _CRYPTOAPI_BLOB;
  PCERT_RDN_VALUE_BLOB = ^_CRYPTOAPI_BLOB;
  CERT_BLOB         = _CRYPTOAPI_BLOB;
  PCERT_BLOB        = ^_CRYPTOAPI_BLOB;
  CRL_BLOB          = _CRYPTOAPI_BLOB;
  PCRL_BLOB         = ^_CRYPTOAPI_BLOB;
  DATA_BLOB         = _CRYPTOAPI_BLOB;
  PDATA_BLOB        = ^_CRYPTOAPI_BLOB;
  CRYPT_DATA_BLOB   = _CRYPTOAPI_BLOB;
  PCRYPT_DATA_BLOB  = ^_CRYPTOAPI_BLOB;
  CRYPT_HASH_BLOB   = _CRYPTOAPI_BLOB;
  PCRYPT_HASH_BLOB  = ^_CRYPTOAPI_BLOB;
  CRYPT_DIGEST_BLOB = _CRYPTOAPI_BLOB;
  PCRYPT_DIGEST_BLOB = ^_CRYPTOAPI_BLOB;
  CRYPT_DER_BLOB    = _CRYPTOAPI_BLOB;
  PCRYPT_DER_BLOB   = ^_CRYPTOAPI_BLOB;
  CRYPT_ATTR_BLOB   = _CRYPTOAPI_BLOB;
  PCRYPT_ATTR_BLOB  = ^_CRYPTOAPI_BLOB;

--  structure for use with CryptSetKeyParam for CMS keys
type
  _CMS_DH_KEY_INFO  = record
dwVersion       : DWORD;
Algid           : ALG_ID;
pszContentEncObjId : LPSTR;
PubInfo         : CRYPT_DATA_BLOB;
pReserved       : ^unchecked;
  end record;
  CMS_DH_KEY_INFO   = _CMS_DH_KEY_INFO;
  PCMS_DH_KEY_INFO  = ^_CMS_DH_KEY_INFO;

type
t_001=^t_HCRYPTPROV for machine_pointer use true;

procedure CryptAcquireContextA(
    phProv          : t_001; 
    szContainer     : LPCSTR; 
    szProvider      : LPCSTR; 
    dwProvType      : DWORD; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptAcquireContextA,system);
#pragma import(CryptAcquireContextA,'CryptAcquireContextA','advapi32.dll');

type
t_002=^t_HCRYPTPROV for machine_pointer use true;

procedure CryptAcquireContextW(
    phProv          : t_002; 
    szContainer     : LPCWSTR; 
    szProvider      : LPCWSTR; 
    dwProvType      : DWORD; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptAcquireContextW,system);
#pragma import(CryptAcquireContextW,'CryptAcquireContextW','advapi32.dll');

#if #declared UNICODE; then;
#template CryptAcquireContext;
  CryptAcquireContextW 
#end CryptAcquireContext;
#else;
#template CryptAcquireContext;
  CryptAcquireContextA 
#end CryptAcquireContext;
#end if;

procedure CryptReleaseContext(
    hProv           : t_HCRYPTPROV; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptReleaseContext,system);
#pragma import(CryptReleaseContext,'CryptReleaseContext','advapi32.dll');

type
t_003=^HCRYPTKEY for machine_pointer use true;

procedure CryptGenKey(
    hProv           : t_HCRYPTPROV; 
    Algid           : ALG_ID; 
    dwFlags         : DWORD; 
    phKey           : t_003)
                      return BOOL;
#pragma convention(CryptGenKey,system);
#pragma import(CryptGenKey,'CryptGenKey','advapi32.dll');

type
t_004=^HCRYPTKEY for machine_pointer use true;

procedure CryptDeriveKey(
    hProv           : t_HCRYPTPROV; 
    Algid           : ALG_ID; 
    hBaseData       : HCRYPTHASH; 
    dwFlags         : DWORD; 
    phKey           : t_004)
                      return BOOL;
#pragma convention(CryptDeriveKey,system);
#pragma import(CryptDeriveKey,'CryptDeriveKey','advapi32.dll');

procedure CryptDestroyKey(
    hKey            : HCRYPTKEY)
                      return BOOL;
#pragma convention(CryptDestroyKey,system);
#pragma import(CryptDestroyKey,'CryptDestroyKey','advapi32.dll');

type
t_005=^BYTE for machine_pointer use true;

procedure CryptSetKeyParam(
    hKey            : HCRYPTKEY; 
    dwParam         : DWORD; 
    pbData          : in t_005; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptSetKeyParam,system);
#pragma import(CryptSetKeyParam,'CryptSetKeyParam','advapi32.dll');

type
t_006=^BYTE for machine_pointer use true;

t_007=^DWORD for machine_pointer use true;

procedure CryptGetKeyParam(
    hKey            : HCRYPTKEY; 
    dwParam         : DWORD; 
    pbData          : t_006; 
    pdwDataLen      : t_007; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptGetKeyParam,system);
#pragma import(CryptGetKeyParam,'CryptGetKeyParam','advapi32.dll');

type
t_008=^BYTE for machine_pointer use true;

procedure CryptSetHashParam(
    hHash           : HCRYPTHASH; 
    dwParam         : DWORD; 
    pbData          : in t_008; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptSetHashParam,system);
#pragma import(CryptSetHashParam,'CryptSetHashParam','advapi32.dll');

type
t_009=^BYTE for machine_pointer use true;

t_010=^DWORD for machine_pointer use true;

procedure CryptGetHashParam(
    hHash           : HCRYPTHASH; 
    dwParam         : DWORD; 
    pbData          : t_009; 
    pdwDataLen      : t_010; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptGetHashParam,system);
#pragma import(CryptGetHashParam,'CryptGetHashParam','advapi32.dll');

type
t_011=^BYTE for machine_pointer use true;

procedure CryptSetProvParam(
    hProv           : t_HCRYPTPROV; 
    dwParam         : DWORD; 
    pbData          : in t_011; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptSetProvParam,system);
#pragma import(CryptSetProvParam,'CryptSetProvParam','advapi32.dll');

type
t_012=^BYTE for machine_pointer use true;

t_013=^DWORD for machine_pointer use true;

procedure CryptGetProvParam(
    hProv           : t_HCRYPTPROV; 
    dwParam         : DWORD; 
    pbData          : t_012; 
    pdwDataLen      : t_013; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptGetProvParam,system);
#pragma import(CryptGetProvParam,'CryptGetProvParam','advapi32.dll');

type
t_014=^BYTE for machine_pointer use true;

procedure CryptGenRandom(
    hProv           : t_HCRYPTPROV; 
    dwLen           : DWORD; 
    pbBuffer        : t_014)
                      return BOOL;
#pragma convention(CryptGenRandom,system);
#pragma import(CryptGenRandom,'CryptGenRandom','advapi32.dll');

type
t_015=^HCRYPTKEY for machine_pointer use true;

procedure CryptGetUserKey(
    hProv           : t_HCRYPTPROV; 
    dwKeySpec       : DWORD; 
    phUserKey       : t_015)
                      return BOOL;
#pragma convention(CryptGetUserKey,system);
#pragma import(CryptGetUserKey,'CryptGetUserKey','advapi32.dll');

type
t_016=^BYTE for machine_pointer use true;

t_017=^DWORD for machine_pointer use true;

procedure CryptExportKey(
    hKey            : HCRYPTKEY; 
    hExpKey         : HCRYPTKEY; 
    dwBlobType      : DWORD; 
    dwFlags         : DWORD; 
    pbData          : t_016; 
    pdwDataLen      : t_017)
                      return BOOL;
#pragma convention(CryptExportKey,system);
#pragma import(CryptExportKey,'CryptExportKey','advapi32.dll');

type
t_018=^BYTE for machine_pointer use true;

t_019=^HCRYPTKEY for machine_pointer use true;

procedure CryptImportKey(
    hProv           : t_HCRYPTPROV; 
    pbData          : in t_018; 
    dwDataLen       : DWORD; 
    hPubKey         : HCRYPTKEY; 
    dwFlags         : DWORD; 
    phKey           : t_019)
                      return BOOL;
#pragma convention(CryptImportKey,system);
#pragma import(CryptImportKey,'CryptImportKey','advapi32.dll');

type
t_020=^BYTE for machine_pointer use true;

t_021=^DWORD for machine_pointer use true;

procedure CryptEncrypt(
    hKey            : HCRYPTKEY; 
    hHash           : HCRYPTHASH; 
    Final           : BOOL; 
    dwFlags         : DWORD; 
    pbData          : t_020; 
    pdwDataLen      : t_021; 
    dwBufLen        : DWORD)
                      return BOOL;
#pragma convention(CryptEncrypt,system);
#pragma import(CryptEncrypt,'CryptEncrypt','advapi32.dll');

type
t_022=^BYTE for machine_pointer use true;

t_023=^DWORD for machine_pointer use true;

procedure CryptDecrypt(
    hKey            : HCRYPTKEY; 
    hHash           : HCRYPTHASH; 
    Final           : BOOL; 
    dwFlags         : DWORD; 
    pbData          : t_022; 
    pdwDataLen      : t_023)
                      return BOOL;
#pragma convention(CryptDecrypt,system);
#pragma import(CryptDecrypt,'CryptDecrypt','advapi32.dll');

type
t_024=^HCRYPTHASH for machine_pointer use true;

procedure CryptCreateHash(
    hProv           : t_HCRYPTPROV; 
    Algid           : ALG_ID; 
    hKey            : HCRYPTKEY; 
    dwFlags         : DWORD; 
    phHash          : t_024)
                      return BOOL;
#pragma convention(CryptCreateHash,system);
#pragma import(CryptCreateHash,'CryptCreateHash','advapi32.dll');

type
t_025=^BYTE for machine_pointer use true;

procedure CryptHashData(
    hHash           : HCRYPTHASH; 
    pbData          : in t_025; 
    dwDataLen       : DWORD; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptHashData,system);
#pragma import(CryptHashData,'CryptHashData','advapi32.dll');

procedure CryptHashSessionKey(
    hHash           : HCRYPTHASH; 
    hKey            : HCRYPTKEY; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptHashSessionKey,system);
#pragma import(CryptHashSessionKey,'CryptHashSessionKey','advapi32.dll');

procedure CryptDestroyHash(
    hHash           : HCRYPTHASH)
                      return BOOL;
#pragma convention(CryptDestroyHash,system);
#pragma import(CryptDestroyHash,'CryptDestroyHash','advapi32.dll');

type
t_026=^BYTE for machine_pointer use true;

t_027=^DWORD for machine_pointer use true;

procedure CryptSignHashA(
    hHash           : HCRYPTHASH; 
    dwKeySpec       : DWORD; 
    szDescription   : LPCSTR; 
    dwFlags         : DWORD; 
    pbSignature     : t_026; 
    pdwSigLen       : t_027)
                      return BOOL;
#pragma convention(CryptSignHashA,system);
#pragma import(CryptSignHashA,'CryptSignHashA','advapi32.dll');

type
t_028=^BYTE for machine_pointer use true;

t_029=^DWORD for machine_pointer use true;

procedure CryptSignHashW(
    hHash           : HCRYPTHASH; 
    dwKeySpec       : DWORD; 
    szDescription   : LPCWSTR; 
    dwFlags         : DWORD; 
    pbSignature     : t_028; 
    pdwSigLen       : t_029)
                      return BOOL;
#pragma convention(CryptSignHashW,system);
#pragma import(CryptSignHashW,'CryptSignHashW','advapi32.dll');

#if #declared UNICODE; then;
#template CryptSignHash;
  CryptSignHashW 
#end CryptSignHash;
#else;
#template CryptSignHash;
  CryptSignHashA 
#end CryptSignHash;
#end if;

type
t_030=^BYTE for machine_pointer use true;

procedure CryptVerifySignatureA(
    hHash           : HCRYPTHASH; 
    pbSignature     : in t_030; 
    dwSigLen        : DWORD; 
    hPubKey         : HCRYPTKEY; 
    szDescription   : LPCSTR; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptVerifySignatureA,system);
#pragma import(CryptVerifySignatureA,'CryptVerifySignatureA','advapi32.dll');

type
t_031=^BYTE for machine_pointer use true;

procedure CryptVerifySignatureW(
    hHash           : HCRYPTHASH; 
    pbSignature     : in t_031; 
    dwSigLen        : DWORD; 
    hPubKey         : HCRYPTKEY; 
    szDescription   : LPCWSTR; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptVerifySignatureW,system);
#pragma import(CryptVerifySignatureW,'CryptVerifySignatureW','advapi32.dll');

#if #declared UNICODE; then;
#template CryptVerifySignature;
  CryptVerifySignatureW 
#end CryptVerifySignature;
#else;
#template CryptVerifySignature;
  CryptVerifySignatureA 
#end CryptVerifySignature;
#end if;

procedure CryptSetProviderA(
    pszProvName     : LPCSTR; 
    dwProvType      : DWORD)
                      return BOOL;
#pragma convention(CryptSetProviderA,system);
#pragma import(CryptSetProviderA,'CryptSetProviderA','advapi32.dll');

procedure CryptSetProviderW(
    pszProvName     : LPCWSTR; 
    dwProvType      : DWORD)
                      return BOOL;
#pragma convention(CryptSetProviderW,system);
#pragma import(CryptSetProviderW,'CryptSetProviderW','advapi32.dll');

#if #declared UNICODE; then;
#template CryptSetProvider;
  CryptSetProviderW 
#end CryptSetProvider;
#else;
#template CryptSetProvider;
  CryptSetProviderA 
#end CryptSetProvider;
#end if;

type
t_032=^DWORD for machine_pointer use true;

procedure CryptSetProviderExA(
    pszProvName     : LPCSTR; 
    dwProvType      : DWORD; 
    pdwReserved     : t_032; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptSetProviderExA,system);
#pragma import(CryptSetProviderExA,'CryptSetProviderExA','advapi32.dll');

type
t_033=^DWORD for machine_pointer use true;

procedure CryptSetProviderExW(
    pszProvName     : LPCWSTR; 
    dwProvType      : DWORD; 
    pdwReserved     : t_033; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptSetProviderExW,system);
#pragma import(CryptSetProviderExW,'CryptSetProviderExW','advapi32.dll');

#if #declared UNICODE; then;
#template CryptSetProviderEx;
  CryptSetProviderExW 
#end CryptSetProviderEx;
#else;
#template CryptSetProviderEx;
  CryptSetProviderExA 
#end CryptSetProviderEx;
#end if;

type
t_034=^DWORD for machine_pointer use true;

t_035=^DWORD for machine_pointer use true;

procedure CryptGetDefaultProviderA(
    dwProvType      : DWORD; 
    pdwReserved     : t_034; 
    dwFlags         : DWORD; 
    pszProvName     : LPSTR; 
    pcbProvName     : t_035)
                      return BOOL;
#pragma convention(CryptGetDefaultProviderA,system);
#pragma import(CryptGetDefaultProviderA,'CryptGetDefaultProviderA','advapi32.dll');

type
t_036=^DWORD for machine_pointer use true;

t_037=^DWORD for machine_pointer use true;

procedure CryptGetDefaultProviderW(
    dwProvType      : DWORD; 
    pdwReserved     : t_036; 
    dwFlags         : DWORD; 
    pszProvName     : LPWSTR; 
    pcbProvName     : t_037)
                      return BOOL;
#pragma convention(CryptGetDefaultProviderW,system);
#pragma import(CryptGetDefaultProviderW,'CryptGetDefaultProviderW','advapi32.dll');

#if #declared UNICODE; then;
#template CryptGetDefaultProvider;
  CryptGetDefaultProviderW 
#end CryptGetDefaultProvider;
#else;
#template CryptGetDefaultProvider;
  CryptGetDefaultProviderA 
#end CryptGetDefaultProvider;
#end if;

type
t_038=^DWORD for machine_pointer use true;

t_039=^DWORD for machine_pointer use true;

t_040=^DWORD for machine_pointer use true;

procedure CryptEnumProviderTypesA(
    dwIndex         : DWORD; 
    pdwReserved     : t_038; 
    dwFlags         : DWORD; 
    pdwProvType     : t_039; 
    szTypeName      : LPSTR; 
    pcbTypeName     : t_040)
                      return BOOL;
#pragma convention(CryptEnumProviderTypesA,system);
#pragma import(CryptEnumProviderTypesA,'CryptEnumProviderTypesA','advapi32.dll');

type
t_041=^DWORD for machine_pointer use true;

t_042=^DWORD for machine_pointer use true;

t_043=^DWORD for machine_pointer use true;

procedure CryptEnumProviderTypesW(
    dwIndex         : DWORD; 
    pdwReserved     : t_041; 
    dwFlags         : DWORD; 
    pdwProvType     : t_042; 
    szTypeName      : LPWSTR; 
    pcbTypeName     : t_043)
                      return BOOL;
#pragma convention(CryptEnumProviderTypesW,system);
#pragma import(CryptEnumProviderTypesW,'CryptEnumProviderTypesW','advapi32.dll');

#if #declared UNICODE; then;
#template CryptEnumProviderTypes;
  CryptEnumProviderTypesW 
#end CryptEnumProviderTypes;
#else;
#template CryptEnumProviderTypes;
  CryptEnumProviderTypesA 
#end CryptEnumProviderTypes;
#end if;

type
t_044=^DWORD for machine_pointer use true;

t_045=^DWORD for machine_pointer use true;

t_046=^DWORD for machine_pointer use true;

procedure CryptEnumProvidersA(
    dwIndex         : DWORD; 
    pdwReserved     : t_044; 
    dwFlags         : DWORD; 
    pdwProvType     : t_045; 
    szProvName      : LPSTR; 
    pcbProvName     : t_046)
                      return BOOL;
#pragma convention(CryptEnumProvidersA,system);
#pragma import(CryptEnumProvidersA,'CryptEnumProvidersA','advapi32.dll');

type
t_047=^DWORD for machine_pointer use true;

t_048=^DWORD for machine_pointer use true;

t_049=^DWORD for machine_pointer use true;

procedure CryptEnumProvidersW(
    dwIndex         : DWORD; 
    pdwReserved     : t_047; 
    dwFlags         : DWORD; 
    pdwProvType     : t_048; 
    szProvName      : LPWSTR; 
    pcbProvName     : t_049)
                      return BOOL;
#pragma convention(CryptEnumProvidersW,system);
#pragma import(CryptEnumProvidersW,'CryptEnumProvidersW','advapi32.dll');

#if #declared UNICODE; then;
#template CryptEnumProviders;
  CryptEnumProvidersW 
#end CryptEnumProviders;
#else;
#template CryptEnumProviders;
  CryptEnumProvidersA 
#end CryptEnumProviders;
#end if;

type
t_050=^DWORD for machine_pointer use true;

procedure CryptContextAddRef(
    hProv           : t_HCRYPTPROV; 
    pdwReserved     : t_050; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CryptContextAddRef,system);
#pragma import(CryptContextAddRef,'CryptContextAddRef','advapi32.dll');

type
t_051=^DWORD for machine_pointer use true;

t_052=^HCRYPTKEY for machine_pointer use true;

procedure CryptDuplicateKey(
    hKey            : HCRYPTKEY; 
    pdwReserved     : t_051; 
    dwFlags         : DWORD; 
    phKey           : t_052)
                      return BOOL;
#pragma convention(CryptDuplicateKey,system);
#pragma import(CryptDuplicateKey,'CryptDuplicateKey','advapi32.dll');

type
t_053=^DWORD for machine_pointer use true;

t_054=^HCRYPTHASH for machine_pointer use true;

procedure CryptDuplicateHash(
    hHash           : HCRYPTHASH; 
    pdwReserved     : t_053; 
    dwFlags         : DWORD; 
    phHash          : t_054)
                      return BOOL;
#pragma convention(CryptDuplicateHash,system);
#pragma import(CryptDuplicateHash,'CryptDuplicateHash','advapi32.dll');

-- 
--  This function is provided in Microsoft Windows 2000 as a means of 
--  installing the 128-bit encryption provider. This function is unavailable 
--  in Microsoft Windows XP, because Windows XP ships with the 128-bit 
--  encryption provider.
-- 
-- +-------------------------------------------------------------------------
--  In a CRYPT_BIT_BLOB the last byte may contain 0-7 unused bits. Therefore, the
--  overall bit length is cbData * 8 - cUnusedBits.
-- --------------------------------------------------------------------------
type
  _CRYPT_BIT_BLOB   = record
cbData          : DWORD;
pbData          : ^BYTE;
cUnusedBits     : DWORD;
  end record;
  CRYPT_BIT_BLOB    = _CRYPT_BIT_BLOB;
  PCRYPT_BIT_BLOB   = ^_CRYPT_BIT_BLOB;

-- +-------------------------------------------------------------------------
--  Type used for any algorithm
-- 
--  Where the Parameters CRYPT_OBJID_BLOB is in its encoded representation. For most
--  algorithm types, the Parameters CRYPT_OBJID_BLOB is NULL (Parameters.cbData = 0).
-- --------------------------------------------------------------------------
type
  _CRYPT_ALGORITHM_IDENTIFIER = record
pszObjId        : LPSTR;
Parameters      : CRYPT_OBJID_BLOB;
  end record;
  CRYPT_ALGORITHM_IDENTIFIER = _CRYPT_ALGORITHM_IDENTIFIER;
  PCRYPT_ALGORITHM_IDENTIFIER = ^_CRYPT_ALGORITHM_IDENTIFIER;

--  Following are the definitions of various algorithm object identifiers
--  RSA
--  ITU-T UsefulDefinitions
--  NIST OSE Implementors' Workshop (OIW)
--  http://nemo.ncsl.nist.gov/oiw/agreements/stable/OSI/12s_9506.w51
--  http://nemo.ncsl.nist.gov/oiw/agreements/working/OSI/12w_9503.w51
--  NIST OSE Implementors' Workshop (OIW) Security SIG algorithm identifiers
--  NIST OSE Implementors' Workshop (OIW) Directory SIG algorithm identifiers
--  INFOSEC Algorithms
--  joint-iso-ccitt(2) country(16) us(840) organization(1) us-government(101) dod(2) id-infosec(1)
type
  _CRYPT_OBJID_TABLE = record
dwAlgId         : DWORD;
pszObjId        : LPCSTR;
  end record;
  CRYPT_OBJID_TABLE = _CRYPT_OBJID_TABLE;
  PCRYPT_OBJID_TABLE = ^_CRYPT_OBJID_TABLE;

-- +-------------------------------------------------------------------------
--  PKCS #1 HashInfo (DigestInfo)
-- --------------------------------------------------------------------------
type
  _CRYPT_HASH_INFO  = record
HashAlgorithm   : CRYPT_ALGORITHM_IDENTIFIER;
Hash            : CRYPT_HASH_BLOB;
  end record;
  CRYPT_HASH_INFO   = _CRYPT_HASH_INFO;
  PCRYPT_HASH_INFO  = ^_CRYPT_HASH_INFO;

-- +-------------------------------------------------------------------------
--  Type used for an extension to an encoded content
-- 
--  Where the Value's CRYPT_OBJID_BLOB is in its encoded representation.
-- --------------------------------------------------------------------------
type
  _CERT_EXTENSION   = record
pszObjId        : LPSTR;
fCritical       : BOOL;
Value           : CRYPT_OBJID_BLOB;
  end record;
  CERT_EXTENSION    = _CERT_EXTENSION;
  PCERT_EXTENSION   = ^_CERT_EXTENSION;

-- +-------------------------------------------------------------------------
--  AttributeTypeValue
-- 
--  Where the Value's CRYPT_OBJID_BLOB is in its encoded representation.
-- --------------------------------------------------------------------------
type
  _CRYPT_ATTRIBUTE_TYPE_VALUE = record
pszObjId        : LPSTR;
Value           : CRYPT_OBJID_BLOB;
  end record;
  CRYPT_ATTRIBUTE_TYPE_VALUE = _CRYPT_ATTRIBUTE_TYPE_VALUE;
  PCRYPT_ATTRIBUTE_TYPE_VALUE = ^_CRYPT_ATTRIBUTE_TYPE_VALUE;

-- +-------------------------------------------------------------------------
--  Attributes
-- 
--  Where the Value's PATTR_BLOBs are in their encoded representation.
-- --------------------------------------------------------------------------
type
  _CRYPT_ATTRIBUTE  = record
pszObjId        : LPSTR;
cValue          : DWORD;
rgValue         : PCRYPT_ATTR_BLOB;
  end record;
  CRYPT_ATTRIBUTE   = _CRYPT_ATTRIBUTE;
  PCRYPT_ATTRIBUTE  = ^_CRYPT_ATTRIBUTE;

type
  _CRYPT_ATTRIBUTES = record
cAttr           : DWORD;
rgAttr          : PCRYPT_ATTRIBUTE;
  end record;
  CRYPT_ATTRIBUTES  = _CRYPT_ATTRIBUTES;
  PCRYPT_ATTRIBUTES = ^_CRYPT_ATTRIBUTES;

-- +-------------------------------------------------------------------------
--  Attributes making up a Relative Distinguished Name (CERT_RDN)
-- 
--  The interpretation of the Value depends on the dwValueType.
--  See below for a list of the types.
-- --------------------------------------------------------------------------
type
  _CERT_RDN_ATTR    = record
pszObjId        : LPSTR;
dwValueType     : DWORD;
Value           : CERT_RDN_VALUE_BLOB;
  end record;
  CERT_RDN_ATTR     = _CERT_RDN_ATTR;
  PCERT_RDN_ATTR    = ^_CERT_RDN_ATTR;

-- +-------------------------------------------------------------------------
--  CERT_RDN attribute Object Identifiers
-- --------------------------------------------------------------------------
--  Labeling attribute types:
--  Geographic attribute types:
--  Organizational attribute types:
--  Explanatory attribute types:
--  Postal addressing attribute types:
--  Telecommunications addressing attribute types:
--  Preference attribute types:
--  OSI application attribute types:
--  Relational application attribute types:
--  Security attribute types:
--  Undocumented attribute types???
-- #define szOID_??? "2.5.4.41"
--  The DN Qualifier attribute type specifies disambiguating information to add
--  to the relative distinguished name of an entry. It is intended to be used
--  for entries held in multiple DSAs which would otherwise have the same name,
--  and that its value be the same in a given DSA for all entries to which
--  the information has been added.
--  Pilot user attribute types:
--  used for PKCS 12 attributes
-- +-------------------------------------------------------------------------
--  Microsoft CERT_RDN attribute Object Identifiers
-- --------------------------------------------------------------------------
--  Special RDN containing the KEY_ID. Its value type is CERT_RDN_OCTET_STRING.
-- +-------------------------------------------------------------------------
--  CERT_RDN Attribute Value Types
-- 
--  For RDN_ENCODED_BLOB, the Value's CERT_RDN_VALUE_BLOB is in its encoded
--  representation. Otherwise, its an array of bytes.
-- 
--  For all CERT_RDN types, Value.cbData is always the number of bytes, not
--  necessarily the number of elements in the string. For instance,
--  RDN_UNIVERSAL_STRING is an array of ints (cbData == intCnt * 4) and
--  RDN_BMP_STRING is an array of unsigned shorts (cbData == ushortCnt * 2).
-- 
--  A RDN_UTF8_STRING is an array of UNICODE characters (cbData == charCnt *2).
--  These UNICODE characters are encoded as UTF8 8 bit characters.
-- 
--  For CertDecodeName, two 0 bytes are always appended to the end of the
--  string (ensures a CHAR or WCHAR string is null terminated).
--  These added 0 bytes are't included in the BLOB.cbData.
-- --------------------------------------------------------------------------
const
  CERT_RDN_ANY_TYPE = 0;

const
  CERT_RDN_ENCODED_BLOB= 1;

const
  CERT_RDN_OCTET_STRING= 2;

const
  CERT_RDN_NUMERIC_STRING= 3;

const
  CERT_RDN_PRINTABLE_STRING= 4;

const
  CERT_RDN_TELETEX_STRING= 5;

const
  CERT_RDN_T61_STRING= 5;

const
  CERT_RDN_VIDEOTEX_STRING= 6;

const
  CERT_RDN_IA5_STRING= 7;

const
  CERT_RDN_GRAPHIC_STRING= 8;

const
  CERT_RDN_VISIBLE_STRING= 9;

const
  CERT_RDN_ISO646_STRING= 9;

const
  CERT_RDN_GENERAL_STRING= 10;

const
  CERT_RDN_UNIVERSAL_STRING= 11;

const
  CERT_RDN_INT4_STRING= 11;

const
  CERT_RDN_BMP_STRING= 12;

const
  CERT_RDN_UNICODE_STRING= 12;

const
  CERT_RDN_UTF8_STRING= 13;

const
  CERT_RDN_TYPE_MASK= $FF;

const
  CERT_RDN_FLAGS_MASK= $FF000000;

-- +-------------------------------------------------------------------------
--  Flags that can be or'ed with the above Value Type when encoding/decoding
-- --------------------------------------------------------------------------
--  For encoding: when set, CERT_RDN_T61_STRING is selected instead of
--  CERT_RDN_UNICODE_STRING if all the unicode characters are <= 0xFF
const
  CERT_RDN_ENABLE_T61_UNICODE_FLAG= $80000000;

--  For encoding: when set, CERT_RDN_UTF8_STRING is selected instead of
--  CERT_RDN_UNICODE_STRING.
const
  CERT_RDN_ENABLE_UTF8_UNICODE_FLAG= $20000000;

--  For encoding: when set, the characters aren't checked to see if they
--  are valid for the Value Type.
const
  CERT_RDN_DISABLE_CHECK_TYPE_FLAG= $40000000;

--  For decoding: by default, CERT_RDN_T61_STRING values are initially decoded
--  as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
--  Setting this flag skips the initial attempt to decode as UTF8.
const
  CERT_RDN_DISABLE_IE4_UTF8_FLAG= $1000000;

--  Macro to check that the dwValueType is a character string and not an
--  encoded blob or octet string
-- +-------------------------------------------------------------------------
--  A CERT_RDN consists of an array of the above attributes
-- --------------------------------------------------------------------------
type
  _CERT_RDN         = record
cRDNAttr        : DWORD;
rgRDNAttr       : PCERT_RDN_ATTR;
  end record;
  CERT_RDN          = _CERT_RDN;
  PCERT_RDN         = ^_CERT_RDN;

-- +-------------------------------------------------------------------------
--  Information stored in a subject's or issuer's name. The information
--  is represented as an array of the above RDNs.
-- --------------------------------------------------------------------------
type
  _CERT_NAME_INFO   = record
cRDN            : DWORD;
rgRDN           : PCERT_RDN;
  end record;
  CERT_NAME_INFO    = _CERT_NAME_INFO;
  PCERT_NAME_INFO   = ^_CERT_NAME_INFO;

-- +-------------------------------------------------------------------------
--  Name attribute value without the Object Identifier
-- 
--  The interpretation of the Value depends on the dwValueType.
--  See above for a list of the types.
-- --------------------------------------------------------------------------
type
  _CERT_NAME_VALUE  = record
dwValueType     : DWORD;
Value           : CERT_RDN_VALUE_BLOB;
  end record;
  CERT_NAME_VALUE   = _CERT_NAME_VALUE;
  PCERT_NAME_VALUE  = ^_CERT_NAME_VALUE;

-- +-------------------------------------------------------------------------
--  Public Key Info
-- 
--  The PublicKey is the encoded representation of the information as it is
--  stored in the bit string
-- --------------------------------------------------------------------------
type
  _CERT_PUBLIC_KEY_INFO = record
Algorithm       : CRYPT_ALGORITHM_IDENTIFIER;
PublicKey       : CRYPT_BIT_BLOB;
  end record;
  CERT_PUBLIC_KEY_INFO = _CERT_PUBLIC_KEY_INFO;
  PCERT_PUBLIC_KEY_INFO = ^_CERT_PUBLIC_KEY_INFO;

-- +-------------------------------------------------------------------------
--  structure that contains all the information in a PKCS#8 PrivateKeyInfo
-- --------------------------------------------------------------------------
type
  _CRYPT_PRIVATE_KEY_INFO = record
Version         : DWORD;
Algorithm       : CRYPT_ALGORITHM_IDENTIFIER;
PrivateKey      : CRYPT_DER_BLOB;
pAttributes     : PCRYPT_ATTRIBUTES;
  end record;
  CRYPT_PRIVATE_KEY_INFO = _CRYPT_PRIVATE_KEY_INFO;
  PCRYPT_PRIVATE_KEY_INFO = ^_CRYPT_PRIVATE_KEY_INFO;

-- +-------------------------------------------------------------------------
--  structure that contains all the information in a PKCS#8
--  EncryptedPrivateKeyInfo
-- --------------------------------------------------------------------------
type
  _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = record
EncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
EncryptedPrivateKey : CRYPT_DATA_BLOB;
  end record;
  CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO;
  PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO = ^_CRYPT_ENCRYPTED_PRIVATE_KEY_INFO;

-- +-------------------------------------------------------------------------
--  this callback is given when an EncryptedProvateKeyInfo structure is
--  encountered during ImportPKCS8. the caller is then expected to decrypt
--  the private key and hand back the decrypted contents.
-- 
--  the parameters are:
--  Algorithm - the algorithm used to encrypt the PrivateKeyInfo
--  EncryptedPrivateKey - the encrypted private key blob
--  pClearTextKey - a buffer to receive the clear text
--  cbClearTextKey - the number of bytes of the pClearTextKey buffer
--  note the if this is zero then this should be
--  filled in with the size required to decrypt the
--  key into, and pClearTextKey should be ignored
--  pVoidDecryptFunc - this is the pVoid that was passed into the call
--  and is preserved and passed back as context
-- +-------------------------------------------------------------------------
type
t_057=^BYTE for machine_pointer use true;
t_058=^DWORD for machine_pointer use true;

PCRYPT_DECRYPT_PRIVATE_KEY_FUNC = ^procedure (
    Algorithm       : CRYPT_ALGORITHM_IDENTIFIER;
    EncryptedPrivateKey : CRYPT_DATA_BLOB;
    pbClearTextKey  : t_057;
    pcbClearTextKey : t_058;
    pVoidDecryptFunc : LPVOID)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  this callback is given when creating a PKCS8 EncryptedPrivateKeyInfo.
--  The caller is then expected to encrypt the private key and hand back
--  the encrypted contents.
-- 
--  the parameters are:
--  Algorithm - the algorithm used to encrypt the PrivateKeyInfo
--  pClearTextPrivateKey - the cleartext private key to be encrypted
--  pbEncryptedKey - the output encrypted private key blob
--  cbEncryptedKey - the number of bytes of the pbEncryptedKey buffer
--  note the if this is zero then this should be
--  filled in with the size required to encrypt the
--  key into, and pbEncryptedKey should be ignored
--  pVoidEncryptFunc - this is the pVoid that was passed into the call
--  and is preserved and passed back as context
-- +-------------------------------------------------------------------------
type
t_059=^CRYPT_ALGORITHM_IDENTIFIER for machine_pointer use true;
t_060=^CRYPT_DATA_BLOB for machine_pointer use true;
t_061=^BYTE for machine_pointer use true;
t_062=^DWORD for machine_pointer use true;

PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC = ^procedure (
    pAlgorithm      : t_059;
    pClearTextPrivateKey : t_060;
    pbEncryptedKey  : t_061;
    pcbEncryptedKey : t_062;
    pVoidEncryptFunc : LPVOID)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  this callback is given from the context of a ImportPKCS8 calls. the caller
--  is then expected to hand back an HCRYPTPROV to receive the key being imported
-- 
--  the parameters are:
--  pPrivateKeyInfo - pointer to a CRYPT_PRIVATE_KEY_INFO structure which
--  describes the key being imported
--  EncryptedPrivateKey - the encrypted private key blob
--  phCryptProv - a pointer to a HCRRYPTPROV to be filled in
--  pVoidResolveFunc - this is the pVoidResolveFunc passed in by the caller in the
--  CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS struct
-- +-------------------------------------------------------------------------
type
t_063=^CRYPT_PRIVATE_KEY_INFO for machine_pointer use true;
t_064=^t_HCRYPTPROV for machine_pointer use true;

PCRYPT_RESOLVE_HCRYPTPROV_FUNC = ^procedure (
    pPrivateKeyInfo : t_063;
    phCryptProv     : t_064;
    pVoidResolveFunc : LPVOID)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  this struct contains a PKCS8 private key and two pointers to callback
--  functions, with a corresponding pVoids. the first callback is used to give
--  the caller the opportunity to specify where the key is imported to. the callback
--  passes the caller the algoroithm OID and key size to use in making the decision.
--  the other callback is used to decrypt the private key if the PKCS8 contains an
--  EncryptedPrivateKeyInfo. both pVoids are preserved and passed back to the caller
--  in the respective callback
-- +-------------------------------------------------------------------------
type
  _CRYPT_PKCS8_IMPORT_PARAMS = record
PrivateKey      : CRYPT_DIGEST_BLOB;
pResolvehCryptProvFunc : PCRYPT_RESOLVE_HCRYPTPROV_FUNC;
pVoidResolveFunc : LPVOID;
pDecryptPrivateKeyFunc : PCRYPT_DECRYPT_PRIVATE_KEY_FUNC;
pVoidDecryptFunc : LPVOID;
  end record;
  CRYPT_PKCS8_IMPORT_PARAMS = _CRYPT_PKCS8_IMPORT_PARAMS;
  PCRYPT_PKCS8_IMPORT_PARAMS = ^_CRYPT_PKCS8_IMPORT_PARAMS;
  CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = _CRYPT_PKCS8_IMPORT_PARAMS;
  PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = ^_CRYPT_PKCS8_IMPORT_PARAMS;

-- +-------------------------------------------------------------------------
--  this struct contains information identifying a private key and a pointer
--  to a callback function, with a corresponding pVoid. The callback is used
--  to encrypt the private key. If the pEncryptPrivateKeyFunc is NULL, the
--  key will not be encrypted and an EncryptedPrivateKeyInfo will not be generated.
--  The pVoid is preserved and passed back to the caller in the respective callback
-- +-------------------------------------------------------------------------
type
  _CRYPT_PKCS8_EXPORT_PARAMS = record
hCryptProv      : t_HCRYPTPROV;
dwKeySpec       : DWORD;
pszPrivateKeyObjId : LPSTR;
pEncryptPrivateKeyFunc : PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC;
pVoidEncryptFunc : LPVOID;
  end record;
  CRYPT_PKCS8_EXPORT_PARAMS = _CRYPT_PKCS8_EXPORT_PARAMS;
  PCRYPT_PKCS8_EXPORT_PARAMS = ^_CRYPT_PKCS8_EXPORT_PARAMS;

-- +-------------------------------------------------------------------------
--  Information stored in a certificate
-- 
--  The Issuer, Subject, Algorithm, PublicKey and Extension BLOBs are the
--  encoded representation of the information.
-- --------------------------------------------------------------------------
type
  _CERT_INFO        = record
dwVersion       : DWORD;
SerialNumber    : CRYPT_INTEGER_BLOB;
SignatureAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
Issuer          : CERT_NAME_BLOB;
NotBefore       : t_FILETIME;
NotAfter        : t_FILETIME;
Subject         : CERT_NAME_BLOB;
SubjectPublicKeyInfo : CERT_PUBLIC_KEY_INFO;
IssuerUniqueId  : CRYPT_BIT_BLOB;
SubjectUniqueId : CRYPT_BIT_BLOB;
cExtension      : DWORD;
rgExtension     : PCERT_EXTENSION;
  end record;
  CERT_INFO         = _CERT_INFO;
  PCERT_INFO        = ^_CERT_INFO;

-- +-------------------------------------------------------------------------
--  Certificate versions
-- --------------------------------------------------------------------------
const
  CERT_V1           = 0;

const
  CERT_V2           = 1;

const
  CERT_V3           = 2;

-- +-------------------------------------------------------------------------
--  Certificate Information Flags
-- --------------------------------------------------------------------------
const
  CERT_INFO_VERSION_FLAG= 1;

const
  CERT_INFO_SERIAL_NUMBER_FLAG= 2;

const
  CERT_INFO_SIGNATURE_ALGORITHM_FLAG= 3;

const
  CERT_INFO_ISSUER_FLAG= 4;

const
  CERT_INFO_NOT_BEFORE_FLAG= 5;

const
  CERT_INFO_NOT_AFTER_FLAG= 6;

const
  CERT_INFO_SUBJECT_FLAG= 7;

const
  CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG= 8;

const
  CERT_INFO_ISSUER_UNIQUE_ID_FLAG= 9;

const
  CERT_INFO_SUBJECT_UNIQUE_ID_FLAG= 10;

const
  CERT_INFO_EXTENSION_FLAG= 11;

-- +-------------------------------------------------------------------------
--  An entry in a CRL
-- 
--  The Extension BLOBs are the encoded representation of the information.
-- --------------------------------------------------------------------------
type
  _CRL_ENTRY        = record
SerialNumber    : CRYPT_INTEGER_BLOB;
RevocationDate  : t_FILETIME;
cExtension      : DWORD;
rgExtension     : PCERT_EXTENSION;
  end record;
  CRL_ENTRY         = _CRL_ENTRY;
  PCRL_ENTRY        = ^_CRL_ENTRY;

-- +-------------------------------------------------------------------------
--  Information stored in a CRL
-- 
--  The Issuer, Algorithm and Extension BLOBs are the encoded
--  representation of the information.
-- --------------------------------------------------------------------------
type
  _CRL_INFO         = record
dwVersion       : DWORD;
SignatureAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
Issuer          : CERT_NAME_BLOB;
ThisUpdate      : t_FILETIME;
NextUpdate      : t_FILETIME;
cCRLEntry       : DWORD;
rgCRLEntry      : PCRL_ENTRY;
cExtension      : DWORD;
rgExtension     : PCERT_EXTENSION;
  end record;
  CRL_INFO          = _CRL_INFO;
  PCRL_INFO         = ^_CRL_INFO;

-- +-------------------------------------------------------------------------
--  CRL versions
-- --------------------------------------------------------------------------
const
  CRL_V1            = 0;

const
  CRL_V2            = 1;

-- +-------------------------------------------------------------------------
--  Information stored in a certificate request
-- 
--  The Subject, Algorithm, PublicKey and Attribute BLOBs are the encoded
--  representation of the information.
-- --------------------------------------------------------------------------
type
  _CERT_REQUEST_INFO = record
dwVersion       : DWORD;
Subject         : CERT_NAME_BLOB;
SubjectPublicKeyInfo : CERT_PUBLIC_KEY_INFO;
cAttribute      : DWORD;
rgAttribute     : PCRYPT_ATTRIBUTE;
  end record;
  CERT_REQUEST_INFO = _CERT_REQUEST_INFO;
  PCERT_REQUEST_INFO = ^_CERT_REQUEST_INFO;

-- +-------------------------------------------------------------------------
--  Certificate Request versions
-- --------------------------------------------------------------------------
const
  CERT_REQUEST_V1   = 0;

-- +-------------------------------------------------------------------------
--  Information stored in Netscape's Keygen request
-- --------------------------------------------------------------------------
type
  _CERT_KEYGEN_REQUEST_INFO = record
dwVersion       : DWORD;
SubjectPublicKeyInfo : CERT_PUBLIC_KEY_INFO;
pwszChallengeString : LPWSTR;
  end record;
  CERT_KEYGEN_REQUEST_INFO = _CERT_KEYGEN_REQUEST_INFO;
  PCERT_KEYGEN_REQUEST_INFO = ^_CERT_KEYGEN_REQUEST_INFO;

const
  CERT_KEYGEN_REQUEST_V1= 0;

-- +-------------------------------------------------------------------------
--  Certificate, CRL, Certificate Request or Keygen Request Signed Content
-- 
--  The "to be signed" encoded content plus its signature. The ToBeSigned
--  is the encoded CERT_INFO, CRL_INFO, CERT_REQUEST_INFO or
--  CERT_KEYGEN_REQUEST_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_SIGNED_CONTENT_INFO = record
ToBeSigned      : CRYPT_DER_BLOB;
SignatureAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
Signature       : CRYPT_BIT_BLOB;
  end record;
  CERT_SIGNED_CONTENT_INFO = _CERT_SIGNED_CONTENT_INFO;
  PCERT_SIGNED_CONTENT_INFO = ^_CERT_SIGNED_CONTENT_INFO;

-- +-------------------------------------------------------------------------
--  Certificate Trust List (CTL)
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CTL Usage. Also used for EnhancedKeyUsage extension.
-- --------------------------------------------------------------------------
type
  _CTL_USAGE        = record
cUsageIdentifier : DWORD;
rgpszUsageIdentifier : ^LPSTR;
  end record;
  CTL_USAGE         = _CTL_USAGE;
  PCTL_USAGE        = ^_CTL_USAGE;
  CERT_ENHKEY_USAGE = _CTL_USAGE;
  PCERT_ENHKEY_USAGE = ^_CTL_USAGE;

-- +-------------------------------------------------------------------------
--  An entry in a CTL
-- --------------------------------------------------------------------------
type
  _CTL_ENTRY        = record
SubjectIdentifier : CRYPT_DATA_BLOB;
cAttribute      : DWORD;
rgAttribute     : PCRYPT_ATTRIBUTE;
  end record;
  CTL_ENTRY         = _CTL_ENTRY;
  PCTL_ENTRY        = ^_CTL_ENTRY;

-- +-------------------------------------------------------------------------
--  Information stored in a CTL
-- --------------------------------------------------------------------------
type
  _CTL_INFO         = record
dwVersion       : DWORD;
SubjectUsage    : CTL_USAGE;
ListIdentifier  : CRYPT_DATA_BLOB;
SequenceNumber  : CRYPT_INTEGER_BLOB;
ThisUpdate      : t_FILETIME;
NextUpdate      : t_FILETIME;
SubjectAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
cCTLEntry       : DWORD;
rgCTLEntry      : PCTL_ENTRY;
cExtension      : DWORD;
rgExtension     : PCERT_EXTENSION;
  end record;
  CTL_INFO          = _CTL_INFO;
  PCTL_INFO         = ^_CTL_INFO;

-- +-------------------------------------------------------------------------
--  CTL versions
-- --------------------------------------------------------------------------
const
  CTL_V1            = 0;

-- +-------------------------------------------------------------------------
--  TimeStamp Request
-- 
--  The pszTimeStamp is the OID for the Time type requested
--  The pszContentType is the Content Type OID for the content, usually DATA
--  The Content is a un-decoded blob
-- --------------------------------------------------------------------------
type
  _CRYPT_TIME_STAMP_REQUEST_INFO = record
pszTimeStampAlgorithm : LPSTR;
pszContentType  : LPSTR;
Content         : CRYPT_OBJID_BLOB;
cAttribute      : DWORD;
rgAttribute     : PCRYPT_ATTRIBUTE;
  end record;
  CRYPT_TIME_STAMP_REQUEST_INFO = _CRYPT_TIME_STAMP_REQUEST_INFO;
  PCRYPT_TIME_STAMP_REQUEST_INFO = ^_CRYPT_TIME_STAMP_REQUEST_INFO;

-- +-------------------------------------------------------------------------
--  Name Value Attribute
-- --------------------------------------------------------------------------
type
  _CRYPT_ENROLLMENT_NAME_VALUE_PAIR = record
pwszName        : LPWSTR;
pwszValue       : LPWSTR;
  end record;
  CRYPT_ENROLLMENT_NAME_VALUE_PAIR = _CRYPT_ENROLLMENT_NAME_VALUE_PAIR;
  PCRYPT_ENROLLMENT_NAME_VALUE_PAIR = ^_CRYPT_ENROLLMENT_NAME_VALUE_PAIR;

-- +-------------------------------------------------------------------------
--  CSP Provider
-- --------------------------------------------------------------------------
type
  _CRYPT_CSP_PROVIDER = record
dwKeySpec       : DWORD;
pwszProviderName : LPWSTR;
Signature       : CRYPT_BIT_BLOB;
  end record;
  CRYPT_CSP_PROVIDER = _CRYPT_CSP_PROVIDER;
  PCRYPT_CSP_PROVIDER = ^_CRYPT_CSP_PROVIDER;

-- +-------------------------------------------------------------------------
--  Certificate and Message encoding types
-- 
--  The encoding type is a DWORD containing both the certificate and message
--  encoding types. The certificate encoding type is stored in the LOWORD.
--  The message encoding type is stored in the HIWORD. Some functions or
--  structure fields require only one of the encoding types. The following
--  naming convention is used to indicate which encoding type(s) are
--  required:
--  dwEncodingType (both encoding types are required)
--  dwMsgAndCertEncodingType (both encoding types are required)
--  dwMsgEncodingType (only msg encoding type is required)
--  dwCertEncodingType (only cert encoding type is required)
-- 
--  Its always acceptable to specify both.
-- --------------------------------------------------------------------------
const
  CERT_ENCODING_TYPE_MASK= $FFFF;

const
  CMSG_ENCODING_TYPE_MASK= $FFFF0000;

const
  CRYPT_ASN_ENCODING= $01;

const
  CRYPT_NDR_ENCODING= $02;

const
  X509_ASN_ENCODING = $01;

const
  X509_NDR_ENCODING = $02;

const
  PKCS_7_ASN_ENCODING= $10000;

const
  PKCS_7_NDR_ENCODING= $20000;

-- +-------------------------------------------------------------------------
--  format the specified data structure according to the certificate
--  encoding type.
-- 
--  The default behavior of CryptFormatObject is to return single line
--  display of the encoded data, that is, each subfield will be concatenated with
--  a ", " on one line. If user prefers to display the data in multiple line,
--  set the flag CRYPT_FORMAT_STR_MULTI_LINE, that is, each subfield will be displayed
--  on a seperate line.
-- 
--  If there is no formatting routine installed or registered
--  for the lpszStructType, the hex dump of the encoded BLOB will be returned.
--  User can set the flag CRYPT_FORMAT_STR_NO_HEX to disable the hex dump.
-- --------------------------------------------------------------------------
type
t_065=^unchecked for machine_pointer use true;

t_066=^BYTE for machine_pointer use true;

t_067=^unchecked for machine_pointer use true;

procedure CryptFormatObject(
    dwCertEncodingType : in DWORD; 
    dwFormatType    : in DWORD; 
    dwFormatStrType : in DWORD; 
    pFormatStruct   : in t_065; 
    lpszStructType  : in LPCSTR; 
    pbEncoded       : in t_066; 
    cbEncoded       : in DWORD; 
    pbFormat        : out {!}t_067; 
    pcbFormat       : in out DWORD)
                      return BOOL;
#pragma convention(CryptFormatObject,system);
#pragma import(CryptFormatObject,'CryptFormatObject','crypt32.dll');

-- -------------------------------------------------------------------------
--  constants for dwFormatStrType of function CryptFormatObject
-- -------------------------------------------------------------------------
const
  CRYPT_FORMAT_STR_MULTI_LINE= $01;

const
  CRYPT_FORMAT_STR_NO_HEX= $10;

-- -------------------------------------------------------------------------
--  constants for dwFormatType of function CryptFormatObject
--  when format X509_NAME or X509_UNICODE_NAME
-- -------------------------------------------------------------------------
--  Just get the simple string
const
  CRYPT_FORMAT_SIMPLE= $01;

-- Put an attribute name infront of the attribute
-- such as "O=Microsoft,DN=xiaohs"
const
  CRYPT_FORMAT_X509 = $02;

-- Put an OID infront of the simple string, such as
-- "2.5.4.22=Microsoft,2.5.4.3=xiaohs"
const
  CRYPT_FORMAT_OID  = $04;

-- Put a ";" between each RDN. The default is ","
const
  CRYPT_FORMAT_RDN_SEMICOLON= $0100;

-- Put a "\n" between each RDN.
const
  CRYPT_FORMAT_RDN_CRLF= $0200;

-- Unquote the DN value, which is quoated by default va the following
-- rules: if the DN contains leading or trailing
-- white space or one of the following characters: ",", "+", "=",
-- """, "\n", "<", ">", "#" or ";". The quoting character is ".
-- If the DN Value contains a " it is double quoted ("").
const
  CRYPT_FORMAT_RDN_UNQUOTE= $0400;

-- reverse the order of the RDNs before converting to the string
const
  CRYPT_FORMAT_RDN_REVERSE= $0800;

-- -------------------------------------------------------------------------
--  contants dwFormatType of function CryptFormatObject when format a DN.:
-- 
--  The following three values are defined in the section above:
--  CRYPT_FORMAT_SIMPLE: Just a simple string
--  such as "Microsoft+xiaohs+NT"
--  CRYPT_FORMAT_X509 Put an attribute name infront of the attribute
--  such as "O=Microsoft+xiaohs+NT"
-- 
--  CRYPT_FORMAT_OID Put an OID infront of the simple string,
--  such as "2.5.4.22=Microsoft+xiaohs+NT"
-- 
--  Additional values are defined as following:
-- ----------------------------------------------------------------------------
-- Put a "," between each value. Default is "+"
const
  CRYPT_FORMAT_COMMA= $1000;

-- Put a ";" between each value
-- Put a "\n" between each value
-- +-------------------------------------------------------------------------
--  Encode / decode the specified data structure according to the certificate
--  encoding type.
-- 
--  See below for a list of the predefined data structures.
-- --------------------------------------------------------------------------
type
PFN_CRYPT_ALLOC   = ^procedure (
    cbSize          : in size_t)
                      return LPVOID for machine_pointer use true;
type
PFN_CRYPT_FREE    = ^procedure (
    pv              : in LPVOID) for machine_pointer use true;
type
  _CRYPT_ENCODE_PARA = record
cbSize          : DWORD;
pfnAlloc        : PFN_CRYPT_ALLOC;
pfnFree         : PFN_CRYPT_FREE;
  end record;
  CRYPT_ENCODE_PARA = _CRYPT_ENCODE_PARA;
  PCRYPT_ENCODE_PARA = ^_CRYPT_ENCODE_PARA;

type
t_068=^unchecked for machine_pointer use true;

t_069=^unchecked for machine_pointer use true;

procedure CryptEncodeObjectEx(
    dwCertEncodingType : in DWORD; 
    lpszStructType  : in LPCSTR; 
    pvStructInfo    : in t_068; 
    dwFlags         : in DWORD; 
    pEncodePara     : in {out optional} PCRYPT_ENCODE_PARA; 
    pvEncoded       : out {!}t_069; 
    pcbEncoded      : in out DWORD)
                      return BOOL;
#pragma convention(CryptEncodeObjectEx,system);
#pragma import(CryptEncodeObjectEx,'CryptEncodeObjectEx','crypt32.dll');

type
t_070=^unchecked for machine_pointer use true;

procedure CryptEncodeObject(
    dwCertEncodingType : in DWORD; 
    lpszStructType  : in LPCSTR; 
    pvStructInfo    : in t_070; 
    pbEncoded       : out BYTE; 
    pcbEncoded      : in out DWORD)
                      return BOOL;
#pragma convention(CryptEncodeObject,system);
#pragma import(CryptEncodeObject,'CryptEncodeObject','crypt32.dll');

--  By default the signature bytes are reversed. The following flag can
--  be set to inhibit the byte reversal.
-- 
--  This flag is applicable to
--  X509_CERT_TO_BE_SIGNED
const
  CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG= $08;

--  When the following flag is set the called encode function allocates
--  memory for the encoded bytes. A pointer to the allocated bytes
--  is returned in pvEncoded. If pEncodePara or pEncodePara->pfnAlloc is
--  NULL, then, LocalAlloc is called for the allocation and LocalFree must
--  be called to do the free. Otherwise, pEncodePara->pfnAlloc is called
--  for the allocation.
-- 
--  *pcbEncoded is ignored on input and updated with the length of the
--  allocated, encoded bytes.
-- 
--  If pfnAlloc is set, then, pfnFree should also be set.
const
  CRYPT_ENCODE_ALLOC_FLAG= $8000;

--  The following flag is applicable when encoding X509_UNICODE_NAME.
--  When set, CERT_RDN_T61_STRING is selected instead of
--  CERT_RDN_UNICODE_STRING if all the unicode characters are <= 0xFF
--  The following flag is applicable when encoding X509_UNICODE_NAME.
--  When set, CERT_RDN_UTF8_STRING is selected instead of
--  CERT_RDN_UNICODE_STRING.
--  The following flag is applicable when encoding X509_UNICODE_NAME,
--  X509_UNICODE_NAME_VALUE or X509_UNICODE_ANY_STRING.
--  When set, the characters aren't checked to see if they
--  are valid for the specified Value Type.
--  The following flag is applicable when encoding the PKCS_SORTED_CTL. This
--  flag should be set if the identifier for the TrustedSubjects is a hash,
--  such as, MD5 or SHA1.
const
  CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG= $10000;

type
  _CRYPT_DECODE_PARA = record
cbSize          : DWORD;
pfnAlloc        : PFN_CRYPT_ALLOC;
pfnFree         : PFN_CRYPT_FREE;
  end record;
  CRYPT_DECODE_PARA = _CRYPT_DECODE_PARA;
  PCRYPT_DECODE_PARA = ^_CRYPT_DECODE_PARA;

type
t_071=^BYTE for machine_pointer use true;

t_072=^unchecked for machine_pointer use true;

procedure CryptDecodeObjectEx(
    dwCertEncodingType : in DWORD; 
    lpszStructType  : in LPCSTR; 
    pbEncoded       : in t_071; 
    cbEncoded       : in DWORD; 
    dwFlags         : in DWORD; 
    pDecodePara     : in {out optional} PCRYPT_DECODE_PARA; 
    pvStructInfo    : out {out optional} {!}t_072; 
    pcbStructInfo   : in out DWORD)
                      return BOOL;
#pragma convention(CryptDecodeObjectEx,system);
#pragma import(CryptDecodeObjectEx,'CryptDecodeObjectEx','crypt32.dll');

type
t_073=^BYTE for machine_pointer use true;

t_074=^unchecked for machine_pointer use true;

procedure CryptDecodeObject(
    dwCertEncodingType : in DWORD; 
    lpszStructType  : in LPCSTR; 
    pbEncoded       : in t_073; 
    cbEncoded       : in DWORD; 
    dwFlags         : in DWORD; 
    pvStructInfo    : out {!}t_074; 
    pcbStructInfo   : in out DWORD)
                      return BOOL;
#pragma convention(CryptDecodeObject,system);
#pragma import(CryptDecodeObject,'CryptDecodeObject','crypt32.dll');

--  When the following flag is set the nocopy optimization is enabled.
--  This optimization where appropriate, updates the pvStructInfo fields
--  to point to content residing within pbEncoded instead of making a copy
--  of and appending to pvStructInfo.
-- 
--  Note, when set, pbEncoded can't be freed until pvStructInfo is freed.
const
  CRYPT_DECODE_NOCOPY_FLAG= $01;

--  For CryptDecodeObject(), by default the pbEncoded is the "to be signed"
--  plus its signature. Set the following flag, if pbEncoded points to only
--  the "to be signed".
-- 
--  This flag is applicable to
--  X509_CERT_TO_BE_SIGNED
--  X509_CERT_CRL_TO_BE_SIGNED
--  X509_CERT_REQUEST_TO_BE_SIGNED
--  X509_KEYGEN_REQUEST_TO_BE_SIGNED
const
  CRYPT_DECODE_TO_BE_SIGNED_FLAG= $02;

--  When the following flag is set, the OID strings are allocated in
--  crypt32.dll and shared instead of being copied into the returned
--  data structure. This flag may be set if crypt32.dll isn't unloaded
--  before the caller is unloaded.
const
  CRYPT_DECODE_SHARE_OID_STRING_FLAG= $04;

--  By default the signature bytes are reversed. The following flag can
--  be set to inhibit the byte reversal.
-- 
--  This flag is applicable to
--  X509_CERT_TO_BE_SIGNED
const
  CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG= $08;

--  When the following flag is set the called decode function allocates
--  memory for the decoded structure. A pointer to the allocated structure
--  is returned in pvStructInfo. If pDecodePara or pDecodePara->pfnAlloc is
--  NULL, then, LocalAlloc is called for the allocation and LocalFree must
--  be called to do the free. Otherwise, pDecodePara->pfnAlloc is called
--  for the allocation.
-- 
--  *pcbStructInfo is ignored on input and updated with the length of the
--  allocated, decoded structure.
-- 
--  This flag may also be set in the CryptDecodeObject API. Since
--  CryptDecodeObject doesn't take a pDecodePara, LocalAlloc is always
--  called for the allocation which must be freed by calling LocalFree.
const
  CRYPT_DECODE_ALLOC_FLAG= $8000;

--  The following flag is applicable when decoding X509_UNICODE_NAME,
--  X509_UNICODE_NAME_VALUE or X509_UNICODE_ANY_STRING.
--  By default, CERT_RDN_T61_STRING values are initially decoded
--  as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
--  Setting this flag skips the initial attempt to decode as UTF8.
-- +-------------------------------------------------------------------------
--  Predefined X509 certificate data structures that can be encoded / decoded.
-- --------------------------------------------------------------------------
const
  CRYPT_ENCODE_DECODE_NONE= 0;

-- +-------------------------------------------------------------------------
--  Predefined X509 certificate extension data structures that can be
--  encoded / decoded.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Additional predefined data structures that can be encoded / decoded.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Predefined primitive data structures that can be encoded / decoded.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  More predefined X509 certificate extension data structures that can be
--  encoded / decoded.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  data structures for private keys
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  certificate policy qualifier
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Diffie-Hellman Key Exchange
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X942 Diffie-Hellman
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  The following is the same as X509_BITS, except before encoding,
--  the bit length is decremented to exclude trailing zero bits.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X942 Diffie-Hellman Other Info
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Certificate Management Messages over CMS (CMC) Data Structures
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Certificate Template
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Predefined PKCS #7 data structures that can be encoded / decoded.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Predefined PKCS #7 data structures that can be encoded / decoded.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Predefined Software Publishing Credential (SPC) data structures that
--  can be encoded / decoded.
-- 
--  Predefined values: 2000 .. 2999
-- 
--  See spc.h for value and data structure definitions.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Extension Object Identifiers
-- --------------------------------------------------------------------------
--  szOID_CRL_NUMBER -- Base CRLs only. Monotonically increasing sequence
--  number for each CRL issued by a CA.
--  szOID_DELTA_CRL_INDICATOR -- Delta CRLs only. Marked critical.
--  Contains the minimum base CRL Number that can be used with a delta CRL.
--  szOID_FRESHEST_CRL -- Base CRLs only. Formatted identically to a CDP
--  extension that holds URLs to fetch the delta CRL.
--  Note on 1/1/2000 szOID_POLICY_MAPPINGS was changed from "2.5.29.5"
--  Microsoft PKCS10 Attributes
-- 
--  Extension contain certificate type
--  Internet Public Key Infrastructure (PKIX)
--  Microsoft extensions or attributes
--  Microsoft PKCS #7 ContentType Object Identifiers
--  Microsoft Sorted CTL Extension Object Identifier
--  serialized serial numbers for PRS
--  UPN principal name in SubjectAltName
--  Windows product update unauthenticated attribute
--  CryptUI
-- +-------------------------------------------------------------------------
--  Object Identifiers for use with Auto Enrollment
-- --------------------------------------------------------------------------
--  Extension contain certificate type
-- +-------------------------------------------------------------------------
--  Object Identifiers for use with the MS Certificate Server
-- --------------------------------------------------------------------------
--  szOID_CERTSRV_PREVIOUS_CERT_HASH -- Contains the sha1 hash of the previous
--  version of the CA certificate.
--  szOID_CRL_VIRTUAL_BASE -- Delta CRLs only. Contains the base CRL Number
--  of the corresponding base CRL.
--  szOID_CRL_NEXT_PUBLISH -- Contains the time when the next CRL is expected
--  to be published. This may be sooner than the CRL's NextUpdate field.
--  Enhanced Key Usage for CA encryption certificate
--  Enhanced Key Usage for key recovery agent certificate
--  Certificate template extension (v2)
--  The root oid for all enterprise specific oids
--  Dummy signing Subject RDN
--  Application Policies extension -- same encoding as szOID_CERT_POLICIES
--  Application Policy Mappings -- same encoding as szOID_POLICY_MAPPINGS
--  Application Policy Constraints -- same encoding as szOID_POLICY_CONSTRAINTS
--  Requires all certificates below the root to have a non-empty intersecting
--  issuance certificate policy usage.
--  Enhanced key usage for DS email replication
-- +-------------------------------------------------------------------------
--  Object Identifiers for use with the MS Directory Service
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Extension Object Identifiers (currently not implemented)
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Enhanced Key Usage (Purpose) Object Identifiers
-- --------------------------------------------------------------------------
--  Consistent key usage bits: DIGITAL_SIGNATURE, KEY_ENCIPHERMENT
--  or KEY_AGREEMENT
--  Consistent key usage bits: DIGITAL_SIGNATURE
--  Consistent key usage bits: DIGITAL_SIGNATURE
--  Consistent key usage bits: DIGITAL_SIGNATURE, NON_REPUDIATION and/or
--  (KEY_ENCIPHERMENT or KEY_AGREEMENT)
--  Consistent key usage bits: DIGITAL_SIGNATURE and/or
--  (KEY_ENCIPHERMENT or KEY_AGREEMENT)
--  Consistent key usage bits: DIGITAL_SIGNATURE and/or
--  (KEY_ENCIPHERMENT or KEY_AGREEMENT)
--  Consistent key usage bits: DIGITAL_SIGNATURE and/or
--  (KEY_ENCIPHERMENT or KEY_AGREEMENT)
--  Consistent key usage bits: DIGITAL_SIGNATURE or NON_REPUDIATION
--  IKE (Internet Key Exchange) Intermediate KP for an IPsec end entity.
--  Defined in draft-ietf-ipsec-pki-req-04.txt, December 14, 1999.
-- +-------------------------------------------------------------------------
--  Microsoft Enhanced Key Usage (Purpose) Object Identifiers
-- +-------------------------------------------------------------------------
--  Signer of CTLs
--  Signer of TimeStamps
--  Can use Windows Hardware Compatible (WHQL)
--  Signed by the NT5 build lab
--  Signed by and OEM of WHQL
--  Signed by the Embedded NT
--  Signer of a CTL containing trusted roots
--  Can sign cross-cert and subordinate CA requests with qualified
--  subordination (name constraints, policy mapping, etc.)
--  Can be used to encrypt/recover escrowed keys
--  Signer of documents
--  The default WinVerifyTrust Authenticode policy is to treat all time stamped
--  signatures as being valid forever. This OID limits the valid lifetime of the
--  signature to the lifetime of the certificate. This allows timestamped
--  signatures to expire. Normally this OID will be used in conjunction with
--  szOID_PKIX_KP_CODE_SIGNING to indicate new time stamp semantics should be
--  used. Support for this OID was added in WXP.
--  Microsoft DRM EKU
-- +-------------------------------------------------------------------------
--  Microsoft Attribute Object Identifiers
-- +-------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Qualifiers that may be part of the szOID_CERT_POLICIES and
--  szOID_CERT_POLICIES95 extensions
-- +-------------------------------------------------------------------------
--  OID for old qualifer
-- +-------------------------------------------------------------------------
--  X509_CERT
-- 
--  The "to be signed" encoded content plus its signature. The ToBeSigned
--  content is the CryptEncodeObject() output for one of the following:
--  X509_CERT_TO_BE_SIGNED, X509_CERT_CRL_TO_BE_SIGNED or
--  X509_CERT_REQUEST_TO_BE_SIGNED.
-- 
--  pvStructInfo points to CERT_SIGNED_CONTENT_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_CERT_TO_BE_SIGNED
-- 
--  pvStructInfo points to CERT_INFO.
-- 
--  For CryptDecodeObject(), the pbEncoded is the "to be signed" plus its
--  signature (output of a X509_CERT CryptEncodeObject()).
-- 
--  For CryptEncodeObject(), the pbEncoded is just the "to be signed".
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_CERT_CRL_TO_BE_SIGNED
-- 
--  pvStructInfo points to CRL_INFO.
-- 
--  For CryptDecodeObject(), the pbEncoded is the "to be signed" plus its
--  signature (output of a X509_CERT CryptEncodeObject()).
-- 
--  For CryptEncodeObject(), the pbEncoded is just the "to be signed".
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_CERT_REQUEST_TO_BE_SIGNED
-- 
--  pvStructInfo points to CERT_REQUEST_INFO.
-- 
--  For CryptDecodeObject(), the pbEncoded is the "to be signed" plus its
--  signature (output of a X509_CERT CryptEncodeObject()).
-- 
--  For CryptEncodeObject(), the pbEncoded is just the "to be signed".
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_EXTENSIONS
--  szOID_CERT_EXTENSIONS
-- 
--  pvStructInfo points to following CERT_EXTENSIONS.
-- --------------------------------------------------------------------------
type
  _CERT_EXTENSIONS  = record
cExtension      : DWORD;
rgExtension     : PCERT_EXTENSION;
  end record;
  CERT_EXTENSIONS   = _CERT_EXTENSIONS;
  PCERT_EXTENSIONS  = ^_CERT_EXTENSIONS;

-- +-------------------------------------------------------------------------
--  X509_NAME_VALUE
--  X509_ANY_STRING
-- 
--  pvStructInfo points to CERT_NAME_VALUE.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_UNICODE_NAME_VALUE
--  X509_UNICODE_ANY_STRING
-- 
--  pvStructInfo points to CERT_NAME_VALUE.
-- 
--  The name values are unicode strings.
-- 
--  For CryptEncodeObject:
--  Value.pbData points to the unicode string.
--  If Value.cbData = 0, then, the unicode string is NULL terminated.
--  Otherwise, Value.cbData is the unicode string byte count. The byte count
--  is twice the character count.
-- 
--  If the unicode string contains an invalid character for the specified
--  dwValueType, then, *pcbEncoded is updated with the unicode character
--  index of the first invalid character. LastError is set to:
--  CRYPT_E_INVALID_NUMERIC_STRING, CRYPT_E_INVALID_PRINTABLE_STRING or
--  CRYPT_E_INVALID_IA5_STRING.
-- 
--  To disable the above check, either set CERT_RDN_DISABLE_CHECK_TYPE_FLAG
--  in dwValueType or set CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG
--  in dwFlags passed to CryptEncodeObjectEx.
-- 
--  The unicode string is converted before being encoded according to
--  the specified dwValueType. If dwValueType is set to 0, LastError
--  is set to E_INVALIDARG.
-- 
--  If the dwValueType isn't one of the character strings (its a
--  CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING), then, CryptEncodeObject
--  will return FALSE with LastError set to CRYPT_E_NOT_CHAR_STRING.
-- 
--  For CryptDecodeObject:
--  Value.pbData points to a NULL terminated unicode string. Value.cbData
--  contains the byte count of the unicode string excluding the NULL
--  terminator. dwValueType contains the type used in the encoded object.
--  Its not forced to CERT_RDN_UNICODE_STRING. The encoded value is
--  converted to the unicode string according to the dwValueType.
-- 
--  If the encoded object isn't one of the character string types, then,
--  CryptDecodeObject will return FALSE with LastError set to
--  CRYPT_E_NOT_CHAR_STRING. For a non character string, decode using
--  X509_NAME_VALUE or X509_ANY_STRING.
-- 
--  By default, CERT_RDN_T61_STRING values are initially decoded
--  as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
--  Set CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG in dwFlags
--  passed to either CryptDecodeObject or CryptDecodeObjectEx to
--  skip the initial attempt to decode as UTF8.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_NAME
-- 
--  pvStructInfo points to CERT_NAME_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_UNICODE_NAME
-- 
--  pvStructInfo points to CERT_NAME_INFO.
-- 
--  The RDN attribute values are unicode strings except for the dwValueTypes of
--  CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING. These dwValueTypes are
--  the same as for a X509_NAME. Their values aren't converted to/from unicode.
-- 
--  For CryptEncodeObject:
--  Value.pbData points to the unicode string.
--  If Value.cbData = 0, then, the unicode string is NULL terminated.
--  Otherwise, Value.cbData is the unicode string byte count. The byte count
--  is twice the character count.
-- 
--  If dwValueType = 0 (CERT_RDN_ANY_TYPE), the pszObjId is used to find
--  an acceptable dwValueType. If the unicode string contains an
--  invalid character for the found or specified dwValueType, then,
--  *pcbEncoded is updated with the error location of the invalid character.
--  See below for details. LastError is set to:
--  CRYPT_E_INVALID_NUMERIC_STRING, CRYPT_E_INVALID_PRINTABLE_STRING or
--  CRYPT_E_INVALID_IA5_STRING.
-- 
--  To disable the above check, either set CERT_RDN_DISABLE_CHECK_TYPE_FLAG
--  in dwValueType or set CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG
--  in dwFlags passed to CryptEncodeObjectEx.
-- 
--  Set CERT_RDN_UNICODE_STRING in dwValueType or set
--  CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG in dwFlags passed
--  to CryptEncodeObjectEx to select CERT_RDN_T61_STRING instead of
--  CERT_RDN_UNICODE_STRING if all the unicode characters are <= 0xFF.
-- 
--  Set CERT_RDN_ENABLE_UTF8_UNICODE_STRING in dwValueType or set
--  CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG in dwFlags passed
--  to CryptEncodeObjectEx to select CERT_RDN_UTF8_STRING instead of
--  CERT_RDN_UNICODE_STRING.
-- 
--  The unicode string is converted before being encoded according to
--  the specified or ObjId matching dwValueType.
-- 
--  For CryptDecodeObject:
--  Value.pbData points to a NULL terminated unicode string. Value.cbData
--  contains the byte count of the unicode string excluding the NULL
--  terminator. dwValueType contains the type used in the encoded object.
--  Its not forced to CERT_RDN_UNICODE_STRING. The encoded value is
--  converted to the unicode string according to the dwValueType.
-- 
--  If the dwValueType of the encoded value isn't a character string
--  type, then, it isn't converted to UNICODE. Use the
--  IS_CERT_RDN_CHAR_STRING() macro on the dwValueType to check
--  that Value.pbData points to a converted unicode string.
-- 
--  By default, CERT_RDN_T61_STRING values are initially decoded
--  as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
--  Set CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG in dwFlags
--  passed to either CryptDecodeObject or CryptDecodeObjectEx to
--  skip the initial attempt to decode as UTF8.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Unicode Name Value Error Location Definitions
-- 
--  Error location is returned in *pcbEncoded by
--  CryptEncodeObject(X509_UNICODE_NAME)
-- 
--  Error location consists of:
--  RDN_INDEX - 10 bits << 22
--  ATTR_INDEX - 6 bits << 16
--  VALUE_INDEX - 16 bits (unicode character index)
-- --------------------------------------------------------------------------
const
  CERT_UNICODE_RDN_ERR_INDEX_MASK= $03FF;

const
  CERT_UNICODE_RDN_ERR_INDEX_SHIFT= 22;

const
  CERT_UNICODE_ATTR_ERR_INDEX_MASK= $3F;

const
  CERT_UNICODE_ATTR_ERR_INDEX_SHIFT= 16;

const
  CERT_UNICODE_VALUE_ERR_INDEX_MASK= $FFFF;

const
  CERT_UNICODE_VALUE_ERR_INDEX_SHIFT= 0;

-- +-------------------------------------------------------------------------
--  X509_PUBLIC_KEY_INFO
-- 
--  pvStructInfo points to CERT_PUBLIC_KEY_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_AUTHORITY_KEY_ID
--  szOID_AUTHORITY_KEY_IDENTIFIER
-- 
--  pvStructInfo points to following CERT_AUTHORITY_KEY_ID_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_AUTHORITY_KEY_ID_INFO = record
KeyId           : CRYPT_DATA_BLOB;
CertIssuer      : CERT_NAME_BLOB;
CertSerialNumber : CRYPT_INTEGER_BLOB;
  end record;
  CERT_AUTHORITY_KEY_ID_INFO = _CERT_AUTHORITY_KEY_ID_INFO;
  PCERT_AUTHORITY_KEY_ID_INFO = ^_CERT_AUTHORITY_KEY_ID_INFO;

-- +-------------------------------------------------------------------------
--  X509_KEY_ATTRIBUTES
--  szOID_KEY_ATTRIBUTES
-- 
--  pvStructInfo points to following CERT_KEY_ATTRIBUTES_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_PRIVATE_KEY_VALIDITY = record
NotBefore       : t_FILETIME;
NotAfter        : t_FILETIME;
  end record;
  CERT_PRIVATE_KEY_VALIDITY = _CERT_PRIVATE_KEY_VALIDITY;
  PCERT_PRIVATE_KEY_VALIDITY = ^_CERT_PRIVATE_KEY_VALIDITY;

type
  _CERT_KEY_ATTRIBUTES_INFO = record
KeyId           : CRYPT_DATA_BLOB;
IntendedKeyUsage : CRYPT_BIT_BLOB;
pPrivateKeyUsagePeriod : PCERT_PRIVATE_KEY_VALIDITY;
  end record;
  CERT_KEY_ATTRIBUTES_INFO = _CERT_KEY_ATTRIBUTES_INFO;
  PCERT_KEY_ATTRIBUTES_INFO = ^_CERT_KEY_ATTRIBUTES_INFO;

--  Byte[0]
const
  CERT_DIGITAL_SIGNATURE_KEY_USAGE= $80;

const
  CERT_NON_REPUDIATION_KEY_USAGE= $40;

const
  CERT_KEY_ENCIPHERMENT_KEY_USAGE= $20;

const
  CERT_DATA_ENCIPHERMENT_KEY_USAGE= $10;

const
  CERT_KEY_AGREEMENT_KEY_USAGE= $08;

const
  CERT_KEY_CERT_SIGN_KEY_USAGE= $04;

const
  CERT_OFFLINE_CRL_SIGN_KEY_USAGE= $02;

const
  CERT_CRL_SIGN_KEY_USAGE= $02;

const
  CERT_ENCIPHER_ONLY_KEY_USAGE= $01;

--  Byte[1]
const
  CERT_DECIPHER_ONLY_KEY_USAGE= $80;

-- +-------------------------------------------------------------------------
--  X509_KEY_USAGE_RESTRICTION
--  szOID_KEY_USAGE_RESTRICTION
-- 
--  pvStructInfo points to following CERT_KEY_USAGE_RESTRICTION_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_POLICY_ID   = record
cCertPolicyElementId : DWORD;
rgpszCertPolicyElementId : ^LPSTR;
  end record;
  CERT_POLICY_ID    = _CERT_POLICY_ID;
  PCERT_POLICY_ID   = ^_CERT_POLICY_ID;

type
  _CERT_KEY_USAGE_RESTRICTION_INFO = record
cCertPolicyId   : DWORD;
rgCertPolicyId  : PCERT_POLICY_ID;
RestrictedKeyUsage : CRYPT_BIT_BLOB;
  end record;
  CERT_KEY_USAGE_RESTRICTION_INFO = _CERT_KEY_USAGE_RESTRICTION_INFO;
  PCERT_KEY_USAGE_RESTRICTION_INFO = ^_CERT_KEY_USAGE_RESTRICTION_INFO;

--  See CERT_KEY_ATTRIBUTES_INFO for definition of the RestrictedKeyUsage bits
-- +-------------------------------------------------------------------------
--  X509_ALTERNATE_NAME
--  szOID_SUBJECT_ALT_NAME
--  szOID_ISSUER_ALT_NAME
--  szOID_SUBJECT_ALT_NAME2
--  szOID_ISSUER_ALT_NAME2
-- 
--  pvStructInfo points to following CERT_ALT_NAME_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_OTHER_NAME  = record
pszObjId        : LPSTR;
Value           : CRYPT_OBJID_BLOB;
  end record;
  CERT_OTHER_NAME   = _CERT_OTHER_NAME;
  PCERT_OTHER_NAME  = ^_CERT_OTHER_NAME;

type
  _CERT_ALT_NAME_ENTRY = record
dwAltNameChoice : DWORD;
t_075            : record
      pOtherName    : PCERT_OTHER_NAME for position use 0;
      pwszRfc822Name : LPWSTR for position use 0;
      pwszDNSName   : LPWSTR for position use 0;
      DirectoryName : CERT_NAME_BLOB for position use 0;
      pwszURL       : LPWSTR for position use 0;
      IPAddress     : CRYPT_DATA_BLOB for position use 0;
      pszRegisteredID : LPSTR for position use 0;
    end record;
  end record;
  CERT_ALT_NAME_ENTRY = _CERT_ALT_NAME_ENTRY;
  PCERT_ALT_NAME_ENTRY = ^_CERT_ALT_NAME_ENTRY;

const
  CERT_ALT_NAME_OTHER_NAME= 1;

const
  CERT_ALT_NAME_RFC822_NAME= 2;

const
  CERT_ALT_NAME_DNS_NAME= 3;

const
  CERT_ALT_NAME_X400_ADDRESS= 4;

const
  CERT_ALT_NAME_DIRECTORY_NAME= 5;

const
  CERT_ALT_NAME_EDI_PARTY_NAME= 6;

const
  CERT_ALT_NAME_URL = 7;

const
  CERT_ALT_NAME_IP_ADDRESS= 8;

const
  CERT_ALT_NAME_REGISTERED_ID= 9;

type
  _CERT_ALT_NAME_INFO = record
cAltEntry       : DWORD;
rgAltEntry      : PCERT_ALT_NAME_ENTRY;
  end record;
  CERT_ALT_NAME_INFO = _CERT_ALT_NAME_INFO;
  PCERT_ALT_NAME_INFO = ^_CERT_ALT_NAME_INFO;

-- +-------------------------------------------------------------------------
--  Alternate name IA5 Error Location Definitions for
--  CRYPT_E_INVALID_IA5_STRING.
-- 
--  Error location is returned in *pcbEncoded by
--  CryptEncodeObject(X509_ALTERNATE_NAME)
-- 
--  Error location consists of:
--  ENTRY_INDEX - 8 bits << 16
--  VALUE_INDEX - 16 bits (unicode character index)
-- --------------------------------------------------------------------------
const
  CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK= $FF;

const
  CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT= 16;

const
  CERT_ALT_NAME_VALUE_ERR_INDEX_MASK= $FFFF;

const
  CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT= 0;

-- +-------------------------------------------------------------------------
--  X509_BASIC_CONSTRAINTS
--  szOID_BASIC_CONSTRAINTS
-- 
--  pvStructInfo points to following CERT_BASIC_CONSTRAINTS_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_BASIC_CONSTRAINTS_INFO = record
SubjectType     : CRYPT_BIT_BLOB;
fPathLenConstraint : BOOL;
dwPathLenConstraint : DWORD;
cSubtreesConstraint : DWORD;
rgSubtreesConstraint : ^CERT_NAME_BLOB;
  end record;
  CERT_BASIC_CONSTRAINTS_INFO = _CERT_BASIC_CONSTRAINTS_INFO;
  PCERT_BASIC_CONSTRAINTS_INFO = ^_CERT_BASIC_CONSTRAINTS_INFO;

const
  CERT_CA_SUBJECT_FLAG= $80;

const
  CERT_END_ENTITY_SUBJECT_FLAG= $40;

-- +-------------------------------------------------------------------------
--  X509_BASIC_CONSTRAINTS2
--  szOID_BASIC_CONSTRAINTS2
-- 
--  pvStructInfo points to following CERT_BASIC_CONSTRAINTS2_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_BASIC_CONSTRAINTS2_INFO = record
fCA             : BOOL;
fPathLenConstraint : BOOL;
dwPathLenConstraint : DWORD;
  end record;
  CERT_BASIC_CONSTRAINTS2_INFO = _CERT_BASIC_CONSTRAINTS2_INFO;
  PCERT_BASIC_CONSTRAINTS2_INFO = ^_CERT_BASIC_CONSTRAINTS2_INFO;

-- +-------------------------------------------------------------------------
--  X509_KEY_USAGE
--  szOID_KEY_USAGE
-- 
--  pvStructInfo points to a CRYPT_BIT_BLOB. Has same bit definitions as
--  CERT_KEY_ATTRIBUTES_INFO's IntendedKeyUsage.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_CERT_POLICIES
--  szOID_CERT_POLICIES
--  szOID_CERT_POLICIES_95 NOTE--Only allowed for decoding!!!
-- 
--  pvStructInfo points to following CERT_POLICIES_INFO.
-- 
--  NOTE: when decoding using szOID_CERT_POLICIES_95 the pszPolicyIdentifier
--  may contain an empty string
-- --------------------------------------------------------------------------
type
  _CERT_POLICY_QUALIFIER_INFO = record
pszPolicyQualifierId : LPSTR;
Qualifier       : CRYPT_OBJID_BLOB;
  end record;
  CERT_POLICY_QUALIFIER_INFO = _CERT_POLICY_QUALIFIER_INFO;
  PCERT_POLICY_QUALIFIER_INFO = ^_CERT_POLICY_QUALIFIER_INFO;

type
  _CERT_POLICY_INFO = record
pszPolicyIdentifier : LPSTR;
cPolicyQualifier : DWORD;
rgPolicyQualifier : ^CERT_POLICY_QUALIFIER_INFO;
  end record;
  CERT_POLICY_INFO  = _CERT_POLICY_INFO;
  PCERT_POLICY_INFO = ^_CERT_POLICY_INFO;

type
  _CERT_POLICIES_INFO = record
cPolicyInfo     : DWORD;
rgPolicyInfo    : ^CERT_POLICY_INFO;
  end record;
  CERT_POLICIES_INFO = _CERT_POLICIES_INFO;
  PCERT_POLICIES_INFO = ^_CERT_POLICIES_INFO;

-- +-------------------------------------------------------------------------
--  X509_PKIX_POLICY_QUALIFIER_USERNOTICE
--  szOID_PKIX_POLICY_QUALIFIER_USERNOTICE
-- 
--  pvStructInfo points to following CERT_POLICY_QUALIFIER_USER_NOTICE.
-- 
-- --------------------------------------------------------------------------
type
  _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = record
pszOrganization : LPSTR;
cNoticeNumbers  : DWORD;
rgNoticeNumbers : ^signed 32;
  end record;
  CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE;
  PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = ^_CERT_POLICY_QUALIFIER_NOTICE_REFERENCE;

type
  _CERT_POLICY_QUALIFIER_USER_NOTICE = record
pNoticeReference : ^CERT_POLICY_QUALIFIER_NOTICE_REFERENCE;
pszDisplayText  : LPWSTR;
  end record;
  CERT_POLICY_QUALIFIER_USER_NOTICE = _CERT_POLICY_QUALIFIER_USER_NOTICE;
  PCERT_POLICY_QUALIFIER_USER_NOTICE = ^_CERT_POLICY_QUALIFIER_USER_NOTICE;

-- +-------------------------------------------------------------------------
--  szOID_CERT_POLICIES_95_QUALIFIER1 - Decode Only!!!!
-- 
--  pvStructInfo points to following CERT_POLICY95_QUALIFIER1.
-- 
-- --------------------------------------------------------------------------
type
  _CPS_URLS         = record
pszURL          : LPWSTR;
pAlgorithm      : ^CRYPT_ALGORITHM_IDENTIFIER;
pDigest         : ^CRYPT_DATA_BLOB;
  end record;
  CPS_URLS          = _CPS_URLS;
  PCPS_URLS         = ^_CPS_URLS;

type
  _CERT_POLICY95_QUALIFIER1 = record
pszPracticesReference : LPWSTR;
pszNoticeIdentifier : LPSTR;
pszNSINoticeIdentifier : LPSTR;
cCPSURLs        : DWORD;
rgCPSURLs       : ^CPS_URLS;
  end record;
  CERT_POLICY95_QUALIFIER1 = _CERT_POLICY95_QUALIFIER1;
  PCERT_POLICY95_QUALIFIER1 = ^_CERT_POLICY95_QUALIFIER1;

-- +-------------------------------------------------------------------------
--  X509_POLICY_MAPPINGS
--  szOID_POLICY_MAPPINGS
--  szOID_LEGACY_POLICY_MAPPINGS
-- 
--  pvStructInfo points to following CERT_POLICY_MAPPINGS_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_POLICY_MAPPING = record
pszIssuerDomainPolicy : LPSTR;
pszSubjectDomainPolicy : LPSTR;
  end record;
  CERT_POLICY_MAPPING = _CERT_POLICY_MAPPING;
  PCERT_POLICY_MAPPING = ^_CERT_POLICY_MAPPING;

type
  _CERT_POLICY_MAPPINGS_INFO = record
cPolicyMapping  : DWORD;
rgPolicyMapping : PCERT_POLICY_MAPPING;
  end record;
  CERT_POLICY_MAPPINGS_INFO = _CERT_POLICY_MAPPINGS_INFO;
  PCERT_POLICY_MAPPINGS_INFO = ^_CERT_POLICY_MAPPINGS_INFO;

-- +-------------------------------------------------------------------------
--  X509_POLICY_CONSTRAINTS
--  szOID_POLICY_CONSTRAINTS
-- 
--  pvStructInfo points to following CERT_POLICY_CONSTRAINTS_INFO.
-- --------------------------------------------------------------------------
type
  _CERT_POLICY_CONSTRAINTS_INFO = record
fRequireExplicitPolicy : BOOL;
dwRequireExplicitPolicySkipCerts : DWORD;
fInhibitPolicyMapping : BOOL;
dwInhibitPolicyMappingSkipCerts : DWORD;
  end record;
  CERT_POLICY_CONSTRAINTS_INFO = _CERT_POLICY_CONSTRAINTS_INFO;
  PCERT_POLICY_CONSTRAINTS_INFO = ^_CERT_POLICY_CONSTRAINTS_INFO;

-- +-------------------------------------------------------------------------
--  RSA_CSP_PUBLICKEYBLOB
-- 
--  pvStructInfo points to a PUBLICKEYSTRUC immediately followed by a
--  RSAPUBKEY and the modulus bytes.
-- 
--  CryptExportKey outputs the above StructInfo for a dwBlobType of
--  PUBLICKEYBLOB. CryptImportKey expects the above StructInfo when
--  importing a public key.
-- 
--  For dwCertEncodingType = X509_ASN_ENCODING, the RSA_CSP_PUBLICKEYBLOB is
--  encoded as a PKCS #1 RSAPublicKey consisting of a SEQUENCE of a
--  modulus INTEGER and a publicExponent INTEGER. The modulus is encoded
--  as being a unsigned integer. When decoded, if the modulus was encoded
--  as unsigned integer with a leading 0 byte, the 0 byte is removed before
--  converting to the CSP modulus bytes.
-- 
--  For decode, the aiKeyAlg field of PUBLICKEYSTRUC is always set to
--  CALG_RSA_KEYX.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_KEYGEN_REQUEST_TO_BE_SIGNED
-- 
--  pvStructInfo points to CERT_KEYGEN_REQUEST_INFO.
-- 
--  For CryptDecodeObject(), the pbEncoded is the "to be signed" plus its
--  signature (output of a X509_CERT CryptEncodeObject()).
-- 
--  For CryptEncodeObject(), the pbEncoded is just the "to be signed".
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  PKCS_ATTRIBUTE data structure
-- 
--  pvStructInfo points to a CRYPT_ATTRIBUTE.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  PKCS_ATTRIBUTES data structure
-- 
--  pvStructInfo points to a CRYPT_ATTRIBUTES.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  PKCS_CONTENT_INFO_SEQUENCE_OF_ANY data structure
-- 
--  pvStructInfo points to following CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY.
-- 
--  For X509_ASN_ENCODING: encoded as a PKCS#7 ContentInfo structure wrapping
--  a sequence of ANY. The value of the contentType field is pszObjId,
--  while the content field is the following structure:
--  SequenceOfAny ::= SEQUENCE OF ANY
-- 
--  The CRYPT_DER_BLOBs point to the already encoded ANY content.
-- --------------------------------------------------------------------------
type
  _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = record
pszObjId        : LPSTR;
cValue          : DWORD;
rgValue         : PCRYPT_DER_BLOB;
  end record;
  CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;
  PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = ^_CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;

-- +-------------------------------------------------------------------------
--  PKCS_CONTENT_INFO data structure
-- 
--  pvStructInfo points to following CRYPT_CONTENT_INFO.
-- 
--  For X509_ASN_ENCODING: encoded as a PKCS#7 ContentInfo structure.
--  The CRYPT_DER_BLOB points to the already encoded ANY content.
-- --------------------------------------------------------------------------
type
  _CRYPT_CONTENT_INFO = record
pszObjId        : LPSTR;
Content         : CRYPT_DER_BLOB;
  end record;
  CRYPT_CONTENT_INFO = _CRYPT_CONTENT_INFO;
  PCRYPT_CONTENT_INFO = ^_CRYPT_CONTENT_INFO;

-- +-------------------------------------------------------------------------
--  X509_OCTET_STRING data structure
-- 
--  pvStructInfo points to a CRYPT_DATA_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_BITS data structure
-- 
--  pvStructInfo points to a CRYPT_BIT_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_BITS_WITHOUT_TRAILING_ZEROES data structure
-- 
--  pvStructInfo points to a CRYPT_BIT_BLOB.
-- 
--  The same as X509_BITS, except before encoding, the bit length is
--  decremented to exclude trailing zero bits.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_INTEGER data structure
-- 
--  pvStructInfo points to an int.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_MULTI_BYTE_INTEGER data structure
-- 
--  pvStructInfo points to a CRYPT_INTEGER_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_ENUMERATED data structure
-- 
--  pvStructInfo points to an int containing the enumerated value
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_CHOICE_OF_TIME data structure
-- 
--  pvStructInfo points to a FILETIME.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_SEQUENCE_OF_ANY data structure
-- 
--  pvStructInfo points to following CRYPT_SEQUENCE_OF_ANY.
-- 
--  The CRYPT_DER_BLOBs point to the already encoded ANY content.
-- --------------------------------------------------------------------------
type
  _CRYPT_SEQUENCE_OF_ANY = record
cValue          : DWORD;
rgValue         : PCRYPT_DER_BLOB;
  end record;
  CRYPT_SEQUENCE_OF_ANY = _CRYPT_SEQUENCE_OF_ANY;
  PCRYPT_SEQUENCE_OF_ANY = ^_CRYPT_SEQUENCE_OF_ANY;

-- +-------------------------------------------------------------------------
--  X509_AUTHORITY_KEY_ID2
--  szOID_AUTHORITY_KEY_IDENTIFIER2
-- 
--  pvStructInfo points to following CERT_AUTHORITY_KEY_ID2_INFO.
-- 
--  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
--  *pcbEncoded by CryptEncodeObject(X509_AUTHORITY_KEY_ID2)
-- 
--  See X509_ALTERNATE_NAME for error location defines.
-- --------------------------------------------------------------------------
type
  _CERT_AUTHORITY_KEY_ID2_INFO = record
KeyId           : CRYPT_DATA_BLOB;
AuthorityCertIssuer : CERT_ALT_NAME_INFO;
AuthorityCertSerialNumber : CRYPT_INTEGER_BLOB;
  end record;
  CERT_AUTHORITY_KEY_ID2_INFO = _CERT_AUTHORITY_KEY_ID2_INFO;
  PCERT_AUTHORITY_KEY_ID2_INFO = ^_CERT_AUTHORITY_KEY_ID2_INFO;

-- +-------------------------------------------------------------------------
--  szOID_SUBJECT_KEY_IDENTIFIER
-- 
--  pvStructInfo points to a CRYPT_DATA_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_AUTHORITY_INFO_ACCESS
--  szOID_AUTHORITY_INFO_ACCESS
-- 
--  pvStructInfo points to following CERT_AUTHORITY_INFO_ACCESS.
-- 
--  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
--  *pcbEncoded by CryptEncodeObject(X509_AUTHORITY_INFO_ACCESS)
-- 
--  Error location consists of:
--  ENTRY_INDEX - 8 bits << 16
--  VALUE_INDEX - 16 bits (unicode character index)
-- 
--  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
--  defines.
-- --------------------------------------------------------------------------
type
  _CERT_ACCESS_DESCRIPTION = record
pszAccessMethod : LPSTR;
AccessLocation  : CERT_ALT_NAME_ENTRY;
  end record;
  CERT_ACCESS_DESCRIPTION = _CERT_ACCESS_DESCRIPTION;
  PCERT_ACCESS_DESCRIPTION = ^_CERT_ACCESS_DESCRIPTION;

type
  _CERT_AUTHORITY_INFO_ACCESS = record
cAccDescr       : DWORD;
rgAccDescr      : PCERT_ACCESS_DESCRIPTION;
  end record;
  CERT_AUTHORITY_INFO_ACCESS = _CERT_AUTHORITY_INFO_ACCESS;
  PCERT_AUTHORITY_INFO_ACCESS = ^_CERT_AUTHORITY_INFO_ACCESS;

-- +-------------------------------------------------------------------------
--  PKIX Access Description: Access Method Object Identifiers
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_CRL_REASON_CODE
--  szOID_CRL_REASON_CODE
-- 
--  pvStructInfo points to an int which can be set to one of the following
--  enumerated values:
-- --------------------------------------------------------------------------
const
  CRL_REASON_UNSPECIFIED= 0;

const
  CRL_REASON_KEY_COMPROMISE= 1;

const
  CRL_REASON_CA_COMPROMISE= 2;

const
  CRL_REASON_AFFILIATION_CHANGED= 3;

const
  CRL_REASON_SUPERSEDED= 4;

const
  CRL_REASON_CESSATION_OF_OPERATION= 5;

const
  CRL_REASON_CERTIFICATE_HOLD= 6;

const
  CRL_REASON_REMOVE_FROM_CRL= 8;

-- +-------------------------------------------------------------------------
--  X509_CRL_DIST_POINTS
--  szOID_CRL_DIST_POINTS
-- 
--  pvStructInfo points to following CRL_DIST_POINTS_INFO.
-- 
--  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
--  *pcbEncoded by CryptEncodeObject(X509_CRL_DIST_POINTS)
-- 
--  Error location consists of:
--  CRL_ISSUER_BIT - 1 bit << 31 (0 for FullName, 1 for CRLIssuer)
--  POINT_INDEX - 7 bits << 24
--  ENTRY_INDEX - 8 bits << 16
--  VALUE_INDEX - 16 bits (unicode character index)
-- 
--  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
--  defines.
-- --------------------------------------------------------------------------
type
  _CRL_DIST_POINT_NAME = record
dwDistPointNameChoice : DWORD;
t_076            : record
      FullName      : CERT_ALT_NAME_INFO for position use 0;
    end record;
  end record;
  CRL_DIST_POINT_NAME = _CRL_DIST_POINT_NAME;
  PCRL_DIST_POINT_NAME = ^_CRL_DIST_POINT_NAME;

const
  CRL_DIST_POINT_NO_NAME= 0;

const
  CRL_DIST_POINT_FULL_NAME= 1;

const
  CRL_DIST_POINT_ISSUER_RDN_NAME= 2;

type
  _CRL_DIST_POINT   = record
DistPointName   : CRL_DIST_POINT_NAME;
ReasonFlags     : CRYPT_BIT_BLOB;
CRLIssuer       : CERT_ALT_NAME_INFO;
  end record;
  CRL_DIST_POINT    = _CRL_DIST_POINT;
  PCRL_DIST_POINT   = ^_CRL_DIST_POINT;

const
  CRL_REASON_UNUSED_FLAG= $80;

const
  CRL_REASON_KEY_COMPROMISE_FLAG= $40;

const
  CRL_REASON_CA_COMPROMISE_FLAG= $20;

const
  CRL_REASON_AFFILIATION_CHANGED_FLAG= $10;

const
  CRL_REASON_SUPERSEDED_FLAG= $08;

const
  CRL_REASON_CESSATION_OF_OPERATION_FLAG= $04;

const
  CRL_REASON_CERTIFICATE_HOLD_FLAG= $02;

type
  _CRL_DIST_POINTS_INFO = record
cDistPoint      : DWORD;
rgDistPoint     : PCRL_DIST_POINT;
  end record;
  CRL_DIST_POINTS_INFO = _CRL_DIST_POINTS_INFO;
  PCRL_DIST_POINTS_INFO = ^_CRL_DIST_POINTS_INFO;

const
  CRL_DIST_POINT_ERR_INDEX_MASK= $7F;

const
  CRL_DIST_POINT_ERR_INDEX_SHIFT= 24;

const
  CRL_DIST_POINT_ERR_CRL_ISSUER_BIT= $80000000;

-- +-------------------------------------------------------------------------
--  X509_CROSS_CERT_DIST_POINTS
--  szOID_CROSS_CERT_DIST_POINTS
-- 
--  pvStructInfo points to following CROSS_CERT_DIST_POINTS_INFO.
-- 
--  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
--  *pcbEncoded by CryptEncodeObject(X509_CRL_DIST_POINTS)
-- 
--  Error location consists of:
--  POINT_INDEX - 8 bits << 24
--  ENTRY_INDEX - 8 bits << 16
--  VALUE_INDEX - 16 bits (unicode character index)
-- 
--  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
--  defines.
-- --------------------------------------------------------------------------
type
  _CROSS_CERT_DIST_POINTS_INFO = record
dwSyncDeltaTime : DWORD;
cDistPoint      : DWORD;
rgDistPoint     : PCERT_ALT_NAME_INFO;
  end record;
  CROSS_CERT_DIST_POINTS_INFO = _CROSS_CERT_DIST_POINTS_INFO;
  PCROSS_CERT_DIST_POINTS_INFO = ^_CROSS_CERT_DIST_POINTS_INFO;

const
  CROSS_CERT_DIST_POINT_ERR_INDEX_MASK= $FF;

const
  CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT= 24;

-- +-------------------------------------------------------------------------
--  X509_ENHANCED_KEY_USAGE
--  szOID_ENHANCED_KEY_USAGE
-- 
--  pvStructInfo points to a CERT_ENHKEY_USAGE, CTL_USAGE.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_CERT_PAIR
-- 
--  pvStructInfo points to the following CERT_PAIR.
-- --------------------------------------------------------------------------
type
  _CERT_PAIR        = record
Forward         : CERT_BLOB;
_Reverse        : CERT_BLOB;
  end record;
  CERT_PAIR         = _CERT_PAIR;
  PCERT_PAIR        = ^_CERT_PAIR;

-- +-------------------------------------------------------------------------
--  szOID_CRL_NUMBER
-- 
--  pvStructInfo points to an int.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_DELTA_CRL_INDICATOR
-- 
--  pvStructInfo points to an int.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_ISSUING_DIST_POINT
--  X509_ISSUING_DIST_POINT
-- 
--  pvStructInfo points to the following CRL_ISSUING_DIST_POINT.
-- 
--  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
--  *pcbEncoded by CryptEncodeObject(X509_ISSUING_DIST_POINT)
-- 
--  Error location consists of:
--  ENTRY_INDEX - 8 bits << 16
--  VALUE_INDEX - 16 bits (unicode character index)
-- 
--  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
--  defines.
-- --------------------------------------------------------------------------
type
  _CRL_ISSUING_DIST_POINT = record
DistPointName   : CRL_DIST_POINT_NAME;
fOnlyContainsUserCerts : BOOL;
fOnlyContainsCACerts : BOOL;
OnlySomeReasonFlags : CRYPT_BIT_BLOB;
fIndirectCRL    : BOOL;
  end record;
  CRL_ISSUING_DIST_POINT = _CRL_ISSUING_DIST_POINT;
  PCRL_ISSUING_DIST_POINT = ^_CRL_ISSUING_DIST_POINT;

-- +-------------------------------------------------------------------------
--  szOID_FRESHEST_CRL
-- 
--  pvStructInfo points to CRL_DIST_POINTS_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NAME_CONSTRAINTS
--  X509_NAME_CONSTRAINTS
-- 
--  pvStructInfo points to the following CERT_NAME_CONSTRAINTS_INFO
-- 
--  For CRYPT_E_INVALID_IA5_STRING, the error location is returned in
--  *pcbEncoded by CryptEncodeObject(X509_NAME_CONSTRAINTS)
-- 
--  Error location consists of:
--  EXCLUDED_SUBTREE_BIT - 1 bit << 31 (0 for permitted, 1 for excluded)
--  ENTRY_INDEX - 8 bits << 16
--  VALUE_INDEX - 16 bits (unicode character index)
-- 
--  See X509_ALTERNATE_NAME for ENTRY_INDEX and VALUE_INDEX error location
--  defines.
-- --------------------------------------------------------------------------
type
  _CERT_GENERAL_SUBTREE = record
Base            : CERT_ALT_NAME_ENTRY;
dwMinimum       : DWORD;
fMaximum        : BOOL;
dwMaximum       : DWORD;
  end record;
  CERT_GENERAL_SUBTREE = _CERT_GENERAL_SUBTREE;
  PCERT_GENERAL_SUBTREE = ^_CERT_GENERAL_SUBTREE;

type
  _CERT_NAME_CONSTRAINTS_INFO = record
cPermittedSubtree : DWORD;
rgPermittedSubtree : PCERT_GENERAL_SUBTREE;
cExcludedSubtree : DWORD;
rgExcludedSubtree : PCERT_GENERAL_SUBTREE;
  end record;
  CERT_NAME_CONSTRAINTS_INFO = _CERT_NAME_CONSTRAINTS_INFO;
  PCERT_NAME_CONSTRAINTS_INFO = ^_CERT_NAME_CONSTRAINTS_INFO;

const
  CERT_EXCLUDED_SUBTREE_BIT= $80000000;

-- +-------------------------------------------------------------------------
--  szOID_NEXT_UPDATE_LOCATION
-- 
--  pvStructInfo points to a CERT_ALT_NAME_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_REMOVE_CERTIFICATE
-- 
--  pvStructInfo points to an int which can be set to one of the following
--  0 - Add certificate
--  1 - Remove certificate
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  PKCS_CTL
--  szOID_CTL
-- 
--  pvStructInfo points to a CTL_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  PKCS_SORTED_CTL
-- 
--  pvStructInfo points to a CTL_INFO.
-- 
--  Same as for PKCS_CTL, except, the CTL entries are sorted. The following
--  extension containing the sort information is inserted as the first
--  extension in the encoded CTL.
-- 
--  Only supported for Encoding. CRYPT_ENCODE_ALLOC_FLAG flag must be
--  set.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Sorted CTL TrustedSubjects extension
-- 
--  Array of little endian DWORDs:
--  [0] - Flags
--  [1] - Count of HashBucket entry offsets
--  [2] - Maximum HashBucket entry collision count
--  [3 ..] (Count + 1) HashBucket entry offsets
-- 
--  When this extension is present in the CTL,
--  the ASN.1 encoded sequence of TrustedSubjects are HashBucket ordered.
-- 
--  The entry offsets point to the start of the first encoded TrustedSubject
--  sequence for the HashBucket. The encoded TrustedSubjects for a HashBucket
--  continue until the encoded offset of the next HashBucket. A HashBucket has
--  no entries if HashBucket[N] == HashBucket[N + 1].
-- 
--  The HashBucket offsets are from the start of the ASN.1 encoded CTL_INFO.
-- --------------------------------------------------------------------------
--  If the SubjectIdentifiers are a MD5 or SHA1 hash, the following flag is
--  set. When set, the first 4 bytes of the SubjectIdentifier are used as
--  the dwhash. Otherwise, the SubjectIdentifier bytes are hashed into dwHash.
--  In either case the HashBucket index = dwHash % cHashBucket.
const
  SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG= $01;

-- +-------------------------------------------------------------------------
--  X509_MULTI_BYTE_UINT
-- 
--  pvStructInfo points to a CRYPT_UINT_BLOB. Before encoding, inserts a
--  leading 0x00. After decoding, removes a leading 0x00.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_DSS_PUBLICKEY
-- 
--  pvStructInfo points to a CRYPT_UINT_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_DSS_PARAMETERS
-- 
--  pvStructInfo points to following CERT_DSS_PARAMETERS data structure.
-- --------------------------------------------------------------------------
type
  _CERT_DSS_PARAMETERS = record
p               : CRYPT_UINT_BLOB;
q               : CRYPT_UINT_BLOB;
g               : CRYPT_UINT_BLOB;
  end record;
  CERT_DSS_PARAMETERS = _CERT_DSS_PARAMETERS;
  PCERT_DSS_PARAMETERS = ^_CERT_DSS_PARAMETERS;

-- +-------------------------------------------------------------------------
--  X509_DSS_SIGNATURE
-- 
--  pvStructInfo is a BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN]. The
--  bytes are ordered as output by the DSS CSP's CryptSignHash().
-- --------------------------------------------------------------------------
const
  CERT_DSS_R_LEN    = 20;

const
  CERT_DSS_S_LEN    = 20;

--  Sequence of 2 unsigned integers (the extra +1 is for a potential leading
--  0x00 to make the integer unsigned)
-- +-------------------------------------------------------------------------
--  X509_DH_PUBLICKEY
-- 
--  pvStructInfo points to a CRYPT_UINT_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  X509_DH_PARAMETERS
-- 
--  pvStructInfo points to following CERT_DH_PARAMETERS data structure.
-- --------------------------------------------------------------------------
type
  _CERT_DH_PARAMETERS = record
p               : CRYPT_UINT_BLOB;
g               : CRYPT_UINT_BLOB;
  end record;
  CERT_DH_PARAMETERS = _CERT_DH_PARAMETERS;
  PCERT_DH_PARAMETERS = ^_CERT_DH_PARAMETERS;

-- +-------------------------------------------------------------------------
--  X942_DH_PARAMETERS
-- 
--  pvStructInfo points to following CERT_X942_DH_PARAMETERS data structure.
-- 
--  If q.cbData == 0, then, the following fields are zero'ed.
-- --------------------------------------------------------------------------
type
  _CERT_X942_DH_VALIDATION_PARAMS = record
seed            : CRYPT_BIT_BLOB;
pgenCounter     : DWORD;
  end record;
  CERT_X942_DH_VALIDATION_PARAMS = _CERT_X942_DH_VALIDATION_PARAMS;
  PCERT_X942_DH_VALIDATION_PARAMS = ^_CERT_X942_DH_VALIDATION_PARAMS;

type
  _CERT_X942_DH_PARAMETERS = record
p               : CRYPT_UINT_BLOB;
g               : CRYPT_UINT_BLOB;
q               : CRYPT_UINT_BLOB;
j               : CRYPT_UINT_BLOB;
pValidationParams : PCERT_X942_DH_VALIDATION_PARAMS;
  end record;
  CERT_X942_DH_PARAMETERS = _CERT_X942_DH_PARAMETERS;
  PCERT_X942_DH_PARAMETERS = ^_CERT_X942_DH_PARAMETERS;

-- +-------------------------------------------------------------------------
--  X942_OTHER_INFO
-- 
--  pvStructInfo points to following CRYPT_X942_OTHER_INFO data structure.
-- 
--  rgbCounter and rgbKeyLength are in Little Endian order.
-- --------------------------------------------------------------------------
const
  CRYPT_X942_COUNTER_BYTE_LENGTH= 4;

const
  CRYPT_X942_KEY_LENGTH_BYTE_LENGTH= 4;

type
  _CRYPT_X942_OTHER_INFO = record
pszContentEncryptionObjId : LPSTR;
rgbCounter      : array 0..CRYPT_X942_COUNTER_BYTE_LENGTH-1 of BYTE;
rgbKeyLength    : array 0..CRYPT_X942_KEY_LENGTH_BYTE_LENGTH-1 of BYTE;
PubInfo         : CRYPT_DATA_BLOB;
  end record;
  CRYPT_X942_OTHER_INFO = _CRYPT_X942_OTHER_INFO;
  PCRYPT_X942_OTHER_INFO = ^_CRYPT_X942_OTHER_INFO;

-- +-------------------------------------------------------------------------
--  PKCS_RC2_CBC_PARAMETERS
--  szOID_RSA_RC2CBC
-- 
--  pvStructInfo points to following CRYPT_RC2_CBC_PARAMETERS data structure.
-- --------------------------------------------------------------------------
type
  _CRYPT_RC2_CBC_PARAMETERS = record
dwVersion       : DWORD;
fIV             : BOOL;
rgbIV           : array 0..7 of BYTE;
  end record;
  CRYPT_RC2_CBC_PARAMETERS = _CRYPT_RC2_CBC_PARAMETERS;
  PCRYPT_RC2_CBC_PARAMETERS = ^_CRYPT_RC2_CBC_PARAMETERS;

const
  CRYPT_RC2_40BIT_VERSION= 160;

const
  CRYPT_RC2_56BIT_VERSION= 52;

const
  CRYPT_RC2_64BIT_VERSION= 120;

const
  CRYPT_RC2_128BIT_VERSION= 58;

-- +-------------------------------------------------------------------------
--  PKCS_SMIME_CAPABILITIES
--  szOID_RSA_SMIMECapabilities
-- 
--  pvStructInfo points to following CRYPT_SMIME_CAPABILITIES data structure.
-- 
--  Note, for CryptEncodeObject(X509_ASN_ENCODING), Parameters.cbData == 0
--  causes the encoded parameters to be omitted and not encoded as a NULL
--  (05 00) as is done when encoding a CRYPT_ALGORITHM_IDENTIFIER. This
--  is per the SMIME specification for encoding capabilities.
-- --------------------------------------------------------------------------
type
  _CRYPT_SMIME_CAPABILITY = record
pszObjId        : LPSTR;
Parameters      : CRYPT_OBJID_BLOB;
  end record;
  CRYPT_SMIME_CAPABILITY = _CRYPT_SMIME_CAPABILITY;
  PCRYPT_SMIME_CAPABILITY = ^_CRYPT_SMIME_CAPABILITY;

type
  _CRYPT_SMIME_CAPABILITIES = record
cCapability     : DWORD;
rgCapability    : PCRYPT_SMIME_CAPABILITY;
  end record;
  CRYPT_SMIME_CAPABILITIES = _CRYPT_SMIME_CAPABILITIES;
  PCRYPT_SMIME_CAPABILITIES = ^_CRYPT_SMIME_CAPABILITIES;

-- +-------------------------------------------------------------------------
--  PKCS7_SIGNER_INFO
-- 
--  pvStructInfo points to CMSG_SIGNER_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMS_SIGNER_INFO
-- 
--  pvStructInfo points to CMSG_CMS_SIGNER_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Verisign Certificate Extension Object Identifiers
-- --------------------------------------------------------------------------
--  Octet String containing Boolean
--  Octet String containing IA5 string: lower case 32 char hex string
--  Octet String containing Bit string
--  EKU
-- +-------------------------------------------------------------------------
--  Netscape Certificate Extension Object Identifiers
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Netscape Certificate Data Type Object Identifiers
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_CERT_TYPE extension
-- 
--  Its value is a bit string. CryptDecodeObject/CryptEncodeObject using
--  X509_BITS or X509_BITS_WITHOUT_TRAILING_ZEROES.
-- 
--  The following bits are defined:
-- --------------------------------------------------------------------------
const
  NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE= $80;

const
  NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE= $40;

const
  NETSCAPE_SMIME_CERT_TYPE= $20;

const
  NETSCAPE_SIGN_CERT_TYPE= $10;

const
  NETSCAPE_SSL_CA_CERT_TYPE= $04;

const
  NETSCAPE_SMIME_CA_CERT_TYPE= $02;

const
  NETSCAPE_SIGN_CA_CERT_TYPE= $01;

-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_BASE_URL extension
-- 
--  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
--  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
--  dwValueType = CERT_RDN_IA5_STRING.
-- 
--  When present this string is added to the beginning of all relative URLs
--  in the certificate. This extension can be considered an optimization
--  to reduce the size of the URL extensions.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_REVOCATION_URL extension
-- 
--  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
--  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
--  dwValueType = CERT_RDN_IA5_STRING.
-- 
--  It is a relative or absolute URL that can be used to check the
--  revocation status of a certificate. The revocation check will be
--  performed as an HTTP GET method using a url that is the concatenation of
--  revocation-url and certificate-serial-number.
--  Where the certificate-serial-number is encoded as a string of
--  ascii hexadecimal digits. For example, if the netscape-base-url is
--  https://www.certs-r-us.com/, the netscape-revocation-url is
--  cgi-bin/check-rev.cgi?, and the certificate serial number is 173420,
--  the resulting URL would be:
--  https://www.certs-r-us.com/cgi-bin/check-rev.cgi?02a56c
-- 
--  The server should return a document with a Content-Type of
--  application/x-netscape-revocation. The document should contain
--  a single ascii digit, '1' if the certificate is not curently valid,
--  and '0' if it is curently valid.
-- 
--  Note: for all of the URLs that include the certificate serial number,
--  the serial number will be encoded as a string which consists of an even
--  number of hexadecimal digits. If the number of significant digits is odd,
--  the string will have a single leading zero to ensure an even number of
--  digits is generated.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_CA_REVOCATION_URL extension
-- 
--  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
--  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
--  dwValueType = CERT_RDN_IA5_STRING.
-- 
--  It is a relative or absolute URL that can be used to check the
--  revocation status of any certificates that are signed by the CA that
--  this certificate belongs to. This extension is only valid in CA
--  certificates. The use of this extension is the same as the above
--  szOID_NETSCAPE_REVOCATION_URL extension.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_CERT_RENEWAL_URL extension
-- 
--  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
--  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
--  dwValueType = CERT_RDN_IA5_STRING.
-- 
--  It is a relative or absolute URL that points to a certificate renewal
--  form. The renewal form will be accessed with an HTTP GET method using a
--  url that is the concatenation of renewal-url and
--  certificate-serial-number. Where the certificate-serial-number is
--  encoded as a string of ascii hexadecimal digits. For example, if the
--  netscape-base-url is https://www.certs-r-us.com/, the
--  netscape-cert-renewal-url is cgi-bin/check-renew.cgi?, and the
--  certificate serial number is 173420, the resulting URL would be:
--  https://www.certs-r-us.com/cgi-bin/check-renew.cgi?02a56c
--  The document returned should be an HTML form that will allow the user
--  to request a renewal of their certificate.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_CA_POLICY_URL extension
-- 
--  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
--  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
--  dwValueType = CERT_RDN_IA5_STRING.
-- 
--  It is a relative or absolute URL that points to a web page that
--  describes the policies under which the certificate was issued.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_SSL_SERVER_NAME extension
-- 
--  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
--  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
--  dwValueType = CERT_RDN_IA5_STRING.
-- 
--  It is a "shell expression" that can be used to match the hostname of the
--  SSL server that is using this certificate. It is recommended that if
--  the server's hostname does not match this pattern the user be notified
--  and given the option to terminate the SSL connection. If this extension
--  is not present then the CommonName in the certificate subject's
--  distinguished name is used for the same purpose.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_COMMENT extension
-- 
--  Its value is an IA5_STRING. CryptDecodeObject/CryptEncodeObject using
--  X509_ANY_STRING or X509_UNICODE_ANY_STRING, where,
--  dwValueType = CERT_RDN_IA5_STRING.
-- 
--  It is a comment that may be displayed to the user when the certificate
--  is viewed.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  szOID_NETSCAPE_CERT_SEQUENCE
-- 
--  Its value is a PKCS#7 ContentInfo structure wrapping a sequence of
--  certificates. The value of the contentType field is
--  szOID_NETSCAPE_CERT_SEQUENCE, while the content field is the following
--  structure:
--  CertificateSequence ::= SEQUENCE OF Certificate.
-- 
--  CryptDecodeObject/CryptEncodeObject using
--  PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, where,
--  pszObjId = szOID_NETSCAPE_CERT_SEQUENCE and the CRYPT_DER_BLOBs point
--  to encoded X509 certificates.
-- --------------------------------------------------------------------------
-- +=========================================================================
--  Certificate Management Messages over CMS (CMC) Data Structures
-- ==========================================================================
--  Content Type (request)
--  Content Type (response)
--  Signature value that only contains the hash octets. The parameters for
--  this algorithm must be present and must be encoded as NULL. 
--  Transaction Id (integer)
--  Sender Nonce (octet string)
--  Recipient Nonce (octet string)
--  Issuer Name + Serial
--  Issuer Name [+ CRL Name] + Time [+ Reasons]
--  Issuer Name + Serial [+ Reason] [+ Effective Time] [+ Secret] [+ Comment]
--  (octet string) URL-style parameter list (IA5?)
--  (octet string)
--  optional Name + Integer
-- +-------------------------------------------------------------------------
--  CMC_DATA
--  CMC_RESPONSE
-- 
--  Certificate Management Messages over CMS (CMC) PKIData and Response
--  messages.
-- 
--  For CMC_DATA, pvStructInfo points to a CMC_DATA_INFO.
--  CMC_DATA_INFO contains optional arrays of tagged attributes, requests,
--  content info and/or arbitrary other messages.
-- 
--  For CMC_RESPONSE, pvStructInfo points to a CMC_RESPONSE_INFO.
--  CMC_RESPONSE_INFO is the same as CMC_DATA_INFO without the tagged
--  requests.
-- --------------------------------------------------------------------------
type
  _CMC_TAGGED_ATTRIBUTE = record
dwBodyPartID    : DWORD;
_Attribute      : CRYPT_ATTRIBUTE;
  end record;
  CMC_TAGGED_ATTRIBUTE = _CMC_TAGGED_ATTRIBUTE;
  PCMC_TAGGED_ATTRIBUTE = ^_CMC_TAGGED_ATTRIBUTE;

type
  _CMC_TAGGED_CERT_REQUEST = record
dwBodyPartID    : DWORD;
SignedCertRequest : CRYPT_DER_BLOB;
  end record;
  CMC_TAGGED_CERT_REQUEST = _CMC_TAGGED_CERT_REQUEST;
  PCMC_TAGGED_CERT_REQUEST = ^_CMC_TAGGED_CERT_REQUEST;

type
  _CMC_TAGGED_REQUEST = record
dwTaggedRequestChoice : DWORD;
t_077            : record
      pTaggedCertRequest : PCMC_TAGGED_CERT_REQUEST for position use 0;
    end record;
  end record;
  CMC_TAGGED_REQUEST = _CMC_TAGGED_REQUEST;
  PCMC_TAGGED_REQUEST = ^_CMC_TAGGED_REQUEST;

const
  CMC_TAGGED_CERT_REQUEST_CHOICE= 1;

type
  _CMC_TAGGED_CONTENT_INFO = record
dwBodyPartID    : DWORD;
EncodedContentInfo : CRYPT_DER_BLOB;
  end record;
  CMC_TAGGED_CONTENT_INFO = _CMC_TAGGED_CONTENT_INFO;
  PCMC_TAGGED_CONTENT_INFO = ^_CMC_TAGGED_CONTENT_INFO;

type
  _CMC_TAGGED_OTHER_MSG = record
dwBodyPartID    : DWORD;
pszObjId        : LPSTR;
Value           : CRYPT_OBJID_BLOB;
  end record;
  CMC_TAGGED_OTHER_MSG = _CMC_TAGGED_OTHER_MSG;
  PCMC_TAGGED_OTHER_MSG = ^_CMC_TAGGED_OTHER_MSG;

--  All the tagged arrays are optional
type
  _CMC_DATA_INFO    = record
cTaggedAttribute : DWORD;
rgTaggedAttribute : PCMC_TAGGED_ATTRIBUTE;
cTaggedRequest  : DWORD;
rgTaggedRequest : PCMC_TAGGED_REQUEST;
cTaggedContentInfo : DWORD;
rgTaggedContentInfo : PCMC_TAGGED_CONTENT_INFO;
cTaggedOtherMsg : DWORD;
rgTaggedOtherMsg : PCMC_TAGGED_OTHER_MSG;
  end record;
  CMC_DATA_INFO     = _CMC_DATA_INFO;
  PCMC_DATA_INFO    = ^_CMC_DATA_INFO;

--  All the tagged arrays are optional
type
  _CMC_RESPONSE_INFO = record
cTaggedAttribute : DWORD;
rgTaggedAttribute : PCMC_TAGGED_ATTRIBUTE;
cTaggedContentInfo : DWORD;
rgTaggedContentInfo : PCMC_TAGGED_CONTENT_INFO;
cTaggedOtherMsg : DWORD;
rgTaggedOtherMsg : PCMC_TAGGED_OTHER_MSG;
  end record;
  CMC_RESPONSE_INFO = _CMC_RESPONSE_INFO;
  PCMC_RESPONSE_INFO = ^_CMC_RESPONSE_INFO;

-- +-------------------------------------------------------------------------
--  CMC_STATUS
-- 
--  Certificate Management Messages over CMS (CMC) Status.
-- 
--  pvStructInfo points to a CMC_STATUS_INFO.
-- --------------------------------------------------------------------------
type
  _CMC_PEND_INFO    = record
PendToken       : CRYPT_DATA_BLOB;
PendTime        : t_FILETIME;
  end record;
  CMC_PEND_INFO     = _CMC_PEND_INFO;
  PCMC_PEND_INFO    = ^_CMC_PEND_INFO;

type
  _CMC_STATUS_INFO  = record
dwStatus        : DWORD;
cBodyList       : DWORD;
rgdwBodyList    : ^DWORD;
pwszStatusString : LPWSTR;
dwOtherInfoChoice : DWORD;
t_078            : record
      dwFailInfo    : DWORD for position use 0;
      pPendInfo     : PCMC_PEND_INFO for position use 0;
    end record;
  end record;
  CMC_STATUS_INFO   = _CMC_STATUS_INFO;
  PCMC_STATUS_INFO  = ^_CMC_STATUS_INFO;

const
  CMC_OTHER_INFO_NO_CHOICE= 0;

const
  CMC_OTHER_INFO_FAIL_CHOICE= 1;

const
  CMC_OTHER_INFO_PEND_CHOICE= 2;

-- 
--  dwStatus values
-- 
--  Request was granted
const
  CMC_STATUS_SUCCESS= 0;

--  Request failed, more information elsewhere in the message
const
  CMC_STATUS_FAILED = 2;

--  The request body part has not yet been processed. Requester is responsible
--  to poll back. May only be returned for certificate request operations.
const
  CMC_STATUS_PENDING= 3;

--  The requested operation is not supported
const
  CMC_STATUS_NO_SUPPORT= 4;

--  Confirmation using the idConfirmCertAcceptance control is required
--  before use of certificate
const
  CMC_STATUS_CONFIRM_REQUIRED= 5;

-- 
--  dwFailInfo values
-- 
--  Unrecognized or unsupported algorithm
const
  CMC_FAIL_BAD_ALG  = 0;

--  Integrity check failed
const
  CMC_FAIL_BAD_MESSAGE_CHECK= 1;

--  Transaction not permitted or supported
const
  CMC_FAIL_BAD_REQUEST= 2;

--  Message time field was not sufficiently close to the system time
const
  CMC_FAIL_BAD_TIME = 3;

--  No certificate could be identified matching the provided criteria
const
  CMC_FAIL_BAD_CERT_ID= 4;

--  A requested X.509 extension is not supported by the recipient CA.
const
  CMC_FAIL_UNSUPORTED_EXT= 5;

--  Private key material must be supplied
const
  CMC_FAIL_MUST_ARCHIVE_KEYS= 6;

--  Identification Attribute failed to verify
const
  CMC_FAIL_BAD_IDENTITY= 7;

--  Server requires a POP proof before issuing certificate
const
  CMC_FAIL_POP_REQUIRED= 8;

--  POP processing failed
const
  CMC_FAIL_POP_FAILED= 9;

--  Server policy does not allow key re-use
const
  CMC_FAIL_NO_KEY_REUSE= 10;

const
  CMC_FAIL_INTERNAL_CA_ERROR= 11;

const
  CMC_FAIL_TRY_LATER= 12;

-- +-------------------------------------------------------------------------
--  CMC_ADD_EXTENSIONS
-- 
--  Certificate Management Messages over CMS (CMC) Add Extensions control
--  attribute.
-- 
--  pvStructInfo points to a CMC_ADD_EXTENSIONS_INFO.
-- --------------------------------------------------------------------------
type
  _CMC_ADD_EXTENSIONS_INFO = record
dwCmcDataReference : DWORD;
cCertReference  : DWORD;
rgdwCertReference : ^DWORD;
cExtension      : DWORD;
rgExtension     : PCERT_EXTENSION;
  end record;
  CMC_ADD_EXTENSIONS_INFO = _CMC_ADD_EXTENSIONS_INFO;
  PCMC_ADD_EXTENSIONS_INFO = ^_CMC_ADD_EXTENSIONS_INFO;

-- +-------------------------------------------------------------------------
--  CMC_ADD_ATTRIBUTES
-- 
--  Certificate Management Messages over CMS (CMC) Add Attributes control
--  attribute.
-- 
--  pvStructInfo points to a CMC_ADD_ATTRIBUTES_INFO.
-- --------------------------------------------------------------------------
type
  _CMC_ADD_ATTRIBUTES_INFO = record
dwCmcDataReference : DWORD;
cCertReference  : DWORD;
rgdwCertReference : ^DWORD;
cAttribute      : DWORD;
rgAttribute     : PCRYPT_ATTRIBUTE;
  end record;
  CMC_ADD_ATTRIBUTES_INFO = _CMC_ADD_ATTRIBUTES_INFO;
  PCMC_ADD_ATTRIBUTES_INFO = ^_CMC_ADD_ATTRIBUTES_INFO;

-- +-------------------------------------------------------------------------
--  X509_CERTIFICATE_TEMPLATE
--  szOID_CERTIFICATE_TEMPLATE
-- 
--  pvStructInfo points to following CERT_TEMPLATE_EXT data structure.
-- 
-- --------------------------------------------------------------------------
type
  _CERT_TEMPLATE_EXT = record
pszObjId        : LPSTR;
dwMajorVersion  : DWORD;
fMinorVersion   : BOOL;
dwMinorVersion  : DWORD;
  end record;
  CERT_TEMPLATE_EXT = _CERT_TEMPLATE_EXT;
  PCERT_TEMPLATE_EXT = ^_CERT_TEMPLATE_EXT;

-- +=========================================================================
--  Object IDentifier (OID) Installable Functions: Data Structures and APIs
-- ==========================================================================
type
HCRYPTOIDFUNCSET  = ^unchecked for machine_pointer use true;
type
HCRYPTOIDFUNCADDR = ^unchecked for machine_pointer use true;
--  Predefined OID Function Names
--  CryptDllEncodeObject has same function signature as CryptEncodeObject.
--  CryptDllDecodeObject has same function signature as CryptDecodeObject.
--  CryptDllEncodeObjectEx has same function signature as CryptEncodeObjectEx.
--  The Ex version MUST support the CRYPT_ENCODE_ALLOC_FLAG option.
-- 
--  If an Ex function isn't installed or registered, then, attempts to find
--  a non-EX version. If the ALLOC flag is set, then, CryptEncodeObjectEx,
--  does the allocation and calls the non-EX version twice.
--  CryptDllDecodeObjectEx has same function signature as CryptDecodeObjectEx.
--  The Ex version MUST support the CRYPT_DECODE_ALLOC_FLAG option.
-- 
--  If an Ex function isn't installed or registered, then, attempts to find
--  a non-EX version. If the ALLOC flag is set, then, CryptDecodeObjectEx,
--  does the allocation and calls the non-EX version twice.
--  CryptDllCreateCOMObject has the following signature:
--  BOOL WINAPI CryptDllCreateCOMObject(
--  IN DWORD dwEncodingType,
--  IN LPCSTR pszOID,
--  IN PCRYPT_DATA_BLOB pEncodedContent,
--  IN DWORD dwFlags,
--  IN REFIID riid,
--  OUT void **ppvObj);
--  CertDllVerifyRevocation has the same signature as CertVerifyRevocation
--  (See CertVerifyRevocation for details on when called)
--  CertDllVerifyCTLUsage has the same signature as CertVerifyCTLUsage
--  CryptDllFindOIDInfo currently is only used to store values used by
--  CryptFindOIDInfo. See CryptFindOIDInfo() for more details.
--  CryptDllFindLocalizedName is only used to store localized string
--  values used by CryptFindLocalizedName. See CryptFindLocalizedName() for
--  more details.
--  Example of a complete OID Function Registry Name:
--  HKEY_LOCAL_MACHINE\Software\Microsoft\Cryptography\OID
--  Encoding Type 1\CryptDllEncodeObject\1.2.3
-- 
--  The key's L"Dll" value contains the name of the Dll.
--  The key's L"FuncName" value overrides the default function name
--  CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG can be set in the key's L"CryptFlags"
--  value to register the functions before the installed functions.
-- 
--  CryptSetOIDFunctionValue must be called to set this value. L"CryptFlags"
--  must be set using a dwValueType of REG_DWORD.
--  OID used for Default OID functions
type
  _CRYPT_OID_FUNC_ENTRY = record
pszOID          : LPCSTR;
pvFuncAddr      : ^unchecked;
  end record;
  CRYPT_OID_FUNC_ENTRY = _CRYPT_OID_FUNC_ENTRY;
  PCRYPT_OID_FUNC_ENTRY = ^_CRYPT_OID_FUNC_ENTRY;

const
  CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG= 1;

-- +-------------------------------------------------------------------------
--  Install a set of callable OID function addresses.
-- 
--  By default the functions are installed at end of the list.
--  Set CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG to install at beginning of list.
-- 
--  hModule should be updated with the hModule passed to DllMain to prevent
--  the Dll containing the function addresses from being unloaded by
--  CryptGetOIDFuncAddress/CryptFreeOIDFunctionAddress. This would be the
--  case when the Dll has also regsvr32'ed OID functions via
--  CryptRegisterOIDFunction.
-- 
--  DEFAULT functions are installed by setting rgFuncEntry[].pszOID =
--  CRYPT_DEFAULT_OID.
-- --------------------------------------------------------------------------
--  hModule passed to DllMain
type
t_079=array of CRYPT_OID_FUNC_ENTRY;

procedure CryptInstallOIDFunctionAddress(
    hModule         : in t_HMODULE; 
    dwEncodingType  : in DWORD; 
    pszFuncName     : in LPCSTR; 
    cFuncEntry      : in DWORD; 
    rgFuncEntry     : in t_079; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(CryptInstallOIDFunctionAddress,system);
#pragma import(CryptInstallOIDFunctionAddress,'CryptInstallOIDFunctionAddress','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Initialize and return handle to the OID function set identified by its
--  function name.
-- 
--  If the set already exists, a handle to the existing set is returned.
-- --------------------------------------------------------------------------
procedure CryptInitOIDFunctionSet(
    pszFuncName     : in LPCSTR; 
    dwFlags         : in DWORD)
                      return HCRYPTOIDFUNCSET;
#pragma convention(CryptInitOIDFunctionSet,system);
#pragma import(CryptInitOIDFunctionSet,'CryptInitOIDFunctionSet','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Search the list of installed functions for an encoding type and OID match.
--  If not found, search the registry.
-- 
--  For success, returns TRUE with *ppvFuncAddr updated with the function's
--  address and *phFuncAddr updated with the function address's handle.
--  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
--  be called to release it.
-- 
--  For a registry match, the Dll containing the function is loaded.
-- 
--  By default, both the registered and installed function lists are searched.
--  Set CRYPT_GET_INSTALLED_OID_FUNC_FLAG to only search the installed list
--  of functions. This flag would be set by a registered function to get
--  the address of a pre-installed function it was replacing. For example,
--  the registered function might handle a new special case and call the
--  pre-installed function to handle the remaining cases.
-- --------------------------------------------------------------------------
type
t_080=^unchecked for machine_pointer use true;

procedure CryptGetOIDFunctionAddress(
    hFuncSet        : in HCRYPTOIDFUNCSET; 
    dwEncodingType  : in DWORD; 
    pszOID          : in LPCSTR; 
    dwFlags         : in DWORD; 
    ppvFuncAddr     : out t_080; 
    phFuncAddr      : out HCRYPTOIDFUNCADDR)
                      return BOOL;
#pragma convention(CryptGetOIDFunctionAddress,system);
#pragma import(CryptGetOIDFunctionAddress,'CryptGetOIDFunctionAddress','crypt32.dll');

const
  CRYPT_GET_INSTALLED_OID_FUNC_FLAG= $01;

-- +-------------------------------------------------------------------------
--  Get the list of registered default Dll entries for the specified
--  function set and encoding type.
-- 
--  The returned list consists of none, one or more null terminated Dll file
--  names. The list is terminated with an empty (L"\0") Dll file name.
--  For example: L"first.dll" L"\0" L"second.dll" L"\0" L"\0"
-- --------------------------------------------------------------------------
procedure CryptGetDefaultOIDDllList(
    hFuncSet        : in HCRYPTOIDFUNCSET; 
    dwEncodingType  : in DWORD; 
    pwszDllList     : out WCHARSTR ; 
    pcchDllList     : in out DWORD)
                      return BOOL;
#pragma convention(CryptGetDefaultOIDDllList,system);
#pragma import(CryptGetDefaultOIDDllList,'CryptGetDefaultOIDDllList','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Either: get the first or next installed DEFAULT function OR
--  load the Dll containing the DEFAULT function.
-- 
--  If pwszDll is NULL, search the list of installed DEFAULT functions.
--  *phFuncAddr must be set to NULL to get the first installed function.
--  Successive installed functions are returned by setting *phFuncAddr
--  to the hFuncAddr returned by the previous call.
-- 
--  If pwszDll is NULL, the input *phFuncAddr
--  is always CryptFreeOIDFunctionAddress'ed by this function, even for
--  an error.
-- 
--  If pwszDll isn't NULL, then, attempts to load the Dll and the DEFAULT
--  function. *phFuncAddr is ignored upon entry and isn't
--  CryptFreeOIDFunctionAddress'ed.
-- 
--  For success, returns TRUE with *ppvFuncAddr updated with the function's
--  address and *phFuncAddr updated with the function address's handle.
--  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
--  be called to release it or CryptGetDefaultOIDFunctionAddress can also
--  be called for a NULL pwszDll.
-- --------------------------------------------------------------------------
type
t_081=^unchecked for machine_pointer use true;

procedure CryptGetDefaultOIDFunctionAddress(
    hFuncSet        : in HCRYPTOIDFUNCSET; 
    dwEncodingType  : in DWORD; 
    pwszDll         : in {out optional} LPCWSTR; 
    dwFlags         : in DWORD; 
    ppvFuncAddr     : out t_081; 
    phFuncAddr      : in out HCRYPTOIDFUNCADDR)
                      return BOOL;
#pragma convention(CryptGetDefaultOIDFunctionAddress,system);
#pragma import(CryptGetDefaultOIDFunctionAddress,'CryptGetDefaultOIDFunctionAddress','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Releases the handle AddRef'ed and returned by CryptGetOIDFunctionAddress
--  or CryptGetDefaultOIDFunctionAddress.
-- 
--  If a Dll was loaded for the function its unloaded. However, before doing
--  the unload, the DllCanUnloadNow function exported by the loaded Dll is
--  called. It should return S_FALSE to inhibit the unload or S_TRUE to enable
--  the unload. If the Dll doesn't export DllCanUnloadNow, the Dll is unloaded.
-- 
--  DllCanUnloadNow has the following signature:
--  STDAPI DllCanUnloadNow(void);
-- --------------------------------------------------------------------------
procedure CryptFreeOIDFunctionAddress(
    hFuncAddr       : in HCRYPTOIDFUNCADDR; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(CryptFreeOIDFunctionAddress,system);
#pragma import(CryptFreeOIDFunctionAddress,'CryptFreeOIDFunctionAddress','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Register the Dll containing the function to be called for the specified
--  encoding type, function name and OID.
-- 
--  pwszDll may contain environment-variable strings
--  which are ExpandEnvironmentStrings()'ed before loading the Dll.
-- 
--  In addition to registering the DLL, you may override the
--  name of the function to be called. For example,
--  pszFuncName = "CryptDllEncodeObject",
--  pszOverrideFuncName = "MyEncodeXyz".
--  This allows a Dll to export multiple OID functions for the same
--  function name without needing to interpose its own OID dispatcher function.
-- --------------------------------------------------------------------------
procedure CryptRegisterOIDFunction(
    dwEncodingType  : in DWORD; 
    pszFuncName     : in LPCSTR; 
    pszOID          : in LPCSTR; 
    pwszDll         : in {out optional} LPCWSTR; 
    pszOverrideFuncName : in {out optional} LPCSTR)
                      return BOOL;
#pragma convention(CryptRegisterOIDFunction,system);
#pragma import(CryptRegisterOIDFunction,'CryptRegisterOIDFunction','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Unregister the Dll containing the function to be called for the specified
--  encoding type, function name and OID.
-- --------------------------------------------------------------------------
procedure CryptUnregisterOIDFunction(
    dwEncodingType  : in DWORD; 
    pszFuncName     : in LPCSTR; 
    pszOID          : in LPCSTR)
                      return BOOL;
#pragma convention(CryptUnregisterOIDFunction,system);
#pragma import(CryptUnregisterOIDFunction,'CryptUnregisterOIDFunction','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Register the Dll containing the default function to be called for the
--  specified encoding type and function name.
-- 
--  Unlike CryptRegisterOIDFunction, you can't override the function name
--  needing to be exported by the Dll.
-- 
--  The Dll is inserted before the entry specified by dwIndex.
--  dwIndex == 0, inserts at the beginning.
--  dwIndex == CRYPT_REGISTER_LAST_INDEX, appends at the end.
-- 
--  pwszDll may contain environment-variable strings
--  which are ExpandEnvironmentStrings()'ed before loading the Dll.
-- --------------------------------------------------------------------------
procedure CryptRegisterDefaultOIDFunction(
    dwEncodingType  : in DWORD; 
    pszFuncName     : in LPCSTR; 
    dwIndex         : in DWORD; 
    pwszDll         : in LPCWSTR)
                      return BOOL;
#pragma convention(CryptRegisterDefaultOIDFunction,system);
#pragma import(CryptRegisterDefaultOIDFunction,'CryptRegisterDefaultOIDFunction','crypt32.dll');

const
  CRYPT_REGISTER_FIRST_INDEX= 0;

const
  CRYPT_REGISTER_LAST_INDEX= $FFFFFFFF;

-- +-------------------------------------------------------------------------
--  Unregister the Dll containing the default function to be called for
--  the specified encoding type and function name.
-- --------------------------------------------------------------------------
procedure CryptUnregisterDefaultOIDFunction(
    dwEncodingType  : in DWORD; 
    pszFuncName     : in LPCSTR; 
    pwszDll         : in LPCWSTR)
                      return BOOL;
#pragma convention(CryptUnregisterDefaultOIDFunction,system);
#pragma import(CryptUnregisterDefaultOIDFunction,'CryptUnregisterDefaultOIDFunction','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Set the value for the specified encoding type, function name, OID and
--  value name.
-- 
--  See RegSetValueEx for the possible value types.
-- 
--  String types are UNICODE.
-- --------------------------------------------------------------------------
type
t_082=^BYTE for machine_pointer use true;

procedure CryptSetOIDFunctionValue(
    dwEncodingType  : in DWORD; 
    pszFuncName     : in LPCSTR; 
    pszOID          : in LPCSTR; 
    pwszValueName   : in LPCWSTR; 
    dwValueType     : in DWORD; 
    pbValueData     : in t_082; 
    cbValueData     : in DWORD)
                      return BOOL;
#pragma convention(CryptSetOIDFunctionValue,system);
#pragma import(CryptSetOIDFunctionValue,'CryptSetOIDFunctionValue','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get the value for the specified encoding type, function name, OID and
--  value name.
-- 
--  See RegEnumValue for the possible value types.
-- 
--  String types are UNICODE.
-- --------------------------------------------------------------------------
procedure CryptGetOIDFunctionValue(
    dwEncodingType  : in DWORD; 
    pszFuncName     : in LPCSTR; 
    pszOID          : in LPCSTR; 
    pwszValueName   : in LPCWSTR; 
    pdwValueType    : out DWORD; 
    pbValueData     : out BYTE; 
    pcbValueData    : in out DWORD)
                      return BOOL;
#pragma convention(CryptGetOIDFunctionValue,system);
#pragma import(CryptGetOIDFunctionValue,'CryptGetOIDFunctionValue','crypt32.dll');

type
t_083=array of DWORD;
t_084=array of LPCWSTR;
t_085=^array of BYTE for machine_pointer use true;
t_086=array of DWORD;
t_087=^unchecked for machine_pointer use true;

PFN_CRYPT_ENUM_OID_FUNC = ^procedure (
    dwEncodingType  : in DWORD;
    pszFuncName     : in LPCSTR;
    pszOID          : in LPCSTR;
    cValue          : in DWORD;
    rgdwValueType   : in t_083;
    rgpwszValueName : in t_084;
    rgpbValueData   : in t_085;
    rgcbValueData   : in t_086;
    pvArg           : in t_087)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Enumerate the OID functions identified by their encoding type,
--  function name and OID.
-- 
--  pfnEnumOIDFunc is called for each registry key matching the input
--  parameters. Setting dwEncodingType to CRYPT_MATCH_ANY_ENCODING_TYPE matches
--  any. Setting pszFuncName or pszOID to NULL matches any.
-- 
--  Set pszOID == CRYPT_DEFAULT_OID to restrict the enumeration to only the
--  DEFAULT functions
-- 
--  String types are UNICODE.
-- --------------------------------------------------------------------------
type
t_088=^unchecked for machine_pointer use true;

procedure CryptEnumOIDFunction(
    dwEncodingType  : in DWORD; 
    pszFuncName     : in {out optional} LPCSTR; 
    pszOID          : in {out optional} LPCSTR; 
    dwFlags         : in DWORD; 
    pvArg           : in t_088; 
    pfnEnumOIDFunc  : in PFN_CRYPT_ENUM_OID_FUNC)
                      return BOOL;
#pragma convention(CryptEnumOIDFunction,system);
#pragma import(CryptEnumOIDFunction,'CryptEnumOIDFunction','crypt32.dll');

const
  CRYPT_MATCH_ANY_ENCODING_TYPE= $FFFFFFFF;

-- +=========================================================================
--  Object IDentifier (OID) Information: Data Structures and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  OID Information
-- --------------------------------------------------------------------------
type
  _CRYPT_OID_INFO   = record
cbSize          : DWORD;
pszOID          : LPCSTR;
pwszName        : LPCWSTR;
dwGroupId       : DWORD;
t_089            : record
      dwValue       : DWORD for position use 0;
      Algid         : ALG_ID for position use 0;
      dwLength      : DWORD for position use 0;
    end record;
ExtraInfo       : CRYPT_DATA_BLOB;
  end record;
  CRYPT_OID_INFO    = _CRYPT_OID_INFO;
  PCRYPT_OID_INFO   = ^_CRYPT_OID_INFO;

type
CCRYPT_OID_INFO   = CRYPT_OID_INFO;
PCCRYPT_OID_INFO  = ^CRYPT_OID_INFO for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  OID Group IDs
-- --------------------------------------------------------------------------
const
  CRYPT_HASH_ALG_OID_GROUP_ID= 1;

const
  CRYPT_ENCRYPT_ALG_OID_GROUP_ID= 2;

const
  CRYPT_PUBKEY_ALG_OID_GROUP_ID= 3;

const
  CRYPT_SIGN_ALG_OID_GROUP_ID= 4;

const
  CRYPT_RDN_ATTR_OID_GROUP_ID= 5;

const
  CRYPT_EXT_OR_ATTR_OID_GROUP_ID= 6;

const
  CRYPT_ENHKEY_USAGE_OID_GROUP_ID= 7;

const
  CRYPT_POLICY_OID_GROUP_ID= 8;

const
  CRYPT_TEMPLATE_OID_GROUP_ID= 9;

const
  CRYPT_LAST_OID_GROUP_ID= 9;

--  The CRYPT_*_ALG_OID_GROUP_ID's have an Algid. The CRYPT_RDN_ATTR_OID_GROUP_ID
--  has a dwLength. The CRYPT_EXT_OR_ATTR_OID_GROUP_ID,
--  CRYPT_ENHKEY_USAGE_OID_GROUP_ID, CRYPT_POLICY_OID_GROUP_ID or
--  CRYPT_TEMPLATE_OID_GROUP_ID don't have a dwValue.
-- 
--  CRYPT_PUBKEY_ALG_OID_GROUP_ID has the following optional ExtraInfo:
--  DWORD[0] - Flags. CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG can be set to
--  inhibit the reformatting of the signature before
--  CryptVerifySignature is called or after CryptSignHash
--  is called. CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG can
--  be set to include the public key algorithm's parameters
--  in the PKCS7's digestEncryptionAlgorithm's parameters.
--  CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG can be set to omit
--  NULL parameters when encoding.
const
  CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG= $01;

const
  CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG= $02;

const
  CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG= $04;

--  CRYPT_SIGN_ALG_OID_GROUP_ID has the following optional ExtraInfo:
--  DWORD[0] - Public Key Algid.
--  DWORD[1] - Flags. Same as above for CRYPT_PUBKEY_ALG_OID_GROUP_ID.
--  DWORD[2] - Optional CryptAcquireContext(CRYPT_VERIFYCONTEXT)'s dwProvType.
--  If omitted or 0, uses Public Key Algid to select
--  appropriate dwProvType for signature verification.
--  CRYPT_RDN_ATTR_OID_GROUP_ID has the following optional ExtraInfo:
--  Array of DWORDs:
--  [0 ..] - Null terminated list of acceptable RDN attribute
--  value types. An empty list implies CERT_RDN_PRINTABLE_STRING,
--  CERT_RDN_UNICODE_STRING, 0.
-- +-------------------------------------------------------------------------
--  Find OID information. Returns NULL if unable to find any information
--  for the specified key and group. Note, returns a pointer to a constant
--  data structure. The returned pointer MUST NOT be freed.
-- 
--  dwKeyType's:
--  CRYPT_OID_INFO_OID_KEY, pvKey points to a szOID
--  CRYPT_OID_INFO_NAME_KEY, pvKey points to a wszName
--  CRYPT_OID_INFO_ALGID_KEY, pvKey points to an ALG_ID
--  CRYPT_OID_INFO_SIGN_KEY, pvKey points to an array of two ALG_ID's:
--  ALG_ID[0] - Hash Algid
--  ALG_ID[1] - PubKey Algid
-- 
--  Setting dwGroupId to 0, searches all groups according to the dwKeyType.
--  Otherwise, only the dwGroupId is searched.
-- --------------------------------------------------------------------------
type
t_090=^unchecked for machine_pointer use true;

procedure CryptFindOIDInfo(
    dwKeyType       : in DWORD; 
    pvKey           : in t_090; 
    dwGroupId       : in DWORD)
                      return PCCRYPT_OID_INFO;
#pragma convention(CryptFindOIDInfo,system);
#pragma import(CryptFindOIDInfo,'CryptFindOIDInfo','crypt32.dll');

const
  CRYPT_OID_INFO_OID_KEY= 1;

const
  CRYPT_OID_INFO_NAME_KEY= 2;

const
  CRYPT_OID_INFO_ALGID_KEY= 3;

const
  CRYPT_OID_INFO_SIGN_KEY= 4;

-- +-------------------------------------------------------------------------
--  Register OID information. The OID information specified in the
--  CCRYPT_OID_INFO structure is persisted to the registry.
-- 
--  crypt32.dll contains information for the commonly known OIDs. This function
--  allows applications to augment crypt32.dll's OID information. During
--  CryptFindOIDInfo's first call, the registered OID information is installed.
-- 
--  By default the registered OID information is installed after crypt32.dll's
--  OID entries. Set CRYPT_INSTALL_OID_INFO_BEFORE_FLAG to install before.
-- --------------------------------------------------------------------------
procedure CryptRegisterOIDInfo(
    pInfo           : in PCCRYPT_OID_INFO; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(CryptRegisterOIDInfo,system);
#pragma import(CryptRegisterOIDInfo,'CryptRegisterOIDInfo','crypt32.dll');

const
  CRYPT_INSTALL_OID_INFO_BEFORE_FLAG= 1;

-- +-------------------------------------------------------------------------
--  Unregister OID information. Only the pszOID and dwGroupId fields are
--  used to identify the OID information to be unregistered.
-- --------------------------------------------------------------------------
procedure CryptUnregisterOIDInfo(
    pInfo           : in PCCRYPT_OID_INFO)
                      return BOOL;
#pragma convention(CryptUnregisterOIDInfo,system);
#pragma import(CryptUnregisterOIDInfo,'CryptUnregisterOIDInfo','crypt32.dll');

--  If the callback returns FALSE, stops the enumeration.
type
t_091=^unchecked for machine_pointer use true;

PFN_CRYPT_ENUM_OID_INFO = ^procedure (
    pInfo           : in PCCRYPT_OID_INFO;
    pvArg           : in t_091)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Enumerate the OID information.
-- 
--  pfnEnumOIDInfo is called for each OID information entry.
-- 
--  Setting dwGroupId to 0 matches all groups. Otherwise, only enumerates
--  entries in the specified group.
-- 
--  dwFlags currently isn't used and must be set to 0.
-- --------------------------------------------------------------------------
type
t_092=^unchecked for machine_pointer use true;

procedure CryptEnumOIDInfo(
    dwGroupId       : in DWORD; 
    dwFlags         : in DWORD; 
    pvArg           : in t_092; 
    pfnEnumOIDInfo  : in PFN_CRYPT_ENUM_OID_INFO)
                      return BOOL;
#pragma convention(CryptEnumOIDInfo,system);
#pragma import(CryptEnumOIDInfo,'CryptEnumOIDInfo','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Find the localized name for the specified name. For example, find the
--  localized name for the "Root" system store name. A case insensitive
--  string comparison is done.
-- 
--  Returns NULL if unable to find the the specified name.
-- 
--  Localized names for the predefined system stores ("Root", "My") and
--  predefined physical stores (".Default", ".LocalMachine") are pre-installed
--  as resource strings in crypt32.dll. CryptSetOIDFunctionValue can be called
--  as follows to register additional localized strings:
--  dwEncodingType = CRYPT_LOCALIZED_NAME_ENCODING_TYPE
--  pszFuncName = CRYPT_OID_FIND_LOCALIZED_NAME_FUNC
--  pszOID = CRYPT_LOCALIZED_NAME_OID
--  pwszValueName = Name to be localized, for example, L"ApplicationStore"
--  dwValueType = REG_SZ
--  pbValueData = pointer to the UNICODE localized string
--  cbValueData = (wcslen(UNICODE localized string) + 1) * sizeof(WCHAR)
-- 
--  To unregister, set pbValueData to NULL and cbValueData to 0.
-- 
--  The registered names are searched before the pre-installed names.
-- --------------------------------------------------------------------------
procedure CryptFindLocalizedName(
    pwszCryptName   : in LPCWSTR)
                      return LPCWSTR;
#pragma convention(CryptFindLocalizedName,system);
#pragma import(CryptFindLocalizedName,'CryptFindLocalizedName','crypt32.dll');

const
  CRYPT_LOCALIZED_NAME_ENCODING_TYPE= 0;

-- +=========================================================================
--  Low Level Cryptographic Message Data Structures and APIs
-- ==========================================================================
type
t_HCRYPTMSG       = ^unchecked for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Message types
-- --------------------------------------------------------------------------
const
  CMSG_DATA         = 1;

const
  CMSG_SIGNED       = 2;

const
  CMSG_ENVELOPED    = 3;

const
  CMSG_SIGNED_AND_ENVELOPED= 4;

const
  CMSG_HASHED       = 5;

const
  CMSG_ENCRYPTED    = 6;

-- +-------------------------------------------------------------------------
--  Message Type Bit Flags
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Certificate Issuer and SerialNumber
-- --------------------------------------------------------------------------
type
  _CERT_ISSUER_SERIAL_NUMBER = record
Issuer          : CERT_NAME_BLOB;
SerialNumber    : CRYPT_INTEGER_BLOB;
  end record;
  CERT_ISSUER_SERIAL_NUMBER = _CERT_ISSUER_SERIAL_NUMBER;
  PCERT_ISSUER_SERIAL_NUMBER = ^_CERT_ISSUER_SERIAL_NUMBER;

-- +-------------------------------------------------------------------------
--  Certificate Identifier
-- --------------------------------------------------------------------------
type
  _CERT_ID          = record
dwIdChoice      : DWORD;
t_093            : record
      IssuerSerialNumber : CERT_ISSUER_SERIAL_NUMBER for position use 0;
      KeyId         : CRYPT_HASH_BLOB for position use 0;
      HashId        : CRYPT_HASH_BLOB for position use 0;
    end record;
  end record;
  CERT_ID           = _CERT_ID;
  PCERT_ID          = ^_CERT_ID;

const
  CERT_ID_ISSUER_SERIAL_NUMBER= 1;

const
  CERT_ID_KEY_IDENTIFIER= 2;

const
  CERT_ID_SHA1_HASH = 3;

-- +-------------------------------------------------------------------------
--  The message encode information (pvMsgEncodeInfo) is message type dependent
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_DATA: pvMsgEncodeInfo = NULL
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_SIGNED
-- 
--  The pCertInfo in the CMSG_SIGNER_ENCODE_INFO provides the Issuer, SerialNumber
--  and PublicKeyInfo.Algorithm. The PublicKeyInfo.Algorithm implicitly
--  specifies the HashEncryptionAlgorithm to be used.
-- 
--  If the SignerId is present with a nonzero dwIdChoice its used instead
--  of the Issuer and SerialNumber in pCertInfo.
-- 
--  CMS supports the KEY_IDENTIFIER and ISSUER_SERIAL_NUMBER CERT_IDs. PKCS #7
--  version 1.5 only supports the ISSUER_SERIAL_NUMBER CERT_ID choice.
-- 
--  If HashEncryptionAlgorithm is present and not NULL its used instead of
--  the PublicKeyInfo.Algorithm.
-- 
--  Note, for RSA, the hash encryption algorithm is normally the same as
--  the public key algorithm. For DSA, the hash encryption algorithm is
--  normally a DSS signature algorithm.
-- 
--  pvHashEncryptionAuxInfo currently isn't used and must be set to NULL if
--  present in the data structure.
-- 
--  The hCryptProv and dwKeySpec specify the private key to use. If dwKeySpec
--  == 0, then, defaults to AT_SIGNATURE.
-- 
--  If the HashEncryptionAlgorithm is set to szOID_PKIX_NO_SIGNATURE, then,
--  the signature value only contains the hash octets. hCryptProv must still
--  be specified. However, since a private key isn't used the hCryptProv can be
--  acquired using CRYPT_VERIFYCONTEXT.
-- 
--  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
--  passed to CryptMsgOpenToEncode(), the signer hCryptProv's are released.
-- 
--  pvHashAuxInfo currently isn't used and must be set to NULL.
-- 
--  CMS signed messages allow the inclusion of Attribute Certs.
-- --------------------------------------------------------------------------
type
  _CMSG_SIGNER_ENCODE_INFO = record
cbSize          : DWORD;
pCertInfo       : PCERT_INFO;
hCryptProv      : t_HCRYPTPROV;
dwKeySpec       : DWORD;
HashAlgorithm   : CRYPT_ALGORITHM_IDENTIFIER;
pvHashAuxInfo   : ^unchecked;
cAuthAttr       : DWORD;
rgAuthAttr      : PCRYPT_ATTRIBUTE;
cUnauthAttr     : DWORD;
rgUnauthAttr    : PCRYPT_ATTRIBUTE;
  end record;
  CMSG_SIGNER_ENCODE_INFO = _CMSG_SIGNER_ENCODE_INFO;
  PCMSG_SIGNER_ENCODE_INFO = ^_CMSG_SIGNER_ENCODE_INFO;

type
  _CMSG_SIGNED_ENCODE_INFO = record
cbSize          : DWORD;
cSigners        : DWORD;
rgSigners       : PCMSG_SIGNER_ENCODE_INFO;
cCertEncoded    : DWORD;
rgCertEncoded   : PCERT_BLOB;
cCrlEncoded     : DWORD;
rgCrlEncoded    : PCRL_BLOB;
  end record;
  CMSG_SIGNED_ENCODE_INFO = _CMSG_SIGNED_ENCODE_INFO;
  PCMSG_SIGNED_ENCODE_INFO = ^_CMSG_SIGNED_ENCODE_INFO;

-- +-------------------------------------------------------------------------
--  CMSG_ENVELOPED
-- 
--  The PCERT_INFO for the rgRecipients provides the Issuer, SerialNumber
--  and PublicKeyInfo. The PublicKeyInfo.Algorithm implicitly
--  specifies the KeyEncryptionAlgorithm to be used.
-- 
--  The PublicKeyInfo.PublicKey in PCERT_INFO is used to encrypt the content
--  encryption key for the recipient.
-- 
--  hCryptProv is used to do the content encryption, recipient key encryption
--  and export. The hCryptProv's private keys aren't used. If hCryptProv
--  is NULL, a default hCryptProv is chosen according to the
--  ContentEncryptionAlgorithm and the first recipient KeyEncryptionAlgorithm.
-- 
--  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
--  passed to CryptMsgOpenToEncode(), the envelope's hCryptProv is released.
-- 
--  Note: CAPI currently doesn't support more than one KeyEncryptionAlgorithm
--  per provider. This will need to be fixed.
-- 
--  Currently, pvEncryptionAuxInfo is only defined for RC2 or RC4 encryption
--  algorithms. Otherwise, its not used and must be set to NULL.
--  See CMSG_RC2_AUX_INFO for the RC2 encryption algorithms.
--  See CMSG_RC4_AUX_INFO for the RC4 encryption algorithms.
-- 
--  To enable SP3 compatible encryption, pvEncryptionAuxInfo should point to
--  a CMSG_SP3_COMPATIBLE_AUX_INFO data structure.
-- 
--  To enable the CMS envelope enhancements, rgpRecipients must be set to
--  NULL, and rgCmsRecipients updated to point to an array of
--  CMSG_RECIPIENT_ENCODE_INFO's.
-- 
--  Also, CMS envelope enhancements support the inclusion of a bag of
--  Certs, CRLs, Attribute Certs and/or Unprotected Attributes.
-- --------------------------------------------------------------------------
type
  CMSG_RECIPIENT_ENCODE_INFO;
  PCMSG_RECIPIENT_ENCODE_INFO = ^CMSG_RECIPIENT_ENCODE_INFO;
type
  _CMSG_ENVELOPED_ENCODE_INFO = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
ContentEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
pvEncryptionAuxInfo : ^unchecked;
cRecipients     : DWORD;
rgpRecipients   : ^PCERT_INFO;
  end record;
  CMSG_ENVELOPED_ENCODE_INFO = _CMSG_ENVELOPED_ENCODE_INFO;
  PCMSG_ENVELOPED_ENCODE_INFO = ^_CMSG_ENVELOPED_ENCODE_INFO;

-- +-------------------------------------------------------------------------
--  Key Transport Recipient Encode Info
-- 
--  hCryptProv is used to do the recipient key encryption
--  and export. The hCryptProv's private keys aren't used.
-- 
--  If hCryptProv is NULL, then, the hCryptProv specified in
--  CMSG_ENVELOPED_ENCODE_INFO is used.
-- 
--  Note, even if CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
--  passed to CryptMsgOpenToEncode(), this hCryptProv isn't released.
-- 
--  CMS supports the KEY_IDENTIFIER and ISSUER_SERIAL_NUMBER CERT_IDs. PKCS #7
--  version 1.5 only supports the ISSUER_SERIAL_NUMBER CERT_ID choice.
-- --------------------------------------------------------------------------
type
  _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = record
cbSize          : DWORD;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
pvKeyEncryptionAuxInfo : ^unchecked;
hCryptProv      : t_HCRYPTPROV;
RecipientPublicKey : CRYPT_BIT_BLOB;
RecipientId     : CERT_ID;
  end record;
  CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;
  PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = ^_CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;

-- +-------------------------------------------------------------------------
--  Key Agreement Recipient Encode Info
-- 
--  If hCryptProv is NULL, then, the hCryptProv specified in
--  CMSG_ENVELOPED_ENCODE_INFO is used.
-- 
--  For the CMSG_KEY_AGREE_STATIC_KEY_CHOICE, both the hCryptProv and
--  dwKeySpec must be specified to select the sender's private key.
-- 
--  Note, even if CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
--  passed to CryptMsgOpenToEncode(), this hCryptProv isn't released.
-- 
--  CMS supports the KEY_IDENTIFIER and ISSUER_SERIAL_NUMBER CERT_IDs.
-- 
--  There is 1 key choice, ephemeral originator. The originator's ephemeral
--  key is generated using the public key algorithm parameters shared
--  amongst all the recipients.
-- 
--  There are 2 key choices: ephemeral originator or static sender. The
--  originator's ephemeral key is generated using the public key algorithm
--  parameters shared amongst all the recipients. For the static sender its
--  private key is used. The hCryptProv and dwKeySpec specify the private key.
--  The pSenderId identifies the certificate containing the sender's public key.
-- 
--  Currently, pvKeyEncryptionAuxInfo isn't used and must be set to NULL.
-- 
--  If KeyEncryptionAlgorithm.Parameters.cbData == 0, then, its Parameters
--  are updated with the encoded KeyWrapAlgorithm.
-- 
--  Currently, pvKeyWrapAuxInfo is only defined for algorithms with
--  RC2. Otherwise, its not used and must be set to NULL.
--  When set for RC2 algorithms, points to a CMSG_RC2_AUX_INFO containing
--  the RC2 effective key length.
-- 
--  Note, key agreement recipients are not supported in PKCS #7 version 1.5.
-- --------------------------------------------------------------------------
type
  _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = record
cbSize          : DWORD;
RecipientPublicKey : CRYPT_BIT_BLOB;
RecipientId     : CERT_ID;
Date            : t_FILETIME;
pOtherAttr      : PCRYPT_ATTRIBUTE_TYPE_VALUE;
  end record;
  CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;
  PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = ^_CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;

type
  _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = record
cbSize          : DWORD;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
pvKeyEncryptionAuxInfo : ^unchecked;
KeyWrapAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
pvKeyWrapAuxInfo : ^unchecked;
hCryptProv      : t_HCRYPTPROV;
dwKeySpec       : DWORD;
dwKeyChoice     : DWORD;
t_094            : record
      pEphemeralAlgorithm : PCRYPT_ALGORITHM_IDENTIFIER for position use 0;
      pSenderId     : PCERT_ID for position use 0;
    end record;
UserKeyingMaterial : CRYPT_DATA_BLOB;
cRecipientEncryptedKeys : DWORD;
rgpRecipientEncryptedKeys : ^PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;
  end record;
  CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;
  PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = ^_CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;

const
  CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE= 1;

const
  CMSG_KEY_AGREE_STATIC_KEY_CHOICE= 2;

-- +-------------------------------------------------------------------------
--  Mail List Recipient Encode Info
-- 
--  There is 1 choice for the KeyEncryptionKey: an already created CSP key
--  handle. For the key handle choice, hCryptProv must be nonzero. This key
--  handle isn't destroyed.
-- 
--  Note, even if CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
--  passed to CryptMsgOpenToEncode(), this hCryptProv isn't released.
-- 
--  Currently, pvKeyEncryptionAuxInfo is only defined for RC2 key wrap
--  algorithms. Otherwise, its not used and must be set to NULL.
--  When set for RC2 algorithms, points to a CMSG_RC2_AUX_INFO containing
--  the RC2 effective key length.
-- 
--  Note, mail list recipients are not supported in PKCS #7 version 1.5.
-- --------------------------------------------------------------------------
type
  _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = record
cbSize          : DWORD;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
pvKeyEncryptionAuxInfo : ^unchecked;
hCryptProv      : t_HCRYPTPROV;
dwKeyChoice     : DWORD;
t_095            : record
      hKeyEncryptionKey : HCRYPTKEY for position use 0;
      pvKeyEncryptionKey : ^unchecked  for position use 0;
    end record;
KeyId           : CRYPT_DATA_BLOB;
Date            : t_FILETIME;
pOtherAttr      : PCRYPT_ATTRIBUTE_TYPE_VALUE;
  end record;
  CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;
  PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = ^_CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;

const
  CMSG_MAIL_LIST_HANDLE_KEY_CHOICE= 1;

-- +-------------------------------------------------------------------------
--  Recipient Encode Info
-- 
--  Note, only key transport recipients are supported in PKCS #7 version 1.5.
-- --------------------------------------------------------------------------
type
  CMSG_RECIPIENT_ENCODE_INFO = record
dwRecipientChoice : DWORD;
t_096            : record
      pKeyTrans     : PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO for position use 0;
      pKeyAgree     : PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO for position use 0;
      pMailList     : PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO for position use 0;
    end record;
  end record;

const
  CMSG_KEY_TRANS_RECIPIENT= 1;

const
  CMSG_KEY_AGREE_RECIPIENT= 2;

const
  CMSG_MAIL_LIST_RECIPIENT= 3;

-- +-------------------------------------------------------------------------
--  CMSG_RC2_AUX_INFO
-- 
--  AuxInfo for RC2 encryption algorithms. The pvEncryptionAuxInfo field
--  in CMSG_ENCRYPTED_ENCODE_INFO should be updated to point to this
--  structure. If not specified, defaults to 40 bit.
-- 
--  Note, this AuxInfo is only used when, the ContentEncryptionAlgorithm's
--  Parameter.cbData is zero. Otherwise, the Parameters is decoded to
--  get the bit length.
-- 
--  If CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG is set in dwBitLen, then, SP3
--  compatible encryption is done and the bit length is ignored.
-- --------------------------------------------------------------------------
type
  _CMSG_RC2_AUX_INFO = record
cbSize          : DWORD;
dwBitLen        : DWORD;
  end record;
  CMSG_RC2_AUX_INFO = _CMSG_RC2_AUX_INFO;
  PCMSG_RC2_AUX_INFO = ^_CMSG_RC2_AUX_INFO;

-- +-------------------------------------------------------------------------
--  CMSG_SP3_COMPATIBLE_AUX_INFO
-- 
--  AuxInfo for enabling SP3 compatible encryption.
-- 
--  The CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG is set in dwFlags to enable SP3
--  compatible encryption. When set, uses zero salt instead of no salt,
--  the encryption algorithm parameters are NULL instead of containing the
--  encoded RC2 parameters or encoded IV octet string and the encrypted
--  symmetric key is encoded little endian instead of big endian.
-- --------------------------------------------------------------------------
type
  _CMSG_SP3_COMPATIBLE_AUX_INFO = record
cbSize          : DWORD;
dwFlags         : DWORD;
  end record;
  CMSG_SP3_COMPATIBLE_AUX_INFO = _CMSG_SP3_COMPATIBLE_AUX_INFO;
  PCMSG_SP3_COMPATIBLE_AUX_INFO = ^_CMSG_SP3_COMPATIBLE_AUX_INFO;

const
  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG= $80000000;

-- +-------------------------------------------------------------------------
--  CMSG_RC4_AUX_INFO
-- 
--  AuxInfo for RC4 encryption algorithms. The pvEncryptionAuxInfo field
--  in CMSG_ENCRYPTED_ENCODE_INFO should be updated to point to this
--  structure. If not specified, uses the CSP's default bit length with no
--  salt. Note, the base CSP has a 40 bit default and the enhanced CSP has
--  a 128 bit default.
-- 
--  If CMSG_RC4_NO_SALT_FLAG is set in dwBitLen, then, no salt is generated.
--  Otherwise, (128 - dwBitLen)/8 bytes of salt are generated and encoded
--  as an OCTET STRING in the algorithm parameters field.
-- --------------------------------------------------------------------------
type
  _CMSG_RC4_AUX_INFO = record
cbSize          : DWORD;
dwBitLen        : DWORD;
  end record;
  CMSG_RC4_AUX_INFO = _CMSG_RC4_AUX_INFO;
  PCMSG_RC4_AUX_INFO = ^_CMSG_RC4_AUX_INFO;

const
  CMSG_RC4_NO_SALT_FLAG= $40000000;

-- +-------------------------------------------------------------------------
--  CMSG_SIGNED_AND_ENVELOPED
-- 
--  For PKCS #7, a signed and enveloped message doesn't have the
--  signer's authenticated or unauthenticated attributes. Otherwise, a
--  combination of the CMSG_SIGNED_ENCODE_INFO and CMSG_ENVELOPED_ENCODE_INFO.
-- --------------------------------------------------------------------------
type
  _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = record
cbSize          : DWORD;
SignedInfo      : CMSG_SIGNED_ENCODE_INFO;
EnvelopedInfo   : CMSG_ENVELOPED_ENCODE_INFO;
  end record;
  CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;
  PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = ^_CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;

-- +-------------------------------------------------------------------------
--  CMSG_HASHED
-- 
--  hCryptProv is used to do the hash. Doesn't need to use a private key.
-- 
--  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags
--  passed to CryptMsgOpenToEncode(), the hCryptProv is released.
-- 
--  If fDetachedHash is set, then, the encoded message doesn't contain
--  any content (its treated as NULL Data)
-- 
--  pvHashAuxInfo currently isn't used and must be set to NULL.
-- --------------------------------------------------------------------------
type
  _CMSG_HASHED_ENCODE_INFO = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
HashAlgorithm   : CRYPT_ALGORITHM_IDENTIFIER;
pvHashAuxInfo   : ^unchecked;
  end record;
  CMSG_HASHED_ENCODE_INFO = _CMSG_HASHED_ENCODE_INFO;
  PCMSG_HASHED_ENCODE_INFO = ^_CMSG_HASHED_ENCODE_INFO;

-- +-------------------------------------------------------------------------
--  CMSG_ENCRYPTED
-- 
--  The key used to encrypt the message is identified outside of the message
--  content (for example, password).
-- 
--  The content input to CryptMsgUpdate has already been encrypted.
-- 
--  pvEncryptionAuxInfo currently isn't used and must be set to NULL.
-- --------------------------------------------------------------------------
type
  _CMSG_ENCRYPTED_ENCODE_INFO = record
cbSize          : DWORD;
ContentEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
pvEncryptionAuxInfo : ^unchecked;
  end record;
  CMSG_ENCRYPTED_ENCODE_INFO = _CMSG_ENCRYPTED_ENCODE_INFO;
  PCMSG_ENCRYPTED_ENCODE_INFO = ^_CMSG_ENCRYPTED_ENCODE_INFO;

-- +-------------------------------------------------------------------------
--  This parameter allows messages to be of variable length with streamed
--  output.
-- 
--  By default, messages are of a definite length and
--  CryptMsgGetParam(CMSG_CONTENT_PARAM) is
--  called to get the cryptographically processed content. Until closed,
--  the handle keeps a copy of the processed content.
-- 
--  With streamed output, the processed content can be freed as its streamed.
-- 
--  If the length of the content to be updated is known at the time of the
--  open, then, ContentLength should be set to that length. Otherwise, it
--  should be set to CMSG_INDEFINITE_LENGTH.
-- --------------------------------------------------------------------------
type
t_097=^unchecked for machine_pointer use true;
t_098=^BYTE for machine_pointer use true;

PFN_CMSG_STREAM_OUTPUT = ^procedure (
    pvArg           : in t_097;
    pbData          : in t_098;
    cbData          : in DWORD;
    fFinal          : in BOOL)
                      return BOOL for machine_pointer use true;
type
  _CMSG_STREAM_INFO = record
cbContent       : DWORD;
pfnStreamOutput : PFN_CMSG_STREAM_OUTPUT;
pvArg           : ^unchecked;
  end record;
  CMSG_STREAM_INFO  = _CMSG_STREAM_INFO;
  PCMSG_STREAM_INFO = ^_CMSG_STREAM_INFO;

-- +-------------------------------------------------------------------------
--  Open dwFlags
-- --------------------------------------------------------------------------
const
  CMSG_BARE_CONTENT_FLAG= $01;

const
  CMSG_LENGTH_ONLY_FLAG= $02;

const
  CMSG_DETACHED_FLAG= $04;

const
  CMSG_AUTHENTICATED_ATTRIBUTES_FLAG= $08;

const
  CMSG_CONTENTS_OCTETS_FLAG= $10;

const
  CMSG_MAX_LENGTH_FLAG= $20;

--  When set, nonData type inner content is encapsulated within an
--  OCTET STRING. Applicable to both Signed and Enveloped messages.
const
  CMSG_CMS_ENCAPSULATED_CONTENT_FLAG= $40;

--  If set, then, the hCryptProv passed to CryptMsgOpenToEncode or
--  CryptMsgOpenToDecode is released on the final CryptMsgClose.
--  Not released if CryptMsgOpenToEncode or CryptMsgOpenToDecode fails.
-- 
--  Note, the envelope recipient hCryptProv's aren't released.
const
  CMSG_CRYPT_RELEASE_CONTEXT_FLAG= $8000;

-- +-------------------------------------------------------------------------
--  Open a cryptographic message for encoding
-- 
--  If CMSG_BARE_CONTENT_FLAG is specified for a streamed message,
--  the streamed output will not have an outer ContentInfo wrapper. This
--  makes it suitable to be streamed into an enclosing message.
-- 
--  The pStreamInfo parameter needs to be set to stream the encoded message
--  output.
-- --------------------------------------------------------------------------
type
t_099=^unchecked for machine_pointer use true;

procedure CryptMsgOpenToEncode(
    dwMsgEncodingType : in DWORD; 
    dwFlags         : in DWORD; 
    dwMsgType       : in DWORD; 
    pvMsgEncodeInfo : in t_099; 
    pszInnerContentObjID : in {out optional} LPSTR; 
    pStreamInfo     : in {out optional} PCMSG_STREAM_INFO)
                      return t_HCRYPTMSG;
#pragma convention(CryptMsgOpenToEncode,system);
#pragma import(CryptMsgOpenToEncode,'CryptMsgOpenToEncode','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Calculate the length of an encoded cryptographic message.
-- 
--  Calculates the length of the encoded message given the
--  message type, encoding parameters and total length of
--  the data to be updated. Note, this might not be the exact length. However,
--  it will always be greater than or equal to the actual length.
-- --------------------------------------------------------------------------
type
t_100=^unchecked for machine_pointer use true;

procedure CryptMsgCalculateEncodedLength(
    dwMsgEncodingType : in DWORD; 
    dwFlags         : in DWORD; 
    dwMsgType       : in DWORD; 
    pvMsgEncodeInfo : in t_100; 
    pszInnerContentObjID : in {out optional} LPSTR; 
    cbData          : in DWORD)
                      return DWORD;
#pragma convention(CryptMsgCalculateEncodedLength,system);
#pragma import(CryptMsgCalculateEncodedLength,'CryptMsgCalculateEncodedLength','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Open a cryptographic message for decoding
-- 
--  hCryptProv specifies the crypto provider to use for hashing and/or
--  decrypting the message. If hCryptProv is NULL, a default crypt provider
--  is used.
-- 
--  Currently pRecipientInfo isn't used and should be set to NULL.
-- 
--  The pStreamInfo parameter needs to be set to stream the decoded content
--  output.
-- --------------------------------------------------------------------------
procedure CryptMsgOpenToDecode(
    dwMsgEncodingType : in DWORD; 
    dwFlags         : in DWORD; 
    dwMsgType       : in DWORD; 
    hCryptProv      : in t_HCRYPTPROV; 
    pRecipientInfo  : in {out optional} PCERT_INFO; 
    pStreamInfo     : in {out optional} PCMSG_STREAM_INFO)
                      return t_HCRYPTMSG;
#pragma convention(CryptMsgOpenToDecode,system);
#pragma import(CryptMsgOpenToDecode,'CryptMsgOpenToDecode','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Duplicate a cryptographic message handle
-- --------------------------------------------------------------------------
procedure CryptMsgDuplicate(
    hCryptMsg       : in t_HCRYPTMSG)
                      return t_HCRYPTMSG;
#pragma convention(CryptMsgDuplicate,system);
#pragma import(CryptMsgDuplicate,'CryptMsgDuplicate','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Close a cryptographic message handle
-- 
--  LastError is preserved unless FALSE is returned.
-- --------------------------------------------------------------------------
procedure CryptMsgClose(
    hCryptMsg       : in t_HCRYPTMSG)
                      return BOOL;
#pragma convention(CryptMsgClose,system);
#pragma import(CryptMsgClose,'CryptMsgClose','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Update the content of a cryptographic message. Depending on how the
--  message was opened, the content is either encoded or decoded.
-- 
--  This function is repetitively called to append to the message content.
--  fFinal is set to identify the last update. On fFinal, the encode/decode
--  is completed. The encoded/decoded content and the decoded parameters
--  are valid until the open and all duplicated handles are closed.
-- --------------------------------------------------------------------------
type
t_101=^BYTE for machine_pointer use true;

procedure CryptMsgUpdate(
    hCryptMsg       : in t_HCRYPTMSG; 
    pbData          : in t_101; 
    cbData          : in DWORD; 
    fFinal          : in BOOL)
                      return BOOL;
#pragma convention(CryptMsgUpdate,system);
#pragma import(CryptMsgUpdate,'CryptMsgUpdate','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get a parameter after encoding/decoding a cryptographic message. Called
--  after the final CryptMsgUpdate. Only the CMSG_CONTENT_PARAM and
--  CMSG_COMPUTED_HASH_PARAM are valid for an encoded message.
-- 
--  For an encoded HASHED message, the CMSG_COMPUTED_HASH_PARAM can be got
--  before any CryptMsgUpdates to get its length.
-- 
--  The pvData type definition depends on the dwParamType value.
-- 
--  Elements pointed to by fields in the pvData structure follow the
--  structure. Therefore, *pcbData may exceed the size of the structure.
-- 
--  Upon input, if *pcbData == 0, then, *pcbData is updated with the length
--  of the data and the pvData parameter is ignored.
-- 
--  Upon return, *pcbData is updated with the length of the data.
-- 
--  The OBJID BLOBs returned in the pvData structures point to
--  their still encoded representation. The appropriate functions
--  must be called to decode the information.
-- 
--  See below for a list of the parameters to get.
-- --------------------------------------------------------------------------
type
t_102=^unchecked for machine_pointer use true;

procedure CryptMsgGetParam(
    hCryptMsg       : in t_HCRYPTMSG; 
    dwParamType     : in DWORD; 
    dwIndex         : in DWORD; 
    pvData          : out {!}t_102; 
    pcbData         : in out DWORD)
                      return BOOL;
#pragma convention(CryptMsgGetParam,system);
#pragma import(CryptMsgGetParam,'CryptMsgGetParam','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get parameter types and their corresponding data structure definitions.
-- --------------------------------------------------------------------------
const
  CMSG_TYPE_PARAM   = 1;

const
  CMSG_CONTENT_PARAM= 2;

const
  CMSG_BARE_CONTENT_PARAM= 3;

const
  CMSG_INNER_CONTENT_TYPE_PARAM= 4;

const
  CMSG_SIGNER_COUNT_PARAM= 5;

const
  CMSG_SIGNER_INFO_PARAM= 6;

const
  CMSG_SIGNER_CERT_INFO_PARAM= 7;

const
  CMSG_SIGNER_HASH_ALGORITHM_PARAM= 8;

const
  CMSG_SIGNER_AUTH_ATTR_PARAM= 9;

const
  CMSG_SIGNER_UNAUTH_ATTR_PARAM= 10;

const
  CMSG_CERT_COUNT_PARAM= 11;

const
  CMSG_CERT_PARAM   = 12;

const
  CMSG_CRL_COUNT_PARAM= 13;

const
  CMSG_CRL_PARAM    = 14;

const
  CMSG_ENVELOPE_ALGORITHM_PARAM= 15;

const
  CMSG_RECIPIENT_COUNT_PARAM= 17;

const
  CMSG_RECIPIENT_INDEX_PARAM= 18;

const
  CMSG_RECIPIENT_INFO_PARAM= 19;

const
  CMSG_HASH_ALGORITHM_PARAM= 20;

const
  CMSG_HASH_DATA_PARAM= 21;

const
  CMSG_COMPUTED_HASH_PARAM= 22;

const
  CMSG_ENCRYPT_PARAM= 26;

const
  CMSG_ENCRYPTED_DIGEST= 27;

const
  CMSG_ENCODED_SIGNER= 28;

const
  CMSG_ENCODED_MESSAGE= 29;

const
  CMSG_VERSION_PARAM= 30;

const
  CMSG_ATTR_CERT_COUNT_PARAM= 31;

const
  CMSG_ATTR_CERT_PARAM= 32;

const
  CMSG_CMS_RECIPIENT_COUNT_PARAM= 33;

const
  CMSG_CMS_RECIPIENT_INDEX_PARAM= 34;

const
  CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM= 35;

const
  CMSG_CMS_RECIPIENT_INFO_PARAM= 36;

const
  CMSG_UNPROTECTED_ATTR_PARAM= 37;

const
  CMSG_SIGNER_CERT_ID_PARAM= 38;

const
  CMSG_CMS_SIGNER_INFO_PARAM= 39;

-- +-------------------------------------------------------------------------
--  CMSG_TYPE_PARAM
-- 
--  The type of the decoded message.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CONTENT_PARAM
-- 
--  The encoded content of a cryptographic message. Depending on how the
--  message was opened, the content is either the whole PKCS#7
--  message (opened to encode) or the inner content (opened to decode).
--  In the decode case, the decrypted content is returned, if enveloped.
--  If not enveloped, and if the inner content is of type DATA, the returned
--  data is the contents octets of the inner content.
-- 
--  pvData points to the buffer receiving the content bytes
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_BARE_CONTENT_PARAM
-- 
--  The encoded content of an encoded cryptographic message, without the
--  outer layer of ContentInfo. That is, only the encoding of the
--  ContentInfo.content field is returned.
-- 
--  pvData points to the buffer receiving the content bytes
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_INNER_CONTENT_TYPE_PARAM
-- 
--  The type of the inner content of a decoded cryptographic message,
--  in the form of a NULL-terminated object identifier string
--  (eg. "1.2.840.113549.1.7.1").
-- 
--  pvData points to the buffer receiving the object identifier string
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_SIGNER_COUNT_PARAM
-- 
--  Count of signers in a SIGNED or SIGNED_AND_ENVELOPED message
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_SIGNER_CERT_INFO_PARAM
-- 
--  To get all the signers, repetitively call CryptMsgGetParam, with
--  dwIndex set to 0 .. SignerCount - 1.
-- 
--  pvData points to a CERT_INFO struct.
-- 
--  Only the following fields have been updated in the CERT_INFO struct:
--  Issuer and SerialNumber.
-- 
--  Note, if the KEYID choice was selected for a CMS SignerId, then, the
--  SerialNumber is 0 and the Issuer is encoded containing a single RDN with a
--  single Attribute whose OID is szOID_KEYID_RDN, value type is
--  CERT_RDN_OCTET_STRING and value is the KEYID. When the
--  CertGetSubjectCertificateFromStore and
--  CertFindCertificateInStore(CERT_FIND_SUBJECT_CERT) APIs see this
--  special KEYID Issuer and SerialNumber, they do a KEYID match.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_SIGNER_INFO_PARAM
-- 
--  To get all the signers, repetitively call CryptMsgGetParam, with
--  dwIndex set to 0 .. SignerCount - 1.
-- 
--  pvData points to a CMSG_SIGNER_INFO struct.
-- 
--  Note, if the KEYID choice was selected for a CMS SignerId, then, the
--  SerialNumber is 0 and the Issuer is encoded containing a single RDN with a
--  single Attribute whose OID is szOID_KEYID_RDN, value type is
--  CERT_RDN_OCTET_STRING and value is the KEYID. When the
--  CertGetSubjectCertificateFromStore and
--  CertFindCertificateInStore(CERT_FIND_SUBJECT_CERT) APIs see this
--  special KEYID Issuer and SerialNumber, they do a KEYID match.
-- --------------------------------------------------------------------------
type
  _CMSG_SIGNER_INFO = record
dwVersion       : DWORD;
Issuer          : CERT_NAME_BLOB;
SerialNumber    : CRYPT_INTEGER_BLOB;
HashAlgorithm   : CRYPT_ALGORITHM_IDENTIFIER;
HashEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
EncryptedHash   : CRYPT_DATA_BLOB;
AuthAttrs       : CRYPT_ATTRIBUTES;
UnauthAttrs     : CRYPT_ATTRIBUTES;
  end record;
  CMSG_SIGNER_INFO  = _CMSG_SIGNER_INFO;
  PCMSG_SIGNER_INFO = ^_CMSG_SIGNER_INFO;

-- +-------------------------------------------------------------------------
--  CMSG_SIGNER_CERT_ID_PARAM
-- 
--  To get all the signers, repetitively call CryptMsgGetParam, with
--  dwIndex set to 0 .. SignerCount - 1.
-- 
--  pvData points to a CERT_ID struct.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CMS_SIGNER_INFO_PARAM
-- 
--  Same as CMSG_SIGNER_INFO_PARAM, except, contains SignerId instead of
--  Issuer and SerialNumber.
-- 
--  To get all the signers, repetitively call CryptMsgGetParam, with
--  dwIndex set to 0 .. SignerCount - 1.
-- 
--  pvData points to a CMSG_CMS_SIGNER_INFO struct.
-- --------------------------------------------------------------------------
type
  _CMSG_CMS_SIGNER_INFO = record
dwVersion       : DWORD;
SignerId        : CERT_ID;
HashAlgorithm   : CRYPT_ALGORITHM_IDENTIFIER;
HashEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
EncryptedHash   : CRYPT_DATA_BLOB;
AuthAttrs       : CRYPT_ATTRIBUTES;
UnauthAttrs     : CRYPT_ATTRIBUTES;
  end record;
  CMSG_CMS_SIGNER_INFO = _CMSG_CMS_SIGNER_INFO;
  PCMSG_CMS_SIGNER_INFO = ^_CMSG_CMS_SIGNER_INFO;

-- +-------------------------------------------------------------------------
--  CMSG_SIGNER_HASH_ALGORITHM_PARAM
-- 
--  This parameter specifies the HashAlgorithm that was used for the signer.
-- 
--  Set dwIndex to iterate through all the signers.
-- 
--  pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_SIGNER_AUTH_ATTR_PARAM
-- 
--  The authenticated attributes for the signer.
-- 
--  Set dwIndex to iterate through all the signers.
-- 
--  pvData points to a CMSG_ATTR struct.
-- --------------------------------------------------------------------------
type
CMSG_ATTR         = CRYPT_ATTRIBUTES;
type
PCMSG_ATTR        = ^CRYPT_ATTRIBUTES for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  CMSG_SIGNER_UNAUTH_ATTR_PARAM
-- 
--  The unauthenticated attributes for the signer.
-- 
--  Set dwIndex to iterate through all the signers.
-- 
--  pvData points to a CMSG_ATTR struct.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CERT_COUNT_PARAM
-- 
--  Count of certificates in a SIGNED or SIGNED_AND_ENVELOPED message.
-- 
--  CMS, also supports certificates in an ENVELOPED message.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CERT_PARAM
-- 
--  To get all the certificates, repetitively call CryptMsgGetParam, with
--  dwIndex set to 0 .. CertCount - 1.
-- 
--  pvData points to an array of the certificate's encoded bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CRL_COUNT_PARAM
-- 
--  Count of CRLs in a SIGNED or SIGNED_AND_ENVELOPED message.
-- 
--  CMS, also supports CRLs in an ENVELOPED message.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CRL_PARAM
-- 
--  To get all the CRLs, repetitively call CryptMsgGetParam, with
--  dwIndex set to 0 .. CrlCount - 1.
-- 
--  pvData points to an array of the CRL's encoded bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_ENVELOPE_ALGORITHM_PARAM
-- 
--  The ContentEncryptionAlgorithm that was used in
--  an ENVELOPED or SIGNED_AND_ENVELOPED message.
-- 
--  For streaming you must be able to successfully get this parameter before
--  doing a CryptMsgControl decrypt.
-- 
--  pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_RECIPIENT_COUNT_PARAM
-- 
--  Count of recipients in an ENVELOPED or SIGNED_AND_ENVELOPED message.
-- 
--  Count of key transport recepients.
-- 
--  The CMSG_CMS_RECIPIENT_COUNT_PARAM has the total count of
--  recipients (it also includes key agree and mail list recipients).
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_RECIPIENT_INDEX_PARAM
-- 
--  Index of the recipient used to decrypt an ENVELOPED or SIGNED_AND_ENVELOPED
--  message.
-- 
--  Index of a key transport recipient. If a non key transport
--  recipient was used to decrypt, fails with LastError set to
--  CRYPT_E_INVALID_INDEX.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_RECIPIENT_INFO_PARAM
-- 
--  To get all the recipients, repetitively call CryptMsgGetParam, with
--  dwIndex set to 0 .. RecipientCount - 1.
-- 
--  Only returns the key transport recepients.
-- 
--  The CMSG_CMS_RECIPIENT_INFO_PARAM returns all recipients.
-- 
--  pvData points to a CERT_INFO struct.
-- 
--  Only the following fields have been updated in the CERT_INFO struct:
--  Issuer, SerialNumber and PublicKeyAlgorithm. The PublicKeyAlgorithm
--  specifies the KeyEncryptionAlgorithm that was used.
-- 
--  Note, if the KEYID choice was selected for a key transport recipient, then,
--  the SerialNumber is 0 and the Issuer is encoded containing a single RDN
--  with a single Attribute whose OID is szOID_KEYID_RDN, value type is
--  CERT_RDN_OCTET_STRING and value is the KEYID. When the
--  CertGetSubjectCertificateFromStore and
--  CertFindCertificateInStore(CERT_FIND_SUBJECT_CERT) APIs see this
--  special KEYID Issuer and SerialNumber, they do a KEYID match.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_HASH_ALGORITHM_PARAM
-- 
--  The HashAlgorithm in a HASHED message.
-- 
--  pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_HASH_DATA_PARAM
-- 
--  The hash in a HASHED message.
-- 
--  pvData points to an array of bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_COMPUTED_HASH_PARAM
-- 
--  The computed hash for a HASHED message.
--  This may be called for either an encoded or decoded message.
-- 
--  Also, the computed hash for one of the signer's in a SIGNED message.
--  It may be called for either an encoded or decoded message after the
--  final update. Set dwIndex to iterate through all the signers.
-- 
--  pvData points to an array of bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_ENCRYPT_PARAM
-- 
--  The ContentEncryptionAlgorithm that was used in an ENCRYPTED message.
-- 
--  pvData points to an CRYPT_ALGORITHM_IDENTIFIER struct.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_ENCODED_MESSAGE
-- 
--  The full encoded message. This is useful in the case of a decoded
--  message which has been modified (eg. a signed-data or
--  signed-and-enveloped-data message which has been countersigned).
-- 
--  pvData points to an array of the message's encoded bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_VERSION_PARAM
-- 
--  The version of the decoded message.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
const
  CMSG_SIGNED_DATA_V1= 1;

const
  CMSG_SIGNED_DATA_V3= 3;

const
  CMSG_SIGNER_INFO_V1= 1;

const
  CMSG_SIGNER_INFO_V3= 3;

const
  CMSG_HASHED_DATA_V0= 0;

const
  CMSG_HASHED_DATA_V2= 2;

const
  CMSG_ENVELOPED_DATA_V0= 0;

const
  CMSG_ENVELOPED_DATA_V2= 2;

-- +-------------------------------------------------------------------------
--  CMSG_ATTR_CERT_COUNT_PARAM
-- 
--  Count of attribute certificates in a SIGNED or ENVELOPED message.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_ATTR_CERT_PARAM
-- 
--  To get all the attribute certificates, repetitively call CryptMsgGetParam,
--  with dwIndex set to 0 .. AttrCertCount - 1.
-- 
--  pvData points to an array of the attribute certificate's encoded bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CMS_RECIPIENT_COUNT_PARAM
-- 
--  Count of all CMS recipients in an ENVELOPED message.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CMS_RECIPIENT_INDEX_PARAM
-- 
--  Index of the CMS recipient used to decrypt an ENVELOPED message.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM
-- 
--  For a CMS key agreement recipient, the index of the encrypted key
--  used to decrypt an ENVELOPED message.
-- 
--  pvData points to a DWORD
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CMS_RECIPIENT_INFO_PARAM
-- 
--  To get all the CMS recipients, repetitively call CryptMsgGetParam, with
--  dwIndex set to 0 .. CmsRecipientCount - 1.
-- 
--  pvData points to a CMSG_CMS_RECIPIENT_INFO struct.
-- --------------------------------------------------------------------------
type
  _CMSG_KEY_TRANS_RECIPIENT_INFO = record
dwVersion       : DWORD;
RecipientId     : CERT_ID;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
EncryptedKey    : CRYPT_DATA_BLOB;
  end record;
  CMSG_KEY_TRANS_RECIPIENT_INFO = _CMSG_KEY_TRANS_RECIPIENT_INFO;
  PCMSG_KEY_TRANS_RECIPIENT_INFO = ^_CMSG_KEY_TRANS_RECIPIENT_INFO;

type
  _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = record
RecipientId     : CERT_ID;
EncryptedKey    : CRYPT_DATA_BLOB;
Date            : t_FILETIME;
pOtherAttr      : PCRYPT_ATTRIBUTE_TYPE_VALUE;
  end record;
  CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO;
  PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = ^_CMSG_RECIPIENT_ENCRYPTED_KEY_INFO;

type
  _CMSG_KEY_AGREE_RECIPIENT_INFO = record
dwVersion       : DWORD;
dwOriginatorChoice : DWORD;
t_103            : record
      OriginatorCertId : CERT_ID for position use 0;
      OriginatorPublicKeyInfo : CERT_PUBLIC_KEY_INFO for position use 0;
    end record;
UserKeyingMaterial : CRYPT_DATA_BLOB;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
cRecipientEncryptedKeys : DWORD;
rgpRecipientEncryptedKeys : ^PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO;
  end record;
  CMSG_KEY_AGREE_RECIPIENT_INFO = _CMSG_KEY_AGREE_RECIPIENT_INFO;
  PCMSG_KEY_AGREE_RECIPIENT_INFO = ^_CMSG_KEY_AGREE_RECIPIENT_INFO;

const
  CMSG_KEY_AGREE_ORIGINATOR_CERT= 1;

const
  CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY= 2;

type
  _CMSG_MAIL_LIST_RECIPIENT_INFO = record
dwVersion       : DWORD;
KeyId           : CRYPT_DATA_BLOB;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
EncryptedKey    : CRYPT_DATA_BLOB;
Date            : t_FILETIME;
pOtherAttr      : PCRYPT_ATTRIBUTE_TYPE_VALUE;
  end record;
  CMSG_MAIL_LIST_RECIPIENT_INFO = _CMSG_MAIL_LIST_RECIPIENT_INFO;
  PCMSG_MAIL_LIST_RECIPIENT_INFO = ^_CMSG_MAIL_LIST_RECIPIENT_INFO;

type
  _CMSG_CMS_RECIPIENT_INFO = record
dwRecipientChoice : DWORD;
t_104            : record
      pKeyTrans     : PCMSG_KEY_TRANS_RECIPIENT_INFO for position use 0;
      pKeyAgree     : PCMSG_KEY_AGREE_RECIPIENT_INFO for position use 0;
      pMailList     : PCMSG_MAIL_LIST_RECIPIENT_INFO for position use 0;
    end record;
  end record;
  CMSG_CMS_RECIPIENT_INFO = _CMSG_CMS_RECIPIENT_INFO;
  PCMSG_CMS_RECIPIENT_INFO = ^_CMSG_CMS_RECIPIENT_INFO;

--  dwVersion numbers for the KeyTrans, KeyAgree and MailList recipients
const
  CMSG_ENVELOPED_RECIPIENT_V0= 0;

const
  CMSG_ENVELOPED_RECIPIENT_V2= 2;

const
  CMSG_ENVELOPED_RECIPIENT_V3= 3;

const
  CMSG_ENVELOPED_RECIPIENT_V4= 4;

-- +-------------------------------------------------------------------------
--  CMSG_UNPROTECTED_ATTR_PARAM
-- 
--  The unprotected attributes in the envelped message.
-- 
--  pvData points to a CMSG_ATTR struct.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Perform a special "control" function after the final CryptMsgUpdate of a
--  encoded/decoded cryptographic message.
-- 
--  The dwCtrlType parameter specifies the type of operation to be performed.
-- 
--  The pvCtrlPara definition depends on the dwCtrlType value.
-- 
--  See below for a list of the control operations and their pvCtrlPara
--  type definition.
-- --------------------------------------------------------------------------
type
t_105=^unchecked for machine_pointer use true;

procedure CryptMsgControl(
    hCryptMsg       : in t_HCRYPTMSG; 
    dwFlags         : in DWORD; 
    dwCtrlType      : in DWORD; 
    pvCtrlPara      : in t_105)
                      return BOOL;
#pragma convention(CryptMsgControl,system);
#pragma import(CryptMsgControl,'CryptMsgControl','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Message control types
-- --------------------------------------------------------------------------
const
  CMSG_CTRL_VERIFY_SIGNATURE= 1;

const
  CMSG_CTRL_DECRYPT = 2;

const
  CMSG_CTRL_VERIFY_HASH= 5;

const
  CMSG_CTRL_ADD_SIGNER= 6;

const
  CMSG_CTRL_DEL_SIGNER= 7;

const
  CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR= 8;

const
  CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR= 9;

const
  CMSG_CTRL_ADD_CERT= 10;

const
  CMSG_CTRL_DEL_CERT= 11;

const
  CMSG_CTRL_ADD_CRL = 12;

const
  CMSG_CTRL_DEL_CRL = 13;

const
  CMSG_CTRL_ADD_ATTR_CERT= 14;

const
  CMSG_CTRL_DEL_ATTR_CERT= 15;

const
  CMSG_CTRL_KEY_TRANS_DECRYPT= 16;

const
  CMSG_CTRL_KEY_AGREE_DECRYPT= 17;

const
  CMSG_CTRL_MAIL_LIST_DECRYPT= 18;

const
  CMSG_CTRL_VERIFY_SIGNATURE_EX= 19;

const
  CMSG_CTRL_ADD_CMS_SIGNER_INFO= 20;

-- +-------------------------------------------------------------------------
--  CMSG_CTRL_VERIFY_SIGNATURE
-- 
--  Verify the signature of a SIGNED or SIGNED_AND_ENVELOPED
--  message after it has been decoded.
-- 
--  For a SIGNED_AND_ENVELOPED message, called after
--  CryptMsgControl(CMSG_CTRL_DECRYPT), if CryptMsgOpenToDecode was called
--  with a NULL pRecipientInfo.
-- 
--  pvCtrlPara points to a CERT_INFO struct.
-- 
--  The CERT_INFO contains the Issuer and SerialNumber identifying
--  the Signer of the message. The CERT_INFO also contains the
--  PublicKeyInfo
--  used to verify the signature. The cryptographic provider specified
--  in CryptMsgOpenToDecode is used.
-- 
--  Note, if the message contains CMS signers identified by KEYID, then,
--  the CERT_INFO's Issuer and SerialNumber is ignored and only the public
--  key is used to find a signer whose signature verifies.
-- 
--  The following CMSG_CTRL_VERIFY_SIGNATURE_EX should be used instead.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_VERIFY_SIGNATURE_EX
-- 
--  Verify the signature of a SIGNED message after it has been decoded.
-- 
--  pvCtrlPara points to the following CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA.
-- 
--  If hCryptProv is NULL, uses the cryptographic provider specified in
--  CryptMsgOpenToDecode. If CryptMsgOpenToDecode's hCryptProv is also NULL,
--  gets default provider according to the signer's public key OID.
-- 
--  dwSignerIndex is the index of the signer to use to verify the signature.
-- 
--  The signer can be a pointer to a CERT_PUBLIC_KEY_INFO, certificate
--  context or a chain context.
-- 
--  If the signer's HashEncryptionAlgorithm is szOID_PKIX_NO_SIGNATURE, then,
--  the signature is expected to contain the hash octets. Only dwSignerType
--  of CMSG_VERIFY_SIGNER_NULL may be specified to verify this no signature
--  case.
-- --------------------------------------------------------------------------
type
  _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
dwSignerIndex   : DWORD;
dwSignerType    : DWORD;
pvSigner        : ^unchecked;
  end record;
  CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;
  PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = ^_CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;

--  Signer Types
const
  CMSG_VERIFY_SIGNER_PUBKEY= 1;

--  pvSigner :: PCERT_PUBLIC_KEY_INFO
const
  CMSG_VERIFY_SIGNER_CERT= 2;

--  pvSigner :: PCCERT_CONTEXT
const
  CMSG_VERIFY_SIGNER_CHAIN= 3;

--  pvSigner :: PCCERT_CHAIN_CONTEXT
const
  CMSG_VERIFY_SIGNER_NULL= 4;

--  pvSigner :: NULL
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_DECRYPT
-- 
--  Decrypt an ENVELOPED or SIGNED_AND_ENVELOPED message after it has been
--  decoded.
-- 
--  This decrypt is only applicable to key transport recipients.
-- 
--  hCryptProv and dwKeySpec specify the private key to use. For dwKeySpec ==
--  0, defaults to AT_KEYEXCHANGE.
-- 
--  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags passed
--  to CryptMsgControl, then, the hCryptProv is released on the final
--  CryptMsgClose. Not released if CryptMsgControl fails.
-- 
--  dwRecipientIndex is the index of the recipient in the message associated
--  with the hCryptProv's private key.
-- 
--  The dwRecipientIndex is the index of a key transport recipient.
-- 
--  Note, the message can only be decrypted once.
-- --------------------------------------------------------------------------
type
  _CMSG_CTRL_DECRYPT_PARA = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
dwKeySpec       : DWORD;
dwRecipientIndex : DWORD;
  end record;
  CMSG_CTRL_DECRYPT_PARA = _CMSG_CTRL_DECRYPT_PARA;
  PCMSG_CTRL_DECRYPT_PARA = ^_CMSG_CTRL_DECRYPT_PARA;

-- +-------------------------------------------------------------------------
--  CMSG_CTRL_KEY_TRANS_DECRYPT
-- 
--  Decrypt an ENVELOPED message after it has been decoded for a key
--  transport recipient.
-- 
--  hCryptProv and dwKeySpec specify the private key to use. For dwKeySpec ==
--  0, defaults to AT_KEYEXCHANGE.
-- 
--  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags passed
--  to CryptMsgControl, then, the hCryptProv is released on the final
--  CryptMsgClose. Not released if CryptMsgControl fails.
-- 
--  pKeyTrans points to the CMSG_KEY_TRANS_RECIPIENT_INFO obtained via
--  CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM)
-- 
--  dwRecipientIndex is the index of the recipient in the message associated
--  with the hCryptProv's private key.
-- 
--  Note, the message can only be decrypted once.
-- --------------------------------------------------------------------------
type
  _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
dwKeySpec       : DWORD;
pKeyTrans       : PCMSG_KEY_TRANS_RECIPIENT_INFO;
dwRecipientIndex : DWORD;
  end record;
  CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA;
  PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = ^_CMSG_CTRL_KEY_TRANS_DECRYPT_PARA;

-- +-------------------------------------------------------------------------
--  CMSG_CTRL_KEY_AGREE_DECRYPT
-- 
--  Decrypt an ENVELOPED message after it has been decoded for a key
--  agreement recipient.
-- 
--  hCryptProv and dwKeySpec specify the private key to use. For dwKeySpec ==
--  0, defaults to AT_KEYEXCHANGE.
-- 
--  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags passed
--  to CryptMsgControl, then, the hCryptProv is released on the final
--  CryptMsgClose. Not released if CryptMsgControl fails.
-- 
--  pKeyAgree points to the CMSG_KEY_AGREE_RECIPIENT_INFO obtained via
--  CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM) for dwRecipientIndex.
-- 
--  dwRecipientIndex, dwRecipientEncryptedKeyIndex are the indices of the
--  recipient's encrypted key in the message associated with the hCryptProv's
--  private key.
-- 
--  OriginatorPublicKey is the originator's public key obtained from either
--  the originator's certificate or the CMSG_KEY_AGREE_RECIPIENT_INFO obtained
--  via the CMSG_CMS_RECIPIENT_INFO_PARAM.
-- 
--  Note, the message can only be decrypted once.
-- --------------------------------------------------------------------------
type
  _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
dwKeySpec       : DWORD;
pKeyAgree       : PCMSG_KEY_AGREE_RECIPIENT_INFO;
dwRecipientIndex : DWORD;
dwRecipientEncryptedKeyIndex : DWORD;
OriginatorPublicKey : CRYPT_BIT_BLOB;
  end record;
  CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA;
  PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = ^_CMSG_CTRL_KEY_AGREE_DECRYPT_PARA;

-- +-------------------------------------------------------------------------
--  CMSG_CTRL_MAIL_LIST_DECRYPT
-- 
--  Decrypt an ENVELOPED message after it has been decoded for a mail
--  list recipient.
-- 
--  pMailList points to the CMSG_MAIL_LIST_RECIPIENT_INFO obtained via
--  CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM) for dwRecipientIndex.
-- 
--  There is 1 choice for the KeyEncryptionKey: an already created CSP key
--  handle. For the key handle choice, hCryptProv must be nonzero. This key
--  handle isn't destroyed.
-- 
--  If CMSG_CRYPT_RELEASE_CONTEXT_FLAG is set in the dwFlags passed
--  to CryptMsgControl, then, the hCryptProv is released on the final
--  CryptMsgClose. Not released if CryptMsgControl fails.
-- 
--  For RC2 wrap, the effective key length is obtained from the
--  KeyEncryptionAlgorithm parameters and set on the hKeyEncryptionKey before
--  decrypting.
-- 
--  Note, the message can only be decrypted once.
-- --------------------------------------------------------------------------
type
  _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
pMailList       : PCMSG_MAIL_LIST_RECIPIENT_INFO;
dwRecipientIndex : DWORD;
dwKeyChoice     : DWORD;
t_106            : record
      hKeyEncryptionKey : HCRYPTKEY for position use 0;
      pvKeyEncryptionKey : ^unchecked  for position use 0;
    end record;
  end record;
  CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA;
  PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = ^_CMSG_CTRL_MAIL_LIST_DECRYPT_PARA;

-- +-------------------------------------------------------------------------
--  CMSG_CTRL_VERIFY_HASH
-- 
--  Verify the hash of a HASHED message after it has been decoded.
-- 
--  Only the hCryptMsg parameter is used, to specify the message whose
--  hash is being verified.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_ADD_SIGNER
-- 
--  Add a signer to a signed-data message.
-- 
--  pvCtrlPara points to a CMSG_SIGNER_ENCODE_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_ADD_CMS_SIGNER_INFO
-- 
--  Add a signer to a signed-data message.
-- 
--  Differs from the above, CMSG_CTRL_ADD_SIGNER, wherein, the signer info
--  already contains the signature.
-- 
--  pvCtrlPara points to a CMSG_CMS_SIGNER_INFO.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_DEL_SIGNER
-- 
--  Remove a signer from a signed-data or signed-and-enveloped-data message.
-- 
--  pvCtrlPara points to a DWORD containing the 0-based index of the
--  signer to be removed.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR
-- 
--  Add an unauthenticated attribute to the SignerInfo of a signed-data or
--  signed-and-enveloped-data message.
-- 
--  The unauthenticated attribute is input in the form of an encoded blob.
-- --------------------------------------------------------------------------
type
  _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = record
cbSize          : DWORD;
dwSignerIndex   : DWORD;
blob            : CRYPT_DATA_BLOB;
  end record;
  CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;
  PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = ^_CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;

-- +-------------------------------------------------------------------------
--  CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR
-- 
--  Delete an unauthenticated attribute from the SignerInfo of a signed-data
--  or signed-and-enveloped-data message.
-- 
--  The unauthenticated attribute to be removed is specified by
--  a 0-based index.
-- --------------------------------------------------------------------------
type
  _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = record
cbSize          : DWORD;
dwSignerIndex   : DWORD;
dwUnauthAttrIndex : DWORD;
  end record;
  CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;
  PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = ^_CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;

-- +-------------------------------------------------------------------------
--  CMSG_CTRL_ADD_CERT
-- 
--  Add a certificate to a signed-data or signed-and-enveloped-data message.
-- 
--  pvCtrlPara points to a CRYPT_DATA_BLOB containing the certificate's
--  encoded bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_DEL_CERT
-- 
--  Delete a certificate from a signed-data or signed-and-enveloped-data
--  message.
-- 
--  pvCtrlPara points to a DWORD containing the 0-based index of the
--  certificate to be removed.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_ADD_CRL
-- 
--  Add a CRL to a signed-data or signed-and-enveloped-data message.
-- 
--  pvCtrlPara points to a CRYPT_DATA_BLOB containing the CRL's
--  encoded bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_DEL_CRL
-- 
--  Delete a CRL from a signed-data or signed-and-enveloped-data message.
-- 
--  pvCtrlPara points to a DWORD containing the 0-based index of the CRL
--  to be removed.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_ADD_ATTR_CERT
-- 
--  Add an attribute certificate to a signed-data message.
-- 
--  pvCtrlPara points to a CRYPT_DATA_BLOB containing the attribute
--  certificate's encoded bytes.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CMSG_CTRL_DEL_ATTR_CERT
-- 
--  Delete an attribute certificate from a signed-data message.
-- 
--  pvCtrlPara points to a DWORD containing the 0-based index of the
--  attribute certificate to be removed.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Verify a countersignature, at the SignerInfo level.
--  ie. verify that pbSignerInfoCountersignature contains the encrypted
--  hash of the encryptedDigest field of pbSignerInfo.
-- 
--  hCryptProv is used to hash the encryptedDigest field of pbSignerInfo.
--  The only fields referenced from pciCountersigner are SerialNumber, Issuer,
--  and SubjectPublicKeyInfo.
-- --------------------------------------------------------------------------
procedure CryptMsgVerifyCountersignatureEncoded(
    hCryptProv      : in t_HCRYPTPROV; 
    dwEncodingType  : in DWORD; 
    pbSignerInfo    : in PBYTE; 
    cbSignerInfo    : in DWORD; 
    pbSignerInfoCountersignature : in PBYTE; 
    cbSignerInfoCountersignature : in DWORD; 
    pciCountersigner : in PCERT_INFO)
                      return BOOL;
#pragma convention(CryptMsgVerifyCountersignatureEncoded,system);
#pragma import(CryptMsgVerifyCountersignatureEncoded,'CryptMsgVerifyCountersignatureEncoded','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify a countersignature, at the SignerInfo level.
--  ie. verify that pbSignerInfoCountersignature contains the encrypted
--  hash of the encryptedDigest field of pbSignerInfo.
-- 
--  hCryptProv is used to hash the encryptedDigest field of pbSignerInfo.
-- 
--  The signer can be a CERT_PUBLIC_KEY_INFO, certificate context or a
--  chain context.
-- --------------------------------------------------------------------------
type
t_107=^unchecked for machine_pointer use true;

t_108=^unchecked for machine_pointer use true;

procedure CryptMsgVerifyCountersignatureEncodedEx(
    hCryptProv      : in t_HCRYPTPROV; 
    dwEncodingType  : in DWORD; 
    pbSignerInfo    : in PBYTE; 
    cbSignerInfo    : in DWORD; 
    pbSignerInfoCountersignature : in PBYTE; 
    cbSignerInfoCountersignature : in DWORD; 
    dwSignerType    : in DWORD; 
    pvSigner        : in t_107; 
    dwFlags         : in DWORD; 
    pvReserved      : in {out optional} t_108)
                      return BOOL;
#pragma convention(CryptMsgVerifyCountersignatureEncodedEx,system);
#pragma import(CryptMsgVerifyCountersignatureEncodedEx,'CryptMsgVerifyCountersignatureEncodedEx','crypt32.dll');

--  See CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA for dwSignerType definitions
-- +-------------------------------------------------------------------------
--  Countersign an already-existing signature in a message
-- 
--  dwIndex is a zero-based index of the SignerInfo to be countersigned.
-- --------------------------------------------------------------------------
procedure CryptMsgCountersign(
    hCryptMsg       : in out unchecked ; 
    dwIndex         : in DWORD; 
    cCountersigners : in DWORD; 
    rgCountersigners : in PCMSG_SIGNER_ENCODE_INFO)
                      return BOOL;
#pragma convention(CryptMsgCountersign,system);
#pragma import(CryptMsgCountersign,'CryptMsgCountersign','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Countersign an already-existing signature (encoded SignerInfo).
--  Output an encoded SignerInfo blob, suitable for use as a countersignature
--  attribute in the unauthenticated attributes of a signed-data or
--  signed-and-enveloped-data message.
-- --------------------------------------------------------------------------
procedure CryptMsgCountersignEncoded(
    dwEncodingType  : in DWORD; 
    pbSignerInfo    : in PBYTE; 
    cbSignerInfo    : in DWORD; 
    cCountersigners : in DWORD; 
    rgCountersigners : in PCMSG_SIGNER_ENCODE_INFO; 
    pbCountersignature : out BYTE ; 
    pcbCountersignature : in out DWORD )
                      return BOOL;
#pragma convention(CryptMsgCountersignEncoded,system);
#pragma import(CryptMsgCountersignEncoded,'CryptMsgCountersignEncoded','crypt32.dll');

-- +-------------------------------------------------------------------------
--  CryptMsg OID installable functions
-- --------------------------------------------------------------------------
type
  t_109 = ^unchecked for machine_pointer use true;

PFN_CMSG_ALLOC    = ^procedure (
    cb              : in size_t)
                      return t_109 for machine_pointer use true;
type
t_110=^unchecked for machine_pointer use true;

PFN_CMSG_FREE     = ^procedure (
    pv              : in t_110) for machine_pointer use true;
--  Note, the following 3 installable functions are obsolete and have been
--  replaced with GenContentEncryptKey, ExportKeyTrans, ExportKeyAgree,
--  ExportMailList, ImportKeyTrans, ImportKeyAgree and ImportMailList
--  installable functions.
--  If *phCryptProv is NULL upon entry, then, if supported, the installable
--  function should acquire a default provider and return. Note, its up
--  to the installable function to release at process detach.
-- 
--  If paiEncrypt->Parameters.cbData is 0, then, the callback may optionally
--  return default encoded parameters in *ppbEncryptParameters and
--  *pcbEncryptParameters. pfnAlloc must be called for the allocation.
type
PFN_CMSG_GEN_ENCRYPT_KEY = ^procedure (
    phCryptProv     : in out t_HCRYPTPROV;
    paiEncrypt      : in PCRYPT_ALGORITHM_IDENTIFIER;
    pvEncryptAuxInfo : in PVOID;
    pPublicKeyInfo  : in PCERT_PUBLIC_KEY_INFO;
    pfnAlloc        : in PFN_CMSG_ALLOC;
    phEncryptKey    : out HCRYPTKEY;
    ppbEncryptParameters : out PBYTE;
    pcbEncryptParameters : out DWORD )
                      return BOOL for machine_pointer use true;
type
PFN_CMSG_EXPORT_ENCRYPT_KEY = ^procedure (
    hCryptProv      : in t_HCRYPTPROV;
    hEncryptKey     : in HCRYPTKEY;
    pPublicKeyInfo  : in PCERT_PUBLIC_KEY_INFO;
    pbData          : out BYTE ;
    pcbData         : in out DWORD )
                      return BOOL for machine_pointer use true;
type
PFN_CMSG_IMPORT_ENCRYPT_KEY = ^procedure (
    hCryptProv      : in t_HCRYPTPROV;
    dwKeySpec       : in DWORD;
    paiEncrypt      : in PCRYPT_ALGORITHM_IDENTIFIER;
    paiPubKey       : in PCRYPT_ALGORITHM_IDENTIFIER;
    pbEncodedKey    : in PBYTE;
    cbEncodedKey    : in DWORD;
    phEncryptKey    : out HCRYPTKEY)
                      return BOOL for machine_pointer use true;
--  To get the default installable function for GenContentEncryptKey,
--  ExportKeyTrans, ExportKeyAgree, ExportMailList, ImportKeyTrans,
--  ImportKeyAgree or ImportMailList call CryptGetOIDFunctionAddress()
--  with the pszOID argument set to the following constant. dwEncodingType
--  should be set to CRYPT_ASN_ENCODING or X509_ASN_ENCODING.
-- +-------------------------------------------------------------------------
--  Content Encrypt Info
-- 
--  The following data structure contains the information shared between
--  the GenContentEncryptKey and the ExportKeyTrans, ExportKeyAgree and
--  ExportMailList installable functions.
-- --------------------------------------------------------------------------
type
  _CMSG_CONTENT_ENCRYPT_INFO = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
ContentEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
pvEncryptionAuxInfo : ^unchecked;
cRecipients     : DWORD;
rgCmsRecipients : PCMSG_RECIPIENT_ENCODE_INFO;
pfnAlloc        : PFN_CMSG_ALLOC;
pfnFree         : PFN_CMSG_FREE;
dwEncryptFlags  : DWORD;
hContentEncryptKey : HCRYPTKEY;
dwFlags         : DWORD;
  end record;
  CMSG_CONTENT_ENCRYPT_INFO = _CMSG_CONTENT_ENCRYPT_INFO;
  PCMSG_CONTENT_ENCRYPT_INFO = ^_CMSG_CONTENT_ENCRYPT_INFO;

const
  CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG= $01;

const
  CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG= $01;

const
  CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG= $8000;

-- +-------------------------------------------------------------------------
--  Upon input, ContentEncryptInfo has been initialized from the
--  EnvelopedEncodeInfo.
-- 
--  Note, if rgpRecipients instead of rgCmsRecipients are set in the
--  EnvelopedEncodeInfo, then, the rgpRecipients have been converted
--  to rgCmsRecipients in the ContentEncryptInfo.
-- 
--  The following fields may be changed in ContentEncryptInfo:
--  hContentEncryptKey
--  hCryptProv
--  ContentEncryptionAlgorithm.Parameters
--  dwFlags
-- 
--  All other fields in the ContentEncryptInfo are READONLY.
-- 
--  If CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG is set upon entry
--  in dwEncryptFlags, then, any potentially variable length encoded
--  output should be padded with zeroes to always obtain the
--  same maximum encoded length. This is necessary for
--  CryptMsgCalculateEncodedLength() or CryptMsgOpenToEncode() with
--  definite length streaming.
-- 
--  The hContentEncryptKey must be updated.
-- 
--  If hCryptProv is NULL upon input, then, it must be updated.
--  If a HCRYPTPROV is acquired that must be released, then, the
--  CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG must be set in dwFlags.
-- 
--  If ContentEncryptionAlgorithm.Parameters is updated, then, the
--  CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG must be set in dwFlags. pfnAlloc and
--  pfnFree must be used for doing the allocation.
-- 
--  ContentEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
-- --------------------------------------------------------------------------
type
t_111=^unchecked for machine_pointer use true;

PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY = ^procedure (
    pContentEncryptInfo : in out _CMSG_CONTENT_ENCRYPT_INFO;
    dwFlags         : in DWORD;
    pvReserved      : in {out optional} t_111)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Key Transport Encrypt Info
-- 
--  The following data structure contains the information updated by the
--  ExportKeyTrans installable function.
-- --------------------------------------------------------------------------
type
  _CMSG_KEY_TRANS_ENCRYPT_INFO = record
cbSize          : DWORD;
dwRecipientIndex : DWORD;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
EncryptedKey    : CRYPT_DATA_BLOB;
dwFlags         : DWORD;
  end record;
  CMSG_KEY_TRANS_ENCRYPT_INFO = _CMSG_KEY_TRANS_ENCRYPT_INFO;
  PCMSG_KEY_TRANS_ENCRYPT_INFO = ^_CMSG_KEY_TRANS_ENCRYPT_INFO;

const
  CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG= $01;

-- +-------------------------------------------------------------------------
--  Upon input, KeyTransEncryptInfo has been initialized from the
--  KeyTransEncodeInfo.
-- 
--  The following fields may be changed in KeyTransEncryptInfo:
--  EncryptedKey
--  KeyEncryptionAlgorithm.Parameters
--  dwFlags
-- 
--  All other fields in the KeyTransEncryptInfo are READONLY.
-- 
--  The EncryptedKey must be updated. The pfnAlloc and pfnFree specified in
--  ContentEncryptInfo must be used for doing the allocation.
-- 
--  If the KeyEncryptionAlgorithm.Parameters is updated, then, the
--  CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG must be set in dwFlags.
--  The pfnAlloc and pfnFree specified in ContentEncryptInfo must be used
--  for doing the allocation.
-- 
--  KeyEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
-- --------------------------------------------------------------------------
type
t_112=^unchecked for machine_pointer use true;

PFN_CMSG_EXPORT_KEY_TRANS = ^procedure (
    pContentEncryptInfo : in PCMSG_CONTENT_ENCRYPT_INFO;
    pKeyTransEncodeInfo : in PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;
    pKeyTransEncryptInfo : in out _CMSG_KEY_TRANS_ENCRYPT_INFO;
    dwFlags         : in DWORD;
    pvReserved      : in {out optional} t_112)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Key Agree Key Encrypt Info
-- 
--  The following data structure contains the information updated by the
--  ExportKeyAgree installable function for each encrypted key agree
--  recipient.
-- --------------------------------------------------------------------------
type
  _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = record
cbSize          : DWORD;
EncryptedKey    : CRYPT_DATA_BLOB;
  end record;
  CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO;
  PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = ^_CMSG_KEY_AGREE_KEY_ENCRYPT_INFO;

-- +-------------------------------------------------------------------------
--  Key Agree Encrypt Info
-- 
--  The following data structure contains the information applicable to
--  all recipients. Its updated by the ExportKeyAgree installable function.
-- --------------------------------------------------------------------------
type
  _CMSG_KEY_AGREE_ENCRYPT_INFO = record
cbSize          : DWORD;
dwRecipientIndex : DWORD;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
UserKeyingMaterial : CRYPT_DATA_BLOB;
dwOriginatorChoice : DWORD;
t_113            : record
      OriginatorCertId : CERT_ID for position use 0;
      OriginatorPublicKeyInfo : CERT_PUBLIC_KEY_INFO for position use 0;
    end record;
cKeyAgreeKeyEncryptInfo : DWORD;
rgpKeyAgreeKeyEncryptInfo : ^PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO;
dwFlags         : DWORD;
  end record;
  CMSG_KEY_AGREE_ENCRYPT_INFO = _CMSG_KEY_AGREE_ENCRYPT_INFO;
  PCMSG_KEY_AGREE_ENCRYPT_INFO = ^_CMSG_KEY_AGREE_ENCRYPT_INFO;

const
  CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG= $01;

const
  CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG= $02;

const
  CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG= $04;

const
  CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG= $08;

const
  CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG= $10;

-- +-------------------------------------------------------------------------
--  Upon input, KeyAgreeEncryptInfo has been initialized from the
--  KeyAgreeEncodeInfo.
-- 
--  The following fields may be changed in KeyAgreeEncryptInfo:
--  KeyEncryptionAlgorithm.Parameters
--  UserKeyingMaterial
--  dwOriginatorChoice
--  OriginatorCertId
--  OriginatorPublicKeyInfo
--  dwFlags
-- 
--  All other fields in the KeyAgreeEncryptInfo are READONLY.
-- 
--  If the KeyEncryptionAlgorithm.Parameters is updated, then, the
--  CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG must be set in dwFlags.
--  The pfnAlloc and pfnFree specified in ContentEncryptInfo must be used
--  for doing the allocation.
-- 
--  If the UserKeyingMaterial is updated, then, the
--  CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG must be set in dwFlags.
--  pfnAlloc and pfnFree must be used for doing the allocation.
-- 
--  The dwOriginatorChoice must be updated to either
--  CMSG_KEY_AGREE_ORIGINATOR_CERT or CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY.
-- 
--  If the OriginatorPublicKeyInfo is updated, then, the appropriate
--  CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_*_FLAG must be set in dwFlags and
--  pfnAlloc and pfnFree must be used for doing the allocation.
-- 
--  If CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG is set upon entry
--  in pContentEncryptInfo->dwEncryptFlags, then, the OriginatorPublicKeyInfo's
--  Ephemeral PublicKey should be padded with zeroes to always obtain the
--  same maximum encoded length. Note, the length of the generated ephemeral Y
--  public key can vary depending on the number of leading zero bits.
-- 
--  Upon input, the array of *rgpKeyAgreeKeyEncryptInfo has been initialized.
--  The EncryptedKey must be updated for each recipient key.
--  The pfnAlloc and pfnFree specified in
--  ContentEncryptInfo must be used for doing the allocation.
-- 
--  KeyEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
-- --------------------------------------------------------------------------
type
t_114=^unchecked for machine_pointer use true;

PFN_CMSG_EXPORT_KEY_AGREE = ^procedure (
    pContentEncryptInfo : in PCMSG_CONTENT_ENCRYPT_INFO;
    pKeyAgreeEncodeInfo : in PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;
    pKeyAgreeEncryptInfo : in out _CMSG_KEY_AGREE_ENCRYPT_INFO;
    dwFlags         : in DWORD;
    pvReserved      : in {out optional} t_114)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Mail List Encrypt Info
-- 
--  The following data structure contains the information updated by the
--  ExportMailList installable function.
-- --------------------------------------------------------------------------
type
  _CMSG_MAIL_LIST_ENCRYPT_INFO = record
cbSize          : DWORD;
dwRecipientIndex : DWORD;
KeyEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
EncryptedKey    : CRYPT_DATA_BLOB;
dwFlags         : DWORD;
  end record;
  CMSG_MAIL_LIST_ENCRYPT_INFO = _CMSG_MAIL_LIST_ENCRYPT_INFO;
  PCMSG_MAIL_LIST_ENCRYPT_INFO = ^_CMSG_MAIL_LIST_ENCRYPT_INFO;

const
  CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG= $01;

-- +-------------------------------------------------------------------------
--  Upon input, MailListEncryptInfo has been initialized from the
--  MailListEncodeInfo.
-- 
--  The following fields may be changed in MailListEncryptInfo:
--  EncryptedKey
--  KeyEncryptionAlgorithm.Parameters
--  dwFlags
-- 
--  All other fields in the MailListEncryptInfo are READONLY.
-- 
--  The EncryptedKey must be updated. The pfnAlloc and pfnFree specified in
--  ContentEncryptInfo must be used for doing the allocation.
-- 
--  If the KeyEncryptionAlgorithm.Parameters is updated, then, the
--  CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG must be set in dwFlags.
--  The pfnAlloc and pfnFree specified in ContentEncryptInfo must be used
--  for doing the allocation.
-- 
--  KeyEncryptionAlgorithm.pszObjId is used to get the OIDFunctionAddress.
-- --------------------------------------------------------------------------
type
t_115=^unchecked for machine_pointer use true;

PFN_CMSG_EXPORT_MAIL_LIST = ^procedure (
    pContentEncryptInfo : in PCMSG_CONTENT_ENCRYPT_INFO;
    pMailListEncodeInfo : in PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;
    pMailListEncryptInfo : in out _CMSG_MAIL_LIST_ENCRYPT_INFO;
    dwFlags         : in DWORD;
    pvReserved      : in {out optional} t_115)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  OID Installable functions for importing an encoded and encrypted content
--  encryption key.
-- 
--  There's a different installable function for each CMS Recipient choice:
--  ImportKeyTrans
--  ImportKeyAgree
--  ImportMailList
-- 
--  Iterates through the following OIDs to get the OID installable function:
--  KeyEncryptionOID!ContentEncryptionOID
--  KeyEncryptionOID
--  ContentEncryptionOID
-- 
--  If the OID installable function doesn't support the specified
--  KeyEncryption and ContentEncryption OIDs, then, return FALSE with
--  LastError set to E_NOTIMPL.
-- --------------------------------------------------------------------------
type
t_116=^unchecked for machine_pointer use true;

PFN_CMSG_IMPORT_KEY_TRANS = ^procedure (
    pContentEncryptionAlgorithm : in PCRYPT_ALGORITHM_IDENTIFIER;
    pKeyTransDecryptPara : in PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA;
    dwFlags         : in DWORD;
    pvReserved      : in {out optional} t_116;
    phContentEncryptKey : out HCRYPTKEY)
                      return BOOL for machine_pointer use true;
type
t_117=^unchecked for machine_pointer use true;

PFN_CMSG_IMPORT_KEY_AGREE = ^procedure (
    pContentEncryptionAlgorithm : in PCRYPT_ALGORITHM_IDENTIFIER;
    pKeyAgreeDecryptPara : in PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA;
    dwFlags         : in DWORD;
    pvReserved      : in {out optional} t_117;
    phContentEncryptKey : out HCRYPTKEY)
                      return BOOL for machine_pointer use true;
type
t_118=^unchecked for machine_pointer use true;

PFN_CMSG_IMPORT_MAIL_LIST = ^procedure (
    pContentEncryptionAlgorithm : in PCRYPT_ALGORITHM_IDENTIFIER;
    pMailListDecryptPara : in PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA;
    dwFlags         : in DWORD;
    pvReserved      : in {out optional} t_118;
    phContentEncryptKey : out HCRYPTKEY)
                      return BOOL for machine_pointer use true;
-- +=========================================================================
--  Certificate Store Data Structures and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  In its most basic implementation, a cert store is simply a
--  collection of certificates and/or CRLs. This is the case when
--  a cert store is opened with all of its certificates and CRLs
--  coming from a PKCS #7 encoded cryptographic message.
-- 
--  Nonetheless, all cert stores have the following properties:
--  - A public key may have more than one certificate in the store.
--  For example, a private/public key used for signing may have a
--  certificate issued for VISA and another issued for
--  Mastercard. Also, when a certificate is renewed there might
--  be more than one certificate with the same subject and
--  issuer.
--  - However, each certificate in the store is uniquely
--  identified by its Issuer and SerialNumber.
--  - There's an issuer of subject certificate relationship. A
--  certificate's issuer is found by doing a match of
--  pSubjectCert->Issuer with pIssuerCert->Subject.
--  The relationship is verified by using
--  the issuer's public key to verify the subject certificate's
--  signature. Note, there might be X.509 v3 extensions
--  to assist in finding the issuer certificate.
--  - Since issuer certificates might be renewed, a subject
--  certificate might have more than one issuer certificate.
--  - There's an issuer of CRL relationship. An
--  issuer's CRL is found by doing a match of
--  pIssuerCert->Subject with pCrl->Issuer.
--  The relationship is verified by using
--  the issuer's public key to verify the CRL's
--  signature. Note, there might be X.509 v3 extensions
--  to assist in finding the CRL.
--  - Since some issuers might support the X.509 v3 delta CRL
--  extensions, an issuer might have more than one CRL.
--  - The store shouldn't have any redundant certificates or
--  CRLs. There shouldn't be two certificates with the same
--  Issuer and SerialNumber. There shouldn't be two CRLs with
--  the same Issuer, ThisUpdate and NextUpdate.
--  - The store has NO policy or trust information. No
--  certificates are tagged as being "root". Its up to
--  the application to maintain a list of CertIds (Issuer +
--  SerialNumber) for certificates it trusts.
--  - The store might contain bad certificates and/or CRLs.
--  The issuer's signature of a subject certificate or CRL may
--  not verify. Certificates or CRLs may not satisfy their
--  time validity requirements. Certificates may be
--  revoked.
-- 
--  In addition to the certificates and CRLs, properties can be
--  stored. There are two predefined property IDs for a user
--  certificate: CERT_KEY_PROV_HANDLE_PROP_ID and
--  CERT_KEY_PROV_INFO_PROP_ID. The CERT_KEY_PROV_HANDLE_PROP_ID
--  is a HCRYPTPROV handle to the private key assoicated
--  with the certificate. The CERT_KEY_PROV_INFO_PROP_ID contains
--  information to be used to call
--  CryptAcquireContext and CryptSetProvParam to get a handle
--  to the private key associated with the certificate.
-- 
--  There exists two more predefined property IDs for certificates
--  and CRLs, CERT_SHA1_HASH_PROP_ID and CERT_MD5_HASH_PROP_ID.
--  If these properties don't already exist, then, a hash of the
--  content is computed. (CERT_HASH_PROP_ID maps to the default
--  hash algorithm, currently, CERT_SHA1_HASH_PROP_ID).
-- 
--  There are additional APIs for creating certificate and CRL
--  contexts not in a store (CertCreateCertificateContext and
--  CertCreateCRLContext).
-- 
-- --------------------------------------------------------------------------
type
t_HCERTSTORE      = ^unchecked for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Certificate context.
-- 
--  A certificate context contains both the encoded and decoded representation
--  of a certificate. A certificate context returned by a cert store function
--  must be freed by calling the CertFreeCertificateContext function. The
--  CertDuplicateCertificateContext function can be called to make a duplicate
--  copy (which also must be freed by calling CertFreeCertificateContext).
-- --------------------------------------------------------------------------
type
  _CERT_CONTEXT     = record
dwCertEncodingType : DWORD;
pbCertEncoded   : ^BYTE;
cbCertEncoded   : DWORD;
pCertInfo       : PCERT_INFO;
hCertStore      : t_HCERTSTORE;
  end record;
  CERT_CONTEXT      = _CERT_CONTEXT;
  PCERT_CONTEXT     = ^_CERT_CONTEXT;

type
PCCERT_CONTEXT    = ^CERT_CONTEXT for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  CRL context.
-- 
--  A CRL context contains both the encoded and decoded representation
--  of a CRL. A CRL context returned by a cert store function
--  must be freed by calling the CertFreeCRLContext function. The
--  CertDuplicateCRLContext function can be called to make a duplicate
--  copy (which also must be freed by calling CertFreeCRLContext).
-- --------------------------------------------------------------------------
type
  _CRL_CONTEXT      = record
dwCertEncodingType : DWORD;
pbCrlEncoded    : ^BYTE;
cbCrlEncoded    : DWORD;
pCrlInfo        : PCRL_INFO;
hCertStore      : t_HCERTSTORE;
  end record;
  CRL_CONTEXT       = _CRL_CONTEXT;
  PCRL_CONTEXT      = ^_CRL_CONTEXT;

type
PCCRL_CONTEXT     = ^CRL_CONTEXT for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Certificate Trust List (CTL) context.
-- 
--  A CTL context contains both the encoded and decoded representation
--  of a CTL. Also contains an opened HCRYPTMSG handle to the decoded
--  cryptographic signed message containing the CTL_INFO as its inner content.
--  pbCtlContent is the encoded inner content of the signed message.
-- 
--  The CryptMsg APIs can be used to extract additional signer information.
-- --------------------------------------------------------------------------
type
  _CTL_CONTEXT      = record
dwMsgAndCertEncodingType : DWORD;
pbCtlEncoded    : ^BYTE;
cbCtlEncoded    : DWORD;
pCtlInfo        : PCTL_INFO;
hCertStore      : t_HCERTSTORE;
hCryptMsg       : t_HCRYPTMSG;
pbCtlContent    : ^BYTE;
cbCtlContent    : DWORD;
  end record;
  CTL_CONTEXT       = _CTL_CONTEXT;
  PCTL_CONTEXT      = ^_CTL_CONTEXT;

type
PCCTL_CONTEXT     = ^CTL_CONTEXT for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Certificate, CRL and CTL property IDs
-- 
--  See CertSetCertificateContextProperty or CertGetCertificateContextProperty
--  for usage information.
-- --------------------------------------------------------------------------
const
  CERT_KEY_PROV_HANDLE_PROP_ID= 1;

const
  CERT_KEY_PROV_INFO_PROP_ID= 2;

const
  CERT_SHA1_HASH_PROP_ID= 3;

const
  CERT_MD5_HASH_PROP_ID= 4;

const
  CERT_KEY_CONTEXT_PROP_ID= 5;

const
  CERT_KEY_SPEC_PROP_ID= 6;

const
  CERT_IE30_RESERVED_PROP_ID= 7;

const
  CERT_PUBKEY_HASH_RESERVED_PROP_ID= 8;

const
  CERT_ENHKEY_USAGE_PROP_ID= 9;

const
  CERT_NEXT_UPDATE_LOCATION_PROP_ID= 10;

const
  CERT_FRIENDLY_NAME_PROP_ID= 11;

const
  CERT_PVK_FILE_PROP_ID= 12;

const
  CERT_DESCRIPTION_PROP_ID= 13;

const
  CERT_ACCESS_STATE_PROP_ID= 14;

const
  CERT_SIGNATURE_HASH_PROP_ID= 15;

const
  CERT_SMART_CARD_DATA_PROP_ID= 16;

const
  CERT_EFS_PROP_ID  = 17;

const
  CERT_FORTEZZA_DATA_PROP_ID= 18;

const
  CERT_ARCHIVED_PROP_ID= 19;

const
  CERT_KEY_IDENTIFIER_PROP_ID= 20;

const
  CERT_AUTO_ENROLL_PROP_ID= 21;

const
  CERT_PUBKEY_ALG_PARA_PROP_ID= 22;

const
  CERT_CROSS_CERT_DIST_POINTS_PROP_ID= 23;

const
  CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID= 24;

const
  CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID= 25;

const
  CERT_ENROLLMENT_PROP_ID= 26;

const
  CERT_DATE_STAMP_PROP_ID= 27;

const
  CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID= 28;

const
  CERT_SUBJECT_NAME_MD5_HASH_PROP_ID= 29;

const
  CERT_EXTENDED_ERROR_INFO_PROP_ID= 30;

--  Note, 32 - 35 are reserved for the CERT, CRL, CTL and KeyId file element IDs.
--  36 - 63 are reserved for future element IDs.
const
  CERT_RENEWAL_PROP_ID= 64;

const
  CERT_ARCHIVED_KEY_HASH_PROP_ID= 65;

const
  CERT_AUTO_ENROLL_RETRY_PROP_ID= 66;

const
  CERT_AIA_URL_RETRIEVED_PROP_ID= 67;

const
  CERT_FIRST_RESERVED_PROP_ID= 68;

const
  CERT_LAST_RESERVED_PROP_ID= $7FFF;

const
  CERT_FIRST_USER_PROP_ID= $8000;

const
  CERT_LAST_USER_PROP_ID= $FFFF;

-- +-------------------------------------------------------------------------
--  Property OIDs
-- --------------------------------------------------------------------------
--  The OID component following the prefix contains the PROP_ID (decimal)
-- +-------------------------------------------------------------------------
--  Access State flags returned by CERT_ACCESS_STATE_PROP_ID. Note,
--  CERT_ACCESS_PROP_ID is read only.
-- --------------------------------------------------------------------------
--  Set if context property writes are persisted. For instance, not set for
--  memory store contexts. Set for registry based stores opened as read or write.
--  Not set for registry based stores opened as read only.
const
  CERT_ACCESS_STATE_WRITE_PERSIST_FLAG= $01;

--  Set if context resides in a SYSTEM or SYSTEM_REGISTRY store.
const
  CERT_ACCESS_STATE_SYSTEM_STORE_FLAG= $02;

--  Set if context resides in a LocalMachine SYSTEM or SYSTEM_REGISTRY store.
const
  CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG= $04;

-- +-------------------------------------------------------------------------
--  Cryptographic Key Provider Information
-- 
--  CRYPT_KEY_PROV_INFO defines the CERT_KEY_PROV_INFO_PROP_ID's pvData.
-- 
--  The CRYPT_KEY_PROV_INFO fields are passed to CryptAcquireContext
--  to get a HCRYPTPROV handle. The optional CRYPT_KEY_PROV_PARAM fields are
--  passed to CryptSetProvParam to further initialize the provider.
-- 
--  The dwKeySpec field identifies the private key to use from the container
--  For example, AT_KEYEXCHANGE or AT_SIGNATURE.
-- --------------------------------------------------------------------------
type
  _CRYPT_KEY_PROV_PARAM = record
dwParam         : DWORD;
pbData          : ^BYTE;
cbData          : DWORD;
dwFlags         : DWORD;
  end record;
  CRYPT_KEY_PROV_PARAM = _CRYPT_KEY_PROV_PARAM;
  PCRYPT_KEY_PROV_PARAM = ^_CRYPT_KEY_PROV_PARAM;

type
  _CRYPT_KEY_PROV_INFO = record
pwszContainerName : LPWSTR;
pwszProvName    : LPWSTR;
dwProvType      : DWORD;
dwFlags         : DWORD;
cProvParam      : DWORD;
rgProvParam     : PCRYPT_KEY_PROV_PARAM;
dwKeySpec       : DWORD;
  end record;
  CRYPT_KEY_PROV_INFO = _CRYPT_KEY_PROV_INFO;
  PCRYPT_KEY_PROV_INFO = ^_CRYPT_KEY_PROV_INFO;

-- +-------------------------------------------------------------------------
--  The following flag should be set in the above dwFlags to enable
--  a CertSetCertificateContextProperty(CERT_KEY_CONTEXT_PROP_ID) after a
--  CryptAcquireContext is done in the Sign or Decrypt Message functions.
-- 
--  The following define must not collide with any of the
--  CryptAcquireContext dwFlag defines.
-- --------------------------------------------------------------------------
const
  CERT_SET_KEY_PROV_HANDLE_PROP_ID= $01;

const
  CERT_SET_KEY_CONTEXT_PROP_ID= $01;

-- +-------------------------------------------------------------------------
--  Certificate Key Context
-- 
--  CERT_KEY_CONTEXT defines the CERT_KEY_CONTEXT_PROP_ID's pvData.
-- --------------------------------------------------------------------------
type
  _CERT_KEY_CONTEXT = record
cbSize          : DWORD;
hCryptProv      : t_HCRYPTPROV;
dwKeySpec       : DWORD;
  end record;
  CERT_KEY_CONTEXT  = _CERT_KEY_CONTEXT;
  PCERT_KEY_CONTEXT = ^_CERT_KEY_CONTEXT;

-- +-------------------------------------------------------------------------
--  Certificate Store Provider Types
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Certificate Store verify/results flags
-- --------------------------------------------------------------------------
const
  CERT_STORE_SIGNATURE_FLAG= $01;

const
  CERT_STORE_TIME_VALIDITY_FLAG= $02;

const
  CERT_STORE_REVOCATION_FLAG= $04;

const
  CERT_STORE_NO_CRL_FLAG= $10000;

const
  CERT_STORE_NO_ISSUER_FLAG= $20000;

const
  CERT_STORE_BASE_CRL_FLAG= $0100;

const
  CERT_STORE_DELTA_CRL_FLAG= $0200;

-- +-------------------------------------------------------------------------
--  Certificate Store open/property flags
-- --------------------------------------------------------------------------
const
  CERT_STORE_NO_CRYPT_RELEASE_FLAG= $01;

const
  CERT_STORE_SET_LOCALIZED_NAME_FLAG= $02;

const
  CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG= $04;

const
  CERT_STORE_DELETE_FLAG= $10;

const
  CERT_STORE_UNSAFE_PHYSICAL_FLAG= $20;

const
  CERT_STORE_SHARE_STORE_FLAG= $40;

const
  CERT_STORE_SHARE_CONTEXT_FLAG= $80;

const
  CERT_STORE_MANIFOLD_FLAG= $0100;

const
  CERT_STORE_ENUM_ARCHIVED_FLAG= $0200;

const
  CERT_STORE_UPDATE_KEYID_FLAG= $0400;

const
  CERT_STORE_BACKUP_RESTORE_FLAG= $0800;

const
  CERT_STORE_READONLY_FLAG= $8000;

const
  CERT_STORE_OPEN_EXISTING_FLAG= $4000;

const
  CERT_STORE_CREATE_NEW_FLAG= $2000;

const
  CERT_STORE_MAXIMUM_ALLOWED_FLAG= $1000;

-- +-------------------------------------------------------------------------
--  Certificate Store Provider flags are in the HiWord (0xFFFF0000)
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Certificate System Store Flag Values
-- --------------------------------------------------------------------------
--  Includes flags and location
const
  CERT_SYSTEM_STORE_MASK= $FFFF0000;

--  Set if pvPara points to a CERT_SYSTEM_STORE_RELOCATE_PARA structure
const
  CERT_SYSTEM_STORE_RELOCATE_FLAG= $80000000;

type
  _CERT_SYSTEM_STORE_RELOCATE_PARA = record
t_119            : record
      hKeyBase      : t_HKEY for position use 0;
      pvBase        : ^unchecked  for position use 0;
    end record;
t_120            : record
      pvSystemStore : ^unchecked  for position use 0;
      pszSystemStore : LPCSTR for position use 0;
      pwszSystemStore : LPCWSTR for position use 0;
    end record;
  end record;
  CERT_SYSTEM_STORE_RELOCATE_PARA = _CERT_SYSTEM_STORE_RELOCATE_PARA;
  PCERT_SYSTEM_STORE_RELOCATE_PARA = ^_CERT_SYSTEM_STORE_RELOCATE_PARA;

--  By default, when the CurrentUser "Root" store is opened, any SystemRegistry
--  roots not also on the protected root list are deleted from the cache before
--  CertOpenStore() returns. Set the following flag to return all the roots
--  in the SystemRegistry without checking the protected root list.
const
  CERT_SYSTEM_STORE_UNPROTECTED_FLAG= $40000000;

--  Location of the system store:
const
  CERT_SYSTEM_STORE_LOCATION_MASK= $FF0000;

const
  CERT_SYSTEM_STORE_LOCATION_SHIFT= 16;

--  Registry: HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE
const
  CERT_SYSTEM_STORE_CURRENT_USER_ID= 1;

const
  CERT_SYSTEM_STORE_LOCAL_MACHINE_ID= 2;

--  Registry: HKEY_LOCAL_MACHINE\Software\Microsoft\Cryptography\Services
const
  CERT_SYSTEM_STORE_CURRENT_SERVICE_ID= 4;

const
  CERT_SYSTEM_STORE_SERVICES_ID= 5;

--  Registry: HKEY_USERS
const
  CERT_SYSTEM_STORE_USERS_ID= 6;

--  Registry: HKEY_CURRENT_USER\Software\Policies\Microsoft\SystemCertificates
const
  CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID= 7;

--  Registry: HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\SystemCertificates
const
  CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID= 8;

--  Registry: HKEY_LOCAL_MACHINE\Software\Microsoft\EnterpriseCertificates
const
  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID= 9;

-- +-------------------------------------------------------------------------
--  Group Policy Store Defines
-- --------------------------------------------------------------------------
--  Registry path to the Group Policy system stores
-- +-------------------------------------------------------------------------
--  EFS Defines
-- --------------------------------------------------------------------------
--  Registry path to the EFS EFSBlob SubKey - Value type is REG_BINARY
-- +-------------------------------------------------------------------------
--  Protected Root Defines
-- --------------------------------------------------------------------------
--  Registry path to the Protected Roots Flags SubKey
--  Set the following flag to inhibit the opening of the CurrentUser's
--  .Default physical store when opening the CurrentUser's "Root" system store.
--  The .Default physical store open's the CurrentUser SystemRegistry "Root"
--  store.
const
  CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG= $01;

--  Set the following flag to inhibit the adding of roots from the
--  CurrentUser SystemRegistry "Root" store to the protected root list
--  when the "Root" store is initially protected.
const
  CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG= $02;

--  Set the following flag to inhibit the purging of protected roots from the
--  CurrentUser SystemRegistry "Root" store that are
--  also in the LocalMachine SystemRegistry "Root" store. Note, when not
--  disabled, the purging is done silently without UI.
const
  CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG= $04;

--  Set the following flag to inhibit the opening of the LocalMachine's
--  .AuthRoot physical store when opening the LocalMachine's "Root" system store.
--  The .AuthRoot physical store open's the LocalMachine SystemRegistry
--  "AuthRoot" store. The "AuthRoot" store contains the pre-installed
--  SSL ServerAuth and the ActiveX Authenticode "root" certificates.
const
  CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG= $08;

--  The semantics for the following legacy definition has been changed to be
--  the same as for the CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG.
const
  CERT_PROT_ROOT_ONLY_LM_GPT_FLAG= $08;

--  Set the following flag to disable the requiring of the issuing CA
--  certificate being in the "NTAuth" system registry store found in the
--  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE store location.
-- 
--  When set, CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)
--  will check that the chain has a valid name constraint for all name
--  spaces, including UPN if the issuing CA isn't in the "NTAuth" store.
const
  CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG= $10;

--  Set the following flag to disable checking for not defined name
--  constraints.
-- 
--  When set, CertGetCertificateChain won't check for or set the following
--  dwErrorStatus: CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT.
const
  CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG= $20;

-- +-------------------------------------------------------------------------
--  Trusted Publisher Definitions
-- --------------------------------------------------------------------------
--  Registry path to the trusted publisher "Safer" group policy subkey
--  Registry path to the Local Machine system stores
--  Registry path to the trusted publisher "Safer" local machine subkey
--  "Safer" subkey value names. All values are DWORDs.
--  AuthenticodeFlags definitions
--  Definition of who is allowed to trust publishers
-- 
--  Setting allowed trust to MACHINE_ADMIN or ENTERPRISE_ADMIN disables UI,
--  only trusts publishers in the "TrustedPublisher" system store and
--  inhibits the opening of the CurrentUser's .Default physical store when
--  opening the CurrentUsers's "TrustedPublisher" system store.
-- 
--  The .Default physical store open's the CurrentUser SystemRegistry
--  "TrustedPublisher" store.
-- 
--  Setting allowed trust to ENTERPRISE_ADMIN only opens the
--  LocalMachine's .GroupPolicy and .Enterprise physical stores when opening
--  the CurrentUser's "TrustedPublisher" system store or when opening the
--  LocalMachine's "TrustedPublisher" system store.
const
  CERT_TRUST_PUB_ALLOW_TRUST_MASK= $03;

const
  CERT_TRUST_PUB_ALLOW_END_USER_TRUST= $00;

const
  CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST= $01;

const
  CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST= $02;

--  Set the following flag to enable revocation checking of the publisher
--  chain.
const
  CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG= $0100;

--  Set the following flag to enable revocation checking of the time stamp
--  chain.
const
  CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG= $0200;

-- +-------------------------------------------------------------------------
--  OCM Subcomponents Definitions
-- --------------------------------------------------------------------------
--  Registry path to the OCM Subcomponents local machine subkey
--  REG_DWORD, 1 is installed, 0 is NOT installed
-- +-------------------------------------------------------------------------
--  AuthRoot Auto Update Definitions
-- --------------------------------------------------------------------------
--  Registry path to the AuthRoot "Auto Update" local machine subkey
--  AuthRoot Auto Update subkey value names.
--  REG_SZ, URL to the directory containing the AuthRoots, CTL and Seq files
--  REG_DWORD, seconds between syncs. 0 implies use default.
--  REG_DWORD, misc flags
const
  CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG= $01;

const
  CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG= $02;

--  AuthRoot Auto Update filenames
--  CTL containing the list of certs in the AuthRoot store
--  Cab containing the above CTL
--  SequenceNumber (Formatted as big endian ascii hex)
--  Root certs extension
-- +-------------------------------------------------------------------------
--  Certificate Registry Store Flag Values (CERT_STORE_REG)
-- --------------------------------------------------------------------------
--  Set this flag if the HKEY passed in pvPara points to a remote computer
--  registry key.
const
  CERT_REGISTRY_STORE_REMOTE_FLAG= $10000;

--  Set this flag if the contexts are to be persisted as a single serialized
--  store in the registry. Mainly used for stores downloaded from the GPT.
--  Such as the CurrentUserGroupPolicy or LocalMachineGroupPolicy stores.
const
  CERT_REGISTRY_STORE_SERIALIZED_FLAG= $20000;

--  The following flags are for internal use. When set, the
--  pvPara parameter passed to CertOpenStore is a pointer to the following
--  data structure and not the HKEY. The above CERT_REGISTRY_STORE_REMOTE_FLAG
--  is also set if hKeyBase was obtained via RegConnectRegistry().
const
  CERT_REGISTRY_STORE_CLIENT_GPT_FLAG= $80000000;

const
  CERT_REGISTRY_STORE_LM_GPT_FLAG= $1000000;

type
  _CERT_REGISTRY_STORE_CLIENT_GPT_PARA = record
hKeyBase        : t_HKEY;
pwszRegPath     : LPWSTR;
  end record;
  CERT_REGISTRY_STORE_CLIENT_GPT_PARA = _CERT_REGISTRY_STORE_CLIENT_GPT_PARA;
  PCERT_REGISTRY_STORE_CLIENT_GPT_PARA = ^_CERT_REGISTRY_STORE_CLIENT_GPT_PARA;

--  The following flag is for internal use. When set, the contexts are
--  persisted into roaming files instead of the registry. Such as, the
--  CurrentUser "My" store. When this flag is set, the following data structure
--  is passed to CertOpenStore instead of HKEY.
const
  CERT_REGISTRY_STORE_ROAMING_FLAG= $40000;

--  hKey may be NULL or non-NULL. When non-NULL, existing contexts are
--  moved from the registry to roaming files.
type
  _CERT_REGISTRY_STORE_ROAMING_PARA = record
hKey            : t_HKEY;
pwszStoreDirectory : LPWSTR;
  end record;
  CERT_REGISTRY_STORE_ROAMING_PARA = _CERT_REGISTRY_STORE_ROAMING_PARA;
  PCERT_REGISTRY_STORE_ROAMING_PARA = ^_CERT_REGISTRY_STORE_ROAMING_PARA;

--  The following flag is for internal use. When set, the "My" DWORD value
--  at HKLM\Software\Microsoft\Cryptography\IEDirtyFlags is set to 0x1
--  whenever a certificate is added to the registry store.
-- 
--  Legacy definition, no longer supported after 01-May-02 (Server 2003)
const
  CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG= $80000;

--  Registry path to the subkey containing the "My" DWORD value to be set
-- 
--  Legacy definition, no longer supported after 01-May-02 (Server 2003)
-- +-------------------------------------------------------------------------
--  Certificate File Store Flag Values for the providers:
--  CERT_STORE_PROV_FILE
--  CERT_STORE_PROV_FILENAME
--  CERT_STORE_PROV_FILENAME_A
--  CERT_STORE_PROV_FILENAME_W
--  sz_CERT_STORE_PROV_FILENAME_W
-- --------------------------------------------------------------------------
--  Set this flag if any store changes are to be committed to the file.
--  The changes are committed at CertCloseStore or by calling
--  CertControlStore(CERT_STORE_CTRL_COMMIT).
-- 
--  The open fails with E_INVALIDARG if both CERT_FILE_STORE_COMMIT_ENABLE_FLAG
--  and CERT_STORE_READONLY_FLAG are set in dwFlags.
-- 
--  For the FILENAME providers: if the file contains an X509 encoded
--  certificate, the open fails with ERROR_ACCESS_DENIED.
-- 
--  For the FILENAME providers: if CERT_STORE_CREATE_NEW_FLAG is set, the
--  CreateFile uses CREATE_NEW. If CERT_STORE_OPEN_EXISTING is set, uses
--  OPEN_EXISTING. Otherwise, defaults to OPEN_ALWAYS.
-- 
--  For the FILENAME providers: the file is committed as either a PKCS7 or
--  serialized store depending on the type read at open. However, if the
--  file is empty then, if the filename has either a ".p7c" or ".spc"
--  extension its committed as a PKCS7. Otherwise, its committed as a
--  serialized store.
-- 
--  For CERT_STORE_PROV_FILE, the file handle is duplicated. Its always
--  committed as a serialized store.
-- 
const
  CERT_FILE_STORE_COMMIT_ENABLE_FLAG= $10000;

-- +-------------------------------------------------------------------------
--  Certificate LDAP Store Flag Values for the providers:
--  CERT_STORE_PROV_LDAP
--  CERT_STORE_PROV_LDAP_W
--  sz_CERT_STORE_PROV_LDAP_W
--  sz_CERT_STORE_PROV_LDAP
-- --------------------------------------------------------------------------
--  Set this flag to digitally sign all of the ldap traffic to and from a
--  Windows 2000 LDAP server using the Kerberos authentication protocol.
--  This feature provides integrity required by some applications. 
-- 
const
  CERT_LDAP_STORE_SIGN_FLAG= $10000;

--  Performs an A-Record only DNS lookup on the supplied host string.
--  This prevents bogus DNS queries from being generated when resolving host
--  names. Use this flag whenever passing a hostname as opposed to a
--  domain name for the hostname parameter. 
-- 
--  See LDAP_OPT_AREC_EXCLUSIVE defined in winldap.h for more details.
const
  CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG= $20000;

--  Set this flag if the LDAP session handle has already been opened. When
--  set, pvPara points to the following CERT_LDAP_STORE_OPENED_PARA structure.
const
  CERT_LDAP_STORE_OPENED_FLAG= $40000;

type
  _CERT_LDAP_STORE_OPENED_PARA = record
pvLdapSessionHandle : ^unchecked;
pwszLdapUrl     : LPCWSTR;
  end record;
  CERT_LDAP_STORE_OPENED_PARA = _CERT_LDAP_STORE_OPENED_PARA;
  PCERT_LDAP_STORE_OPENED_PARA = ^_CERT_LDAP_STORE_OPENED_PARA;

--  Set this flag if the above CERT_LDAP_STORE_OPENED_FLAG is set and
--  you want an ldap_unbind() of the above pvLdapSessionHandle when the
--  store is closed. Note, if CertOpenStore() fails, then, ldap_unbind()
--  isn't called.
const
  CERT_LDAP_STORE_UNBIND_FLAG= $80000;

-- +-------------------------------------------------------------------------
--  Open the cert store using the specified store provider.
-- 
--  If CERT_STORE_DELETE_FLAG is set, then, the store is deleted. NULL is
--  returned for both success and failure. However, GetLastError() returns 0
--  for success and nonzero for failure.
-- 
--  If CERT_STORE_SET_LOCALIZED_NAME_FLAG is set, then, if supported, the
--  provider sets the store's CERT_STORE_LOCALIZED_NAME_PROP_ID property.
--  The store's localized name can be retrieved by calling
--  CertSetStoreProperty(dwPropID = CERT_STORE_LOCALIZED_NAME_PROP_ID).
--  This flag is supported by the following providers (and their sz_
--  equivalent):
--  CERT_STORE_PROV_FILENAME_A
--  CERT_STORE_PROV_FILENAME_W
--  CERT_STORE_PROV_SYSTEM_A
--  CERT_STORE_PROV_SYSTEM_W
--  CERT_STORE_PROV_SYSTEM_REGISTRY_A
--  CERT_STORE_PROV_SYSTEM_REGISTRY_W
--  CERT_STORE_PROV_PHYSICAL_W
-- 
--  If CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG is set, then, the
--  closing of the store's provider is deferred until all certificate,
--  CRL and CTL contexts obtained from the store are freed. Also,
--  if a non NULL HCRYPTPROV was passed, then, it will continue to be used.
--  By default, the store's provider is closed on the final CertCloseStore.
--  If this flag isn't set, then, any property changes made to previously
--  duplicated contexts after the final CertCloseStore will not be persisted.
--  By setting this flag, property changes made
--  after the CertCloseStore will be persisted. Note, setting this flag
--  causes extra overhead in doing context duplicates and frees.
--  If CertCloseStore is called with CERT_CLOSE_STORE_FORCE_FLAG, then,
--  the CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG flag is ignored.
-- 
--  CERT_STORE_MANIFOLD_FLAG can be set to check for certificates having the
--  manifold extension and archive the "older" certificates with the same
--  manifold extension value. A certificate is archived by setting the
--  CERT_ARCHIVED_PROP_ID.
-- 
--  By default, contexts having the CERT_ARCHIVED_PROP_ID, are skipped
--  during enumeration. CERT_STORE_ENUM_ARCHIVED_FLAG can be set to include
--  archived contexts when enumerating. Note, contexts having the
--  CERT_ARCHIVED_PROP_ID are still found for explicit finds, such as,
--  finding a context with a specific hash or finding a certificate having
--  a specific issuer and serial number.
-- 
--  CERT_STORE_UPDATE_KEYID_FLAG can be set to also update the Key Identifier's
--  CERT_KEY_PROV_INFO_PROP_ID property whenever a certificate's
--  CERT_KEY_IDENTIFIER_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID property is set
--  and the other property already exists. If the Key Identifier's
--  CERT_KEY_PROV_INFO_PROP_ID already exists, it isn't updated. Any
--  errors encountered are silently ignored.
-- 
--  By default, this flag is implicitly set for the "My\.Default" CurrentUser
--  and LocalMachine physical stores.
-- 
--  CERT_STORE_READONLY_FLAG can be set to open the store as read only.
--  Otherwise, the store is opened as read/write.
-- 
--  CERT_STORE_OPEN_EXISTING_FLAG can be set to only open an existing
--  store. CERT_STORE_CREATE_NEW_FLAG can be set to create a new store and
--  fail if the store already exists. Otherwise, the default is to open
--  an existing store or create a new store if it doesn't already exist.
-- 
--  hCryptProv specifies the crypto provider to use to create the hash
--  properties or verify the signature of a subject certificate or CRL.
--  The store doesn't need to use a private
--  key. If the CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, hCryptProv is
--  CryptReleaseContext'ed on the final CertCloseStore.
-- 
--  Note, if the open fails, hCryptProv is released if it would have been
--  released when the store was closed.
-- 
--  If hCryptProv is zero, then, the default provider and container for the
--  PROV_RSA_FULL provider type is CryptAcquireContext'ed with
--  CRYPT_VERIFYCONTEXT access. The CryptAcquireContext is deferred until
--  the first create hash or verify signature. In addition, once acquired,
--  the default provider isn't released until process exit when crypt32.dll
--  is unloaded. The acquired default provider is shared across all stores
--  and threads.
-- 
--  After initializing the store's data structures and optionally acquiring a
--  default crypt provider, CertOpenStore calls CryptGetOIDFunctionAddress to
--  get the address of the CRYPT_OID_OPEN_STORE_PROV_FUNC specified by
--  lpszStoreProvider. Since a store can contain certificates with different
--  encoding types, CryptGetOIDFunctionAddress is called with dwEncodingType
--  set to 0 and not the dwEncodingType passed to CertOpenStore.
--  PFN_CERT_DLL_OPEN_STORE_FUNC specifies the signature of the provider's
--  open function. This provider open function is called to load the
--  store's certificates and CRLs. Optionally, the provider may return an
--  array of functions called before a certificate or CRL is added or deleted
--  or has a property that is set.
-- 
--  Use of the dwEncodingType parameter is provider dependent. The type
--  definition for pvPara also depends on the provider.
-- 
--  Store providers are installed or registered via
--  CryptInstallOIDFunctionAddress or CryptRegisterOIDFunction, where,
--  dwEncodingType is 0 and pszFuncName is CRYPT_OID_OPEN_STORE_PROV_FUNC.
-- 
--  Here's a list of the predefined provider types (implemented in crypt32.dll):
-- 
--  CERT_STORE_PROV_MSG:
--  Gets the certificates and CRLs from the specified cryptographic message.
--  dwEncodingType contains the message and certificate encoding types.
--  The message's handle is passed in pvPara. Given,
--  HCRYPTMSG hCryptMsg; pvPara = (const void *) hCryptMsg;
-- 
--  CERT_STORE_PROV_MEMORY
--  sz_CERT_STORE_PROV_MEMORY:
--  Opens a store without any initial certificates or CRLs. pvPara
--  isn't used.
-- 
--  CERT_STORE_PROV_FILE:
--  Reads the certificates and CRLs from the specified file. The file's
--  handle is passed in pvPara. Given,
--  HANDLE hFile; pvPara = (const void *) hFile;
-- 
--  For a successful open, the file pointer is advanced past
--  the certificates and CRLs and their properties read from the file.
--  Note, only expects a serialized store and not a file containing
--  either a PKCS #7 signed message or a single encoded certificate.
-- 
--  The hFile isn't closed.
-- 
--  CERT_STORE_PROV_REG:
--  Reads the certificates and CRLs from the registry. The registry's
--  key handle is passed in pvPara. Given,
--  HKEY hKey; pvPara = (const void *) hKey;
-- 
--  The input hKey isn't closed by the provider. Before returning, the
--  provider opens it own copy of the hKey.
-- 
--  If CERT_STORE_READONLY_FLAG is set, then, the registry subkeys are
--  RegOpenKey'ed with KEY_READ_ACCESS. Otherwise, the registry subkeys
--  are RegCreateKey'ed with KEY_ALL_ACCESS.
-- 
--  This provider returns the array of functions for reading, writing,
--  deleting and property setting certificates and CRLs.
--  Any changes to the opened store are immediately pushed through to
--  the registry. However, if CERT_STORE_READONLY_FLAG is set, then,
--  writing, deleting or property setting results in a
--  SetLastError(E_ACCESSDENIED).
-- 
--  Note, all the certificates and CRLs are read from the registry
--  when the store is opened. The opened store serves as a write through
--  cache.
-- 
--  If CERT_REGISTRY_STORE_SERIALIZED_FLAG is set, then, the
--  contexts are persisted as a single serialized store subkey in the
--  registry.
-- 
--  CERT_STORE_PROV_PKCS7:
--  sz_CERT_STORE_PROV_PKCS7:
--  Gets the certificates and CRLs from the encoded PKCS #7 signed message.
--  dwEncodingType specifies the message and certificate encoding types.
--  The pointer to the encoded message's blob is passed in pvPara. Given,
--  CRYPT_DATA_BLOB EncodedMsg; pvPara = (const void *) &EncodedMsg;
-- 
--  Note, also supports the IE3.0 special version of a
--  PKCS #7 signed message referred to as a "SPC" formatted message.
-- 
--  CERT_STORE_PROV_SERIALIZED:
--  sz_CERT_STORE_PROV_SERIALIZED:
--  Gets the certificates and CRLs from memory containing a serialized
--  store. The pointer to the serialized memory blob is passed in pvPara.
--  Given,
--  CRYPT_DATA_BLOB Serialized; pvPara = (const void *) &Serialized;
-- 
--  CERT_STORE_PROV_FILENAME_A:
--  CERT_STORE_PROV_FILENAME_W:
--  CERT_STORE_PROV_FILENAME:
--  sz_CERT_STORE_PROV_FILENAME_W:
--  sz_CERT_STORE_PROV_FILENAME:
--  Opens the file and first attempts to read as a serialized store. Then,
--  as a PKCS #7 signed message. Finally, as a single encoded certificate.
--  The filename is passed in pvPara. The filename is UNICODE for the
--  "_W" provider and ASCII for the "_A" provider. For "_W": given,
--  LPCWSTR pwszFilename; pvPara = (const void *) pwszFilename;
--  For "_A": given,
--  LPCSTR pszFilename; pvPara = (const void *) pszFilename;
-- 
--  Note, the default (without "_A" or "_W") is unicode.
-- 
--  Note, also supports the reading of the IE3.0 special version of a
--  PKCS #7 signed message file referred to as a "SPC" formatted file.
-- 
--  CERT_STORE_PROV_SYSTEM_A:
--  CERT_STORE_PROV_SYSTEM_W:
--  CERT_STORE_PROV_SYSTEM:
--  sz_CERT_STORE_PROV_SYSTEM_W:
--  sz_CERT_STORE_PROV_SYSTEM:
--  Opens the specified logical "System" store. The upper word of the
--  dwFlags parameter is used to specify the location of the system store.
-- 
--  A "System" store is a collection consisting of one or more "Physical"
--  stores. A "Physical" store is registered via the
--  CertRegisterPhysicalStore API. Each of the registered physical stores
--  is CertStoreOpen'ed and added to the collection via
--  CertAddStoreToCollection.
-- 
--  The CERT_SYSTEM_STORE_CURRENT_USER, CERT_SYSTEM_STORE_LOCAL_MACHINE,
--  CERT_SYSTEM_STORE_CURRENT_SERVICE, CERT_SYSTEM_STORE_SERVICES,
--  CERT_SYSTEM_STORE_USERS, CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY,
--  CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY and
--  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRSE
--  system stores by default have a "SystemRegistry" store that is
--  opened and added to the collection.
-- 
--  The system store name is passed in pvPara. The name is UNICODE for the
--  "_W" provider and ASCII for the "_A" provider. For "_W": given,
--  LPCWSTR pwszSystemName; pvPara = (const void *) pwszSystemName;
--  For "_A": given,
--  LPCSTR pszSystemName; pvPara = (const void *) pszSystemName;
-- 
--  Note, the default (without "_A" or "_W") is UNICODE.
-- 
--  The system store name can't contain any backslashes.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvPara
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure instead
--  of pointing to a null terminated UNICODE or ASCII string.
--  Sibling physical stores are also opened as relocated using
--  pvPara's hKeyBase.
-- 
--  The CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS system
--  store name must be prefixed with the ServiceName or UserName.
--  For example, "ServiceName\Trust".
-- 
--  Stores on remote computers can be accessed for the
--  CERT_SYSTEM_STORE_LOCAL_MACHINE, CERT_SYSTEM_STORE_SERVICES,
--  CERT_SYSTEM_STORE_USERS, CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
--  or CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
--  locations by prepending the computer name. For example, a remote
--  local machine store is accessed via "\\ComputerName\Trust" or
--  "ComputerName\Trust". A remote service store is accessed via
--  "\\ComputerName\ServiceName\Trust". The leading "\\" backslashes are
--  optional in the ComputerName.
-- 
--  If CERT_STORE_READONLY_FLAG is set, then, the registry is
--  RegOpenKey'ed with KEY_READ_ACCESS. Otherwise, the registry is
--  RegCreateKey'ed with KEY_ALL_ACCESS.
-- 
--  The "root" store is treated differently from the other system
--  stores. Before a certificate is added to or deleted from the "root"
--  store, a pop up message box is displayed. The certificate's subject,
--  issuer, serial number, time validity, sha1 and md5 thumbprints are
--  displayed. The user is given the option to do the add or delete.
--  If they don't allow the operation, LastError is set to E_ACCESSDENIED.
-- 
--  CERT_STORE_PROV_SYSTEM_REGISTRY_A
--  CERT_STORE_PROV_SYSTEM_REGISTRY_W
--  CERT_STORE_PROV_SYSTEM_REGISTRY
--  sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W
--  sz_CERT_STORE_PROV_SYSTEM_REGISTRY
--  Opens the "System" store's default "Physical" store residing in the
--  registry. The upper word of the dwFlags
--  parameter is used to specify the location of the system store.
-- 
--  After opening the registry key associated with the system name,
--  the CERT_STORE_PROV_REG provider is called to complete the open.
-- 
--  The system store name is passed in pvPara. The name is UNICODE for the
--  "_W" provider and ASCII for the "_A" provider. For "_W": given,
--  LPCWSTR pwszSystemName; pvPara = (const void *) pwszSystemName;
--  For "_A": given,
--  LPCSTR pszSystemName; pvPara = (const void *) pszSystemName;
-- 
--  Note, the default (without "_A" or "_W") is UNICODE.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvPara
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure instead
--  of pointing to a null terminated UNICODE or ASCII string.
-- 
--  See above for details on prepending a ServiceName and/or ComputerName
--  to the store name.
-- 
--  If CERT_STORE_READONLY_FLAG is set, then, the registry is
--  RegOpenKey'ed with KEY_READ_ACCESS. Otherwise, the registry is
--  RegCreateKey'ed with KEY_ALL_ACCESS.
-- 
--  The "root" store is treated differently from the other system
--  stores. Before a certificate is added to or deleted from the "root"
--  store, a pop up message box is displayed. The certificate's subject,
--  issuer, serial number, time validity, sha1 and md5 thumbprints are
--  displayed. The user is given the option to do the add or delete.
--  If they don't allow the operation, LastError is set to E_ACCESSDENIED.
-- 
--  CERT_STORE_PROV_PHYSICAL_W
--  CERT_STORE_PROV_PHYSICAL
--  sz_CERT_STORE_PROV_PHYSICAL_W
--  sz_CERT_STORE_PROV_PHYSICAL
--  Opens the specified "Physical" store in the "System" store.
-- 
--  Both the system store and physical names are passed in pvPara. The
--  names are separated with an intervening "\". For example,
--  "Root\.Default". The string is UNICODE.
-- 
--  The system and physical store names can't contain any backslashes.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvPara
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure instead
--  of pointing to a null terminated UNICODE string.
--  The specified physical store is opened as relocated using pvPara's
--  hKeyBase.
-- 
--  For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS,
--  the system and physical store names
--  must be prefixed with the ServiceName or UserName. For example,
--  "ServiceName\Root\.Default".
-- 
--  Physical stores on remote computers can be accessed for the
--  CERT_SYSTEM_STORE_LOCAL_MACHINE, CERT_SYSTEM_STORE_SERVICES,
--  CERT_SYSTEM_STORE_USERS, CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
--  or CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
--  locations by prepending the computer name. For example, a remote
--  local machine store is accessed via "\\ComputerName\Root\.Default"
--  or "ComputerName\Root\.Default". A remote service store is
--  accessed via "\\ComputerName\ServiceName\Root\.Default". The
--  leading "\\" backslashes are optional in the ComputerName.
-- 
--  CERT_STORE_PROV_COLLECTION
--  sz_CERT_STORE_PROV_COLLECTION
--  Opens a store that is a collection of other stores. Stores are
--  added or removed to/from the collection via the CertAddStoreToCollection
--  and CertRemoveStoreFromCollection APIs.
-- 
--  CERT_STORE_PROV_SMART_CARD_W
--  CERT_STORE_PROV_SMART_CARD
--  sz_CERT_STORE_PROV_SMART_CARD_W
--  sz_CERT_STORE_PROV_SMART_CARD
--  Opens a store instantiated over a particular smart card storage. pvPara
--  identifies where on the card the store is located and is of the
--  following format:
-- 
--  Card Name\Provider Name\Provider Type[\Container Name]
-- 
--  Container Name is optional and if NOT specified the Card Name is used
--  as the Container Name. Future versions of the provider will support
--  instantiating the store over the entire card in which case just
--  Card Name ( or id ) will be sufficient.
-- 
--  Here's a list of the predefined provider types (implemented in
--  cryptnet.dll):
-- 
--  CERT_STORE_PROV_LDAP_W
--  CERT_STORE_PROV_LDAP
--  sz_CERT_STORE_PROV_LDAP_W
--  sz_CERT_STORE_PROV_LDAP
--  Opens a store over the results of the query specified by and LDAP
--  URL which is passed in via pvPara. In order to do writes to the
--  store the URL must specify a BASE query, no filter and a single
--  attribute.
-- 
-- --------------------------------------------------------------------------
type
t_121=^unchecked for machine_pointer use true;

procedure CertOpenStore(
    lpszStoreProvider : in LPCSTR; 
    dwEncodingType  : in DWORD; 
    hCryptProv      : in t_HCRYPTPROV; 
    dwFlags         : in DWORD; 
    pvPara          : in t_121)
                      return t_HCERTSTORE;
#pragma convention(CertOpenStore,system);
#pragma import(CertOpenStore,'CertOpenStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  OID Installable Certificate Store Provider Data Structures
-- --------------------------------------------------------------------------
--  Handle returned by the store provider when opened.
type
HCERTSTOREPROV    = ^unchecked for machine_pointer use true;
--  Store Provider OID function's pszFuncName.
--  Note, the Store Provider OID function's dwEncodingType is always 0.
--  The following information is returned by the provider when opened. Its
--  zeroed with cbSize set before the provider is called. If the provider
--  doesn't need to be called again after the open it doesn't need to
--  make any updates to the CERT_STORE_PROV_INFO.
type
  _CERT_STORE_PROV_INFO = record
cbSize          : DWORD;
cStoreProvFunc  : DWORD;
rgpvStoreProvFunc : ^^unchecked;
hStoreProv      : HCERTSTOREPROV;
dwStoreProvFlags : DWORD;
hStoreProvFuncAddr2 : HCRYPTOIDFUNCADDR;
  end record;
  CERT_STORE_PROV_INFO = _CERT_STORE_PROV_INFO;
  PCERT_STORE_PROV_INFO = ^_CERT_STORE_PROV_INFO;

--  Definition of the store provider's open function.
-- 
--  *pStoreProvInfo has been zeroed before the call.
-- 
--  Note, pStoreProvInfo->cStoreProvFunc should be set last. Once set,
--  all subsequent store calls, such as CertAddSerializedElementToStore will
--  call the appropriate provider callback function.
type
t_122=^unchecked for machine_pointer use true;

PFN_CERT_DLL_OPEN_STORE_PROV_FUNC = ^procedure (
    lpszStoreProvider : in LPCSTR;
    dwEncodingType  : in DWORD;
    hCryptProv      : in t_HCRYPTPROV;
    dwFlags         : in DWORD;
    pvPara          : in t_122;
    hCertStore      : in t_HCERTSTORE;
    pStoreProvInfo  : in out _CERT_STORE_PROV_INFO)
                      return BOOL for machine_pointer use true;
--  The open callback sets the following flag, if it maintains its
--  contexts externally and not in the cached store.
const
  CERT_STORE_PROV_EXTERNAL_FLAG= $01;

--  The open callback sets the following flag for a successful delete.
--  When set, the close callback isn't called.
const
  CERT_STORE_PROV_DELETED_FLAG= $02;

--  The open callback sets the following flag if it doesn't persist store
--  changes.
const
  CERT_STORE_PROV_NO_PERSIST_FLAG= $04;

--  The open callback sets the following flag if the contexts are persisted
--  to a system store.
const
  CERT_STORE_PROV_SYSTEM_STORE_FLAG= $08;

--  The open callback sets the following flag if the contexts are persisted
--  to a LocalMachine system store.
const
  CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG= $10;

--  Indices into the store provider's array of callback functions.
-- 
--  The provider can implement any subset of the following functions. It
--  sets pStoreProvInfo->cStoreProvFunc to the last index + 1 and any
--  preceding not implemented functions to NULL.
const
  CERT_STORE_PROV_CLOSE_FUNC= 0;

const
  CERT_STORE_PROV_READ_CERT_FUNC= 1;

const
  CERT_STORE_PROV_WRITE_CERT_FUNC= 2;

const
  CERT_STORE_PROV_DELETE_CERT_FUNC= 3;

const
  CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC= 4;

const
  CERT_STORE_PROV_READ_CRL_FUNC= 5;

const
  CERT_STORE_PROV_WRITE_CRL_FUNC= 6;

const
  CERT_STORE_PROV_DELETE_CRL_FUNC= 7;

const
  CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC= 8;

const
  CERT_STORE_PROV_READ_CTL_FUNC= 9;

const
  CERT_STORE_PROV_WRITE_CTL_FUNC= 10;

const
  CERT_STORE_PROV_DELETE_CTL_FUNC= 11;

const
  CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC= 12;

const
  CERT_STORE_PROV_CONTROL_FUNC= 13;

const
  CERT_STORE_PROV_FIND_CERT_FUNC= 14;

const
  CERT_STORE_PROV_FREE_FIND_CERT_FUNC= 15;

const
  CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC= 16;

const
  CERT_STORE_PROV_FIND_CRL_FUNC= 17;

const
  CERT_STORE_PROV_FREE_FIND_CRL_FUNC= 18;

const
  CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC= 19;

const
  CERT_STORE_PROV_FIND_CTL_FUNC= 20;

const
  CERT_STORE_PROV_FREE_FIND_CTL_FUNC= 21;

const
  CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC= 22;

--  Called by CertCloseStore when the store's reference count is
--  decremented to 0.
type
PFN_CERT_STORE_PROV_CLOSE = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    dwFlags         : in DWORD) for machine_pointer use true;
--  Currently not called directly by the store APIs. However, may be exported
--  to support other providers based on it.
-- 
--  Reads the provider's copy of the certificate context. If it exists,
--  creates a new certificate context.
type
PFN_CERT_STORE_PROV_READ_CERT = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pStoreCertContext : in PCCERT_CONTEXT;
    dwFlags         : in DWORD;
    ppProvCertContext : out PCCERT_CONTEXT)
                      return BOOL for machine_pointer use true;
const
  CERT_STORE_PROV_WRITE_ADD_FLAG= $01;

--  Called by CertAddEncodedCertificateToStore,
--  CertAddCertificateContextToStore or CertAddSerializedElementToStore before
--  adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In
--  addition to the encoded certificate, the added pCertContext might also
--  have properties.
-- 
--  Returns TRUE if its OK to update the the store.
type
PFN_CERT_STORE_PROV_WRITE_CERT = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCertContext    : in PCCERT_CONTEXT;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
--  Called by CertDeleteCertificateFromStore before deleting from the
--  store.
-- 
--  Returns TRUE if its OK to delete from the store.
type
PFN_CERT_STORE_PROV_DELETE_CERT = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCertContext    : in PCCERT_CONTEXT;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
--  Called by CertSetCertificateContextProperty before setting the
--  certificate's property. Also called by CertGetCertificateContextProperty,
--  when getting a hash property that needs to be created and then persisted
--  via the set.
-- 
--  Upon input, the property hasn't been set for the pCertContext parameter.
-- 
--  Returns TRUE if its OK to set the property.
type
t_123=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_SET_CERT_PROPERTY = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCertContext    : in PCCERT_CONTEXT;
    dwPropId        : in DWORD;
    dwFlags         : in DWORD;
    pvData          : in t_123)
                      return BOOL for machine_pointer use true;
--  Currently not called directly by the store APIs. However, may be exported
--  to support other providers based on it.
-- 
--  Reads the provider's copy of the CRL context. If it exists,
--  creates a new CRL context.
type
PFN_CERT_STORE_PROV_READ_CRL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pStoreCrlContext : in PCCRL_CONTEXT;
    dwFlags         : in DWORD;
    ppProvCrlContext : out PCCRL_CONTEXT)
                      return BOOL for machine_pointer use true;
--  Called by CertAddEncodedCRLToStore,
--  CertAddCRLContextToStore or CertAddSerializedElementToStore before
--  adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In
--  addition to the encoded CRL, the added pCertContext might also
--  have properties.
-- 
--  Returns TRUE if its OK to update the the store.
type
PFN_CERT_STORE_PROV_WRITE_CRL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCrlContext     : in PCCRL_CONTEXT;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
--  Called by CertDeleteCRLFromStore before deleting from the store.
-- 
--  Returns TRUE if its OK to delete from the store.
type
PFN_CERT_STORE_PROV_DELETE_CRL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCrlContext     : in PCCRL_CONTEXT;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
--  Called by CertSetCRLContextProperty before setting the
--  CRL's property. Also called by CertGetCRLContextProperty,
--  when getting a hash property that needs to be created and then persisted
--  via the set.
-- 
--  Upon input, the property hasn't been set for the pCrlContext parameter.
-- 
--  Returns TRUE if its OK to set the property.
type
t_124=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_SET_CRL_PROPERTY = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCrlContext     : in PCCRL_CONTEXT;
    dwPropId        : in DWORD;
    dwFlags         : in DWORD;
    pvData          : in t_124)
                      return BOOL for machine_pointer use true;
--  Currently not called directly by the store APIs. However, may be exported
--  to support other providers based on it.
-- 
--  Reads the provider's copy of the CTL context. If it exists,
--  creates a new CTL context.
type
PFN_CERT_STORE_PROV_READ_CTL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pStoreCtlContext : in PCCTL_CONTEXT;
    dwFlags         : in DWORD;
    ppProvCtlContext : out PCCTL_CONTEXT)
                      return BOOL for machine_pointer use true;
--  Called by CertAddEncodedCTLToStore,
--  CertAddCTLContextToStore or CertAddSerializedElementToStore before
--  adding to the store. The CERT_STORE_PROV_WRITE_ADD_FLAG is set. In
--  addition to the encoded CTL, the added pCertContext might also
--  have properties.
-- 
--  Returns TRUE if its OK to update the the store.
type
PFN_CERT_STORE_PROV_WRITE_CTL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCtlContext     : in PCCTL_CONTEXT;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
--  Called by CertDeleteCTLFromStore before deleting from the store.
-- 
--  Returns TRUE if its OK to delete from the store.
type
PFN_CERT_STORE_PROV_DELETE_CTL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCtlContext     : in PCCTL_CONTEXT;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
--  Called by CertSetCTLContextProperty before setting the
--  CTL's property. Also called by CertGetCTLContextProperty,
--  when getting a hash property that needs to be created and then persisted
--  via the set.
-- 
--  Upon input, the property hasn't been set for the pCtlContext parameter.
-- 
--  Returns TRUE if its OK to set the property.
type
t_125=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_SET_CTL_PROPERTY = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCtlContext     : in PCCTL_CONTEXT;
    dwPropId        : in DWORD;
    dwFlags         : in DWORD;
    pvData          : in t_125)
                      return BOOL for machine_pointer use true;
type
t_126=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_CONTROL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    dwFlags         : in DWORD;
    dwCtrlType      : in DWORD;
    pvCtrlPara      : in t_126)
                      return BOOL for machine_pointer use true;
type
  _CERT_STORE_PROV_FIND_INFO = record
cbSize          : DWORD;
dwMsgAndCertEncodingType : DWORD;
dwFindFlags     : DWORD;
dwFindType      : DWORD;
pvFindPara      : ^unchecked;
  end record;
  CERT_STORE_PROV_FIND_INFO = _CERT_STORE_PROV_FIND_INFO;
  PCERT_STORE_PROV_FIND_INFO = ^_CERT_STORE_PROV_FIND_INFO;

type
CCERT_STORE_PROV_FIND_INFO = CERT_STORE_PROV_FIND_INFO;
PCCERT_STORE_PROV_FIND_INFO = ^CERT_STORE_PROV_FIND_INFO for machine_pointer use true;
type
t_127=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_FIND_CERT = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pFindInfo       : in PCCERT_STORE_PROV_FIND_INFO;
    pPrevCertContext : in PCCERT_CONTEXT;
    dwFlags         : in DWORD;
    ppvStoreProvFindInfo : in out t_127;
    ppProvCertContext : out PCCERT_CONTEXT)
                      return BOOL for machine_pointer use true;
type
t_128=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_FREE_FIND_CERT = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCertContext    : in PCCERT_CONTEXT;
    pvStoreProvFindInfo : in t_128;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
type
t_129=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_GET_CERT_PROPERTY = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCertContext    : in PCCERT_CONTEXT;
    dwPropId        : in DWORD;
    dwFlags         : in DWORD;
    pvData          : out {!}t_129;
    pcbData         : in out DWORD)
                      return BOOL for machine_pointer use true;
type
t_130=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_FIND_CRL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pFindInfo       : in PCCERT_STORE_PROV_FIND_INFO;
    pPrevCrlContext : in PCCRL_CONTEXT;
    dwFlags         : in DWORD;
    ppvStoreProvFindInfo : in out t_130;
    ppProvCrlContext : out PCCRL_CONTEXT)
                      return BOOL for machine_pointer use true;
type
t_131=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_FREE_FIND_CRL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCrlContext     : in PCCRL_CONTEXT;
    pvStoreProvFindInfo : in t_131;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
type
t_132=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_GET_CRL_PROPERTY = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCrlContext     : in PCCRL_CONTEXT;
    dwPropId        : in DWORD;
    dwFlags         : in DWORD;
    pvData          : out {!}t_132;
    pcbData         : in out DWORD)
                      return BOOL for machine_pointer use true;
type
t_133=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_FIND_CTL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pFindInfo       : in PCCERT_STORE_PROV_FIND_INFO;
    pPrevCtlContext : in PCCTL_CONTEXT;
    dwFlags         : in DWORD;
    ppvStoreProvFindInfo : in out t_133;
    ppProvCtlContext : out PCCTL_CONTEXT)
                      return BOOL for machine_pointer use true;
type
t_134=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_FREE_FIND_CTL = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCtlContext     : in PCCTL_CONTEXT;
    pvStoreProvFindInfo : in t_134;
    dwFlags         : in DWORD)
                      return BOOL for machine_pointer use true;
type
t_135=^unchecked for machine_pointer use true;

PFN_CERT_STORE_PROV_GET_CTL_PROPERTY = ^procedure (
    hStoreProv      : in HCERTSTOREPROV;
    pCtlContext     : in PCCTL_CONTEXT;
    dwPropId        : in DWORD;
    dwFlags         : in DWORD;
    pvData          : out {!}t_135;
    pcbData         : in out DWORD)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Duplicate a cert store handle
-- --------------------------------------------------------------------------
procedure CertDuplicateStore(
    hCertStore      : in t_HCERTSTORE)
                      return t_HCERTSTORE;
#pragma convention(CertDuplicateStore,system);
#pragma import(CertDuplicateStore,'CertDuplicateStore','crypt32.dll');

const
  CERT_STORE_SAVE_AS_STORE= 1;

const
  CERT_STORE_SAVE_AS_PKCS7= 2;

const
  CERT_STORE_SAVE_TO_FILE= 1;

const
  CERT_STORE_SAVE_TO_MEMORY= 2;

const
  CERT_STORE_SAVE_TO_FILENAME_A= 3;

const
  CERT_STORE_SAVE_TO_FILENAME_W= 4;

-- +-------------------------------------------------------------------------
--  Save the cert store. Extended version with lots of options.
-- 
--  According to the dwSaveAs parameter, the store can be saved as a
--  serialized store (CERT_STORE_SAVE_AS_STORE) containing properties in
--  addition to encoded certificates, CRLs and CTLs or the store can be saved
--  as a PKCS #7 signed message (CERT_STORE_SAVE_AS_PKCS7) which doesn't
--  include the properties or CTLs.
-- 
--  Note, the CERT_KEY_CONTEXT_PROP_ID property (and its
--  CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't saved into
--  a serialized store.
-- 
--  For CERT_STORE_SAVE_AS_PKCS7, the dwEncodingType specifies the message
--  encoding type. The dwEncodingType parameter isn't used for
--  CERT_STORE_SAVE_AS_STORE.
-- 
--  The dwFlags parameter currently isn't used and should be set to 0.
-- 
--  The dwSaveTo and pvSaveToPara parameters specify where to save the
--  store as follows:
--  CERT_STORE_SAVE_TO_FILE:
--  Saves to the specified file. The file's handle is passed in
--  pvSaveToPara. Given,
--  HANDLE hFile; pvSaveToPara = (void *) hFile;
-- 
--  For a successful save, the file pointer is positioned after the
--  last write.
-- 
--  CERT_STORE_SAVE_TO_MEMORY:
--  Saves to the specified memory blob. The pointer to
--  the memory blob is passed in pvSaveToPara. Given,
--  CRYPT_DATA_BLOB SaveBlob; pvSaveToPara = (void *) &SaveBlob;
--  Upon entry, the SaveBlob's pbData and cbData need to be initialized.
--  Upon return, cbData is updated with the actual length.
--  For a length only calculation, pbData should be set to NULL. If
--  pbData is non-NULL and cbData isn't large enough, FALSE is returned
--  with a last error of ERRROR_MORE_DATA.
-- 
--  CERT_STORE_SAVE_TO_FILENAME_A:
--  CERT_STORE_SAVE_TO_FILENAME_W:
--  CERT_STORE_SAVE_TO_FILENAME:
--  Opens the file and saves to it. The filename is passed in pvSaveToPara.
--  The filename is UNICODE for the "_W" option and ASCII for the "_A"
--  option. For "_W": given,
--  LPCWSTR pwszFilename; pvSaveToPara = (void *) pwszFilename;
--  For "_A": given,
--  LPCSTR pszFilename; pvSaveToPara = (void *) pszFilename;
-- 
--  Note, the default (without "_A" or "_W") is UNICODE.
-- 
-- --------------------------------------------------------------------------
type
t_136=^unchecked for machine_pointer use true;

procedure CertSaveStore(
    hCertStore      : in t_HCERTSTORE; 
    dwEncodingType  : in DWORD; 
    dwSaveAs        : in DWORD; 
    dwSaveTo        : in DWORD; 
    pvSaveToPara    : in out {!}t_136; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(CertSaveStore,system);
#pragma import(CertSaveStore,'CertSaveStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Certificate Store close flags
-- --------------------------------------------------------------------------
const
  CERT_CLOSE_STORE_FORCE_FLAG= $01;

const
  CERT_CLOSE_STORE_CHECK_FLAG= $02;

-- +-------------------------------------------------------------------------
--  Close a cert store handle.
-- 
--  There needs to be a corresponding close for each open and duplicate.
-- 
--  Even on the final close, the cert store isn't freed until all of its
--  certificate and CRL contexts have also been freed.
-- 
--  On the final close, the hCryptProv passed to CertStoreOpen is
--  CryptReleaseContext'ed.
-- 
--  To force the closure of the store with all of its memory freed, set the
--  CERT_STORE_CLOSE_FORCE_FLAG. This flag should be set when the caller does
--  its own reference counting and wants everything to vanish.
-- 
--  To check if all the store's certificates and CRLs have been freed and that
--  this is the last CertCloseStore, set the CERT_CLOSE_STORE_CHECK_FLAG. If
--  set and certs, CRLs or stores still need to be freed/closed, FALSE is
--  returned with LastError set to CRYPT_E_PENDING_CLOSE. Note, for FALSE,
--  the store is still closed. This is a diagnostic flag.
-- 
--  LastError is preserved unless CERT_CLOSE_STORE_CHECK_FLAG is set and FALSE
--  is returned.
-- --------------------------------------------------------------------------
procedure CertCloseStore(
    hCertStore      : in t_HCERTSTORE; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(CertCloseStore,system);
#pragma import(CertCloseStore,'CertCloseStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get the subject certificate context uniquely identified by its Issuer and
--  SerialNumber from the store.
-- 
--  If the certificate isn't found, NULL is returned. Otherwise, a pointer to
--  a read only CERT_CONTEXT is returned. CERT_CONTEXT must be freed by calling
--  CertFreeCertificateContext. CertDuplicateCertificateContext can be called to make a
--  duplicate.
-- 
--  The returned certificate might not be valid. Normally, it would be
--  verified when getting its issuer certificate (CertGetIssuerCertificateFromStore).
-- --------------------------------------------------------------------------
--  Only the Issuer and SerialNumber
--  fields are used
procedure CertGetSubjectCertificateFromStore(
    hCertStore      : in t_HCERTSTORE; 
    dwCertEncodingType : in DWORD; 
    pCertId         : in PCERT_INFO)
                      return PCCERT_CONTEXT;
#pragma convention(CertGetSubjectCertificateFromStore,system);
#pragma import(CertGetSubjectCertificateFromStore,'CertGetSubjectCertificateFromStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerate the certificate contexts in the store.
-- 
--  If a certificate isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
--  must be freed by calling CertFreeCertificateContext or is freed when passed as the
--  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
--  can be called to make a duplicate.
-- 
--  pPrevCertContext MUST BE NULL to enumerate the first
--  certificate in the store. Successive certificates are enumerated by setting
--  pPrevCertContext to the CERT_CONTEXT returned by a previous call.
-- 
--  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
procedure CertEnumCertificatesInStore(
    hCertStore      : in t_HCERTSTORE; 
    pPrevCertContext : in PCCERT_CONTEXT)
                      return PCCERT_CONTEXT;
#pragma convention(CertEnumCertificatesInStore,system);
#pragma import(CertEnumCertificatesInStore,'CertEnumCertificatesInStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Find the first or next certificate context in the store.
-- 
--  The certificate is found according to the dwFindType and its pvFindPara.
--  See below for a list of the find types and its parameters.
-- 
--  Currently dwFindFlags is only used for CERT_FIND_SUBJECT_ATTR,
--  CERT_FIND_ISSUER_ATTR or CERT_FIND_CTL_USAGE. Otherwise, must be set to 0.
-- 
--  Usage of dwCertEncodingType depends on the dwFindType.
-- 
--  If the first or next certificate isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
--  must be freed by calling CertFreeCertificateContext or is freed when passed as the
--  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
--  can be called to make a duplicate.
-- 
--  pPrevCertContext MUST BE NULL on the first
--  call to find the certificate. To find the next certificate, the
--  pPrevCertContext is set to the CERT_CONTEXT returned by a previous call.
-- 
--  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
type
t_137=^unchecked for machine_pointer use true;

procedure CertFindCertificateInStore(
    hCertStore      : in t_HCERTSTORE; 
    dwCertEncodingType : in DWORD; 
    dwFindFlags     : in DWORD; 
    dwFindType      : in DWORD; 
    pvFindPara      : in t_137; 
    pPrevCertContext : in PCCERT_CONTEXT)
                      return PCCERT_CONTEXT;
#pragma convention(CertFindCertificateInStore,system);
#pragma import(CertFindCertificateInStore,'CertFindCertificateInStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Certificate comparison functions
-- --------------------------------------------------------------------------
const
  CERT_COMPARE_MASK = $FFFF;

const
  CERT_COMPARE_SHIFT= 16;

const
  CERT_COMPARE_ANY  = 0;

const
  CERT_COMPARE_SHA1_HASH= 1;

const
  CERT_COMPARE_NAME = 2;

const
  CERT_COMPARE_ATTR = 3;

const
  CERT_COMPARE_MD5_HASH= 4;

const
  CERT_COMPARE_PROPERTY= 5;

const
  CERT_COMPARE_PUBLIC_KEY= 6;

const
  CERT_COMPARE_NAME_STR_A= 7;

const
  CERT_COMPARE_NAME_STR_W= 8;

const
  CERT_COMPARE_KEY_SPEC= 9;

const
  CERT_COMPARE_ENHKEY_USAGE= 10;

const
  CERT_COMPARE_SUBJECT_CERT= 11;

const
  CERT_COMPARE_ISSUER_OF= 12;

const
  CERT_COMPARE_EXISTING= 13;

const
  CERT_COMPARE_SIGNATURE_HASH= 14;

const
  CERT_COMPARE_KEY_IDENTIFIER= 15;

const
  CERT_COMPARE_CERT_ID= 16;

const
  CERT_COMPARE_CROSS_CERT_DIST_POINTS= 17;

const
  CERT_COMPARE_PUBKEY_MD5_HASH= 18;

-- +-------------------------------------------------------------------------
--  dwFindType
-- 
--  The dwFindType definition consists of two components:
--  - comparison function
--  - certificate information flag
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_ANY
-- 
--  Find any certificate.
-- 
--  pvFindPara isn't used.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_HASH
-- 
--  Find a certificate with the specified hash.
-- 
--  pvFindPara points to a CRYPT_HASH_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_KEY_IDENTIFIER
-- 
--  Find a certificate with the specified KeyIdentifier. Gets the
--  CERT_KEY_IDENTIFIER_PROP_ID property and compares with the input
--  CRYPT_HASH_BLOB.
-- 
--  pvFindPara points to a CRYPT_HASH_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_PROPERTY
-- 
--  Find a certificate having the specified property.
-- 
--  pvFindPara points to a DWORD containing the PROP_ID
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_PUBLIC_KEY
-- 
--  Find a certificate matching the specified public key.
-- 
--  pvFindPara points to a CERT_PUBLIC_KEY_INFO containing the public key
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_SUBJECT_NAME
--  CERT_FIND_ISSUER_NAME
-- 
--  Find a certificate with the specified subject/issuer name. Does an exact
--  match of the entire name.
-- 
--  Restricts search to certificates matching the dwCertEncodingType.
-- 
--  pvFindPara points to a CERT_NAME_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_SUBJECT_ATTR
--  CERT_FIND_ISSUER_ATTR
-- 
--  Find a certificate with the specified subject/issuer attributes.
-- 
--  Compares the attributes in the subject/issuer name with the
--  Relative Distinguished Name's (CERT_RDN) array of attributes specified in
--  pvFindPara. The comparison iterates through the CERT_RDN attributes and looks
--  for an attribute match in any of the subject/issuer's RDNs.
-- 
--  The CERT_RDN_ATTR fields can have the following special values:
--  pszObjId == NULL - ignore the attribute object identifier
--  dwValueType == RDN_ANY_TYPE - ignore the value type
--  Value.pbData == NULL - match any value
-- 
--  CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG should be set in dwFindFlags to do
--  a case insensitive match. Otherwise, defaults to an exact, case sensitive
--  match.
-- 
--  CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set in dwFindFlags if the RDN was
--  initialized with unicode strings as for
--  CryptEncodeObject(X509_UNICODE_NAME).
-- 
--  Restricts search to certificates matching the dwCertEncodingType.
-- 
--  pvFindPara points to a CERT_RDN (defined in wincert.h).
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_SUBJECT_STR_A
--  CERT_FIND_SUBJECT_STR_W | CERT_FIND_SUBJECT_STR
--  CERT_FIND_ISSUER_STR_A
--  CERT_FIND_ISSUER_STR_W | CERT_FIND_ISSUER_STR
-- 
--  Find a certificate containing the specified subject/issuer name string.
-- 
--  First, the certificate's subject/issuer is converted to a name string
--  via CertNameToStrA/CertNameToStrW(CERT_SIMPLE_NAME_STR). Then, a
--  case insensitive substring within string match is performed.
-- 
--  Restricts search to certificates matching the dwCertEncodingType.
-- 
--  For *_STR_A, pvFindPara points to a null terminated character string.
--  For *_STR_W, pvFindPara points to a null terminated wide character string.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_KEY_SPEC
-- 
--  Find a certificate having a CERT_KEY_SPEC_PROP_ID property matching
--  the specified KeySpec.
-- 
--  pvFindPara points to a DWORD containing the KeySpec.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_ENHKEY_USAGE
-- 
--  Find a certificate having the szOID_ENHANCED_KEY_USAGE extension or
--  the CERT_ENHKEY_USAGE_PROP_ID and matching the specified pszUsageIdentifers.
-- 
--  pvFindPara points to a CERT_ENHKEY_USAGE data structure. If pvFindPara
--  is NULL or CERT_ENHKEY_USAGE's cUsageIdentifier is 0, then, matches any
--  certificate having enhanced key usage.
-- 
--  If the CERT_FIND_VALID_ENHKEY_USAGE_FLAG is set, then, only does a match
--  for certificates that are valid for the specified usages. By default,
--  the ceriticate must be valid for all usages. CERT_FIND_OR_ENHKEY_USAGE_FLAG
--  can be set, if the certificate only needs to be valid for one of the
--  specified usages. Note, CertGetValidUsages() is called to get the
--  certificate's list of valid usages. Only the CERT_FIND_OR_ENHKEY_USAGE_FLAG
--  is applicable when this flag is set.
-- 
--  The CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG can be set in dwFindFlags to
--  also match a certificate without either the extension or property.
-- 
--  If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set in dwFindFlags, finds
--  certificates without the key usage extension or property. Setting this
--  flag takes precedence over pvFindPara being NULL.
-- 
--  If the CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG is set, then, only does a match
--  using the extension. If pvFindPara is NULL or cUsageIdentifier is set to
--  0, finds certificates having the extension. If
--  CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG is set, also matches a certificate
--  without the extension. If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set, finds
--  certificates without the extension.
-- 
--  If the CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG is set, then, only does a match
--  using the property. If pvFindPara is NULL or cUsageIdentifier is set to
--  0, finds certificates having the property. If
--  CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG is set, also matches a certificate
--  without the property. If CERT_FIND_NO_ENHKEY_USAGE_FLAG is set, finds
--  certificates without the property.
-- 
--  If CERT_FIND_OR_ENHKEY_USAGE_FLAG is set, does an "OR" match of any of
--  the specified pszUsageIdentifiers. If not set, then, does an "AND" match
--  of all of the specified pszUsageIdentifiers.
-- --------------------------------------------------------------------------
const
  CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG= $01;

const
  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG= $02;

const
  CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG= $04;

const
  CERT_FIND_NO_ENHKEY_USAGE_FLAG= $08;

const
  CERT_FIND_OR_ENHKEY_USAGE_FLAG= $10;

const
  CERT_FIND_VALID_ENHKEY_USAGE_FLAG= $20;

-- +-------------------------------------------------------------------------
--  CERT_FIND_CERT_ID
-- 
--  Find a certificate with the specified CERT_ID.
-- 
--  pvFindPara points to a CERT_ID.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_FIND_CROSS_CERT_DIST_POINTS
-- 
--  Find a certificate having either a cross certificate distribution
--  point extension or property.
-- 
--  pvFindPara isn't used.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Get the certificate context from the store for the first or next issuer
--  of the specified subject certificate. Perform the enabled
--  verification checks on the subject. (Note, the checks are on the subject
--  using the returned issuer certificate.)
-- 
--  If the first or next issuer certificate isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
--  must be freed by calling CertFreeCertificateContext or is freed when passed as the
--  pPrevIssuerContext on a subsequent call. CertDuplicateCertificateContext
--  can be called to make a duplicate.
-- 
--  For a self signed subject certificate, NULL is returned with LastError set
--  to CERT_STORE_SELF_SIGNED. The enabled verification checks are still done.
-- 
--  The pSubjectContext may have been obtained from this store, another store
--  or created by the caller application. When created by the caller, the
--  CertCreateCertificateContext function must have been called.
-- 
--  An issuer may have multiple certificates. This may occur when the validity
--  period is about to change. pPrevIssuerContext MUST BE NULL on the first
--  call to get the issuer. To get the next certificate for the issuer, the
--  pPrevIssuerContext is set to the CERT_CONTEXT returned by a previous call.
-- 
--  NOTE: a NON-NULL pPrevIssuerContext is always CertFreeCertificateContext'ed by
--  this function, even for an error.
-- 
--  The following flags can be set in *pdwFlags to enable verification checks
--  on the subject certificate context:
--  CERT_STORE_SIGNATURE_FLAG - use the public key in the returned
--  issuer certificate to verify the
--  signature on the subject certificate.
--  Note, if pSubjectContext->hCertStore ==
--  hCertStore, the store provider might
--  be able to eliminate a redo of
--  the signature verify.
--  CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
--  its within the subject certificate's
--  validity period
--  CERT_STORE_REVOCATION_FLAG - check if the subject certificate is on
--  the issuer's revocation list
-- 
--  If an enabled verification check fails, then, its flag is set upon return.
--  If CERT_STORE_REVOCATION_FLAG was enabled and the issuer doesn't have a
--  CRL in the store, then, CERT_STORE_NO_CRL_FLAG is set in addition to
--  the CERT_STORE_REVOCATION_FLAG.
-- 
--  If CERT_STORE_SIGNATURE_FLAG or CERT_STORE_REVOCATION_FLAG is set, then,
--  CERT_STORE_NO_ISSUER_FLAG is set if it doesn't have an issuer certificate
--  in the store.
-- 
--  For a verification check failure, a pointer to the issuer's CERT_CONTEXT
--  is still returned and SetLastError isn't updated.
-- --------------------------------------------------------------------------
procedure CertGetIssuerCertificateFromStore(
    hCertStore      : in t_HCERTSTORE; 
    pSubjectContext : in PCCERT_CONTEXT; 
    pPrevIssuerContext : in {out optional} PCCERT_CONTEXT; 
    pdwFlags        : in out DWORD)
                      return PCCERT_CONTEXT;
#pragma convention(CertGetIssuerCertificateFromStore,system);
#pragma import(CertGetIssuerCertificateFromStore,'CertGetIssuerCertificateFromStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Perform the enabled verification checks on the subject certificate
--  using the issuer. Same checks and flags definitions as for the above
--  CertGetIssuerCertificateFromStore.
-- 
--  If you are only checking CERT_STORE_TIME_VALIDITY_FLAG, then, the
--  issuer can be NULL.
-- 
--  For a verification check failure, SUCCESS is still returned.
-- --------------------------------------------------------------------------
procedure CertVerifySubjectCertificateContext(
    pSubject        : in PCCERT_CONTEXT; 
    pIssuer         : in {out optional} PCCERT_CONTEXT; 
    pdwFlags        : in out DWORD)
                      return BOOL;
#pragma convention(CertVerifySubjectCertificateContext,system);
#pragma import(CertVerifySubjectCertificateContext,'CertVerifySubjectCertificateContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Duplicate a certificate context
-- --------------------------------------------------------------------------
procedure CertDuplicateCertificateContext(
    pCertContext    : in PCCERT_CONTEXT)
                      return PCCERT_CONTEXT;
#pragma convention(CertDuplicateCertificateContext,system);
#pragma import(CertDuplicateCertificateContext,'CertDuplicateCertificateContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Create a certificate context from the encoded certificate. The created
--  context isn't put in a store.
-- 
--  Makes a copy of the encoded certificate in the created context.
-- 
--  If unable to decode and create the certificate context, NULL is returned.
--  Otherwise, a pointer to a read only CERT_CONTEXT is returned.
--  CERT_CONTEXT must be freed by calling CertFreeCertificateContext.
--  CertDuplicateCertificateContext can be called to make a duplicate.
-- 
--  CertSetCertificateContextProperty and CertGetCertificateContextProperty can be called
--  to store properties for the certificate.
-- --------------------------------------------------------------------------
type
t_138=^BYTE for machine_pointer use true;

procedure CertCreateCertificateContext(
    dwCertEncodingType : in DWORD; 
    pbCertEncoded   : in t_138; 
    cbCertEncoded   : in DWORD)
                      return PCCERT_CONTEXT;
#pragma convention(CertCreateCertificateContext,system);
#pragma import(CertCreateCertificateContext,'CertCreateCertificateContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Free a certificate context
-- 
--  There needs to be a corresponding free for each context obtained by a
--  get, find, duplicate or create.
-- --------------------------------------------------------------------------
procedure CertFreeCertificateContext(
    pCertContext    : in PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CertFreeCertificateContext,system);
#pragma import(CertFreeCertificateContext,'CertFreeCertificateContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Set the property for the specified certificate context.
-- 
--  The type definition for pvData depends on the dwPropId value. There are
--  five predefined types:
--  CERT_KEY_PROV_HANDLE_PROP_ID - a HCRYPTPROV for the certificate's
--  private key is passed in pvData. Updates the hCryptProv field
--  of the CERT_KEY_CONTEXT_PROP_ID. If the CERT_KEY_CONTEXT_PROP_ID
--  doesn't exist, its created with all the other fields zeroed out. If
--  CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, HCRYPTPROV is implicitly
--  released when either the property is set to NULL or on the final
--  free of the CertContext.
-- 
--  CERT_KEY_PROV_INFO_PROP_ID - a PCRYPT_KEY_PROV_INFO for the certificate's
--  private key is passed in pvData.
-- 
--  CERT_SHA1_HASH_PROP_ID -
--  CERT_MD5_HASH_PROP_ID -
--  CERT_SIGNATURE_HASH_PROP_ID - normally, a hash property is implicitly
--  set by doing a CertGetCertificateContextProperty. pvData points to a
--  CRYPT_HASH_BLOB.
-- 
--  CERT_KEY_CONTEXT_PROP_ID - a PCERT_KEY_CONTEXT for the certificate's
--  private key is passed in pvData. The CERT_KEY_CONTEXT contains both the
--  hCryptProv and dwKeySpec for the private key.
--  See the CERT_KEY_PROV_HANDLE_PROP_ID for more information about
--  the hCryptProv field and dwFlags settings. Note, more fields may
--  be added for this property. The cbSize field value will be adjusted
--  accordingly.
-- 
--  CERT_KEY_SPEC_PROP_ID - the dwKeySpec for the private key. pvData
--  points to a DWORD containing the KeySpec
-- 
--  CERT_ENHKEY_USAGE_PROP_ID - enhanced key usage definition for the
--  certificate. pvData points to a CRYPT_DATA_BLOB containing an
--  ASN.1 encoded CERT_ENHKEY_USAGE (encoded via
--  CryptEncodeObject(X509_ENHANCED_KEY_USAGE).
-- 
--  CERT_NEXT_UPDATE_LOCATION_PROP_ID - location of the next update.
--  Currently only applicable to CTLs. pvData points to a CRYPT_DATA_BLOB
--  containing an ASN.1 encoded CERT_ALT_NAME_INFO (encoded via
--  CryptEncodeObject(X509_ALTERNATE_NAME)).
-- 
--  CERT_FRIENDLY_NAME_PROP_ID - friendly name for the cert, CRL or CTL.
--  pvData points to a CRYPT_DATA_BLOB. pbData is a pointer to a NULL
--  terminated unicode, wide character string.
--  cbData = (wcslen((LPWSTR) pbData) + 1) * sizeof(WCHAR).
-- 
--  CERT_DESCRIPTION_PROP_ID - description for the cert, CRL or CTL.
--  pvData points to a CRYPT_DATA_BLOB. pbData is a pointer to a NULL
--  terminated unicode, wide character string.
--  cbData = (wcslen((LPWSTR) pbData) + 1) * sizeof(WCHAR).
-- 
--  CERT_ARCHIVED_PROP_ID - when this property is set, the certificate
--  is skipped during enumeration. Note, certificates having this property
--  are still found for explicit finds, such as, finding a certificate
--  with a specific hash or finding a certificate having a specific issuer
--  and serial number. pvData points to a CRYPT_DATA_BLOB. This blob
--  can be NULL (pbData = NULL, cbData = 0).
-- 
--  CERT_PUBKEY_ALG_PARA_PROP_ID - for public keys supporting
--  algorithm parameter inheritance. pvData points to a CRYPT_OBJID_BLOB
--  containing the ASN.1 encoded PublicKey Algorithm Parameters. For
--  DSS this would be the parameters encoded via
--  CryptEncodeObject(X509_DSS_PARAMETERS). This property may be set
--  by CryptVerifyCertificateSignatureEx().
-- 
--  CERT_CROSS_CERT_DIST_POINTS_PROP_ID - location of the cross certs.
--  Currently only applicable to certs. pvData points to a CRYPT_DATA_BLOB
--  containing an ASN.1 encoded CROSS_CERT_DIST_POINTS_INFO (encoded via
--  CryptEncodeObject(X509_CROSS_CERT_DIST_POINTS)).
-- 
--  CERT_ENROLLMENT_PROP_ID - enrollment information of the pending request.
--  It contains RequestID, CADNSName, CAName, and FriendlyName.
--  The data format is defined as, the first 4 bytes - pending request ID,
--  next 4 bytes - CADNSName size in characters including null-terminator
--  followed by CADNSName string with null-terminator,
--  next 4 bytes - CAName size in characters including null-terminator
--  followed by CAName string with null-terminator,
--  next 4 bytes - FriendlyName size in characters including null-terminator
--  followed by FriendlyName string with null-terminator.
-- 
--  CERT_DATE_STAMP_PROP_ID - contains the time when added to the store
--  by an admin tool. pvData points to a CRYPT_DATA_BLOB containing
--  the FILETIME.
-- 
--  CERT_RENEWAL_PROP_ID - contains the hash of renewed certificate
-- 
--  For all the other PROP_IDs: an encoded PCRYPT_DATA_BLOB is passed in pvData.
-- 
--  If the property already exists, then, the old value is deleted and silently
--  replaced. Setting, pvData to NULL, deletes the property.
-- 
--  CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG can be set to ignore any
--  provider write errors and always update the cached context's property.
-- --------------------------------------------------------------------------
type
t_139=^unchecked for machine_pointer use true;

procedure CertSetCertificateContextProperty(
    pCertContext    : in PCCERT_CONTEXT; 
    dwPropId        : in DWORD; 
    dwFlags         : in DWORD; 
    pvData          : in t_139)
                      return BOOL;
#pragma convention(CertSetCertificateContextProperty,system);
#pragma import(CertSetCertificateContextProperty,'CertSetCertificateContextProperty','crypt32.dll');

--  Set this flag to ignore any store provider write errors and always update
--  the cached context's property
const
  CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG= $80000000;

--  Set this flag to inhibit the persisting of this property
const
  CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG= $40000000;

-- +-------------------------------------------------------------------------
--  Get the property for the specified certificate context.
-- 
--  For CERT_KEY_PROV_HANDLE_PROP_ID, pvData points to a HCRYPTPROV.
-- 
--  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO structure.
--  Elements pointed to by fields in the pvData structure follow the
--  structure. Therefore, *pcbData may exceed the size of the structure.
-- 
--  For CERT_KEY_CONTEXT_PROP_ID, pvData points to a CERT_KEY_CONTEXT structure.
-- 
--  For CERT_KEY_SPEC_PROP_ID, pvData points to a DWORD containing the KeySpec.
--  If the CERT_KEY_CONTEXT_PROP_ID exists, the KeySpec is obtained from there.
--  Otherwise, if the CERT_KEY_PROV_INFO_PROP_ID exists, its the source
--  of the KeySpec.
-- 
--  For CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID, if the hash
--  doesn't already exist, then, its computed via CryptHashCertificate()
--  and then set. pvData points to the computed hash. Normally, the length
--  is 20 bytes for SHA and 16 for MD5.
-- 
--  For CERT_SIGNATURE_HASH_PROP_ID, if the hash
--  doesn't already exist, then, its computed via CryptHashToBeSigned()
--  and then set. pvData points to the computed hash. Normally, the length
--  is 20 bytes for SHA and 16 for MD5.
-- 
--  For CERT_ACCESS_STATE_PROP_ID, pvData points to a DWORD containing the
--  access state flags. The appropriate CERT_ACCESS_STATE_*_FLAG's are set
--  in the returned DWORD. See the CERT_ACCESS_STATE_*_FLAG definitions
--  above. Note, this property is read only. It can't be set.
-- 
--  For CERT_KEY_IDENTIFIER_PROP_ID, if property doesn't already exist,
--  first searches for the szOID_SUBJECT_KEY_IDENTIFIER extension. Next,
--  does SHA1 hash of the certficate's SubjectPublicKeyInfo. pvData
--  points to the key identifier bytes. Normally, the length is 20 bytes.
-- 
--  For CERT_PUBKEY_ALG_PARA_PROP_ID, pvPara points to the ASN.1 encoded
--  PublicKey Algorithm Parameters. This property will only be set
--  for public keys supporting algorithm parameter inheritance and when the
--  parameters have been omitted from the encoded and signed certificate.
-- 
--  For CERT_DATE_STAMP_PROP_ID, pvPara points to a FILETIME updated by
--  an admin tool to indicate when the certificate was added to the store.
-- 
--  For all other PROP_IDs, pvData points to an encoded array of bytes.
-- --------------------------------------------------------------------------
type
t_140=^unchecked for machine_pointer use true;

procedure CertGetCertificateContextProperty(
    pCertContext    : in PCCERT_CONTEXT; 
    dwPropId        : in DWORD; 
    pvData          : out {!}t_140; 
    pcbData         : in out DWORD)
                      return BOOL;
#pragma convention(CertGetCertificateContextProperty,system);
#pragma import(CertGetCertificateContextProperty,'CertGetCertificateContextProperty','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerate the properties for the specified certificate context.
-- 
--  To get the first property, set dwPropId to 0. The ID of the first
--  property is returned. To get the next property, set dwPropId to the
--  ID returned by the last call. To enumerate all the properties continue
--  until 0 is returned.
-- 
--  CertGetCertificateContextProperty is called to get the property's data.
-- 
--  Note, since, the CERT_KEY_PROV_HANDLE_PROP_ID and CERT_KEY_SPEC_PROP_ID
--  properties are stored as fields in the CERT_KEY_CONTEXT_PROP_ID
--  property, they aren't enumerated individually.
-- --------------------------------------------------------------------------
procedure CertEnumCertificateContextProperties(
    pCertContext    : in PCCERT_CONTEXT; 
    dwPropId        : in DWORD)
                      return DWORD;
#pragma convention(CertEnumCertificateContextProperties,system);
#pragma import(CertEnumCertificateContextProperties,'CertEnumCertificateContextProperties','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Creates a CTL entry whose attributes are the certificate context's
--  properties.
-- 
--  The SubjectIdentifier in the CTL entry is the SHA1 hash of the certificate.
-- 
--  The certificate properties are added as attributes. The property attribute 
--  OID is the decimal PROP_ID preceded by szOID_CERT_PROP_ID_PREFIX. Each
--  property value is copied as a single attribute value.
-- 
--  Any additional attributes to be included in the CTL entry can be passed
--  in via the cOptAttr and rgOptAttr parameters.
-- 
--  CTL_ENTRY_FROM_PROP_CHAIN_FLAG can be set in dwFlags, to force the
--  inclusion of the chain building hash properties as attributes.
-- --------------------------------------------------------------------------
type
t_141=^unchecked for machine_pointer use true;

procedure CertCreateCTLEntryFromCertificateContextProperties(
    pCertContext    : in PCCERT_CONTEXT; 
    cOptAttr        : in DWORD; 
    rgOptAttr       : in {out optional} PCRYPT_ATTRIBUTE; 
    dwFlags         : in DWORD; 
    pvReserved      : in {out optional} t_141; 
    pCtlEntry       : out {out optional} _CTL_ENTRY; 
    pcbCtlEntry     : in out DWORD)
                      return BOOL;
#pragma convention(CertCreateCTLEntryFromCertificateContextProperties,system);
#pragma import(CertCreateCTLEntryFromCertificateContextProperties,'CertCreateCTLEntryFromCertificateContextProperties','crypt32.dll');

--  Set this flag to get and include the chain building hash properties
--  as attributes in the CTL entry
const
  CTL_ENTRY_FROM_PROP_CHAIN_FLAG= $01;

-- +-------------------------------------------------------------------------
--  Sets properties on the certificate context using the attributes in
--  the CTL entry.
-- 
--  The property attribute OID is the decimal PROP_ID preceded by
--  szOID_CERT_PROP_ID_PREFIX. Only attributes containing such an OID are
--  copied.
-- 
--  CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG may be set in dwFlags.
-- --------------------------------------------------------------------------
procedure CertSetCertificateContextPropertiesFromCTLEntry(
    pCertContext    : in PCCERT_CONTEXT; 
    pCtlEntry       : in PCTL_ENTRY; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(CertSetCertificateContextPropertiesFromCTLEntry,system);
#pragma import(CertSetCertificateContextPropertiesFromCTLEntry,'CertSetCertificateContextPropertiesFromCTLEntry','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get the first or next CRL context from the store for the specified
--  issuer certificate. Perform the enabled verification checks on the CRL.
-- 
--  If the first or next CRL isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
--  must be freed by calling CertFreeCRLContext. However, the free must be
--  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
--  can be called to make a duplicate.
-- 
--  The pIssuerContext may have been obtained from this store, another store
--  or created by the caller application. When created by the caller, the
--  CertCreateCertificateContext function must have been called.
-- 
--  If pIssuerContext == NULL, finds all the CRLs in the store.
-- 
--  An issuer may have multiple CRLs. For example, it generates delta CRLs
--  using a X.509 v3 extension. pPrevCrlContext MUST BE NULL on the first
--  call to get the CRL. To get the next CRL for the issuer, the
--  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
-- 
--  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
--  this function, even for an error.
-- 
--  The following flags can be set in *pdwFlags to enable verification checks
--  on the returned CRL:
--  CERT_STORE_SIGNATURE_FLAG - use the public key in the
--  issuer's certificate to verify the
--  signature on the returned CRL.
--  Note, if pIssuerContext->hCertStore ==
--  hCertStore, the store provider might
--  be able to eliminate a redo of
--  the signature verify.
--  CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
--  its within the CRL's ThisUpdate and
--  NextUpdate validity period.
--  CERT_STORE_BASE_CRL_FLAG - get base CRL.
--  CERT_STORE_DELTA_CRL_FLAG - get delta CRL.
-- 
--  If only one of CERT_STORE_BASE_CRL_FLAG or CERT_STORE_DELTA_CRL_FLAG is
--  set, then, only returns either a base or delta CRL. In any case, the
--  appropriate base or delta flag will be cleared upon returned. If both
--  flags are set, then, only one of flags will be cleared.
-- 
--  If an enabled verification check fails, then, its flag is set upon return.
-- 
--  If pIssuerContext == NULL, then, an enabled CERT_STORE_SIGNATURE_FLAG
--  always fails and the CERT_STORE_NO_ISSUER_FLAG is also set.
-- 
--  For a verification check failure, a pointer to the first or next
--  CRL_CONTEXT is still returned and SetLastError isn't updated.
-- --------------------------------------------------------------------------
procedure CertGetCRLFromStore(
    hCertStore      : in t_HCERTSTORE; 
    pIssuerContext  : in {out optional} PCCERT_CONTEXT; 
    pPrevCrlContext : in PCCRL_CONTEXT; 
    pdwFlags        : in out DWORD)
                      return PCCRL_CONTEXT;
#pragma convention(CertGetCRLFromStore,system);
#pragma import(CertGetCRLFromStore,'CertGetCRLFromStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerate the CRL contexts in the store.
-- 
--  If a CRL isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
--  must be freed by calling CertFreeCRLContext or is freed when passed as the
--  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
--  can be called to make a duplicate.
-- 
--  pPrevCrlContext MUST BE NULL to enumerate the first
--  CRL in the store. Successive CRLs are enumerated by setting
--  pPrevCrlContext to the CRL_CONTEXT returned by a previous call.
-- 
--  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
procedure CertEnumCRLsInStore(
    hCertStore      : in t_HCERTSTORE; 
    pPrevCrlContext : in PCCRL_CONTEXT)
                      return PCCRL_CONTEXT;
#pragma convention(CertEnumCRLsInStore,system);
#pragma import(CertEnumCRLsInStore,'CertEnumCRLsInStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Find the first or next CRL context in the store.
-- 
--  The CRL is found according to the dwFindType and its pvFindPara.
--  See below for a list of the find types and its parameters.
-- 
--  Currently dwFindFlags isn't used and must be set to 0.
-- 
--  Usage of dwCertEncodingType depends on the dwFindType.
-- 
--  If the first or next CRL isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
--  must be freed by calling CertFreeCRLContext or is freed when passed as the
--  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
--  can be called to make a duplicate.
-- 
--  pPrevCrlContext MUST BE NULL on the first
--  call to find the CRL. To find the next CRL, the
--  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
-- 
--  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
type
t_142=^unchecked for machine_pointer use true;

procedure CertFindCRLInStore(
    hCertStore      : in t_HCERTSTORE; 
    dwCertEncodingType : in DWORD; 
    dwFindFlags     : in DWORD; 
    dwFindType      : in DWORD; 
    pvFindPara      : in t_142; 
    pPrevCrlContext : in PCCRL_CONTEXT)
                      return PCCRL_CONTEXT;
#pragma convention(CertFindCRLInStore,system);
#pragma import(CertFindCRLInStore,'CertFindCRLInStore','crypt32.dll');

const
  CRL_FIND_ANY      = 0;

const
  CRL_FIND_ISSUED_BY= 1;

const
  CRL_FIND_EXISTING = 2;

const
  CRL_FIND_ISSUED_FOR= 3;

-- +-------------------------------------------------------------------------
--  CRL_FIND_ANY
-- 
--  Find any CRL.
-- 
--  pvFindPara isn't used.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CRL_FIND_ISSUED_BY
-- 
--  Find CRL matching the specified issuer.
-- 
--  pvFindPara is the PCCERT_CONTEXT of the CRL issuer. May be NULL to
--  match any issuer.
-- 
--  By default, only does issuer name matching. The following flags can be
--  set in dwFindFlags to do additional filtering.
-- 
--  If CRL_FIND_ISSUED_BY_AKI_FLAG is set in dwFindFlags, then, checks if the
--  CRL has an Authority Key Identifier (AKI) extension. If the CRL has an
--  AKI, then, only returns a CRL whose AKI matches the issuer.
-- 
--  Note, the AKI extension has the following OID:
--  szOID_AUTHORITY_KEY_IDENTIFIER2 and its corresponding data structure.
-- 
--  If CRL_FIND_ISSUED_BY_SIGNATURE_FLAG is set in dwFindFlags, then,
--  uses the public key in the issuer's certificate to verify the
--  signature on the CRL. Only returns a CRL having a valid signature.
-- 
--  If CRL_FIND_ISSUED_BY_DELTA_FLAG is set in dwFindFlags, then, only
--  returns a delta CRL.
-- 
--  If CRL_FIND_ISSUED_BY_BASE_FLAG is set in dwFindFlags, then, only
--  returns a base CRL.
-- --------------------------------------------------------------------------
const
  CRL_FIND_ISSUED_BY_AKI_FLAG= $01;

const
  CRL_FIND_ISSUED_BY_SIGNATURE_FLAG= $02;

const
  CRL_FIND_ISSUED_BY_DELTA_FLAG= $04;

const
  CRL_FIND_ISSUED_BY_BASE_FLAG= $08;

-- +-------------------------------------------------------------------------
--  CRL_FIND_EXISTING
-- 
--  Find existing CRL in the store.
-- 
--  pvFindPara is the PCCRL_CONTEXT of the CRL to check if it already
--  exists in the store.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CRL_FIND_ISSUED_FOR
-- 
--  Find CRL for the specified subject and its issuer.
-- 
--  pvFindPara points to the following CRL_FIND_ISSUED_FOR_PARA which contains
--  both the subject and issuer certificates. Not optional.
-- 
--  The subject's issuer name is used to match the CRL's issuer name. Otherwise,
--  the issuer's certificate is used the same as in the above
--  CRL_FIND_ISSUED_BY.
-- 
--  Note, when cross certificates are used, the subject name in the issuer's
--  certificate may not match the issuer name in the subject certificate and
--  its corresponding CRL.
-- 
--  All of the above CRL_FIND_ISSUED_BY_*_FLAGS apply to this find type.
-- --------------------------------------------------------------------------
type
  _CRL_FIND_ISSUED_FOR_PARA = record
pSubjectCert    : PCCERT_CONTEXT;
pIssuerCert     : PCCERT_CONTEXT;
  end record;
  CRL_FIND_ISSUED_FOR_PARA = _CRL_FIND_ISSUED_FOR_PARA;
  PCRL_FIND_ISSUED_FOR_PARA = ^_CRL_FIND_ISSUED_FOR_PARA;

-- +-------------------------------------------------------------------------
--  Duplicate a CRL context
-- --------------------------------------------------------------------------
procedure CertDuplicateCRLContext(
    pCrlContext     : in PCCRL_CONTEXT)
                      return PCCRL_CONTEXT;
#pragma convention(CertDuplicateCRLContext,system);
#pragma import(CertDuplicateCRLContext,'CertDuplicateCRLContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Create a CRL context from the encoded CRL. The created
--  context isn't put in a store.
-- 
--  Makes a copy of the encoded CRL in the created context.
-- 
--  If unable to decode and create the CRL context, NULL is returned.
--  Otherwise, a pointer to a read only CRL_CONTEXT is returned.
--  CRL_CONTEXT must be freed by calling CertFreeCRLContext.
--  CertDuplicateCRLContext can be called to make a duplicate.
-- 
--  CertSetCRLContextProperty and CertGetCRLContextProperty can be called
--  to store properties for the CRL.
-- --------------------------------------------------------------------------
type
t_143=^BYTE for machine_pointer use true;

procedure CertCreateCRLContext(
    dwCertEncodingType : in DWORD; 
    pbCrlEncoded    : in t_143; 
    cbCrlEncoded    : in DWORD)
                      return PCCRL_CONTEXT;
#pragma convention(CertCreateCRLContext,system);
#pragma import(CertCreateCRLContext,'CertCreateCRLContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Free a CRL context
-- 
--  There needs to be a corresponding free for each context obtained by a
--  get, duplicate or create.
-- --------------------------------------------------------------------------
procedure CertFreeCRLContext(
    pCrlContext     : in PCCRL_CONTEXT)
                      return BOOL;
#pragma convention(CertFreeCRLContext,system);
#pragma import(CertFreeCRLContext,'CertFreeCRLContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Set the property for the specified CRL context.
-- 
--  Same Property Ids and semantics as CertSetCertificateContextProperty.
-- --------------------------------------------------------------------------
type
t_144=^unchecked for machine_pointer use true;

procedure CertSetCRLContextProperty(
    pCrlContext     : in PCCRL_CONTEXT; 
    dwPropId        : in DWORD; 
    dwFlags         : in DWORD; 
    pvData          : in t_144)
                      return BOOL;
#pragma convention(CertSetCRLContextProperty,system);
#pragma import(CertSetCRLContextProperty,'CertSetCRLContextProperty','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get the property for the specified CRL context.
-- 
--  Same Property Ids and semantics as CertGetCertificateContextProperty.
-- 
--  CERT_SHA1_HASH_PROP_ID, CERT_MD5_HASH_PROP_ID or
--  CERT_SIGNATURE_HASH_PROP_ID is the predefined property of most interest.
-- --------------------------------------------------------------------------
type
t_145=^unchecked for machine_pointer use true;

procedure CertGetCRLContextProperty(
    pCrlContext     : in PCCRL_CONTEXT; 
    dwPropId        : in DWORD; 
    pvData          : out {!}t_145; 
    pcbData         : in out DWORD)
                      return BOOL;
#pragma convention(CertGetCRLContextProperty,system);
#pragma import(CertGetCRLContextProperty,'CertGetCRLContextProperty','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerate the properties for the specified CRL context.
-- 
--  To get the first property, set dwPropId to 0. The ID of the first
--  property is returned. To get the next property, set dwPropId to the
--  ID returned by the last call. To enumerate all the properties continue
--  until 0 is returned.
-- 
--  CertGetCRLContextProperty is called to get the property's data.
-- --------------------------------------------------------------------------
procedure CertEnumCRLContextProperties(
    pCrlContext     : in PCCRL_CONTEXT; 
    dwPropId        : in DWORD)
                      return DWORD;
#pragma convention(CertEnumCRLContextProperties,system);
#pragma import(CertEnumCRLContextProperties,'CertEnumCRLContextProperties','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Search the CRL's list of entries for the specified certificate.
-- 
--  TRUE is returned if we were able to search the list. Otherwise, FALSE is
--  returned,
-- 
--  For success, if the certificate was found in the list, *ppCrlEntry is
--  updated with a pointer to the entry. Otherwise, *ppCrlEntry is set to NULL.
--  The returned entry isn't allocated and must not be freed.
-- 
--  dwFlags and pvReserved currently aren't used and must be set to 0 or NULL.
-- --------------------------------------------------------------------------
type
t_146=^unchecked for machine_pointer use true;

procedure CertFindCertificateInCRL(
    pCert           : in PCCERT_CONTEXT; 
    pCrlContext     : in PCCRL_CONTEXT; 
    dwFlags         : in DWORD; 
    pvReserved      : in {out optional} t_146; 
    ppCrlEntry      : out PCRL_ENTRY)
                      return BOOL;
#pragma convention(CertFindCertificateInCRL,system);
#pragma import(CertFindCertificateInCRL,'CertFindCertificateInCRL','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Is the specified CRL valid for the certificate.
-- 
--  Returns TRUE if the CRL's list of entries would contain the certificate
--  if it was revoked. Note, doesn't check that the certificate is in the
--  list of entries.
-- 
--  If the CRL has an Issuing Distribution Point (IDP) extension, checks
--  that it's valid for the subject certificate.
-- 
--  dwFlags and pvReserved currently aren't used and must be set to 0 and NULL.
-- --------------------------------------------------------------------------
type
t_147=^unchecked for machine_pointer use true;

procedure CertIsValidCRLForCertificate(
    pCert           : in PCCERT_CONTEXT; 
    pCrl            : in PCCRL_CONTEXT; 
    dwFlags         : in DWORD; 
    pvReserved      : in t_147)
                      return BOOL;
#pragma convention(CertIsValidCRLForCertificate,system);
#pragma import(CertIsValidCRLForCertificate,'CertIsValidCRLForCertificate','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Add certificate/CRL, encoded, context or element disposition values.
-- --------------------------------------------------------------------------
const
  CERT_STORE_ADD_NEW= 1;

const
  CERT_STORE_ADD_USE_EXISTING= 2;

const
  CERT_STORE_ADD_REPLACE_EXISTING= 3;

const
  CERT_STORE_ADD_ALWAYS= 4;

const
  CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES= 5;

const
  CERT_STORE_ADD_NEWER= 6;

const
  CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES= 7;

-- +-------------------------------------------------------------------------
--  Add the encoded certificate to the store according to the specified
--  disposition action.
-- 
--  Makes a copy of the encoded certificate before adding to the store.
-- 
--  dwAddDispostion specifies the action to take if the certificate
--  already exists in the store. This parameter must be one of the following
--  values:
--  CERT_STORE_ADD_NEW
--  Fails if the certificate already exists in the store. LastError
--  is set to CRYPT_E_EXISTS.
--  CERT_STORE_ADD_USE_EXISTING
--  If the certifcate already exists, then, its used and if ppCertContext
--  is non-NULL, the existing context is duplicated.
--  CERT_STORE_ADD_REPLACE_EXISTING
--  If the certificate already exists, then, the existing certificate
--  context is deleted before creating and adding the new context.
--  CERT_STORE_ADD_ALWAYS
--  No check is made to see if the certificate already exists. A
--  new certificate context is always created. This may lead to
--  duplicates in the store.
--  CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES
--  If the certificate already exists, then, its used.
--  CERT_STORE_ADD_NEWER
--  Fails if the certificate already exists in the store AND the NotBefore
--  time of the existing certificate is equal to or greater than the
--  NotBefore time of the new certificate being added. LastError
--  is set to CRYPT_E_EXISTS.
-- 
--  If an older certificate is replaced, same as
--  CERT_STORE_ADD_REPLACE_EXISTING.
-- 
--  For CRLs or CTLs compares the ThisUpdate times.
-- 
--  CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES
--  Same as CERT_STORE_ADD_NEWER. However, if an older certificate is
--  replaced, same as CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES.
-- 
--  CertGetSubjectCertificateFromStore is called to determine if the
--  certificate already exists in the store.
-- 
--  ppCertContext can be NULL, indicating the caller isn't interested
--  in getting the CERT_CONTEXT of the added or existing certificate.
-- --------------------------------------------------------------------------
type
t_148=^BYTE for machine_pointer use true;

procedure CertAddEncodedCertificateToStore(
    hCertStore      : in t_HCERTSTORE; 
    dwCertEncodingType : in DWORD; 
    pbCertEncoded   : in t_148; 
    cbCertEncoded   : in DWORD; 
    dwAddDisposition : in DWORD; 
    ppCertContext   : out {out optional} PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CertAddEncodedCertificateToStore,system);
#pragma import(CertAddEncodedCertificateToStore,'CertAddEncodedCertificateToStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Add the certificate context to the store according to the specified
--  disposition action.
-- 
--  In addition to the encoded certificate, the context's properties are
--  also copied. Note, the CERT_KEY_CONTEXT_PROP_ID property (and its
--  CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied.
-- 
--  Makes a copy of the certificate context before adding to the store.
-- 
--  dwAddDispostion specifies the action to take if the certificate
--  already exists in the store. This parameter must be one of the following
--  values:
--  CERT_STORE_ADD_NEW
--  Fails if the certificate already exists in the store. LastError
--  is set to CRYPT_E_EXISTS.
--  CERT_STORE_ADD_USE_EXISTING
--  If the certifcate already exists, then, its used and if ppStoreContext
--  is non-NULL, the existing context is duplicated. Iterates
--  through pCertContext's properties and only copies the properties
--  that don't already exist. The SHA1 and MD5 hash properties aren't
--  copied.
--  CERT_STORE_ADD_REPLACE_EXISTING
--  If the certificate already exists, then, the existing certificate
--  context is deleted before creating and adding a new context.
--  Properties are copied before doing the add.
--  CERT_STORE_ADD_ALWAYS
--  No check is made to see if the certificate already exists. A
--  new certificate context is always created and added. This may lead to
--  duplicates in the store. Properties are
--  copied before doing the add.
--  CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES
--  If the certificate already exists, then, the existing certificate
--  context is used. Properties from the added context are copied and
--  replace existing properties. However, any existing properties not
--  in the added context remain and aren't deleted.
--  CERT_STORE_ADD_NEWER
--  Fails if the certificate already exists in the store AND the NotBefore
--  time of the existing context is equal to or greater than the
--  NotBefore time of the new context being added. LastError
--  is set to CRYPT_E_EXISTS.
-- 
--  If an older context is replaced, same as
--  CERT_STORE_ADD_REPLACE_EXISTING.
-- 
--  For CRLs or CTLs compares the ThisUpdate times.
-- 
--  CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES
--  Same as CERT_STORE_ADD_NEWER. However, if an older context is
--  replaced, same as CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES.
-- 
--  CertGetSubjectCertificateFromStore is called to determine if the
--  certificate already exists in the store.
-- 
--  ppStoreContext can be NULL, indicating the caller isn't interested
--  in getting the CERT_CONTEXT of the added or existing certificate.
-- --------------------------------------------------------------------------
procedure CertAddCertificateContextToStore(
    hCertStore      : in t_HCERTSTORE; 
    pCertContext    : in PCCERT_CONTEXT; 
    dwAddDisposition : in DWORD; 
    ppStoreContext  : out {out optional} PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CertAddCertificateContextToStore,system);
#pragma import(CertAddCertificateContextToStore,'CertAddCertificateContextToStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Certificate Store Context Types
-- --------------------------------------------------------------------------
const
  CERT_STORE_CERTIFICATE_CONTEXT= 1;

const
  CERT_STORE_CRL_CONTEXT= 2;

const
  CERT_STORE_CTL_CONTEXT= 3;

-- +-------------------------------------------------------------------------
--  Certificate Store Context Bit Flags
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Add the serialized certificate or CRL element to the store.
-- 
--  The serialized element contains the encoded certificate, CRL or CTL and
--  its properties, such as, CERT_KEY_PROV_INFO_PROP_ID.
-- 
--  If hCertStore is NULL, creates a certificate, CRL or CTL context not
--  residing in any store.
-- 
--  dwAddDispostion specifies the action to take if the certificate or CRL
--  already exists in the store. See CertAddCertificateContextToStore for a
--  list of and actions taken.
-- 
--  dwFlags currently isn't used and should be set to 0.
-- 
--  dwContextTypeFlags specifies the set of allowable contexts. For example, to
--  add either a certificate or CRL, set dwContextTypeFlags to:
--  CERT_STORE_CERTIFICATE_CONTEXT_FLAG | CERT_STORE_CRL_CONTEXT_FLAG
-- 
--  *pdwContextType is updated with the type of the context returned in
--  *ppvContxt. pdwContextType or ppvContext can be NULL, indicating the
--  caller isn't interested in getting the output. If *ppvContext is
--  returned it must be freed by calling CertFreeCertificateContext or
--  CertFreeCRLContext.
-- --------------------------------------------------------------------------
type
t_149=^BYTE for machine_pointer use true;

t_150=^unchecked for machine_pointer use true;

procedure CertAddSerializedElementToStore(
    hCertStore      : in t_HCERTSTORE; 
    pbElement       : in t_149; 
    cbElement       : in DWORD; 
    dwAddDisposition : in DWORD; 
    dwFlags         : in DWORD; 
    dwContextTypeFlags : in DWORD; 
    pdwContextType  : out {out optional} DWORD; 
    ppvContext      : out {out optional} t_150)
                      return BOOL;
#pragma convention(CertAddSerializedElementToStore,system);
#pragma import(CertAddSerializedElementToStore,'CertAddSerializedElementToStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Delete the specified certificate from the store.
-- 
--  All subsequent gets or finds for the certificate will fail. However,
--  memory allocated for the certificate isn't freed until all of its contexts
--  have also been freed.
-- 
--  The pCertContext is obtained from a get, enum, find or duplicate.
-- 
--  Some store provider implementations might also delete the issuer's CRLs
--  if this is the last certificate for the issuer in the store.
-- 
--  NOTE: the pCertContext is always CertFreeCertificateContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
procedure CertDeleteCertificateFromStore(
    pCertContext    : in PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CertDeleteCertificateFromStore,system);
#pragma import(CertDeleteCertificateFromStore,'CertDeleteCertificateFromStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Add the encoded CRL to the store according to the specified
--  disposition option.
-- 
--  Makes a copy of the encoded CRL before adding to the store.
-- 
--  dwAddDispostion specifies the action to take if the CRL
--  already exists in the store. See CertAddEncodedCertificateToStore for a
--  list of and actions taken.
-- 
--  Compares the CRL's Issuer to determine if the CRL already exists in the
--  store.
-- 
--  ppCrlContext can be NULL, indicating the caller isn't interested
--  in getting the CRL_CONTEXT of the added or existing CRL.
-- --------------------------------------------------------------------------
type
t_151=^BYTE for machine_pointer use true;

procedure CertAddEncodedCRLToStore(
    hCertStore      : in t_HCERTSTORE; 
    dwCertEncodingType : in DWORD; 
    pbCrlEncoded    : in t_151; 
    cbCrlEncoded    : in DWORD; 
    dwAddDisposition : in DWORD; 
    ppCrlContext    : out {out optional} PCCRL_CONTEXT)
                      return BOOL;
#pragma convention(CertAddEncodedCRLToStore,system);
#pragma import(CertAddEncodedCRLToStore,'CertAddEncodedCRLToStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Add the CRL context to the store according to the specified
--  disposition option.
-- 
--  In addition to the encoded CRL, the context's properties are
--  also copied. Note, the CERT_KEY_CONTEXT_PROP_ID property (and its
--  CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied.
-- 
--  Makes a copy of the encoded CRL before adding to the store.
-- 
--  dwAddDispostion specifies the action to take if the CRL
--  already exists in the store. See CertAddCertificateContextToStore for a
--  list of and actions taken.
-- 
--  Compares the CRL's Issuer, ThisUpdate and NextUpdate to determine
--  if the CRL already exists in the store.
-- 
--  ppStoreContext can be NULL, indicating the caller isn't interested
--  in getting the CRL_CONTEXT of the added or existing CRL.
-- --------------------------------------------------------------------------
procedure CertAddCRLContextToStore(
    hCertStore      : in t_HCERTSTORE; 
    pCrlContext     : in PCCRL_CONTEXT; 
    dwAddDisposition : in DWORD; 
    ppStoreContext  : out {out optional} PCCRL_CONTEXT)
                      return BOOL;
#pragma convention(CertAddCRLContextToStore,system);
#pragma import(CertAddCRLContextToStore,'CertAddCRLContextToStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Delete the specified CRL from the store.
-- 
--  All subsequent gets for the CRL will fail. However,
--  memory allocated for the CRL isn't freed until all of its contexts
--  have also been freed.
-- 
--  The pCrlContext is obtained from a get or duplicate.
-- 
--  NOTE: the pCrlContext is always CertFreeCRLContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
procedure CertDeleteCRLFromStore(
    pCrlContext     : in PCCRL_CONTEXT)
                      return BOOL;
#pragma convention(CertDeleteCRLFromStore,system);
#pragma import(CertDeleteCRLFromStore,'CertDeleteCRLFromStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Serialize the certificate context's encoded certificate and its
--  properties.
-- --------------------------------------------------------------------------
procedure CertSerializeCertificateStoreElement(
    pCertContext    : in PCCERT_CONTEXT; 
    dwFlags         : in DWORD; 
    pbElement       : out BYTE; 
    pcbElement      : in out DWORD)
                      return BOOL;
#pragma convention(CertSerializeCertificateStoreElement,system);
#pragma import(CertSerializeCertificateStoreElement,'CertSerializeCertificateStoreElement','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Serialize the CRL context's encoded CRL and its properties.
-- --------------------------------------------------------------------------
procedure CertSerializeCRLStoreElement(
    pCrlContext     : in PCCRL_CONTEXT; 
    dwFlags         : in DWORD; 
    pbElement       : out BYTE; 
    pcbElement      : in out DWORD)
                      return BOOL;
#pragma convention(CertSerializeCRLStoreElement,system);
#pragma import(CertSerializeCRLStoreElement,'CertSerializeCRLStoreElement','crypt32.dll');

-- +=========================================================================
--  Certificate Trust List (CTL) Store Data Structures and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  Duplicate a CTL context
-- --------------------------------------------------------------------------
procedure CertDuplicateCTLContext(
    pCtlContext     : in PCCTL_CONTEXT)
                      return PCCTL_CONTEXT;
#pragma convention(CertDuplicateCTLContext,system);
#pragma import(CertDuplicateCTLContext,'CertDuplicateCTLContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Create a CTL context from the encoded CTL. The created
--  context isn't put in a store.
-- 
--  Makes a copy of the encoded CTL in the created context.
-- 
--  If unable to decode and create the CTL context, NULL is returned.
--  Otherwise, a pointer to a read only CTL_CONTEXT is returned.
--  CTL_CONTEXT must be freed by calling CertFreeCTLContext.
--  CertDuplicateCTLContext can be called to make a duplicate.
-- 
--  CertSetCTLContextProperty and CertGetCTLContextProperty can be called
--  to store properties for the CTL.
-- --------------------------------------------------------------------------
type
t_152=^BYTE for machine_pointer use true;

procedure CertCreateCTLContext(
    dwMsgAndCertEncodingType : in DWORD; 
    pbCtlEncoded    : in t_152; 
    cbCtlEncoded    : in DWORD)
                      return PCCTL_CONTEXT;
#pragma convention(CertCreateCTLContext,system);
#pragma import(CertCreateCTLContext,'CertCreateCTLContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Free a CTL context
-- 
--  There needs to be a corresponding free for each context obtained by a
--  get, duplicate or create.
-- --------------------------------------------------------------------------
procedure CertFreeCTLContext(
    pCtlContext     : in PCCTL_CONTEXT)
                      return BOOL;
#pragma convention(CertFreeCTLContext,system);
#pragma import(CertFreeCTLContext,'CertFreeCTLContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Set the property for the specified CTL context.
-- 
--  Same Property Ids and semantics as CertSetCertificateContextProperty.
-- --------------------------------------------------------------------------
type
t_153=^unchecked for machine_pointer use true;

procedure CertSetCTLContextProperty(
    pCtlContext     : in PCCTL_CONTEXT; 
    dwPropId        : in DWORD; 
    dwFlags         : in DWORD; 
    pvData          : in t_153)
                      return BOOL;
#pragma convention(CertSetCTLContextProperty,system);
#pragma import(CertSetCTLContextProperty,'CertSetCTLContextProperty','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get the property for the specified CTL context.
-- 
--  Same Property Ids and semantics as CertGetCertificateContextProperty.
-- 
--  CERT_SHA1_HASH_PROP_ID or CERT_NEXT_UPDATE_LOCATION_PROP_ID are the
--  predefined properties of most interest.
-- --------------------------------------------------------------------------
type
t_154=^unchecked for machine_pointer use true;

procedure CertGetCTLContextProperty(
    pCtlContext     : in PCCTL_CONTEXT; 
    dwPropId        : in DWORD; 
    pvData          : out {!}t_154; 
    pcbData         : in out DWORD)
                      return BOOL;
#pragma convention(CertGetCTLContextProperty,system);
#pragma import(CertGetCTLContextProperty,'CertGetCTLContextProperty','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerate the properties for the specified CTL context.
-- --------------------------------------------------------------------------
procedure CertEnumCTLContextProperties(
    pCtlContext     : in PCCTL_CONTEXT; 
    dwPropId        : in DWORD)
                      return DWORD;
#pragma convention(CertEnumCTLContextProperties,system);
#pragma import(CertEnumCTLContextProperties,'CertEnumCTLContextProperties','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerate the CTL contexts in the store.
-- 
--  If a CTL isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
--  must be freed by calling CertFreeCTLContext or is freed when passed as the
--  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
--  can be called to make a duplicate.
-- 
--  pPrevCtlContext MUST BE NULL to enumerate the first
--  CTL in the store. Successive CTLs are enumerated by setting
--  pPrevCtlContext to the CTL_CONTEXT returned by a previous call.
-- 
--  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
procedure CertEnumCTLsInStore(
    hCertStore      : in t_HCERTSTORE; 
    pPrevCtlContext : in PCCTL_CONTEXT)
                      return PCCTL_CONTEXT;
#pragma convention(CertEnumCTLsInStore,system);
#pragma import(CertEnumCTLsInStore,'CertEnumCTLsInStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Attempt to find the specified subject in the CTL.
-- 
--  For CTL_CERT_SUBJECT_TYPE, pvSubject points to a CERT_CONTEXT. The CTL's
--  SubjectAlgorithm is examined to determine the representation of the
--  subject's identity. Initially, only SHA1 or MD5 hash will be supported.
--  The appropriate hash property is obtained from the CERT_CONTEXT.
-- 
--  For CTL_ANY_SUBJECT_TYPE, pvSubject points to the CTL_ANY_SUBJECT_INFO
--  structure which contains the SubjectAlgorithm to be matched in the CTL
--  and the SubjectIdentifer to be matched in one of the CTL entries.
-- 
--  The certificate's hash or the CTL_ANY_SUBJECT_INFO's SubjectIdentifier
--  is used as the key in searching the subject entries. A binary
--  memory comparison is done between the key and the entry's SubjectIdentifer.
-- 
--  dwEncodingType isn't used for either of the above SubjectTypes.
-- --------------------------------------------------------------------------
type
t_155=^unchecked for machine_pointer use true;

procedure CertFindSubjectInCTL(
    dwEncodingType  : in DWORD; 
    dwSubjectType   : in DWORD; 
    pvSubject       : in t_155; 
    pCtlContext     : in PCCTL_CONTEXT; 
    dwFlags         : in DWORD)
                      return PCTL_ENTRY;
#pragma convention(CertFindSubjectInCTL,system);
#pragma import(CertFindSubjectInCTL,'CertFindSubjectInCTL','crypt32.dll');

--  Subject Types:
--  CTL_ANY_SUBJECT_TYPE, pvSubject points to following CTL_ANY_SUBJECT_INFO.
--  CTL_CERT_SUBJECT_TYPE, pvSubject points to CERT_CONTEXT.
const
  CTL_ANY_SUBJECT_TYPE= 1;

const
  CTL_CERT_SUBJECT_TYPE= 2;

type
  _CTL_ANY_SUBJECT_INFO = record
SubjectAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
SubjectIdentifier : CRYPT_DATA_BLOB;
  end record;
  CTL_ANY_SUBJECT_INFO = _CTL_ANY_SUBJECT_INFO;
  PCTL_ANY_SUBJECT_INFO = ^_CTL_ANY_SUBJECT_INFO;

-- +-------------------------------------------------------------------------
--  Find the first or next CTL context in the store.
-- 
--  The CTL is found according to the dwFindType and its pvFindPara.
--  See below for a list of the find types and its parameters.
-- 
--  Currently dwFindFlags isn't used and must be set to 0.
-- 
--  Usage of dwMsgAndCertEncodingType depends on the dwFindType.
-- 
--  If the first or next CTL isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
--  must be freed by calling CertFreeCTLContext or is freed when passed as the
--  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
--  can be called to make a duplicate.
-- 
--  pPrevCtlContext MUST BE NULL on the first
--  call to find the CTL. To find the next CTL, the
--  pPrevCtlContext is set to the CTL_CONTEXT returned by a previous call.
-- 
--  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
type
t_156=^unchecked for machine_pointer use true;

procedure CertFindCTLInStore(
    hCertStore      : in t_HCERTSTORE; 
    dwMsgAndCertEncodingType : in DWORD; 
    dwFindFlags     : in DWORD; 
    dwFindType      : in DWORD; 
    pvFindPara      : in t_156; 
    pPrevCtlContext : in PCCTL_CONTEXT)
                      return PCCTL_CONTEXT;
#pragma convention(CertFindCTLInStore,system);
#pragma import(CertFindCTLInStore,'CertFindCTLInStore','crypt32.dll');

const
  CTL_FIND_ANY      = 0;

const
  CTL_FIND_SHA1_HASH= 1;

const
  CTL_FIND_MD5_HASH = 2;

const
  CTL_FIND_USAGE    = 3;

const
  CTL_FIND_SUBJECT  = 4;

const
  CTL_FIND_EXISTING = 5;

type
  _CTL_FIND_USAGE_PARA = record
cbSize          : DWORD;
SubjectUsage    : CTL_USAGE;
ListIdentifier  : CRYPT_DATA_BLOB;
pSigner         : PCERT_INFO;
  end record;
  CTL_FIND_USAGE_PARA = _CTL_FIND_USAGE_PARA;
  PCTL_FIND_USAGE_PARA = ^_CTL_FIND_USAGE_PARA;

const
  CTL_FIND_NO_LIST_ID_CBDATA= $FFFFFFFF;

const
  CTL_FIND_SAME_USAGE_FLAG= $01;

type
  _CTL_FIND_SUBJECT_PARA = record
cbSize          : DWORD;
pUsagePara      : PCTL_FIND_USAGE_PARA;
dwSubjectType   : DWORD;
pvSubject       : ^unchecked;
  end record;
  CTL_FIND_SUBJECT_PARA = _CTL_FIND_SUBJECT_PARA;
  PCTL_FIND_SUBJECT_PARA = ^_CTL_FIND_SUBJECT_PARA;

-- +-------------------------------------------------------------------------
--  CTL_FIND_ANY
-- 
--  Find any CTL.
-- 
--  pvFindPara isn't used.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CTL_FIND_SHA1_HASH
--  CTL_FIND_MD5_HASH
-- 
--  Find a CTL with the specified hash.
-- 
--  pvFindPara points to a CRYPT_HASH_BLOB.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CTL_FIND_USAGE
-- 
--  Find a CTL having the specified usage identifiers, list identifier or
--  signer. The CertEncodingType of the signer is obtained from the
--  dwMsgAndCertEncodingType parameter.
-- 
--  pvFindPara points to a CTL_FIND_USAGE_PARA data structure. The
--  SubjectUsage.cUsageIdentifer can be 0 to match any usage. The
--  ListIdentifier.cbData can be 0 to match any list identifier. To only match
--  CTLs without a ListIdentifier, cbData must be set to
--  CTL_FIND_NO_LIST_ID_CBDATA. pSigner can be NULL to match any signer. Only
--  the Issuer and SerialNumber fields of the pSigner's PCERT_INFO are used.
--  To only match CTLs without a signer, pSigner must be set to
--  CTL_FIND_NO_SIGNER_PTR.
-- 
--  The CTL_FIND_SAME_USAGE_FLAG can be set in dwFindFlags to
--  only match CTLs with the same usage identifiers. CTLs having additional
--  usage identifiers aren't matched. For example, if only "1.2.3" is specified
--  in CTL_FIND_USAGE_PARA, then, for a match, the CTL must only contain
--  "1.2.3" and not any additional usage identifers.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CTL_FIND_SUBJECT
-- 
--  Find a CTL having the specified subject. CertFindSubjectInCTL can be
--  called to get a pointer to the subject's entry in the CTL. pUsagePara can
--  optionally be set to enable the above CTL_FIND_USAGE matching.
-- 
--  pvFindPara points to a CTL_FIND_SUBJECT_PARA data structure.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Add the encoded CTL to the store according to the specified
--  disposition option.
-- 
--  Makes a copy of the encoded CTL before adding to the store.
-- 
--  dwAddDispostion specifies the action to take if the CTL
--  already exists in the store. See CertAddEncodedCertificateToStore for a
--  list of and actions taken.
-- 
--  Compares the CTL's SubjectUsage, ListIdentifier and any of its signers
--  to determine if the CTL already exists in the store.
-- 
--  ppCtlContext can be NULL, indicating the caller isn't interested
--  in getting the CTL_CONTEXT of the added or existing CTL.
-- --------------------------------------------------------------------------
type
t_157=^BYTE for machine_pointer use true;

procedure CertAddEncodedCTLToStore(
    hCertStore      : in t_HCERTSTORE; 
    dwMsgAndCertEncodingType : in DWORD; 
    pbCtlEncoded    : in t_157; 
    cbCtlEncoded    : in DWORD; 
    dwAddDisposition : in DWORD; 
    ppCtlContext    : out {out optional} PCCTL_CONTEXT)
                      return BOOL;
#pragma convention(CertAddEncodedCTLToStore,system);
#pragma import(CertAddEncodedCTLToStore,'CertAddEncodedCTLToStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Add the CTL context to the store according to the specified
--  disposition option.
-- 
--  In addition to the encoded CTL, the context's properties are
--  also copied. Note, the CERT_KEY_CONTEXT_PROP_ID property (and its
--  CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_SPEC_PROP_ID) isn't copied.
-- 
--  Makes a copy of the encoded CTL before adding to the store.
-- 
--  dwAddDispostion specifies the action to take if the CTL
--  already exists in the store. See CertAddCertificateContextToStore for a
--  list of and actions taken.
-- 
--  Compares the CTL's SubjectUsage, ListIdentifier and any of its signers
--  to determine if the CTL already exists in the store.
-- 
--  ppStoreContext can be NULL, indicating the caller isn't interested
--  in getting the CTL_CONTEXT of the added or existing CTL.
-- --------------------------------------------------------------------------
procedure CertAddCTLContextToStore(
    hCertStore      : in t_HCERTSTORE; 
    pCtlContext     : in PCCTL_CONTEXT; 
    dwAddDisposition : in DWORD; 
    ppStoreContext  : out {out optional} PCCTL_CONTEXT)
                      return BOOL;
#pragma convention(CertAddCTLContextToStore,system);
#pragma import(CertAddCTLContextToStore,'CertAddCTLContextToStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Serialize the CTL context's encoded CTL and its properties.
-- --------------------------------------------------------------------------
procedure CertSerializeCTLStoreElement(
    pCtlContext     : in PCCTL_CONTEXT; 
    dwFlags         : in DWORD; 
    pbElement       : out BYTE; 
    pcbElement      : in out DWORD)
                      return BOOL;
#pragma convention(CertSerializeCTLStoreElement,system);
#pragma import(CertSerializeCTLStoreElement,'CertSerializeCTLStoreElement','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Delete the specified CTL from the store.
-- 
--  All subsequent gets for the CTL will fail. However,
--  memory allocated for the CTL isn't freed until all of its contexts
--  have also been freed.
-- 
--  The pCtlContext is obtained from a get or duplicate.
-- 
--  NOTE: the pCtlContext is always CertFreeCTLContext'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
procedure CertDeleteCTLFromStore(
    pCtlContext     : in PCCTL_CONTEXT)
                      return BOOL;
#pragma convention(CertDeleteCTLFromStore,system);
#pragma import(CertDeleteCTLFromStore,'CertDeleteCTLFromStore','crypt32.dll');

procedure CertAddCertificateLinkToStore(
    hCertStore      : in t_HCERTSTORE; 
    pCertContext    : in PCCERT_CONTEXT; 
    dwAddDisposition : in DWORD; 
    ppStoreContext  : out {out optional} PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CertAddCertificateLinkToStore,system);
#pragma import(CertAddCertificateLinkToStore,'CertAddCertificateLinkToStore','crypt32.dll');

procedure CertAddCRLLinkToStore(
    hCertStore      : in t_HCERTSTORE; 
    pCrlContext     : in PCCRL_CONTEXT; 
    dwAddDisposition : in DWORD; 
    ppStoreContext  : out {out optional} PCCRL_CONTEXT)
                      return BOOL;
#pragma convention(CertAddCRLLinkToStore,system);
#pragma import(CertAddCRLLinkToStore,'CertAddCRLLinkToStore','crypt32.dll');

procedure CertAddCTLLinkToStore(
    hCertStore      : in t_HCERTSTORE; 
    pCtlContext     : in PCCTL_CONTEXT; 
    dwAddDisposition : in DWORD; 
    ppStoreContext  : out {out optional} PCCTL_CONTEXT)
                      return BOOL;
#pragma convention(CertAddCTLLinkToStore,system);
#pragma import(CertAddCTLLinkToStore,'CertAddCTLLinkToStore','crypt32.dll');

procedure CertAddStoreToCollection(
    hCollectionStore : in t_HCERTSTORE; 
    hSiblingStore   : in {out optional} t_HCERTSTORE; 
    dwUpdateFlags   : in DWORD; 
    dwPriority      : in DWORD)
                      return BOOL;
#pragma convention(CertAddStoreToCollection,system);
#pragma import(CertAddStoreToCollection,'CertAddStoreToCollection','crypt32.dll');

procedure CertRemoveStoreFromCollection(
    hCollectionStore : in t_HCERTSTORE; 
    hSiblingStore   : in t_HCERTSTORE);
#pragma convention(CertRemoveStoreFromCollection,system);
#pragma import(CertRemoveStoreFromCollection,'CertRemoveStoreFromCollection','crypt32.dll');

type
t_158=^unchecked for machine_pointer use true;

procedure CertControlStore(
    hCertStore      : in t_HCERTSTORE; 
    dwFlags         : in DWORD; 
    dwCtrlType      : in DWORD; 
    pvCtrlPara      : in t_158)
                      return BOOL;
#pragma convention(CertControlStore,system);
#pragma import(CertControlStore,'CertControlStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Certificate Store control types
-- --------------------------------------------------------------------------
const
  CERT_STORE_CTRL_RESYNC= 1;

const
  CERT_STORE_CTRL_NOTIFY_CHANGE= 2;

const
  CERT_STORE_CTRL_COMMIT= 3;

const
  CERT_STORE_CTRL_AUTO_RESYNC= 4;

const
  CERT_STORE_CTRL_CANCEL_NOTIFY= 5;

const
  CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG= $01;

-- +-------------------------------------------------------------------------
--  CERT_STORE_CTRL_RESYNC
-- 
--  Re-synchronize the store.
-- 
--  The pvCtrlPara points to the event HANDLE to be signaled on
--  the next store change. Normally, this would be the same
--  event HANDLE passed to CERT_STORE_CTRL_NOTIFY_CHANGE during initialization.
-- 
--  If pvCtrlPara is NULL, no events are re-armed.
-- 
--  By default the event HANDLE is DuplicateHandle'd.
--  CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG can be set in dwFlags
--  to inhibit a DupicateHandle of the event HANDLE. If this flag
--  is set, then, CertControlStore(CERT_STORE_CTRL_CANCEL_NOTIFY) must be
--  called for this event HANDLE before closing the hCertStore.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_STORE_CTRL_NOTIFY_CHANGE
-- 
--  Signal the event when the underlying store is changed.
-- 
--  pvCtrlPara points to the event HANDLE to be signaled.
-- 
--  pvCtrlPara can be NULL to inform the store of a subsequent
--  CERT_STORE_CTRL_RESYNC and allow it to optimize by only doing a resync
--  if the store has changed. For the registry based stores, an internal
--  notify change event is created and registered to be signaled.
-- 
--  Recommend calling CERT_STORE_CTRL_NOTIFY_CHANGE once for each event to
--  be passed to CERT_STORE_CTRL_RESYNC. This should only happen after
--  the event has been created. Not after each time the event is signaled.
-- 
--  By default the event HANDLE is DuplicateHandle'd.
--  CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG can be set in dwFlags
--  to inhibit a DupicateHandle of the event HANDLE. If this flag
--  is set, then, CertControlStore(CERT_STORE_CTRL_CANCEL_NOTIFY) must be
--  called for this event HANDLE before closing the hCertStore.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_STORE_CTRL_CANCEL_NOTIFY
-- 
--  Cancel notification signaling of the event HANDLE passed in a previous
--  CERT_STORE_CTRL_NOTIFY_CHANGE or CERT_STORE_CTRL_RESYNC.
-- 
--  pvCtrlPara points to the event HANDLE to be canceled.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_STORE_CTRL_AUTO_RESYNC
-- 
--  At the start of every enumeration or find store API call, check if the
--  underlying store has changed. If it has changed, re-synchronize.
-- 
--  This check is only done in the enumeration or find APIs when the
--  pPrevContext is NULL.
-- 
--  The pvCtrlPara isn't used and must be set to NULL.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_STORE_CTRL_COMMIT
-- 
--  If any changes have been to the cached store, they are committed to
--  persisted storage. If no changes have been made since the store was
--  opened or the last commit, this call is ignored. May also be ignored by
--  store providers that persist changes immediately.
-- 
--  CERT_STORE_CTRL_COMMIT_FORCE_FLAG can be set to force the store
--  to be committed even if it hasn't been touched.
-- 
--  CERT_STORE_CTRL_COMMIT_CLEAR_FLAG can be set to inhibit a commit on
--  store close.
-- --------------------------------------------------------------------------
const
  CERT_STORE_CTRL_COMMIT_FORCE_FLAG= $01;

const
  CERT_STORE_CTRL_COMMIT_CLEAR_FLAG= $02;

-- +=========================================================================
--  Cert Store Property Defines and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  Store property IDs. This is a property applicable to the entire store.
--  Its not a property on an individual certificate, CRL or CTL context.
-- 
--  Currently, no store properties are persisted. (This differs from
--  most context properties which are persisted.)
-- 
--  See CertSetStoreProperty or CertGetStoreProperty for usage information.
-- 
--  Note, the range for predefined store properties should be outside
--  the range of predefined context properties. We will start at 4096.
-- --------------------------------------------------------------------------
const
  CERT_STORE_LOCALIZED_NAME_PROP_ID= $1000;

-- +-------------------------------------------------------------------------
--  Set a store property.
-- 
--  The type definition for pvData depends on the dwPropId value.
--  CERT_STORE_LOCALIZED_NAME_PROP_ID - localized name of the store.
--  pvData points to a CRYPT_DATA_BLOB. pbData is a pointer to a NULL
--  terminated unicode, wide character string.
--  cbData = (wcslen((LPWSTR) pbData) + 1) * sizeof(WCHAR).
-- 
--  For all the other PROP_IDs: an encoded PCRYPT_DATA_BLOB is passed in pvData.
-- 
--  If the property already exists, then, the old value is deleted and silently
--  replaced. Setting, pvData to NULL, deletes the property.
-- --------------------------------------------------------------------------
type
t_159=^unchecked for machine_pointer use true;

procedure CertSetStoreProperty(
    hCertStore      : in t_HCERTSTORE; 
    dwPropId        : in DWORD; 
    dwFlags         : in DWORD; 
    pvData          : in t_159)
                      return BOOL;
#pragma convention(CertSetStoreProperty,system);
#pragma import(CertSetStoreProperty,'CertSetStoreProperty','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get a store property.
-- 
--  The type definition for pvData depends on the dwPropId value.
--  CERT_STORE_LOCALIZED_NAME_PROP_ID - localized name of the store.
--  pvData points to a NULL terminated unicode, wide character string.
--  cbData = (wcslen((LPWSTR) pvData) + 1) * sizeof(WCHAR).
-- 
--  For all other PROP_IDs, pvData points to an array of bytes.
-- 
--  If the property doesn't exist, returns FALSE and sets LastError to
--  CRYPT_E_NOT_FOUND.
-- --------------------------------------------------------------------------
type
t_160=^unchecked for machine_pointer use true;

procedure CertGetStoreProperty(
    hCertStore      : in t_HCERTSTORE; 
    dwPropId        : in DWORD; 
    pvData          : out {!}t_160; 
    pcbData         : in out DWORD)
                      return BOOL;
#pragma convention(CertGetStoreProperty,system);
#pragma import(CertGetStoreProperty,'CertGetStoreProperty','crypt32.dll');

type
  _CERT_CREATE_CONTEXT_PARA = record
cbSize          : DWORD;
pfnFree         : PFN_CRYPT_FREE;
pvFree          : ^unchecked;
  end record;
  CERT_CREATE_CONTEXT_PARA = _CERT_CREATE_CONTEXT_PARA;
  PCERT_CREATE_CONTEXT_PARA = ^_CERT_CREATE_CONTEXT_PARA;

-- +-------------------------------------------------------------------------
--  Creates the specified context from the encoded bytes. The created
--  context isn't put in a store.
-- 
--  dwContextType values:
--  CERT_STORE_CERTIFICATE_CONTEXT
--  CERT_STORE_CRL_CONTEXT
--  CERT_STORE_CTL_CONTEXT
-- 
--  If CERT_CREATE_CONTEXT_NOCOPY_FLAG is set, the created context points
--  directly to the pbEncoded instead of an allocated copy. See flag
--  definition for more details.
-- 
--  If CERT_CREATE_CONTEXT_SORTED_FLAG is set, the context is created
--  with sorted entries. This flag may only be set for CERT_STORE_CTL_CONTEXT.
--  Setting this flag implicitly sets CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG and
--  CERT_CREATE_CONTEXT_NO_ENTRY_FLAG. See flag definition for
--  more details.
-- 
--  If CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG is set, the context is created
--  without creating a HCRYPTMSG handle for the context. This flag may only be
--  set for CERT_STORE_CTL_CONTEXT. See flag definition for more details.
-- 
--  If CERT_CREATE_CONTEXT_NO_ENTRY_FLAG is set, the context is created
--  without decoding the entries. This flag may only be set for
--  CERT_STORE_CTL_CONTEXT. See flag definition for more details.
-- 
--  If unable to decode and create the context, NULL is returned.
--  Otherwise, a pointer to a read only CERT_CONTEXT, CRL_CONTEXT or
--  CTL_CONTEXT is returned. The context must be freed by the appropriate
--  free context API. The context can be duplicated by calling the
--  appropriate duplicate context API.
-- --------------------------------------------------------------------------
type
t_161=^BYTE for machine_pointer use true;

  t_162 = ^unchecked for machine_pointer use true;

procedure CertCreateContext(
    dwContextType   : in DWORD; 
    dwEncodingType  : in DWORD; 
    pbEncoded       : in t_161; 
    cbEncoded       : in DWORD; 
    dwFlags         : in DWORD; 
    pCreatePara     : in {out optional} PCERT_CREATE_CONTEXT_PARA)
                      return t_162;
#pragma convention(CertCreateContext,system);
#pragma import(CertCreateContext,'CertCreateContext','crypt32.dll');

--  When the following flag is set, the created context points directly to the
--  pbEncoded instead of an allocated copy. If pCreatePara and
--  pCreatePara->pfnFree are non-NULL, then, pfnFree is called to free
--  the pbEncoded when the context is last freed. Otherwise, no attempt is
--  made to free the pbEncoded. If pCreatePara->pvFree is non-NULL, then its
--  passed to pfnFree instead of pbEncoded.
-- 
--  Note, if CertCreateContext fails, pfnFree is still called.
const
  CERT_CREATE_CONTEXT_NOCOPY_FLAG= $01;

--  When the following flag is set, a context with sorted entries is created.
--  Currently only applicable to a CTL context.
-- 
--  For CTLs: the cCTLEntry in the returned CTL_INFO is always
--  0. CertFindSubjectInSortedCTL and CertEnumSubjectInSortedCTL must be called
--  to find or enumerate the CTL entries.
-- 
--  The Sorted CTL TrustedSubjects extension isn't returned in the created
--  context's CTL_INFO.
const
  CERT_CREATE_CONTEXT_SORTED_FLAG= $02;

--  By default when a CTL context is created, a HCRYPTMSG handle to its
--  SignedData message is created. This flag can be set to improve performance
--  by not creating the HCRYPTMSG handle.
-- 
--  This flag is only applicable to a CTL context.
const
  CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG= $04;

--  By default when a CTL context is created, its entries are decoded.
--  This flag can be set to improve performance by not decoding the
--  entries.
-- 
--  This flag is only applicable to a CTL context.
const
  CERT_CREATE_CONTEXT_NO_ENTRY_FLAG= $08;

-- +=========================================================================
--  Certificate System Store Data Structures and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  System Store Information
-- 
--  Currently, no system store information is persisted.
-- --------------------------------------------------------------------------
type
  _CERT_SYSTEM_STORE_INFO = record
cbSize          : DWORD;
  end record;
  CERT_SYSTEM_STORE_INFO = _CERT_SYSTEM_STORE_INFO;
  PCERT_SYSTEM_STORE_INFO = ^_CERT_SYSTEM_STORE_INFO;

-- +-------------------------------------------------------------------------
--  Physical Store Information
-- 
--  The Open fields are passed directly to CertOpenStore() to open
--  the physical store.
-- 
--  By default all system stores located in the registry have an
--  implicit SystemRegistry physical store that is opened. To disable the
--  opening of this store, the SystemRegistry
--  physical store corresponding to the System store must be registered with
--  CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG set in dwFlags. Alternatively,
--  a physical store with the name of ".Default" may be registered.
-- 
--  Depending on the store location and store name, additional predefined
--  physical stores may be opened. For example, system stores in
--  CURRENT_USER have the predefined physical store, .LocalMachine.
--  To disable the opening of these predefined physical stores, the
--  corresponding physical store must be registered with
--  CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG set in dwFlags.
-- 
--  The CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG must be set in dwFlags
--  to enable the adding of a context to the store.
-- 
--  When a system store is opened via the SERVICES or USERS store location,
--  the ServiceName\ is prepended to the OpenParameters
--  for CERT_SYSTEM_STORE_CURRENT_USER or CERT_SYSTEM_STORE_CURRENT_SERVICE
--  physical stores and the dwOpenFlags store location is changed to
--  CERT_SYSTEM_STORE_USERS or CERT_SYSTEM_STORE_SERVICES.
-- 
--  By default the SYSTEM, SYSTEM_REGISTRY and PHYSICAL provider
--  stores are also opened remotely when the outer system store is opened.
--  The CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG may be set in dwFlags
--  to disable remote opens.
-- 
--  When opened remotely, the \\ComputerName is implicitly prepended to the
--  OpenParameters for the SYSTEM, SYSTEM_REGISTRY and PHYSICAL provider types.
--  To also prepend the \\ComputerName to other provider types, set the
--  CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG in dwFlags.
-- 
--  When the system store is opened, its physical stores are ordered
--  according to the dwPriority. A larger dwPriority indicates higher priority.
-- --------------------------------------------------------------------------
type
  _CERT_PHYSICAL_STORE_INFO = record
cbSize          : DWORD;
pszOpenStoreProvider : LPSTR;
dwOpenEncodingType : DWORD;
dwOpenFlags     : DWORD;
OpenParameters  : CRYPT_DATA_BLOB;
dwFlags         : DWORD;
dwPriority      : DWORD;
  end record;
  CERT_PHYSICAL_STORE_INFO = _CERT_PHYSICAL_STORE_INFO;
  PCERT_PHYSICAL_STORE_INFO = ^_CERT_PHYSICAL_STORE_INFO;

-- +-------------------------------------------------------------------------
--  Physical Store Information dwFlags
-- --------------------------------------------------------------------------
const
  CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG= $01;

const
  CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG= $02;

const
  CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG= $04;

const
  CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG= $08;

-- +-------------------------------------------------------------------------
--  Register a system store.
-- 
--  The upper word of the dwFlags parameter is used to specify the location of
--  the system store.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
--  pvSystemStore points to a null terminated UNICODE string.
-- 
--  The CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS system store
--  name must be prefixed with the ServiceName or UserName. For example,
--  "ServiceName\Trust".
-- 
--  Stores on remote computers can be registered for the
--  CERT_SYSTEM_STORE_LOCAL_MACHINE, CERT_SYSTEM_STORE_SERVICES,
--  CERT_SYSTEM_STORE_USERS, CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
--  or CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
--  locations by prepending the computer name. For example, a remote
--  local machine store is registered via "\\ComputerName\Trust" or
--  "ComputerName\Trust". A remote service store is registered via
--  "\\ComputerName\ServiceName\Trust". The leading "\\" backslashes are
--  optional in the ComputerName.
-- 
--  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the system store
--  already exists in the store location.
-- --------------------------------------------------------------------------
type
t_163=^unchecked for machine_pointer use true;

t_164=^unchecked for machine_pointer use true;

procedure CertRegisterSystemStore(
    pvSystemStore   : in t_163; 
    dwFlags         : in DWORD; 
    pStoreInfo      : in PCERT_SYSTEM_STORE_INFO; 
    pvReserved      : in {out optional} t_164)
                      return BOOL;
#pragma convention(CertRegisterSystemStore,system);
#pragma import(CertRegisterSystemStore,'CertRegisterSystemStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Register a physical store for the specified system store.
-- 
--  The upper word of the dwFlags parameter is used to specify the location of
--  the system store.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
--  pvSystemStore points to a null terminated UNICODE string.
-- 
--  See CertRegisterSystemStore for details on prepending a ServiceName
--  and/or ComputerName to the system store name.
-- 
--  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the physical store
--  already exists in the system store.
-- --------------------------------------------------------------------------
type
t_165=^unchecked for machine_pointer use true;

t_166=^unchecked for machine_pointer use true;

procedure CertRegisterPhysicalStore(
    pvSystemStore   : in t_165; 
    dwFlags         : in DWORD; 
    pwszStoreName   : in LPCWSTR; 
    pStoreInfo      : in PCERT_PHYSICAL_STORE_INFO; 
    pvReserved      : in {out optional} t_166)
                      return BOOL;
#pragma convention(CertRegisterPhysicalStore,system);
#pragma import(CertRegisterPhysicalStore,'CertRegisterPhysicalStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Unregister the specified system store.
-- 
--  The upper word of the dwFlags parameter is used to specify the location of
--  the system store.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
--  pvSystemStore points to a null terminated UNICODE string.
-- 
--  See CertRegisterSystemStore for details on prepending a ServiceName
--  and/or ComputerName to the system store name.
-- 
--  CERT_STORE_DELETE_FLAG can optionally be set in dwFlags.
-- --------------------------------------------------------------------------
type
t_167=^unchecked for machine_pointer use true;

procedure CertUnregisterSystemStore(
    pvSystemStore   : in t_167; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(CertUnregisterSystemStore,system);
#pragma import(CertUnregisterSystemStore,'CertUnregisterSystemStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Unregister the physical store from the specified system store.
-- 
--  The upper word of the dwFlags parameter is used to specify the location of
--  the system store.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
--  pvSystemStore points to a null terminated UNICODE string.
-- 
--  See CertRegisterSystemStore for details on prepending a ServiceName
--  and/or ComputerName to the system store name.
-- 
--  CERT_STORE_DELETE_FLAG can optionally be set in dwFlags.
-- --------------------------------------------------------------------------
type
t_168=^unchecked for machine_pointer use true;

procedure CertUnregisterPhysicalStore(
    pvSystemStore   : in t_168; 
    dwFlags         : in DWORD; 
    pwszStoreName   : in LPCWSTR)
                      return BOOL;
#pragma convention(CertUnregisterPhysicalStore,system);
#pragma import(CertUnregisterPhysicalStore,'CertUnregisterPhysicalStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enum callbacks
-- 
--  The CERT_SYSTEM_STORE_LOCATION_MASK bits in the dwFlags parameter
--  specifies the location of the system store
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
--  pvSystemStore points to a null terminated UNICODE string.
-- 
--  The callback returns FALSE and sets LAST_ERROR to stop the enumeration.
--  The LAST_ERROR is returned to the caller of the enumeration.
-- 
--  The pvSystemStore passed to the callback has leading ComputerName and/or
--  ServiceName prefixes where appropriate.
-- --------------------------------------------------------------------------
type
t_169=^unchecked for machine_pointer use true;
t_170=^unchecked for machine_pointer use true;

PFN_CERT_ENUM_SYSTEM_STORE_LOCATION = ^procedure (
    pwszStoreLocation : in LPCWSTR;
    dwFlags         : in DWORD;
    pvReserved      : in {out optional} t_169;
    pvArg           : in {out optional} t_170)
                      return BOOL for machine_pointer use true;
type
t_171=^unchecked for machine_pointer use true;
t_172=^unchecked for machine_pointer use true;
t_173=^unchecked for machine_pointer use true;

PFN_CERT_ENUM_SYSTEM_STORE = ^procedure (
    pvSystemStore   : in t_171;
    dwFlags         : in DWORD;
    pStoreInfo      : in PCERT_SYSTEM_STORE_INFO;
    pvReserved      : in {out optional} t_172;
    pvArg           : in {out optional} t_173)
                      return BOOL for machine_pointer use true;
type
t_174=^unchecked for machine_pointer use true;
t_175=^unchecked for machine_pointer use true;
t_176=^unchecked for machine_pointer use true;

PFN_CERT_ENUM_PHYSICAL_STORE = ^procedure (
    pvSystemStore   : in t_174;
    dwFlags         : in DWORD;
    pwszStoreName   : in LPCWSTR;
    pStoreInfo      : in PCERT_PHYSICAL_STORE_INFO;
    pvReserved      : in {out optional} t_175;
    pvArg           : in {out optional} t_176)
                      return BOOL for machine_pointer use true;
--  In the PFN_CERT_ENUM_PHYSICAL_STORE callback the following flag is
--  set if the physical store wasn't registered and is an implicitly created
--  predefined physical store.
const
  CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG= $01;

--  Names of implicitly created predefined physical stores
-- +-------------------------------------------------------------------------
--  Enumerate the system store locations.
-- --------------------------------------------------------------------------
type
t_177=^unchecked for machine_pointer use true;

procedure CertEnumSystemStoreLocation(
    dwFlags         : in DWORD; 
    pvArg           : in t_177; 
    pfnEnum         : in PFN_CERT_ENUM_SYSTEM_STORE_LOCATION)
                      return BOOL;
#pragma convention(CertEnumSystemStoreLocation,system);
#pragma import(CertEnumSystemStoreLocation,'CertEnumSystemStoreLocation','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerate the system stores.
-- 
--  The upper word of the dwFlags parameter is used to specify the location of
--  the system store.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags,
--  pvSystemStoreLocationPara points to a CERT_SYSTEM_STORE_RELOCATE_PARA
--  data structure. Otherwise, pvSystemStoreLocationPara points to a null
--  terminated UNICODE string.
-- 
--  For CERT_SYSTEM_STORE_LOCAL_MACHINE,
--  CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY or
--  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, pvSystemStoreLocationPara can
--  optionally be set to a unicode computer name for enumerating local machine
--  stores on a remote computer. For example, "\\ComputerName" or
--  "ComputerName". The leading "\\" backslashes are optional in the
--  ComputerName.
-- 
--  For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS,
--  if pvSystemStoreLocationPara is NULL, then,
--  enumerates both the service/user names and the stores for each service/user
--  name. Otherwise, pvSystemStoreLocationPara is a unicode string specifying a
--  remote computer name and/or service/user name. For example:
--  "ServiceName"
--  "\\ComputerName" or "ComputerName\"
--  "ComputerName\ServiceName"
--  Note, if only the ComputerName is specified, then, it must have either
--  the leading "\\" backslashes or a trailing backslash. Otherwise, its
--  interpretted as the ServiceName or UserName.
-- --------------------------------------------------------------------------
type
t_178=^unchecked for machine_pointer use true;

t_179=^unchecked for machine_pointer use true;

procedure CertEnumSystemStore(
    dwFlags         : in DWORD; 
    pvSystemStoreLocationPara : in {out optional} t_178; 
    pvArg           : in t_179; 
    pfnEnum         : in PFN_CERT_ENUM_SYSTEM_STORE)
                      return BOOL;
#pragma convention(CertEnumSystemStore,system);
#pragma import(CertEnumSystemStore,'CertEnumSystemStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerate the physical stores for the specified system store.
-- 
--  The upper word of the dwFlags parameter is used to specify the location of
--  the system store.
-- 
--  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, pvSystemStore
--  points to a CERT_SYSTEM_STORE_RELOCATE_PARA data structure. Otherwise,
--  pvSystemStore points to a null terminated UNICODE string.
-- 
--  See CertRegisterSystemStore for details on prepending a ServiceName
--  and/or ComputerName to the system store name.
-- 
--  If the system store location only supports system stores and doesn't
--  support physical stores, LastError is set to ERROR_CALL_NOT_IMPLEMENTED.
-- --------------------------------------------------------------------------
type
t_180=^unchecked for machine_pointer use true;

t_181=^unchecked for machine_pointer use true;

procedure CertEnumPhysicalStore(
    pvSystemStore   : in t_180; 
    dwFlags         : in DWORD; 
    pvArg           : in t_181; 
    pfnEnum         : in PFN_CERT_ENUM_PHYSICAL_STORE)
                      return BOOL;
#pragma convention(CertEnumPhysicalStore,system);
#pragma import(CertEnumPhysicalStore,'CertEnumPhysicalStore','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Certificate System Store Installable Functions
-- 
--  The CERT_SYSTEM_STORE_LOCATION_MASK bits in the dwFlags parameter passed
--  to the CertOpenStore(for "System", "SystemRegistry" or "Physical"
--  Provider), CertRegisterSystemStore,
--  CertUnregisterSystemStore, CertEnumSystemStore, CertRegisterPhysicalStore,
--  CertUnregisterPhysicalStore and CertEnumPhysicalStore APIs is used as the
--  constant pszOID value passed to the OID installable functions.
--  Therefore, the pszOID is restricted to a constant <= (LPCSTR) 0x0FFF.
-- 
--  The EncodingType is 0.
-- --------------------------------------------------------------------------
--  Installable System Store Provider OID pszFuncNames.
--  CertDllOpenSystemStoreProv has the same function signature as the
--  installable "CertDllOpenStoreProv" function. See CertOpenStore for
--  more details.
--  CertDllRegisterSystemStore has the same function signature as
--  CertRegisterSystemStore.
-- 
--  The "SystemStoreLocation" REG_SZ value must also be set for registered
--  CertDllEnumSystemStore OID functions.
--  The remaining Register, Enum and Unregister OID installable functions
--  have the same signature as their Cert Store API counterpart.
-- +=========================================================================
--  Enhanced Key Usage Helper Functions
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  Get the enhanced key usage extension or property from the certificate
--  and decode.
-- 
--  If the CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG is set, then, only get the
--  extension.
-- 
--  If the CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG is set, then, only get the
--  property.
-- --------------------------------------------------------------------------
procedure CertGetEnhancedKeyUsage(
    pCertContext    : in PCCERT_CONTEXT; 
    dwFlags         : in DWORD; 
    pUsage          : out _CTL_USAGE; 
    pcbUsage        : in out DWORD)
                      return BOOL;
#pragma convention(CertGetEnhancedKeyUsage,system);
#pragma import(CertGetEnhancedKeyUsage,'CertGetEnhancedKeyUsage','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Set the enhanced key usage property for the certificate.
-- --------------------------------------------------------------------------
procedure CertSetEnhancedKeyUsage(
    pCertContext    : in PCCERT_CONTEXT; 
    pUsage          : in PCERT_ENHKEY_USAGE)
                      return BOOL;
#pragma convention(CertSetEnhancedKeyUsage,system);
#pragma import(CertSetEnhancedKeyUsage,'CertSetEnhancedKeyUsage','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Add the usage identifier to the certificate's enhanced key usage property.
-- --------------------------------------------------------------------------
procedure CertAddEnhancedKeyUsageIdentifier(
    pCertContext    : in PCCERT_CONTEXT; 
    pszUsageIdentifier : in LPCSTR)
                      return BOOL;
#pragma convention(CertAddEnhancedKeyUsageIdentifier,system);
#pragma import(CertAddEnhancedKeyUsageIdentifier,'CertAddEnhancedKeyUsageIdentifier','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Remove the usage identifier from the certificate's enhanced key usage
--  property.
-- --------------------------------------------------------------------------
procedure CertRemoveEnhancedKeyUsageIdentifier(
    pCertContext    : in PCCERT_CONTEXT; 
    pszUsageIdentifier : in LPCSTR)
                      return BOOL;
#pragma convention(CertRemoveEnhancedKeyUsageIdentifier,system);
#pragma import(CertRemoveEnhancedKeyUsageIdentifier,'CertRemoveEnhancedKeyUsageIdentifier','crypt32.dll');

-- +---------------------------------------------------------------------------
-- 
-- 
--  Takes an array of certs and returns an array of usages
--  which consists of the intersection of the valid usages for each cert.
--  If each cert is good for all possible usages then the cNumOIDs is set to -1.
-- 
-- ----------------------------------------------------------------------------
type
t_182=^PCCERT_CONTEXT for machine_pointer use true;

t_183=signed 32;

procedure CertGetValidUsages(
    cCerts          : in DWORD; 
    rghCerts        : in t_182; 
    cNumOIDs        : out t_183; 
    rghOIDs         : out LPSTR; 
    pcbOIDs         : in out DWORD)
                      return BOOL;
#pragma convention(CertGetValidUsages,system);
#pragma import(CertGetValidUsages,'CertGetValidUsages','crypt32.dll');

-- +=========================================================================
--  Cryptographic Message helper functions for verifying and signing a
--  CTL.
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  Get and verify the signer of a cryptographic message.
-- 
--  To verify a CTL, the hCryptMsg is obtained from the CTL_CONTEXT's
--  hCryptMsg field.
-- 
--  If CMSG_TRUSTED_SIGNER_FLAG is set, then, treat the Signer stores as being
--  trusted and only search them to find the certificate corresponding to the
--  signer's issuer and serial number. Otherwise, the SignerStores are
--  optionally provided to supplement the message's store of certificates.
--  If a signer certificate is found, its public key is used to verify
--  the message signature. The CMSG_SIGNER_ONLY_FLAG can be set to
--  return the signer without doing the signature verify.
-- 
--  If CMSG_USE_SIGNER_INDEX_FLAG is set, then, only get the signer specified
--  by *pdwSignerIndex. Otherwise, iterate through all the signers
--  until a signer verifies or no more signers.
-- 
--  For a verified signature, *ppSigner is updated with certificate context
--  of the signer and *pdwSignerIndex is updated with the index of the signer.
--  ppSigner and/or pdwSignerIndex can be NULL, indicating the caller isn't
--  interested in getting the CertContext and/or index of the signer.
-- --------------------------------------------------------------------------
type
t_184=^t_HCERTSTORE for machine_pointer use true;

procedure CryptMsgGetAndVerifySigner(
    hCryptMsg       : in t_HCRYPTMSG; 
    cSignerStore    : in DWORD; 
    rghSignerStore  : in {out optional} t_184; 
    dwFlags         : in DWORD; 
    ppSigner        : out {out optional} PCCERT_CONTEXT; 
    pdwSignerIndex  : in out {out optional} DWORD)
                      return BOOL;
#pragma convention(CryptMsgGetAndVerifySigner,system);
#pragma import(CryptMsgGetAndVerifySigner,'CryptMsgGetAndVerifySigner','crypt32.dll');

const
  CMSG_TRUSTED_SIGNER_FLAG= $01;

const
  CMSG_SIGNER_ONLY_FLAG= $02;

const
  CMSG_USE_SIGNER_INDEX_FLAG= $04;

-- +-------------------------------------------------------------------------
--  Sign an encoded CTL.
-- 
--  The pbCtlContent can be obtained via a CTL_CONTEXT's pbCtlContent
--  field or via a CryptEncodeObject(PKCS_CTL or PKCS_SORTED_CTL).
-- 
--  CMSG_CMS_ENCAPSULATED_CTL_FLAG can be set to encode a CMS compatible
--  V3 SignedData message.
-- --------------------------------------------------------------------------
type
t_185=^BYTE for machine_pointer use true;

procedure CryptMsgSignCTL(
    dwMsgEncodingType : in DWORD; 
    pbCtlContent    : in t_185; 
    cbCtlContent    : in DWORD; 
    pSignInfo       : in PCMSG_SIGNED_ENCODE_INFO; 
    dwFlags         : in DWORD; 
    pbEncoded       : out BYTE; 
    pcbEncoded      : in out DWORD)
                      return BOOL;
#pragma convention(CryptMsgSignCTL,system);
#pragma import(CryptMsgSignCTL,'CryptMsgSignCTL','crypt32.dll');

--  When set, CTL inner content is encapsulated within an OCTET STRING
const
  CMSG_CMS_ENCAPSULATED_CTL_FLAG= $8000;

-- +-------------------------------------------------------------------------
--  Encode the CTL and create a signed message containing the encoded CTL.
-- 
--  Set CMSG_ENCODE_SORTED_CTL_FLAG if the CTL entries are to be sorted
--  before encoding. This flag should be set, if the
--  CertFindSubjectInSortedCTL or CertEnumSubjectInSortedCTL APIs will
--  be called. If the identifier for the CTL entries is a hash, such as,
--  MD5 or SHA1, then, CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG should
--  also be set.
-- 
--  CMSG_CMS_ENCAPSULATED_CTL_FLAG can be set to encode a CMS compatible
--  V3 SignedData message.
-- --------------------------------------------------------------------------
procedure CryptMsgEncodeAndSignCTL(
    dwMsgEncodingType : in DWORD; 
    pCtlInfo        : in PCTL_INFO; 
    pSignInfo       : in PCMSG_SIGNED_ENCODE_INFO; 
    dwFlags         : in DWORD; 
    pbEncoded       : out BYTE; 
    pcbEncoded      : in out DWORD)
                      return BOOL;
#pragma convention(CryptMsgEncodeAndSignCTL,system);
#pragma import(CryptMsgEncodeAndSignCTL,'CryptMsgEncodeAndSignCTL','crypt32.dll');

--  The following flag is set if the CTL is to be encoded with sorted
--  trusted subjects and the szOID_SORTED_CTL extension is inserted containing
--  sorted offsets to the encoded subjects.
const
  CMSG_ENCODE_SORTED_CTL_FLAG= $01;

--  If the above sorted flag is set, then, the following flag should also
--  be set if the identifier for the TrustedSubjects is a hash,
--  such as, MD5 or SHA1.
const
  CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG= $02;

-- +-------------------------------------------------------------------------
--  Returns TRUE if the SubjectIdentifier exists in the CTL. Optionally
--  returns a pointer to and byte count of the Subject's encoded attributes.
-- --------------------------------------------------------------------------
type
t_186=^unchecked for machine_pointer use true;

procedure CertFindSubjectInSortedCTL(
    pSubjectIdentifier : in PCRYPT_DATA_BLOB; 
    pCtlContext     : in PCCTL_CONTEXT; 
    dwFlags         : in DWORD; 
    pvReserved      : in t_186; 
    pEncodedAttributes : out {out optional} _CRYPTOAPI_BLOB)
                      return BOOL;
#pragma convention(CertFindSubjectInSortedCTL,system);
#pragma import(CertFindSubjectInSortedCTL,'CertFindSubjectInSortedCTL','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Enumerates through the sequence of TrustedSubjects in a CTL context
--  created with CERT_CREATE_CONTEXT_SORTED_FLAG set.
-- 
--  To start the enumeration, *ppvNextSubject must be NULL. Upon return,
--  *ppvNextSubject is updated to point to the next TrustedSubject in
--  the encoded sequence.
-- 
--  Returns FALSE for no more subjects or invalid arguments.
-- 
--  Note, the returned DER_BLOBs point directly into the encoded
--  bytes (not allocated, and must not be freed).
-- --------------------------------------------------------------------------
type
t_187=^unchecked for machine_pointer use true;

procedure CertEnumSubjectInSortedCTL(
    pCtlContext     : in PCCTL_CONTEXT; 
    ppvNextSubject  : in out t_187; 
    pSubjectIdentifier : out {out optional} _CRYPTOAPI_BLOB; 
    pEncodedAttributes : out {out optional} _CRYPTOAPI_BLOB)
                      return BOOL;
#pragma convention(CertEnumSubjectInSortedCTL,system);
#pragma import(CertEnumSubjectInSortedCTL,'CertEnumSubjectInSortedCTL','crypt32.dll');

-- +=========================================================================
--  Certificate Verify CTL Usage Data Structures and APIs
-- ==========================================================================
type
  _CTL_VERIFY_USAGE_PARA = record
cbSize          : DWORD;
ListIdentifier  : CRYPT_DATA_BLOB;
cCtlStore       : DWORD;
rghCtlStore     : ^t_HCERTSTORE;
cSignerStore    : DWORD;
rghSignerStore  : ^t_HCERTSTORE;
  end record;
  CTL_VERIFY_USAGE_PARA = _CTL_VERIFY_USAGE_PARA;
  PCTL_VERIFY_USAGE_PARA = ^_CTL_VERIFY_USAGE_PARA;

type
  _CTL_VERIFY_USAGE_STATUS = record
cbSize          : DWORD;
dwError         : DWORD;
dwFlags         : DWORD;
ppCtl           : ^PCCTL_CONTEXT;
dwCtlEntryIndex : DWORD;
ppSigner        : ^PCCERT_CONTEXT;
dwSignerIndex   : DWORD;
  end record;
  CTL_VERIFY_USAGE_STATUS = _CTL_VERIFY_USAGE_STATUS;
  PCTL_VERIFY_USAGE_STATUS = ^_CTL_VERIFY_USAGE_STATUS;

const
  CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG= $01;

const
  CERT_VERIFY_TRUSTED_SIGNERS_FLAG= $02;

const
  CERT_VERIFY_NO_TIME_CHECK_FLAG= $04;

const
  CERT_VERIFY_ALLOW_MORE_USAGE_FLAG= $08;

const
  CERT_VERIFY_UPDATED_CTL_FLAG= $01;

-- +-------------------------------------------------------------------------
--  Verify that a subject is trusted for the specified usage by finding a
--  signed and time valid CTL with the usage identifiers and containing the
--  the subject. A subject can be identified by either its certificate context
--  or any identifier such as its SHA1 hash.
-- 
--  See CertFindSubjectInCTL for definition of dwSubjectType and pvSubject
--  parameters.
-- 
--  Via pVerifyUsagePara, the caller can specify the stores to be searched
--  to find the CTL. The caller can also specify the stores containing
--  acceptable CTL signers. By setting the ListIdentifier, the caller
--  can also restrict to a particular signer CTL list.
-- 
--  Via pVerifyUsageStatus, the CTL containing the subject, the subject's
--  index into the CTL's array of entries, and the signer of the CTL
--  are returned. If the caller is not interested, ppCtl and ppSigner can be set
--  to NULL. Returned contexts must be freed via the store's free context APIs.
-- 
--  If the CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG isn't set, then, a time
--  invalid CTL in one of the CtlStores may be replaced. When replaced, the
--  CERT_VERIFY_UPDATED_CTL_FLAG is set in pVerifyUsageStatus->dwFlags.
-- 
--  If the CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, then, only the
--  SignerStores specified in pVerifyUsageStatus are searched to find
--  the signer. Otherwise, the SignerStores provide additional sources
--  to find the signer's certificate.
-- 
--  If CERT_VERIFY_NO_TIME_CHECK_FLAG is set, then, the CTLs aren't checked
--  for time validity.
-- 
--  If CERT_VERIFY_ALLOW_MORE_USAGE_FLAG is set, then, the CTL may contain
--  additional usage identifiers than specified by pSubjectUsage. Otherwise,
--  the found CTL will contain the same usage identifers and no more.
-- 
--  CertVerifyCTLUsage will be implemented as a dispatcher to OID installable
--  functions. First, it will try to find an OID function matching the first
--  usage object identifier in the pUsage sequence. Next, it will dispatch
--  to the default CertDllVerifyCTLUsage functions.
-- 
--  If the subject is trusted for the specified usage, then, TRUE is
--  returned. Otherwise, FALSE is returned with dwError set to one of the
--  following:
--  CRYPT_E_NO_VERIFY_USAGE_DLL
--  CRYPT_E_NO_VERIFY_USAGE_CHECK
--  CRYPT_E_VERIFY_USAGE_OFFLINE
--  CRYPT_E_NOT_IN_CTL
--  CRYPT_E_NO_TRUSTED_SIGNER
-- --------------------------------------------------------------------------
type
t_188=^unchecked for machine_pointer use true;

procedure CertVerifyCTLUsage(
    dwEncodingType  : in DWORD; 
    dwSubjectType   : in DWORD; 
    pvSubject       : in t_188; 
    pSubjectUsage   : in PCTL_USAGE; 
    dwFlags         : in DWORD; 
    pVerifyUsagePara : in {out optional} PCTL_VERIFY_USAGE_PARA; 
    pVerifyUsageStatus : in out _CTL_VERIFY_USAGE_STATUS)
                      return BOOL;
#pragma convention(CertVerifyCTLUsage,system);
#pragma import(CertVerifyCTLUsage,'CertVerifyCTLUsage','crypt32.dll');

-- +=========================================================================
--  Certificate Revocation Data Structures and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  This data structure is updated by a CRL revocation type handler
--  with the base and possibly the delta CRL used.
-- --------------------------------------------------------------------------
type
  _CERT_REVOCATION_CRL_INFO = record
cbSize          : DWORD;
pBaseCrlContext : PCCRL_CONTEXT;
pDeltaCrlContext : PCCRL_CONTEXT;
pCrlEntry       : PCRL_ENTRY;
fDeltaCrlEntry  : BOOL;
  end record;
  CERT_REVOCATION_CRL_INFO = _CERT_REVOCATION_CRL_INFO;
  PCERT_REVOCATION_CRL_INFO = ^_CERT_REVOCATION_CRL_INFO;

-- +-------------------------------------------------------------------------
--  The following data structure may be passed to CertVerifyRevocation to
--  assist in finding the issuer of the context to be verified.
-- 
--  When pIssuerCert is specified, pIssuerCert is the issuer of
--  rgpvContext[cContext - 1].
-- 
--  When cCertStore and rgCertStore are specified, these stores may contain
--  an issuer certificate.
-- 
--  When hCrlStore is specified then a handler which uses CRLs can search this
--  store for them
-- 
--  When pftTimeToUse is specified then the handler (if possible) must determine
--  revocation status relative to the time given otherwise the answer may be
--  independent of time or relative to current time
-- --------------------------------------------------------------------------
type
  _CERT_REVOCATION_PARA = record
cbSize          : DWORD;
pIssuerCert     : PCCERT_CONTEXT;
cCertStore      : DWORD;
rgCertStore     : ^t_HCERTSTORE;
hCrlStore       : t_HCERTSTORE;
pftTimeToUse    : p_FILETIME;
  end record;
  CERT_REVOCATION_PARA = _CERT_REVOCATION_PARA;
  PCERT_REVOCATION_PARA = ^_CERT_REVOCATION_PARA;

-- +-------------------------------------------------------------------------
--  The following data structure is returned by CertVerifyRevocation to
--  specify the status of the revoked or unchecked context. Review the
--  following CertVerifyRevocation comments for details.
-- 
--  Upon input to CertVerifyRevocation, cbSize must be set to a size
--  >= (offsetof(CERT_REVOCATION_STATUS, dwReason) + sizeof(DWORD) ).
--  Otherwise, CertVerifyRevocation returns FALSE and sets LastError to
--  E_INVALIDARG.
-- 
--  Upon input to the installed or registered CRYPT_OID_VERIFY_REVOCATION_FUNC
--  functions, the dwIndex, dwError and dwReason have been zero'ed.
--  If present, fHasFreshnessTime and dwFreshnessTime have been zero'ed.
-- --------------------------------------------------------------------------
type
  _CERT_REVOCATION_STATUS = record
cbSize          : DWORD;
dwIndex         : DWORD;
dwError         : DWORD;
dwReason        : DWORD;
fHasFreshnessTime : BOOL;
dwFreshnessTime : DWORD;
  end record;
  CERT_REVOCATION_STATUS = _CERT_REVOCATION_STATUS;
  PCERT_REVOCATION_STATUS = ^_CERT_REVOCATION_STATUS;

-- +-------------------------------------------------------------------------
--  Verifies the array of contexts for revocation. The dwRevType parameter
--  indicates the type of the context data structure passed in rgpvContext.
--  Currently only the revocation of certificates is defined.
-- 
--  If the CERT_VERIFY_REV_CHAIN_FLAG flag is set, then, CertVerifyRevocation
--  is verifying a chain of certs where, rgpvContext[i + 1] is the issuer
--  of rgpvContext[i]. Otherwise, CertVerifyRevocation makes no assumptions
--  about the order of the contexts.
-- 
--  To assist in finding the issuer, the pRevPara may optionally be set. See
--  the CERT_REVOCATION_PARA data structure for details.
-- 
--  The contexts must contain enough information to allow the
--  installable or registered revocation DLLs to find the revocation server. For
--  certificates, this information would normally be conveyed in an
--  extension such as the IETF's AuthorityInfoAccess extension.
-- 
--  CertVerifyRevocation returns TRUE if all of the contexts were successfully
--  checked and none were revoked. Otherwise, returns FALSE and updates the
--  returned pRevStatus data structure as follows:
--  dwIndex
--  Index of the first context that was revoked or unable to
--  be checked for revocation
--  dwError
--  Error status. LastError is also set to this error status.
--  dwError can be set to one of the following error codes defined
--  in winerror.h:
--  ERROR_SUCCESS - good context
--  CRYPT_E_REVOKED - context was revoked. dwReason contains the
--  reason for revocation
--  CRYPT_E_REVOCATION_OFFLINE - unable to connect to the
--  revocation server
--  CRYPT_E_NOT_IN_REVOCATION_DATABASE - the context to be checked
--  was not found in the revocation server's database.
--  CRYPT_E_NO_REVOCATION_CHECK - the called revocation function
--  wasn't able to do a revocation check on the context
--  CRYPT_E_NO_REVOCATION_DLL - no installed or registered Dll was
--  found to verify revocation
--  dwReason
--  The dwReason is currently only set for CRYPT_E_REVOKED and contains
--  the reason why the context was revoked. May be one of the following
--  CRL reasons defined by the CRL Reason Code extension ("2.5.29.21")
--  CRL_REASON_UNSPECIFIED 0
--  CRL_REASON_KEY_COMPROMISE 1
--  CRL_REASON_CA_COMPROMISE 2
--  CRL_REASON_AFFILIATION_CHANGED 3
--  CRL_REASON_SUPERSEDED 4
--  CRL_REASON_CESSATION_OF_OPERATION 5
--  CRL_REASON_CERTIFICATE_HOLD 6
-- 
--  For each entry in rgpvContext, CertVerifyRevocation iterates
--  through the CRYPT_OID_VERIFY_REVOCATION_FUNC
--  function set's list of installed DEFAULT functions.
--  CryptGetDefaultOIDFunctionAddress is called with pwszDll = NULL. If no
--  installed functions are found capable of doing the revocation verification,
--  CryptVerifyRevocation iterates through CRYPT_OID_VERIFY_REVOCATION_FUNC's
--  list of registered DEFAULT Dlls. CryptGetDefaultOIDDllList is called to
--  get the list. CryptGetDefaultOIDFunctionAddress is called to load the Dll.
-- 
--  The called functions have the same signature as CertVerifyRevocation. A
--  called function returns TRUE if it was able to successfully check all of
--  the contexts and none were revoked. Otherwise, the called function returns
--  FALSE and updates pRevStatus. dwIndex is set to the index of
--  the first context that was found to be revoked or unable to be checked.
--  dwError and LastError are updated. For CRYPT_E_REVOKED, dwReason
--  is updated. Upon input to the called function, dwIndex, dwError and
--  dwReason have been zero'ed. cbSize has been checked to be >=
--  sizeof(CERT_REVOCATION_STATUS).
-- 
--  If the called function returns FALSE, and dwError isn't set to
--  CRYPT_E_REVOKED, then, CertVerifyRevocation either continues on to the
--  next DLL in the list for a returned dwIndex of 0 or for a returned
--  dwIndex > 0, restarts the process of finding a verify function by
--  advancing the start of the context array to the returned dwIndex and
--  decrementing the count of remaining contexts.
-- --------------------------------------------------------------------------
type
t_189=array of PVOID;

procedure CertVerifyRevocation(
    dwEncodingType  : in DWORD; 
    dwRevType       : in DWORD; 
    cContext        : in DWORD; 
    rgpvContext     : in t_189; 
    dwFlags         : in DWORD; 
    pRevPara        : in {out optional} PCERT_REVOCATION_PARA; 
    pRevStatus      : in out _CERT_REVOCATION_STATUS)
                      return BOOL;
#pragma convention(CertVerifyRevocation,system);
#pragma import(CertVerifyRevocation,'CertVerifyRevocation','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Revocation types
-- --------------------------------------------------------------------------
const
  CERT_CONTEXT_REVOCATION_TYPE= 1;

-- +-------------------------------------------------------------------------
--  When the following flag is set, rgpvContext[] consists of a chain
--  of certificates, where rgpvContext[i + 1] is the issuer of rgpvContext[i].
-- --------------------------------------------------------------------------
const
  CERT_VERIFY_REV_CHAIN_FLAG= $01;

-- +-------------------------------------------------------------------------
--  CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION prevents the revocation handler from
--  accessing any network based resources for revocation checking
-- --------------------------------------------------------------------------
const
  CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION= $02;

-- +-------------------------------------------------------------------------
--  By default, the dwUrlRetrievalTimeout in pRevPara is the timeout used
--  for each URL wire retrieval. When the following flag is set,
--  dwUrlRetrievalTimeout is the accumulative timeout across all URL wire
--  retrievals.
-- --------------------------------------------------------------------------
const
  CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG= $04;

-- +-------------------------------------------------------------------------
--  CERT_CONTEXT_REVOCATION_TYPE
-- 
--  pvContext points to a const CERT_CONTEXT.
-- --------------------------------------------------------------------------
-- +=========================================================================
--  Certificate Helper APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  Compare two multiple byte integer blobs to see if they are identical.
-- 
--  Before doing the comparison, leading zero bytes are removed from a
--  positive number and leading 0xFF bytes are removed from a negative
--  number.
-- 
--  The multiple byte integers are treated as Little Endian. pbData[0] is the
--  least significant byte and pbData[cbData - 1] is the most significant
--  byte.
-- 
--  Returns TRUE if the integer blobs are identical after removing leading
--  0 or 0xFF bytes.
-- --------------------------------------------------------------------------
procedure CertCompareIntegerBlob(
    pInt1           : in PCRYPT_INTEGER_BLOB; 
    pInt2           : in PCRYPT_INTEGER_BLOB)
                      return BOOL;
#pragma convention(CertCompareIntegerBlob,system);
#pragma import(CertCompareIntegerBlob,'CertCompareIntegerBlob','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Compare two certificates to see if they are identical.
-- 
--  Since a certificate is uniquely identified by its Issuer and SerialNumber,
--  these are the only fields needing to be compared.
-- 
--  Returns TRUE if the certificates are identical.
-- --------------------------------------------------------------------------
procedure CertCompareCertificate(
    dwCertEncodingType : in DWORD; 
    pCertId1        : in PCERT_INFO; 
    pCertId2        : in PCERT_INFO)
                      return BOOL;
#pragma convention(CertCompareCertificate,system);
#pragma import(CertCompareCertificate,'CertCompareCertificate','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Compare two certificate names to see if they are identical.
-- 
--  Returns TRUE if the names are identical.
-- --------------------------------------------------------------------------
procedure CertCompareCertificateName(
    dwCertEncodingType : in DWORD; 
    pCertName1      : in PCERT_NAME_BLOB; 
    pCertName2      : in PCERT_NAME_BLOB)
                      return BOOL;
#pragma convention(CertCompareCertificateName,system);
#pragma import(CertCompareCertificateName,'CertCompareCertificateName','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Compare the attributes in the certificate name with the specified
--  Relative Distinguished Name's (CERT_RDN) array of attributes.
--  The comparison iterates through the CERT_RDN attributes and looks for an
--  attribute match in any of the certificate name's RDNs.
--  Returns TRUE if all the attributes are found and match.
-- 
--  The CERT_RDN_ATTR fields can have the following special values:
--  pszObjId == NULL - ignore the attribute object identifier
--  dwValueType == RDN_ANY_TYPE - ignore the value type
-- 
--  CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG should be set to do
--  a case insensitive match. Otherwise, defaults to an exact, case sensitive
--  match.
-- 
--  CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set if the pRDN was initialized
--  with unicode strings as for CryptEncodeObject(X509_UNICODE_NAME).
-- --------------------------------------------------------------------------
procedure CertIsRDNAttrsInCertificateName(
    dwCertEncodingType : in DWORD; 
    dwFlags         : in DWORD; 
    pCertName       : in PCERT_NAME_BLOB; 
    pRDN            : in PCERT_RDN)
                      return BOOL;
#pragma convention(CertIsRDNAttrsInCertificateName,system);
#pragma import(CertIsRDNAttrsInCertificateName,'CertIsRDNAttrsInCertificateName','crypt32.dll');

const
  CERT_UNICODE_IS_RDN_ATTRS_FLAG= $01;

const
  CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG= $02;

-- +-------------------------------------------------------------------------
--  Compare two public keys to see if they are identical.
-- 
--  Returns TRUE if the keys are identical.
-- --------------------------------------------------------------------------
procedure CertComparePublicKeyInfo(
    dwCertEncodingType : in DWORD; 
    pPublicKey1     : in PCERT_PUBLIC_KEY_INFO; 
    pPublicKey2     : in PCERT_PUBLIC_KEY_INFO)
                      return BOOL;
#pragma convention(CertComparePublicKeyInfo,system);
#pragma import(CertComparePublicKeyInfo,'CertComparePublicKeyInfo','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get the public/private key's bit length.
-- 
--  Returns 0 if unable to determine the key's length.
-- --------------------------------------------------------------------------
procedure CertGetPublicKeyLength(
    dwCertEncodingType : in DWORD; 
    pPublicKey      : in PCERT_PUBLIC_KEY_INFO)
                      return DWORD;
#pragma convention(CertGetPublicKeyLength,system);
#pragma import(CertGetPublicKeyLength,'CertGetPublicKeyLength','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify the signature of a subject certificate or a CRL using the
--  public key info
-- 
--  Returns TRUE for a valid signature.
-- 
--  hCryptProv specifies the crypto provider to use to verify the signature.
--  It doesn't need to use a private key.
-- --------------------------------------------------------------------------
type
t_190=^BYTE for machine_pointer use true;

procedure CryptVerifyCertificateSignature(
    hCryptProv      : in t_HCRYPTPROV; 
    dwCertEncodingType : in DWORD; 
    pbEncoded       : in t_190; 
    cbEncoded       : in DWORD; 
    pPublicKey      : in PCERT_PUBLIC_KEY_INFO)
                      return BOOL;
#pragma convention(CryptVerifyCertificateSignature,system);
#pragma import(CryptVerifyCertificateSignature,'CryptVerifyCertificateSignature','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify the signature of a subject certificate, CRL, certificate request
--  or keygen request using the issuer's public key.
-- 
--  Returns TRUE for a valid signature.
-- 
--  The subject can be an encoded blob or a context for a certificate or CRL.
--  For a subject certificate context, if the certificate is missing
--  inheritable PublicKey Algorithm Parameters, the context's
--  CERT_PUBKEY_ALG_PARA_PROP_ID is updated with the issuer's public key
--  algorithm parameters for a valid signature.
-- 
--  The issuer can be a pointer to a CERT_PUBLIC_KEY_INFO, certificate
--  context or a chain context.
-- 
--  hCryptProv specifies the crypto provider to use to verify the signature.
--  Its private key isn't used. If hCryptProv is NULL, a default
--  provider is picked according to the PublicKey Algorithm OID.
-- 
--  If the signature algorithm is a hashing algorithm, then, the
--  signature is expected to contain the hash octets. Only dwIssuerType
--  of CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL may be specified
--  to verify this no signature case. If any other dwIssuerType is
--  specified, the verify will fail with LastError set to E_INVALIDARG.
-- --------------------------------------------------------------------------
type
t_191=^unchecked for machine_pointer use true;

t_192=^unchecked for machine_pointer use true;

t_193=^unchecked for machine_pointer use true;

procedure CryptVerifyCertificateSignatureEx(
    hCryptProv      : in {out optional} t_HCRYPTPROV; 
    dwCertEncodingType : in DWORD; 
    dwSubjectType   : in DWORD; 
    pvSubject       : in t_191; 
    dwIssuerType    : in DWORD; 
    pvIssuer        : in t_192; 
    dwFlags         : in DWORD; 
    pvReserved      : in {out optional} t_193)
                      return BOOL;
#pragma convention(CryptVerifyCertificateSignatureEx,system);
#pragma import(CryptVerifyCertificateSignatureEx,'CryptVerifyCertificateSignatureEx','crypt32.dll');

--  Subject Types
const
  CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB= 1;

--  pvSubject :: PCRYPT_DATA_BLOB
const
  CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT= 2;

--  pvSubject :: PCCERT_CONTEXT
const
  CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL= 3;

--  pvSubject :: PCCRL_CONTEXT
--  Issuer Types
const
  CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY= 1;

--  pvIssuer :: PCERT_PUBLIC_KEY_INFO
const
  CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT= 2;

--  pvIssuer :: PCCERT_CONTEXT
const
  CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN= 3;

--  pvIssuer :: PCCERT_CHAIN_CONTEXT
const
  CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL= 4;

--  pvIssuer :: NULL
-- +-------------------------------------------------------------------------
--  Compute the hash of the "to be signed" information in the encoded
--  signed content (CERT_SIGNED_CONTENT_INFO).
-- 
--  hCryptProv specifies the crypto provider to use to compute the hash.
--  It doesn't need to use a private key.
-- --------------------------------------------------------------------------
type
t_194=^BYTE for machine_pointer use true;

procedure CryptHashToBeSigned(
    hCryptProv      : in t_HCRYPTPROV; 
    dwCertEncodingType : in DWORD; 
    pbEncoded       : in t_194; 
    cbEncoded       : in DWORD; 
    pbComputedHash  : out BYTE; 
    pcbComputedHash : in out DWORD)
                      return BOOL;
#pragma convention(CryptHashToBeSigned,system);
#pragma import(CryptHashToBeSigned,'CryptHashToBeSigned','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Hash the encoded content.
-- 
--  hCryptProv specifies the crypto provider to use to compute the hash.
--  It doesn't need to use a private key.
-- 
--  Algid specifies the CAPI hash algorithm to use. If Algid is 0, then, the
--  default hash algorithm (currently SHA1) is used.
-- --------------------------------------------------------------------------
type
t_195=^BYTE for machine_pointer use true;

procedure CryptHashCertificate(
    hCryptProv      : in t_HCRYPTPROV; 
    Algid           : in ALG_ID; 
    dwFlags         : in DWORD; 
    pbEncoded       : in t_195; 
    cbEncoded       : in DWORD; 
    pbComputedHash  : out BYTE; 
    pcbComputedHash : in out DWORD)
                      return BOOL;
#pragma convention(CryptHashCertificate,system);
#pragma import(CryptHashCertificate,'CryptHashCertificate','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Sign the "to be signed" information in the encoded signed content.
-- 
--  hCryptProv specifies the crypto provider to use to do the signature.
--  It uses the specified private key.
-- 
--  If the SignatureAlgorithm is a hash algorithm, then, the signature
--  contains the hash octets. A private key isn't used to encrypt the hash.
--  dwKeySpec isn't used and hCryptProv can be NULL where an appropriate
--  default provider will be used for hashing.
-- --------------------------------------------------------------------------
type
t_196=^BYTE for machine_pointer use true;

t_197=^unchecked for machine_pointer use true;

procedure CryptSignCertificate(
    hCryptProv      : in t_HCRYPTPROV; 
    dwKeySpec       : in DWORD; 
    dwCertEncodingType : in DWORD; 
    pbEncodedToBeSigned : in t_196; 
    cbEncodedToBeSigned : in DWORD; 
    pSignatureAlgorithm : in PCRYPT_ALGORITHM_IDENTIFIER; 
    pvHashAuxInfo   : in {out optional} t_197; 
    pbSignature     : out BYTE; 
    pcbSignature    : in out DWORD)
                      return BOOL;
#pragma convention(CryptSignCertificate,system);
#pragma import(CryptSignCertificate,'CryptSignCertificate','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Encode the "to be signed" information. Sign the encoded "to be signed".
--  Encode the "to be signed" and the signature.
-- 
--  hCryptProv specifies the crypto provider to use to do the signature.
--  It uses the specified private key.
-- 
--  If the SignatureAlgorithm is a hash algorithm, then, the signature
--  contains the hash octets. A private key isn't used to encrypt the hash.
--  dwKeySpec isn't used and hCryptProv can be NULL where an appropriate
--  default provider will be used for hashing.
-- --------------------------------------------------------------------------
--  "to be signed"
type
t_198=^unchecked for machine_pointer use true;

t_199=^unchecked for machine_pointer use true;

procedure CryptSignAndEncodeCertificate(
    hCryptProv      : in t_HCRYPTPROV; 
    dwKeySpec       : in DWORD; 
    dwCertEncodingType : in DWORD; 
    lpszStructType  : in LPCSTR; 
    pvStructInfo    : in t_198; 
    pSignatureAlgorithm : in PCRYPT_ALGORITHM_IDENTIFIER; 
    pvHashAuxInfo   : in {out optional} t_199; 
    pbEncoded       : out BYTE ; 
    pcbEncoded      : in out DWORD)
                      return BOOL;
#pragma convention(CryptSignAndEncodeCertificate,system);
#pragma import(CryptSignAndEncodeCertificate,'CryptSignAndEncodeCertificate','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify the time validity of a certificate.
-- 
--  Returns -1 if before NotBefore, +1 if after NotAfter and otherwise 0 for
--  a valid certificate
-- 
--  If pTimeToVerify is NULL, uses the current time.
-- --------------------------------------------------------------------------
procedure CertVerifyTimeValidity(
    pTimeToVerify   : in p_FILETIME; 
    pCertInfo       : in PCERT_INFO)
                      return LONG;
#pragma convention(CertVerifyTimeValidity,system);
#pragma import(CertVerifyTimeValidity,'CertVerifyTimeValidity','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify the time validity of a CRL.
-- 
--  Returns -1 if before ThisUpdate, +1 if after NextUpdate and otherwise 0 for
--  a valid CRL
-- 
--  If pTimeToVerify is NULL, uses the current time.
-- --------------------------------------------------------------------------
procedure CertVerifyCRLTimeValidity(
    pTimeToVerify   : in p_FILETIME; 
    pCrlInfo        : in PCRL_INFO)
                      return LONG;
#pragma convention(CertVerifyCRLTimeValidity,system);
#pragma import(CertVerifyCRLTimeValidity,'CertVerifyCRLTimeValidity','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify that the subject's time validity nests within the issuer's time
--  validity.
-- 
--  Returns TRUE if it nests. Otherwise, returns FALSE.
-- --------------------------------------------------------------------------
procedure CertVerifyValidityNesting(
    pSubjectInfo    : in PCERT_INFO; 
    pIssuerInfo     : in PCERT_INFO)
                      return BOOL;
#pragma convention(CertVerifyValidityNesting,system);
#pragma import(CertVerifyValidityNesting,'CertVerifyValidityNesting','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify that the subject certificate isn't on its issuer CRL.
-- 
--  Returns true if the certificate isn't on the CRL.
-- --------------------------------------------------------------------------
--  Only the Issuer and SerialNumber
--  fields are used
type
t_200=array of PCRL_INFO;

procedure CertVerifyCRLRevocation(
    dwCertEncodingType : in DWORD; 
    pCertId         : in PCERT_INFO; 
    cCrlInfo        : in DWORD; 
    rgpCrlInfo      : in t_200)
                      return BOOL;
#pragma convention(CertVerifyCRLRevocation,system);
#pragma import(CertVerifyCRLRevocation,'CertVerifyCRLRevocation','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Convert the CAPI AlgId to the ASN.1 Object Identifier string
-- 
--  Returns NULL if there isn't an ObjId corresponding to the AlgId.
-- --------------------------------------------------------------------------
procedure CertAlgIdToOID(
    dwAlgId         : in DWORD)
                      return LPCSTR;
#pragma convention(CertAlgIdToOID,system);
#pragma import(CertAlgIdToOID,'CertAlgIdToOID','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Convert the ASN.1 Object Identifier string to the CAPI AlgId.
-- 
--  Returns 0 if there isn't an AlgId corresponding to the ObjId.
-- --------------------------------------------------------------------------
procedure CertOIDToAlgId(
    pszObjId        : in LPCSTR)
                      return DWORD;
#pragma convention(CertOIDToAlgId,system);
#pragma import(CertOIDToAlgId,'CertOIDToAlgId','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Find an extension identified by its Object Identifier.
-- 
--  If found, returns pointer to the extension. Otherwise, returns NULL.
-- --------------------------------------------------------------------------
type
t_201=array of CERT_EXTENSION;

procedure CertFindExtension(
    pszObjId        : in LPCSTR; 
    cExtensions     : in DWORD; 
    rgExtensions    : in t_201)
                      return PCERT_EXTENSION;
#pragma convention(CertFindExtension,system);
#pragma import(CertFindExtension,'CertFindExtension','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Find the first attribute identified by its Object Identifier.
-- 
--  If found, returns pointer to the attribute. Otherwise, returns NULL.
-- --------------------------------------------------------------------------
type
t_202=array of CRYPT_ATTRIBUTE;

procedure CertFindAttribute(
    pszObjId        : in LPCSTR; 
    cAttr           : in DWORD; 
    rgAttr          : in t_202)
                      return PCRYPT_ATTRIBUTE;
#pragma convention(CertFindAttribute,system);
#pragma import(CertFindAttribute,'CertFindAttribute','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Find the first CERT_RDN attribute identified by its Object Identifier in
--  the name's list of Relative Distinguished Names.
-- 
--  If found, returns pointer to the attribute. Otherwise, returns NULL.
-- --------------------------------------------------------------------------
procedure CertFindRDNAttr(
    pszObjId        : in LPCSTR; 
    pName           : in PCERT_NAME_INFO)
                      return PCERT_RDN_ATTR;
#pragma convention(CertFindRDNAttr,system);
#pragma import(CertFindRDNAttr,'CertFindRDNAttr','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Get the intended key usage bytes from the certificate.
-- 
--  If the certificate doesn't have any intended key usage bytes, returns FALSE
--  and *pbKeyUsage is zeroed. Otherwise, returns TRUE and up through
--  cbKeyUsage bytes are copied into *pbKeyUsage. Any remaining uncopied
--  bytes are zeroed.
-- --------------------------------------------------------------------------
procedure CertGetIntendedKeyUsage(
    dwCertEncodingType : in DWORD; 
    pCertInfo       : in PCERT_INFO; 
    pbKeyUsage      : out BYTE; 
    cbKeyUsage      : in DWORD)
                      return BOOL;
#pragma convention(CertGetIntendedKeyUsage,system);
#pragma import(CertGetIntendedKeyUsage,'CertGetIntendedKeyUsage','crypt32.dll');

type
HCRYPTDEFAULTCONTEXT = ^unchecked for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Install a previously CryptAcquiredContext'ed HCRYPTPROV to be used as
--  a default context.
-- 
--  dwDefaultType and pvDefaultPara specify where the default context is used.
--  For example, install the HCRYPTPROV to be used to verify certificate's
--  having szOID_OIWSEC_md5RSA signatures.
-- 
--  By default, the installed HCRYPTPROV is only applicable to the current
--  thread. Set CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG to allow the HCRYPTPROV
--  to be used by all threads in the current process.
-- 
--  For a successful install, TRUE is returned and *phDefaultContext is
--  updated with the HANDLE to be passed to CryptUninstallDefaultContext.
-- 
--  The installed HCRYPTPROVs are stack ordered (the last installed
--  HCRYPTPROV is checked first). All thread installed HCRYPTPROVs are
--  checked before any process HCRYPTPROVs.
-- 
--  The installed HCRYPTPROV remains available for default usage until
--  CryptUninstallDefaultContext is called or the thread or process exits.
-- 
--  If CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG is set, then, the HCRYPTPROV
--  is CryptReleaseContext'ed at thread or process exit. However,
--  not CryptReleaseContext'ed if CryptUninstallDefaultContext is
--  called.
-- --------------------------------------------------------------------------
type
t_203=^unchecked for machine_pointer use true;

t_204=^unchecked for machine_pointer use true;

procedure CryptInstallDefaultContext(
    hCryptProv      : in t_HCRYPTPROV; 
    dwDefaultType   : in DWORD; 
    pvDefaultPara   : in t_203; 
    dwFlags         : in DWORD; 
    pvReserved      : in t_204; 
    phDefaultContext : out HCRYPTDEFAULTCONTEXT)
                      return BOOL;
#pragma convention(CryptInstallDefaultContext,system);
#pragma import(CryptInstallDefaultContext,'CryptInstallDefaultContext','crypt32.dll');

--  dwFlags
const
  CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG= $01;

const
  CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG= $02;

--  List of dwDefaultType's
const
  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID= 1;

const
  CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID= 2;

-- +-------------------------------------------------------------------------
--  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID
-- 
--  Install a default HCRYPTPROV used to verify a certificate
--  signature. pvDefaultPara points to the szOID of the certificate
--  signature algorithm, for example, szOID_OIWSEC_md5RSA. If
--  pvDefaultPara is NULL, then, the HCRYPTPROV is used to verify all
--  certificate signatures. Note, pvDefaultPara can't be NULL when
--  CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG is set.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID
-- 
--  Same as CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID. However, the default
--  HCRYPTPROV is to be used for multiple signature szOIDs. pvDefaultPara
--  points to a CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA structure containing
--  an array of szOID pointers.
-- --------------------------------------------------------------------------
type
  _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = record
cOID            : DWORD;
rgpszOID        : ^LPSTR;
  end record;
  CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;
  PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = ^_CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;

-- +-------------------------------------------------------------------------
--  Uninstall a default context previously installed by
--  CryptInstallDefaultContext.
-- 
--  For a default context installed with CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG
--  set, if any other threads are currently using this context,
--  this function will block until they finish.
-- --------------------------------------------------------------------------
type
t_205=^unchecked for machine_pointer use true;

procedure CryptUninstallDefaultContext(
    hDefaultContext : HCRYPTDEFAULTCONTEXT; 
    dwFlags         : in DWORD; 
    pvReserved      : in t_205)
                      return BOOL;
#pragma convention(CryptUninstallDefaultContext,system);
#pragma import(CryptUninstallDefaultContext,'CryptUninstallDefaultContext','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Export the public key info associated with the provider's corresponding
--  private key.
-- 
--  Calls CryptExportPublicKeyInfoEx with pszPublicKeyObjId = NULL,
--  dwFlags = 0 and pvAuxInfo = NULL.
-- --------------------------------------------------------------------------
procedure CryptExportPublicKeyInfo(
    hCryptProv      : in t_HCRYPTPROV; 
    dwKeySpec       : in DWORD; 
    dwCertEncodingType : in DWORD; 
    pInfo           : out _CERT_PUBLIC_KEY_INFO; 
    pcbInfo         : in out DWORD)
                      return BOOL;
#pragma convention(CryptExportPublicKeyInfo,system);
#pragma import(CryptExportPublicKeyInfo,'CryptExportPublicKeyInfo','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Export the public key info associated with the provider's corresponding
--  private key.
-- 
--  Uses the dwCertEncodingType and pszPublicKeyObjId to call the
--  installable CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC. The called function
--  has the same signature as CryptExportPublicKeyInfoEx.
-- 
--  If unable to find an installable OID function for the pszPublicKeyObjId,
--  attempts to export as a RSA Public Key (szOID_RSA_RSA).
-- 
--  The dwFlags and pvAuxInfo aren't used for szOID_RSA_RSA.
-- --------------------------------------------------------------------------
type
t_206=^unchecked for machine_pointer use true;

procedure CryptExportPublicKeyInfoEx(
    hCryptProv      : in t_HCRYPTPROV; 
    dwKeySpec       : in DWORD; 
    dwCertEncodingType : in DWORD; 
    pszPublicKeyObjId : in LPSTR; 
    dwFlags         : in DWORD; 
    pvAuxInfo       : in {out optional} t_206; 
    pInfo           : out _CERT_PUBLIC_KEY_INFO; 
    pcbInfo         : in out DWORD)
                      return BOOL;
#pragma convention(CryptExportPublicKeyInfoEx,system);
#pragma import(CryptExportPublicKeyInfoEx,'CryptExportPublicKeyInfoEx','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Convert and import the public key info into the provider and return a
--  handle to the public key.
-- 
--  Calls CryptImportPublicKeyInfoEx with aiKeyAlg = 0, dwFlags = 0 and
--  pvAuxInfo = NULL.
-- --------------------------------------------------------------------------
procedure CryptImportPublicKeyInfo(
    hCryptProv      : in t_HCRYPTPROV; 
    dwCertEncodingType : in DWORD; 
    pInfo           : in PCERT_PUBLIC_KEY_INFO; 
    phKey           : out HCRYPTKEY)
                      return BOOL;
#pragma convention(CryptImportPublicKeyInfo,system);
#pragma import(CryptImportPublicKeyInfo,'CryptImportPublicKeyInfo','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Convert and import the public key info into the provider and return a
--  handle to the public key.
-- 
--  Uses the dwCertEncodingType and pInfo->Algorithm.pszObjId to call the
--  installable CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC. The called function
--  has the same signature as CryptImportPublicKeyInfoEx.
-- 
--  If unable to find an installable OID function for the pszObjId,
--  attempts to import as a RSA Public Key (szOID_RSA_RSA).
-- 
--  For szOID_RSA_RSA: aiKeyAlg may be set to CALG_RSA_SIGN or CALG_RSA_KEYX.
--  Defaults to CALG_RSA_KEYX. The dwFlags and pvAuxInfo aren't used.
-- --------------------------------------------------------------------------
type
t_207=^unchecked for machine_pointer use true;

procedure CryptImportPublicKeyInfoEx(
    hCryptProv      : in t_HCRYPTPROV; 
    dwCertEncodingType : in DWORD; 
    pInfo           : in PCERT_PUBLIC_KEY_INFO; 
    aiKeyAlg        : in ALG_ID; 
    dwFlags         : in DWORD; 
    pvAuxInfo       : in {out optional} t_207; 
    phKey           : out HCRYPTKEY)
                      return BOOL;
#pragma convention(CryptImportPublicKeyInfoEx,system);
#pragma import(CryptImportPublicKeyInfoEx,'CryptImportPublicKeyInfoEx','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Acquire a HCRYPTPROV handle and dwKeySpec for the specified certificate
--  context. Uses the certificate's CERT_KEY_PROV_INFO_PROP_ID property.
--  The returned HCRYPTPROV handle may optionally be cached using the
--  certificate's CERT_KEY_CONTEXT_PROP_ID property.
-- 
--  If CRYPT_ACQUIRE_CACHE_FLAG is set, then, if an already acquired and
--  cached HCRYPTPROV exists for the certificate, its returned. Otherwise,
--  a HCRYPTPROV is acquired and then cached via the certificate's
--  CERT_KEY_CONTEXT_PROP_ID.
-- 
--  The CRYPT_ACQUIRE_USE_PROV_INFO_FLAG can be set to use the dwFlags field of
--  the certificate's CERT_KEY_PROV_INFO_PROP_ID property's CRYPT_KEY_PROV_INFO
--  data structure to determine if the returned HCRYPTPROV should be cached.
--  HCRYPTPROV caching is enabled if the CERT_SET_KEY_CONTEXT_PROP_ID flag was
--  set.
-- 
--  If CRYPT_ACQUIRE_COMPARE_KEY_FLAG is set, then,
--  the public key in the certificate is compared with the public
--  key returned by the cryptographic provider. If the keys don't match, the
--  acquire fails and LastError is set to NTE_BAD_PUBLIC_KEY. Note, if
--  a cached HCRYPTPROV is returned, the comparison isn't done. We assume the
--  comparison was done on the initial acquire.
-- 
--  The CRYPT_ACQUIRE_SILENT_FLAG can be set to suppress any UI by the CSP.
--  See CryptAcquireContext's CRYPT_SILENT flag for more details.
-- 
--  *pfCallerFreeProv is returned set to FALSE for:
--  - Acquire or public key comparison fails.
--  - CRYPT_ACQUIRE_CACHE_FLAG is set.
--  - CRYPT_ACQUIRE_USE_PROV_INFO_FLAG is set AND
--  CERT_SET_KEY_CONTEXT_PROP_ID flag is set in the dwFlags field of the
--  certificate's CERT_KEY_PROV_INFO_PROP_ID property's
--  CRYPT_KEY_PROV_INFO data structure.
--  When *pfCallerFreeProv is FALSE, the caller must not release. The
--  returned HCRYPTPROV will be released on the last free of the certificate
--  context.
-- 
--  Otherwise, *pfCallerFreeProv is TRUE and the returned HCRYPTPROV must
--  be released by the caller by calling CryptReleaseContext.
-- --------------------------------------------------------------------------
type
t_208=^unchecked for machine_pointer use true;

procedure CryptAcquireCertificatePrivateKey(
    pCert           : in PCCERT_CONTEXT; 
    dwFlags         : in DWORD; 
    pvReserved      : in t_208; 
    phCryptProv     : out t_HCRYPTPROV; 
    pdwKeySpec      : out {out optional} DWORD; 
    pfCallerFreeProv : out {out optional} BOOL)
                      return BOOL;
#pragma convention(CryptAcquireCertificatePrivateKey,system);
#pragma import(CryptAcquireCertificatePrivateKey,'CryptAcquireCertificatePrivateKey','crypt32.dll');

const
  CRYPT_ACQUIRE_CACHE_FLAG= $01;

const
  CRYPT_ACQUIRE_USE_PROV_INFO_FLAG= $02;

const
  CRYPT_ACQUIRE_COMPARE_KEY_FLAG= $04;

const
  CRYPT_ACQUIRE_SILENT_FLAG= $40;

-- +-------------------------------------------------------------------------
--  Enumerates the cryptographic providers and their containers to find the
--  private key corresponding to the certificate's public key. For a match,
--  the certificate's CERT_KEY_PROV_INFO_PROP_ID property is updated.
-- 
--  If the CERT_KEY_PROV_INFO_PROP_ID is already set, then, its checked to
--  see if it matches the provider's public key. For a match, the above
--  enumeration is skipped.
-- 
--  By default both the user and machine key containers are searched.
--  The CRYPT_FIND_USER_KEYSET_FLAG or CRYPT_FIND_MACHINE_KEYSET_FLAG
--  can be set in dwFlags to restrict the search to either of the containers.
-- 
--  The CRYPT_FIND_SILENT_KEYSET_FLAG can be set to suppress any UI by the CSP.
--  See CryptAcquireContext's CRYPT_SILENT flag for more details.
-- 
--  If a container isn't found, returns FALSE with LastError set to
--  NTE_NO_KEY.
-- --------------------------------------------------------------------------
type
t_209=^unchecked for machine_pointer use true;

procedure CryptFindCertificateKeyProvInfo(
    pCert           : in PCCERT_CONTEXT; 
    dwFlags         : in DWORD; 
    pvReserved      : in t_209)
                      return BOOL;
#pragma convention(CryptFindCertificateKeyProvInfo,system);
#pragma import(CryptFindCertificateKeyProvInfo,'CryptFindCertificateKeyProvInfo','crypt32.dll');

const
  CRYPT_FIND_USER_KEYSET_FLAG= $01;

const
  CRYPT_FIND_MACHINE_KEYSET_FLAG= $02;

const
  CRYPT_FIND_SILENT_KEYSET_FLAG= $40;

-- +-------------------------------------------------------------------------
--  This is the prototype for the installable function which is called to
--  actually import a key into a CSP. an installable of this type is called
--  from CryptImportPKCS8. the algorithm OID of the private key is used
--  to look up the proper installable function to call.
-- 
--  hCryptProv - the provider to import the key to
--  pPrivateKeyInfo - describes the key to be imported
--  dwFlags - The available flags are:
--  CRYPT_EXPORTABLE
--  this flag is used when importing private keys, for a full
--  explanation please see the documentation for CryptImportKey.
--  pvAuxInfo - reserved for future, must be NULL
-- --------------------------------------------------------------------------
type
t_210=^CRYPT_PRIVATE_KEY_INFO for machine_pointer use true;
t_211=^unchecked for machine_pointer use true;

PFN_IMPORT_PRIV_KEY_FUNC = ^procedure (
    hCryptProv      : t_HCRYPTPROV;
    pPrivateKeyInfo : t_210;
    dwFlags         : DWORD;
    pvAuxInfo       : t_211)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Convert (from PKCS8 format) and import the private key into a provider
--  and return a handle to the provider as well as the KeySpec used to import to.
-- 
--  This function will call the PRESOLVE_HCRYPTPROV_FUNC in the
--  privateKeyAndParams to obtain a handle of provider to import the key to.
--  if the PRESOLVE_HCRYPTPROV_FUNC is NULL then the default provider will be used.
-- 
--  privateKeyAndParams - private key blob and corresponding parameters
--  dwFlags - The available flags are:
--  CRYPT_EXPORTABLE
--  this flag is used when importing private keys, for a full
--  explanation please see the documentation for CryptImportKey.
--  phCryptProv - filled in with the handle of the provider the key was
--  imported to, the caller is responsible for freeing it
--  pvAuxInfo - This parameter is reserved for future use and should be set
--  to NULL in the interim.
-- --------------------------------------------------------------------------
--  in
--  in, optional
type
t_212=^t_HCRYPTPROV for machine_pointer use true;

--  out, optional
--  in, optional
t_213=^unchecked for machine_pointer use true;

procedure CryptImportPKCS8(
    sImportParams   : CRYPT_PKCS8_IMPORT_PARAMS; 
    dwFlags         : DWORD; 
    phCryptProv     : t_212; 
    pvAuxInfo       : t_213)
                      return BOOL;
#pragma convention(CryptImportPKCS8,system);
#pragma import(CryptImportPKCS8,'CryptImportPKCS8','crypt32.dll');

-- +-------------------------------------------------------------------------
--  this is the prototype for installable functions for exporting the private key
-- --------------------------------------------------------------------------
type
t_214=^unchecked for machine_pointer use true;
t_215=^CRYPT_PRIVATE_KEY_INFO for machine_pointer use true;
t_216=^DWORD for machine_pointer use true;

PFN_EXPORT_PRIV_KEY_FUNC = ^procedure (
    hCryptProv      : t_HCRYPTPROV;
    dwKeySpec       : DWORD;
    pszPrivateKeyObjId : LPSTR;
    dwFlags         : DWORD;
    pvAuxInfo       : t_214;
    pPrivateKeyInfo : t_215;
    pcbPrivateKeyBlob : t_216)
                      return BOOL for machine_pointer use true;
const
  CRYPT_DELETE_KEYSET= $01;

-- +-------------------------------------------------------------------------
--  CryptExportPKCS8 -- superseded by CryptExportPKCS8Ex
-- 
--  Export the private key in PKCS8 format
-- --------------------------------------------------------------------------
--  in
--  in
--  in
--  in
type
t_217=^unchecked for machine_pointer use true;

--  in
t_218=^BYTE for machine_pointer use true;

--  out
--  in, out
t_219=^DWORD for machine_pointer use true;

procedure CryptExportPKCS8(
    hCryptProv      : t_HCRYPTPROV; 
    dwKeySpec       : DWORD; 
    pszPrivateKeyObjId : LPSTR; 
    dwFlags         : DWORD; 
    pvAuxInfo       : t_217; 
    pbPrivateKeyBlob : t_218; 
    pcbPrivateKeyBlob : t_219)
                      return BOOL;
#pragma convention(CryptExportPKCS8,system);
#pragma import(CryptExportPKCS8,'CryptExportPKCS8','crypt32.dll');

-- +-------------------------------------------------------------------------
--  CryptExportPKCS8Ex
-- 
--  Export the private key in PKCS8 format
-- 
-- 
--  Uses the pszPrivateKeyObjId to call the
--  installable CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC. The called function
--  has the signature defined by PFN_EXPORT_PRIV_KEY_FUNC.
-- 
--  If unable to find an installable OID function for the pszPrivateKeyObjId,
--  attempts to export as a RSA Private Key (szOID_RSA_RSA).
-- 
--  psExportParams - specifies information about the key to export
--  dwFlags - The flag values. None currently supported
--  pvAuxInfo - This parameter is reserved for future use and should be set to
--  NULL in the interim.
--  pbPrivateKeyBlob - A pointer to the private key blob. It will be encoded
--  as a PKCS8 PrivateKeyInfo.
--  pcbPrivateKeyBlob - A pointer to a DWORD that contains the size, in bytes,
--  of the private key blob being exported.
-- +-------------------------------------------------------------------------
--  in
--  in
--  in
--  out
--  in, out
-- +-------------------------------------------------------------------------
--  Compute the hash of the encoded public key info.
-- 
--  The public key info is encoded and then hashed.
-- --------------------------------------------------------------------------
procedure CryptHashPublicKeyInfo(
    hCryptProv      : in t_HCRYPTPROV; 
    Algid           : in ALG_ID; 
    dwFlags         : in DWORD; 
    dwCertEncodingType : in DWORD; 
    pInfo           : in PCERT_PUBLIC_KEY_INFO; 
    pbComputedHash  : out BYTE; 
    pcbComputedHash : in out DWORD)
                      return BOOL;
#pragma convention(CryptHashPublicKeyInfo,system);
#pragma import(CryptHashPublicKeyInfo,'CryptHashPublicKeyInfo','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Convert a Name Value to a null terminated char string
-- 
--  Returns the number of characters converted including the terminating null
--  character. If psz is NULL or csz is 0, returns the required size of the
--  destination string (including the terminating null char).
-- 
--  If psz != NULL && csz != 0, returned psz is always NULL terminated.
-- 
--  Note: csz includes the NULL char.
-- --------------------------------------------------------------------------
procedure CertRDNValueToStrA(
    dwValueType     : in DWORD; 
    pValue          : in PCERT_RDN_VALUE_BLOB; 
    psz             : out {out optional} CHARSTR ; 
    csz             : in DWORD)
                      return DWORD;
#pragma convention(CertRDNValueToStrA,system);
#pragma import(CertRDNValueToStrA,'CertRDNValueToStrA','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Convert a Name Value to a null terminated char string
-- 
--  Returns the number of characters converted including the terminating null
--  character. If psz is NULL or csz is 0, returns the required size of the
--  destination string (including the terminating null char).
-- 
--  If psz != NULL && csz != 0, returned psz is always NULL terminated.
-- 
--  Note: csz includes the NULL char.
-- --------------------------------------------------------------------------
procedure CertRDNValueToStrW(
    dwValueType     : in DWORD; 
    pValue          : in PCERT_RDN_VALUE_BLOB; 
    psz             : out {out optional} WCHARSTR ; 
    csz             : in DWORD)
                      return DWORD;
#pragma convention(CertRDNValueToStrW,system);
#pragma import(CertRDNValueToStrW,'CertRDNValueToStrW','crypt32.dll');

#if #declared UNICODE; then;
#template CertRDNValueToStr;
  CertRDNValueToStrW 
#end CertRDNValueToStr;
#else;
#template CertRDNValueToStr;
  CertRDNValueToStrA 
#end CertRDNValueToStr;
#end if;

-- +-------------------------------------------------------------------------
--  Convert the certificate name blob to a null terminated char string.
-- 
--  Follows the string representation of distinguished names specified in
--  RFC 1779. (Note, added double quoting "" for embedded quotes, quote
--  empty strings and don't quote strings containing consecutive spaces).
--  RDN values of type CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING are
--  formatted in hexadecimal (e.g. #0A56CF).
-- 
--  The name string is formatted according to the dwStrType:
--  CERT_SIMPLE_NAME_STR
--  The object identifiers are discarded. CERT_RDN entries are separated
--  by ", ". Multiple attributes per CERT_RDN are separated by " + ".
--  For example:
--  Microsoft, Joe Cool + Programmer
--  CERT_OID_NAME_STR
--  The object identifiers are included with a "=" separator from their
--  attribute value. CERT_RDN entries are separated by ", ".
--  Multiple attributes per CERT_RDN are separated by " + ". For example:
--  2.5.4.11=Microsoft, 2.5.4.3=Joe Cool + 2.5.4.12=Programmer
--  CERT_X500_NAME_STR
--  The object identifiers are converted to their X500 key name. Otherwise,
--  same as CERT_OID_NAME_STR. If the object identifier doesn't have
--  a corresponding X500 key name, then, the object identifier is used with
--  a "OID." prefix. For example:
--  OU=Microsoft, CN=Joe Cool + T=Programmer, OID.1.2.3.4.5.6=Unknown
-- 
--  We quote the RDN value if it contains leading or trailing whitespace
--  or one of the following characters: ",", "+", "=", """, "\n", "<", ">",
--  "#" or ";". The quoting character is ". If the the RDN Value contains
--  a " it is double quoted (""). For example:
--  OU=" Microsoft", CN="Joe ""Cool""" + T="Programmer, Manager"
-- 
--  CERT_NAME_STR_SEMICOLON_FLAG can be or'ed into dwStrType to replace
--  the ", " separator with a "; " separator.
-- 
--  CERT_NAME_STR_CRLF_FLAG can be or'ed into dwStrType to replace
--  the ", " separator with a "\r\n" separator.
-- 
--  CERT_NAME_STR_NO_PLUS_FLAG can be or'ed into dwStrType to replace the
--  " + " separator with a single space, " ".
-- 
--  CERT_NAME_STR_NO_QUOTING_FLAG can be or'ed into dwStrType to inhibit
--  the above quoting.
-- 
--  CERT_NAME_STR_REVERSE_FLAG can be or'ed into dwStrType to reverse the
--  order of the RDNs before converting to the string.
-- 
--  By default, CERT_RDN_T61_STRING encoded values are initially decoded
--  as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
--  CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG can be or'ed into dwStrType to
--  skip the initial attempt to decode as UTF8.
-- 
--  Returns the number of characters converted including the terminating null
--  character. If psz is NULL or csz is 0, returns the required size of the
--  destination string (including the terminating null char).
-- 
--  If psz != NULL && csz != 0, returned psz is always NULL terminated.
-- 
--  Note: csz includes the NULL char.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
-- --------------------------------------------------------------------------
procedure CertNameToStrA(
    dwCertEncodingType : in DWORD; 
    pName           : in PCERT_NAME_BLOB; 
    dwStrType       : in DWORD; 
    psz             : out {out optional} CHARSTR ; 
    csz             : in DWORD)
                      return DWORD;
#pragma convention(CertNameToStrA,system);
#pragma import(CertNameToStrA,'CertNameToStrA','crypt32.dll');

-- +-------------------------------------------------------------------------
-- --------------------------------------------------------------------------
procedure CertNameToStrW(
    dwCertEncodingType : in DWORD; 
    pName           : in PCERT_NAME_BLOB; 
    dwStrType       : in DWORD; 
    psz             : out {out optional} WCHARSTR ; 
    csz             : in DWORD)
                      return DWORD;
#pragma convention(CertNameToStrW,system);
#pragma import(CertNameToStrW,'CertNameToStrW','crypt32.dll');

#if #declared UNICODE; then;
#template CertNameToStr;
  CertNameToStrW 
#end CertNameToStr;
#else;
#template CertNameToStr;
  CertNameToStrA 
#end CertNameToStr;
#end if;

-- +-------------------------------------------------------------------------
--  Certificate name string types
-- --------------------------------------------------------------------------
const
  CERT_SIMPLE_NAME_STR= 1;

const
  CERT_OID_NAME_STR = 2;

const
  CERT_X500_NAME_STR= 3;

-- +-------------------------------------------------------------------------
--  Certificate name string type flags OR'ed with the above types
-- --------------------------------------------------------------------------
const
  CERT_NAME_STR_SEMICOLON_FLAG= $40000000;

const
  CERT_NAME_STR_NO_PLUS_FLAG= $20000000;

const
  CERT_NAME_STR_NO_QUOTING_FLAG= $10000000;

const
  CERT_NAME_STR_CRLF_FLAG= $8000000;

const
  CERT_NAME_STR_COMMA_FLAG= $4000000;

const
  CERT_NAME_STR_REVERSE_FLAG= $2000000;

const
  CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG= $10000;

const
  CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG= $20000;

const
  CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG= $40000;

-- +-------------------------------------------------------------------------
--  Convert the null terminated X500 string to an encoded certificate name.
-- 
--  The input string is expected to be formatted the same as the output
--  from the above CertNameToStr API.
-- 
--  The CERT_SIMPLE_NAME_STR type isn't supported. Otherwise, when dwStrType
--  is set to 0, CERT_OID_NAME_STR or CERT_X500_NAME_STR, allow either a
--  case insensitive X500 key (CN=), case insensitive "OID." prefixed
--  object identifier (OID.1.2.3.4.5.6=) or an object identifier (1.2.3.4=).
-- 
--  If no flags are OR'ed into dwStrType, then, allow "," or ";" as RDN
--  separators and "+" as the multiple RDN value separator. Quoting is
--  supported. A quote may be included in a quoted value by double quoting,
--  for example (CN="Joe ""Cool"""). A value starting with a "#" is treated
--  as ascii hex and converted to a CERT_RDN_OCTET_STRING. Embedded whitespace
--  is skipped (1.2.3 = # AB CD 01 is the same as 1.2.3=#ABCD01).
-- 
--  Whitespace surrounding the keys, object identifers and values is removed.
-- 
--  CERT_NAME_STR_COMMA_FLAG can be or'ed into dwStrType to only allow the
--  "," as the RDN separator.
-- 
--  CERT_NAME_STR_SEMICOLON_FLAG can be or'ed into dwStrType to only allow the
--  ";" as the RDN separator.
-- 
--  CERT_NAME_STR_CRLF_FLAG can be or'ed into dwStrType to only allow
--  "\r" or "\n" as the RDN separator.
-- 
--  CERT_NAME_STR_NO_PLUS_FLAG can be or'ed into dwStrType to ignore "+"
--  as a separator and not allow multiple values per RDN.
-- 
--  CERT_NAME_STR_NO_QUOTING_FLAG can be or'ed into dwStrType to inhibit
--  quoting.
-- 
--  CERT_NAME_STR_REVERSE_FLAG can be or'ed into dwStrType to reverse the
--  order of the RDNs after converting from the string and before encoding.
-- 
--  CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG can be or'ed into dwStrType to
--  to select the CERT_RDN_T61_STRING encoded value type instead of
--  CERT_RDN_UNICODE_STRING if all the UNICODE characters are <= 0xFF.
-- 
--  CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG can be or'ed into dwStrType to
--  to select the CERT_RDN_UTF8_STRING encoded value type instead of
--  CERT_RDN_UNICODE_STRING.
-- 
--  Support the following X500 Keys:
-- 
--  Key Object Identifier RDN Value Type(s)
--  --- ----------------- -----------------
--  CN szOID_COMMON_NAME Printable, Unicode
--  L szOID_LOCALITY_NAME Printable, Unicode
--  O szOID_ORGANIZATION_NAME Printable, Unicode
--  OU szOID_ORGANIZATIONAL_UNIT_NAME Printable, Unicode
--  E szOID_RSA_emailAddr Only IA5
--  Email szOID_RSA_emailAddr Only IA5
--  C szOID_COUNTRY_NAME Only Printable
--  S szOID_STATE_OR_PROVINCE_NAME Printable, Unicode
--  ST szOID_STATE_OR_PROVINCE_NAME Printable, Unicode
--  STREET szOID_STREET_ADDRESS Printable, Unicode
--  T szOID_TITLE Printable, Unicode
--  Title szOID_TITLE Printable, Unicode
--  G szOID_GIVEN_NAME Printable, Unicode
--  GivenName szOID_GIVEN_NAME Printable, Unicode
--  I szOID_INITIALS Printable, Unicode
--  Initials szOID_INITIALS Printable, Unicode
--  SN szOID_SUR_NAME Printable, Unicode
--  DC szOID_DOMAIN_COMPONENT IA5, UTF8
-- 
--  Note, T61 is selected instead of Unicode if
--  CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG is set and all the unicode
--  characters are <= 0xFF.
-- 
--  Note, UTF8 is selected instead of Unicode if
--  CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG is set.
-- 
--  Returns TRUE if successfully parsed the input string and encoded
--  the name.
-- 
--  If the input string is detected to be invalid, *ppszError is updated
--  to point to the beginning of the invalid character sequence. Otherwise,
--  *ppszError is set to NULL. *ppszError is updated with a non-NULL pointer
--  for the following errors:
--  CRYPT_E_INVALID_X500_STRING
--  CRYPT_E_INVALID_NUMERIC_STRING
--  CRYPT_E_INVALID_PRINTABLE_STRING
--  CRYPT_E_INVALID_IA5_STRING
-- 
--  ppszError can be set to NULL if not interested in getting a pointer
--  to the invalid character sequence.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
-- --------------------------------------------------------------------------
type
t_224=^unchecked for machine_pointer use true;

procedure CertStrToNameA(
    dwCertEncodingType : in DWORD; 
    pszX500         : in LPCSTR; 
    dwStrType       : in DWORD; 
    pvReserved      : in {out optional} t_224; 
    pbEncoded       : out BYTE; 
    pcbEncoded      : in out DWORD; 
    ppszError       : out {out optional} LPCSTR)
                      return BOOL;
#pragma convention(CertStrToNameA,system);
#pragma import(CertStrToNameA,'CertStrToNameA','crypt32.dll');

-- +-------------------------------------------------------------------------
-- --------------------------------------------------------------------------
type
t_225=^unchecked for machine_pointer use true;

procedure CertStrToNameW(
    dwCertEncodingType : in DWORD; 
    pszX500         : in LPCWSTR; 
    dwStrType       : in DWORD; 
    pvReserved      : in {out optional} t_225; 
    pbEncoded       : out BYTE; 
    pcbEncoded      : in out DWORD; 
    ppszError       : out {out optional} LPCWSTR)
                      return BOOL;
#pragma convention(CertStrToNameW,system);
#pragma import(CertStrToNameW,'CertStrToNameW','crypt32.dll');

#if #declared UNICODE; then;
#template CertStrToName;
  CertStrToNameW 
#end CertStrToName;
#else;
#template CertStrToName;
  CertStrToNameA 
#end CertStrToName;
#end if;

-- +-------------------------------------------------------------------------
--  Get the subject or issuer name from the certificate and
--  according to the specified format type, convert to a null terminated
--  character string.
-- 
--  CERT_NAME_ISSUER_FLAG can be set to get the issuer's name. Otherwise,
--  gets the subject's name.
-- 
--  By default, CERT_RDN_T61_STRING encoded values are initially decoded
--  as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
--  CERT_NAME_DISABLE_IE4_UTF8_FLAG can be set in dwFlags to
--  skip the initial attempt to decode as UTF8.
-- 
--  The name string is formatted according to the dwType:
--  CERT_NAME_EMAIL_TYPE
--  If the certificate has a Subject Alternative Name extension (for
--  issuer, Issuer Alternative Name), searches for first rfc822Name choice.
--  If the rfc822Name choice isn't found in the extension, searches the
--  Subject Name field for the Email OID, "1.2.840.113549.1.9.1".
--  If the rfc822Name or Email OID is found, returns the string. Otherwise,
--  returns an empty string (returned character count is 1).
--  CERT_NAME_DNS_TYPE
--  If the certificate has a Subject Alternative Name extension (for
--  issuer, Issuer Alternative Name), searches for first DNSName choice.
--  If the DNSName choice isn't found in the extension, searches the
--  Subject Name field for the CN OID, "2.5.4.3".
--  If the DNSName or CN OID is found, returns the string. Otherwise,
--  returns an empty string.
--  CERT_NAME_URL_TYPE
--  If the certificate has a Subject Alternative Name extension (for
--  issuer, Issuer Alternative Name), searches for first URL choice.
--  If the URL choice is found, returns the string. Otherwise,
--  returns an empty string.
--  CERT_NAME_UPN_TYPE
--  If the certificate has a Subject Alternative Name extension,
--  searches the OtherName choices looking for a
--  pszObjId == szOID_NT_PRINCIPAL_NAME, "1.3.6.1.4.1.311.20.2.3".
--  If the UPN OID is found, the blob is decoded as a
--  X509_UNICODE_ANY_STRING and the decoded string is returned.
--  Otherwise, returns an empty string.
--  CERT_NAME_RDN_TYPE
--  Converts the Subject Name blob by calling CertNameToStr. pvTypePara
--  points to a DWORD containing the dwStrType passed to CertNameToStr.
--  If the Subject Name field is empty and the certificate has a
--  Subject Alternative Name extension, searches for and converts
--  the first directoryName choice.
--  CERT_NAME_ATTR_TYPE
--  pvTypePara points to the Object Identifier specifying the name attribute
--  to be returned. For example, to get the CN,
--  pvTypePara = szOID_COMMON_NAME ("2.5.4.3"). Searches, the Subject Name
--  field for the attribute.
--  If the Subject Name field is empty and the certificate has a
--  Subject Alternative Name extension, checks for
--  the first directoryName choice and searches it.
-- 
--  Note, searches the RDNs in reverse order.
-- 
--  CERT_NAME_SIMPLE_DISPLAY_TYPE
--  Iterates through the following list of name attributes and searches
--  the Subject Name and then the Subject Alternative Name extension
--  for the first occurrence of:
--  szOID_COMMON_NAME ("2.5.4.3")
--  szOID_ORGANIZATIONAL_UNIT_NAME ("2.5.4.11")
--  szOID_ORGANIZATION_NAME ("2.5.4.10")
--  szOID_RSA_emailAddr ("1.2.840.113549.1.9.1")
-- 
--  If none of the above attributes is found, then, searches the
--  Subject Alternative Name extension for a rfc822Name choice.
-- 
--  If still no match, then, returns the first attribute.
-- 
--  Note, like CERT_NAME_ATTR_TYPE, searches the RDNs in reverse order.
-- 
--  CERT_NAME_FRIENDLY_DISPLAY_TYPE
--  First checks if the certificate has a CERT_FRIENDLY_NAME_PROP_ID
--  property. If it does, then, this property is returned. Otherwise,
--  returns the above CERT_NAME_SIMPLE_DISPLAY_TYPE.
-- 
--  Returns the number of characters converted including the terminating null
--  character. If pwszNameString is NULL or cchNameString is 0, returns the
--  required size of the destination string (including the terminating null
--  char). If the specified name type isn't found. returns an empty string
--  with a returned character count of 1.
-- 
--  If pwszNameString != NULL && cwszNameString != 0, returned pwszNameString
--  is always NULL terminated.
-- 
--  Note: cchNameString includes the NULL char.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
-- --------------------------------------------------------------------------
type
t_226=^unchecked for machine_pointer use true;

procedure CertGetNameStringA(
    pCertContext    : in PCCERT_CONTEXT; 
    dwType          : in DWORD; 
    dwFlags         : in DWORD; 
    pvTypePara      : in t_226; 
    pszNameString   : out {out optional} CHARSTR ; 
    cchNameString   : in DWORD)
                      return DWORD;
#pragma convention(CertGetNameStringA,system);
#pragma import(CertGetNameStringA,'CertGetNameStringA','crypt32.dll');

-- +-------------------------------------------------------------------------
-- --------------------------------------------------------------------------
type
t_227=^unchecked for machine_pointer use true;

procedure CertGetNameStringW(
    pCertContext    : in PCCERT_CONTEXT; 
    dwType          : in DWORD; 
    dwFlags         : in DWORD; 
    pvTypePara      : in t_227; 
    pszNameString   : out {out optional} WCHARSTR ; 
    cchNameString   : in DWORD)
                      return DWORD;
#pragma convention(CertGetNameStringW,system);
#pragma import(CertGetNameStringW,'CertGetNameStringW','crypt32.dll');

#if #declared UNICODE; then;
#template CertGetNameString;
  CertGetNameStringW 
#end CertGetNameString;
#else;
#template CertGetNameString;
  CertGetNameStringA 
#end CertGetNameString;
#end if;

-- +-------------------------------------------------------------------------
--  Certificate name types
-- --------------------------------------------------------------------------
const
  CERT_NAME_EMAIL_TYPE= 1;

const
  CERT_NAME_RDN_TYPE= 2;

const
  CERT_NAME_ATTR_TYPE= 3;

const
  CERT_NAME_SIMPLE_DISPLAY_TYPE= 4;

const
  CERT_NAME_FRIENDLY_DISPLAY_TYPE= 5;

const
  CERT_NAME_DNS_TYPE= 6;

const
  CERT_NAME_URL_TYPE= 7;

const
  CERT_NAME_UPN_TYPE= 8;

-- +-------------------------------------------------------------------------
--  Certificate name flags
-- --------------------------------------------------------------------------
const
  CERT_NAME_ISSUER_FLAG= $01;

const
  CERT_NAME_DISABLE_IE4_UTF8_FLAG= $10000;

-- +=========================================================================
--  Simplified Cryptographic Message Data Structures and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  Conventions for the *pb and *pcb output parameters:
-- 
--  Upon entry to the function:
--  if pcb is OPTIONAL && pcb == NULL, then,
--  No output is returned
--  else if pb == NULL && pcb != NULL, then,
--  Length only determination. No length error is
--  returned.
--  otherwise where (pb != NULL && pcb != NULL && *pcb != 0)
--  Output is returned. If *pcb isn't big enough a
--  length error is returned. In all cases *pcb is updated
--  with the actual length needed/returned.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Type definitions of the parameters used for doing the cryptographic
--  operations.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  Callback to get and verify the signer's certificate.
-- 
--  Passed the CertId of the signer (its Issuer and SerialNumber) and a
--  handle to its cryptographic signed message's cert store.
-- 
--  For CRYPT_E_NO_SIGNER, called with pSignerId == NULL.
-- 
--  For a valid signer certificate, returns a pointer to a read only
--  CERT_CONTEXT. The returned CERT_CONTEXT is either obtained from a
--  cert store or was created via CertCreateCertificateContext. For either case,
--  its freed via CertFreeCertificateContext.
-- 
--  If a valid certificate isn't found, this callback returns NULL with
--  LastError set via SetLastError().
-- 
--  The NULL implementation tries to get the Signer certificate from the
--  message cert store. It doesn't verify the certificate.
-- 
--  Note, if the KEYID choice was selected for a CMS SignerId, then, the
--  SerialNumber is 0 and the Issuer is encoded containing a single RDN with a
--  single Attribute whose OID is szOID_KEYID_RDN, value type is
--  CERT_RDN_OCTET_STRING and value is the KEYID. When the
--  CertGetSubjectCertificateFromStore and
--  CertFindCertificateInStore(CERT_FIND_SUBJECT_CERT) APIs see this
--  special KEYID Issuer and SerialNumber, they do a KEYID match.
-- --------------------------------------------------------------------------
type
t_228=^unchecked for machine_pointer use true;

PFN_CRYPT_GET_SIGNER_CERTIFICATE = ^procedure (
    pvGetArg        : in t_228;
    dwCertEncodingType : in DWORD;
    pSignerId       : in PCERT_INFO;
    hMsgCertStore   : in t_HCERTSTORE)
                      return PCCERT_CONTEXT for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  The CRYPT_SIGN_MESSAGE_PARA are used for signing messages using the
--  specified signing certificate context.
-- 
--  Either the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID must
--  be set for each rgpSigningCert[]. Either one specifies the private
--  signature key to use.
-- 
--  If any certificates and/or CRLs are to be included in the signed message,
--  then, the MsgCert and MsgCrl parameters need to be updated. If the
--  rgpSigningCerts are to be included, then, they must also be in the
--  rgpMsgCert array.
-- 
--  cbSize must be set to the sizeof(CRYPT_SIGN_MESSAGE_PARA) or else
--  LastError will be updated with E_INVALIDARG.
-- 
--  pvHashAuxInfo currently isn't used and must be set to NULL.
-- 
--  dwFlags normally is set to 0. However, if the encoded output
--  is to be a CMSG_SIGNED inner content of an outer cryptographic message,
--  such as a CMSG_ENVELOPED, then, the CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG
--  should be set. If not set, then it would be encoded as an inner content
--  type of CMSG_DATA.
-- 
--  dwInnerContentType is normally set to 0. It needs to be set if the
--  ToBeSigned input is the encoded output of another cryptographic
--  message, such as, an CMSG_ENVELOPED. When set, it's one of the cryptographic
--  message types, for example, CMSG_ENVELOPED.
-- 
--  If the inner content of a nested cryptographic message is data (CMSG_DATA
--  the default), then, neither dwFlags or dwInnerContentType need to be set.
-- 
--  For CMS messages, CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG may be
--  set to encapsulate nonData inner content within an OCTET STRING.
-- 
--  For CMS messages, CRYPT_MESSAGE_KEYID_SIGNER_FLAG may be set to identify
--  signers by their Key Identifier and not their Issuer and Serial Number.
-- 
--  The CRYPT_MESSAGE_SILENT_KEYSET_FLAG can be set to suppress any UI by the
--  CSP. See CryptAcquireContext's CRYPT_SILENT flag for more details.
-- 
--  If HashEncryptionAlgorithm is present and not NULL its used instead of
--  the SigningCert's PublicKeyInfo.Algorithm.
-- 
--  Note, for RSA, the hash encryption algorithm is normally the same as
--  the public key algorithm. For DSA, the hash encryption algorithm is
--  normally a DSS signature algorithm.
-- 
--  pvHashEncryptionAuxInfo currently isn't used and must be set to NULL if
--  present in the data structure.
-- --------------------------------------------------------------------------
type
  _CRYPT_SIGN_MESSAGE_PARA = record
cbSize          : DWORD;
dwMsgEncodingType : DWORD;
pSigningCert    : PCCERT_CONTEXT;
HashAlgorithm   : CRYPT_ALGORITHM_IDENTIFIER;
pvHashAuxInfo   : ^unchecked;
cMsgCert        : DWORD;
rgpMsgCert      : ^PCCERT_CONTEXT;
cMsgCrl         : DWORD;
rgpMsgCrl       : ^PCCRL_CONTEXT;
cAuthAttr       : DWORD;
rgAuthAttr      : PCRYPT_ATTRIBUTE;
cUnauthAttr     : DWORD;
rgUnauthAttr    : PCRYPT_ATTRIBUTE;
dwFlags         : DWORD;
dwInnerContentType : DWORD;
  end record;
  CRYPT_SIGN_MESSAGE_PARA = _CRYPT_SIGN_MESSAGE_PARA;
  PCRYPT_SIGN_MESSAGE_PARA = ^_CRYPT_SIGN_MESSAGE_PARA;

const
  CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG= $01;

--  When set, nonData type inner content is encapsulated within an
--  OCTET STRING
const
  CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG= $02;

--  When set, signers are identified by their Key Identifier and not
--  their Issuer and Serial Number.
const
  CRYPT_MESSAGE_KEYID_SIGNER_FLAG= $04;

--  When set, suppresses any UI by the CSP.
--  See CryptAcquireContext's CRYPT_SILENT flag for more details.
const
  CRYPT_MESSAGE_SILENT_KEYSET_FLAG= $40;

-- +-------------------------------------------------------------------------
--  The CRYPT_VERIFY_MESSAGE_PARA are used to verify signed messages.
-- 
--  hCryptProv is used to do hashing and signature verification.
-- 
--  The dwCertEncodingType specifies the encoding type of the certificates
--  and/or CRLs in the message.
-- 
--  pfnGetSignerCertificate is called to get and verify the message signer's
--  certificate.
-- 
--  cbSize must be set to the sizeof(CRYPT_VERIFY_MESSAGE_PARA) or else
--  LastError will be updated with E_INVALIDARG.
-- --------------------------------------------------------------------------
type
  _CRYPT_VERIFY_MESSAGE_PARA = record
cbSize          : DWORD;
dwMsgAndCertEncodingType : DWORD;
hCryptProv      : t_HCRYPTPROV;
pfnGetSignerCertificate : PFN_CRYPT_GET_SIGNER_CERTIFICATE;
pvGetArg        : ^unchecked;
  end record;
  CRYPT_VERIFY_MESSAGE_PARA = _CRYPT_VERIFY_MESSAGE_PARA;
  PCRYPT_VERIFY_MESSAGE_PARA = ^_CRYPT_VERIFY_MESSAGE_PARA;

-- +-------------------------------------------------------------------------
--  The CRYPT_ENCRYPT_MESSAGE_PARA are used for encrypting messages.
-- 
--  hCryptProv is used to do content encryption, recipient key
--  encryption, and recipient key export. Its private key
--  isn't used.
-- 
--  Currently, pvEncryptionAuxInfo is only defined for RC2 or RC4 encryption
--  algorithms. Otherwise, its not used and must be set to NULL.
--  See CMSG_RC2_AUX_INFO for the RC2 encryption algorithms.
--  See CMSG_RC4_AUX_INFO for the RC4 encryption algorithms.
-- 
--  To enable SP3 compatible encryption, pvEncryptionAuxInfo should point to
--  a CMSG_SP3_COMPATIBLE_AUX_INFO data structure.
-- 
--  cbSize must be set to the sizeof(CRYPT_ENCRYPT_MESSAGE_PARA) or else
--  LastError will be updated with E_INVALIDARG.
-- 
--  dwFlags normally is set to 0. However, if the encoded output
--  is to be a CMSG_ENVELOPED inner content of an outer cryptographic message,
--  such as a CMSG_SIGNED, then, the CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG
--  should be set. If not set, then it would be encoded as an inner content
--  type of CMSG_DATA.
-- 
--  dwInnerContentType is normally set to 0. It needs to be set if the
--  ToBeEncrypted input is the encoded output of another cryptographic
--  message, such as, an CMSG_SIGNED. When set, it's one of the cryptographic
--  message types, for example, CMSG_SIGNED.
-- 
--  If the inner content of a nested cryptographic message is data (CMSG_DATA
--  the default), then, neither dwFlags or dwInnerContentType need to be set.
-- 
--  For CMS messages, CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG may be
--  set to encapsulate nonData inner content within an OCTET STRING before
--  encrypting.
-- 
--  For CMS messages, CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG may be set to identify
--  recipients by their Key Identifier and not their Issuer and Serial Number.
-- --------------------------------------------------------------------------
type
  _CRYPT_ENCRYPT_MESSAGE_PARA = record
cbSize          : DWORD;
dwMsgEncodingType : DWORD;
hCryptProv      : t_HCRYPTPROV;
ContentEncryptionAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
pvEncryptionAuxInfo : ^unchecked;
dwFlags         : DWORD;
dwInnerContentType : DWORD;
  end record;
  CRYPT_ENCRYPT_MESSAGE_PARA = _CRYPT_ENCRYPT_MESSAGE_PARA;
  PCRYPT_ENCRYPT_MESSAGE_PARA = ^_CRYPT_ENCRYPT_MESSAGE_PARA;

--  When set, recipients are identified by their Key Identifier and not
--  their Issuer and Serial Number.
const
  CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG= $04;

-- +-------------------------------------------------------------------------
--  The CRYPT_DECRYPT_MESSAGE_PARA are used for decrypting messages.
-- 
--  The CertContext to use for decrypting a message is obtained from one
--  of the specified cert stores. An encrypted message can have one or
--  more recipients. The recipients are identified by their CertId (Issuer
--  and SerialNumber). The cert stores are searched to find the CertContext
--  corresponding to the CertId.
-- 
--  For CMS, the recipients may also be identified by their KeyId.
--  CMS also allows Key Agreement (Diffie Hellman) in addition to
--  Key Transport (RSA) recipients.
-- 
--  Only CertContexts in the store with either
--  the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID set
--  can be used. Either property specifies the private exchange key to use.
-- 
--  cbSize must be set to the sizeof(CRYPT_DECRYPT_MESSAGE_PARA) or else
--  LastError will be updated with E_INVALIDARG.
-- --------------------------------------------------------------------------
type
  _CRYPT_DECRYPT_MESSAGE_PARA = record
cbSize          : DWORD;
dwMsgAndCertEncodingType : DWORD;
cCertStore      : DWORD;
rghCertStore    : ^t_HCERTSTORE;
  end record;
  CRYPT_DECRYPT_MESSAGE_PARA = _CRYPT_DECRYPT_MESSAGE_PARA;
  PCRYPT_DECRYPT_MESSAGE_PARA = ^_CRYPT_DECRYPT_MESSAGE_PARA;

-- +-------------------------------------------------------------------------
--  The CRYPT_HASH_MESSAGE_PARA are used for hashing or unhashing
--  messages.
-- 
--  hCryptProv is used to compute the hash.
-- 
--  pvHashAuxInfo currently isn't used and must be set to NULL.
-- 
--  cbSize must be set to the sizeof(CRYPT_HASH_MESSAGE_PARA) or else
--  LastError will be updated with E_INVALIDARG.
-- --------------------------------------------------------------------------
type
  _CRYPT_HASH_MESSAGE_PARA = record
cbSize          : DWORD;
dwMsgEncodingType : DWORD;
hCryptProv      : t_HCRYPTPROV;
HashAlgorithm   : CRYPT_ALGORITHM_IDENTIFIER;
pvHashAuxInfo   : ^unchecked;
  end record;
  CRYPT_HASH_MESSAGE_PARA = _CRYPT_HASH_MESSAGE_PARA;
  PCRYPT_HASH_MESSAGE_PARA = ^_CRYPT_HASH_MESSAGE_PARA;

-- +-------------------------------------------------------------------------
--  The CRYPT_KEY_SIGN_MESSAGE_PARA are used for signing messages until a
--  certificate has been created for the signature key.
-- 
--  pvHashAuxInfo currently isn't used and must be set to NULL.
-- 
--  If PubKeyAlgorithm isn't set, defaults to szOID_RSA_RSA.
-- 
--  cbSize must be set to the sizeof(CRYPT_KEY_SIGN_MESSAGE_PARA) or else
--  LastError will be updated with E_INVALIDARG.
-- --------------------------------------------------------------------------
type
  _CRYPT_KEY_SIGN_MESSAGE_PARA = record
cbSize          : DWORD;
dwMsgAndCertEncodingType : DWORD;
hCryptProv      : t_HCRYPTPROV;
dwKeySpec       : DWORD;
HashAlgorithm   : CRYPT_ALGORITHM_IDENTIFIER;
pvHashAuxInfo   : ^unchecked;
PubKeyAlgorithm : CRYPT_ALGORITHM_IDENTIFIER;
  end record;
  CRYPT_KEY_SIGN_MESSAGE_PARA = _CRYPT_KEY_SIGN_MESSAGE_PARA;
  PCRYPT_KEY_SIGN_MESSAGE_PARA = ^_CRYPT_KEY_SIGN_MESSAGE_PARA;

-- +-------------------------------------------------------------------------
--  The CRYPT_KEY_VERIFY_MESSAGE_PARA are used to verify signed messages without
--  a certificate for the signer.
-- 
--  Normally used until a certificate has been created for the key.
-- 
--  hCryptProv is used to do hashing and signature verification.
-- 
--  cbSize must be set to the sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA) or else
--  LastError will be updated with E_INVALIDARG.
-- --------------------------------------------------------------------------
type
  _CRYPT_KEY_VERIFY_MESSAGE_PARA = record
cbSize          : DWORD;
dwMsgEncodingType : DWORD;
hCryptProv      : t_HCRYPTPROV;
  end record;
  CRYPT_KEY_VERIFY_MESSAGE_PARA = _CRYPT_KEY_VERIFY_MESSAGE_PARA;
  PCRYPT_KEY_VERIFY_MESSAGE_PARA = ^_CRYPT_KEY_VERIFY_MESSAGE_PARA;

-- +-------------------------------------------------------------------------
--  Sign the message.
-- 
--  If fDetachedSignature is TRUE, the "to be signed" content isn't included
--  in the encoded signed blob.
-- --------------------------------------------------------------------------
type
t_229=^array of BYTE for machine_pointer use true;

t_230=array of DWORD;

procedure CryptSignMessage(
    pSignPara       : in PCRYPT_SIGN_MESSAGE_PARA; 
    fDetachedSignature : in BOOL; 
    cToBeSigned     : in DWORD; 
    rgpbToBeSigned  : in t_229; 
    rgcbToBeSigned  : in t_230; 
    pbSignedBlob    : out BYTE; 
    pcbSignedBlob   : in out DWORD)
                      return BOOL;
#pragma convention(CryptSignMessage,system);
#pragma import(CryptSignMessage,'CryptSignMessage','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify a signed message.
-- 
--  If pbDecoded == NULL, then, *pcbDecoded is implicitly set to 0 on input.
--  For *pcbDecoded == 0 && ppSignerCert == NULL on input, the signer isn't
--  verified.
-- 
--  A message might have more than one signer. Set dwSignerIndex to iterate
--  through all the signers. dwSignerIndex == 0 selects the first signer.
-- 
--  pVerifyPara's pfnGetSignerCertificate is called to get the signer's
--  certificate.
-- 
--  For a verified signer and message, *ppSignerCert is updated
--  with the CertContext of the signer. It must be freed by calling
--  CertFreeCertificateContext. Otherwise, *ppSignerCert is set to NULL.
-- 
--  ppSignerCert can be NULL, indicating the caller isn't interested
--  in getting the CertContext of the signer.
-- 
--  pcbDecoded can be NULL, indicating the caller isn't interested in getting
--  the decoded content. Furthermore, if the message doesn't contain any
--  content or signers, then, pcbDecoded must be set to NULL, to allow the
--  pVerifyPara->pfnGetCertificate to be called. Normally, this would be
--  the case when the signed message contains only certficates and CRLs.
--  If pcbDecoded is NULL and the message doesn't have the indicated signer,
--  pfnGetCertificate is called with pSignerId set to NULL.
-- 
--  If the message doesn't contain any signers || dwSignerIndex > message's
--  SignerCount, then, an error is returned with LastError set to
--  CRYPT_E_NO_SIGNER. Also, for CRYPT_E_NO_SIGNER, pfnGetSignerCertificate
--  is still called with pSignerId set to NULL.
-- 
--  Note, an alternative way to get the certificates and CRLs from a
--  signed message is to call CryptGetMessageCertificates.
-- --------------------------------------------------------------------------
type
t_231=^BYTE for machine_pointer use true;

procedure CryptVerifyMessageSignature(
    pVerifyPara     : in PCRYPT_VERIFY_MESSAGE_PARA; 
    dwSignerIndex   : in DWORD; 
    pbSignedBlob    : in t_231; 
    cbSignedBlob    : in DWORD; 
    pbDecoded       : out {out optional} BYTE; 
    pcbDecoded      : in out {out optional} DWORD; 
    ppSignerCert    : out {out optional} PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CryptVerifyMessageSignature,system);
#pragma import(CryptVerifyMessageSignature,'CryptVerifyMessageSignature','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Returns the count of signers in the signed message. For no signers, returns
--  0. For an error returns -1 with LastError updated accordingly.
-- --------------------------------------------------------------------------
type
t_232=^BYTE for machine_pointer use true;

procedure CryptGetMessageSignerCount(
    dwMsgEncodingType : in DWORD; 
    pbSignedBlob    : in t_232; 
    cbSignedBlob    : in DWORD)
                      return LONG;
#pragma convention(CryptGetMessageSignerCount,system);
#pragma import(CryptGetMessageSignerCount,'CryptGetMessageSignerCount','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Returns the cert store containing the message's certs and CRLs.
--  For an error, returns NULL with LastError updated.
-- --------------------------------------------------------------------------
--  passed to CertOpenStore
--  passed to CertOpenStore
type
t_233=^BYTE for machine_pointer use true;

procedure CryptGetMessageCertificates(
    dwMsgAndCertEncodingType : in DWORD; 
    hCryptProv      : in t_HCRYPTPROV; 
    dwFlags         : in DWORD; 
    pbSignedBlob    : in t_233; 
    cbSignedBlob    : in DWORD)
                      return t_HCERTSTORE;
#pragma convention(CryptGetMessageCertificates,system);
#pragma import(CryptGetMessageCertificates,'CryptGetMessageCertificates','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify a signed message containing detached signature(s).
--  The "to be signed" content is passed in separately. No
--  decoded output. Otherwise, identical to CryptVerifyMessageSignature.
-- --------------------------------------------------------------------------
type
t_234=^BYTE for machine_pointer use true;

t_235=^array of BYTE for machine_pointer use true;

t_236=array of DWORD;

procedure CryptVerifyDetachedMessageSignature(
    pVerifyPara     : in PCRYPT_VERIFY_MESSAGE_PARA; 
    dwSignerIndex   : in DWORD; 
    pbDetachedSignBlob : in t_234; 
    cbDetachedSignBlob : in DWORD; 
    cToBeSigned     : in DWORD; 
    rgpbToBeSigned  : in t_235; 
    rgcbToBeSigned  : in t_236; 
    ppSignerCert    : out {out optional} PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CryptVerifyDetachedMessageSignature,system);
#pragma import(CryptVerifyDetachedMessageSignature,'CryptVerifyDetachedMessageSignature','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Encrypts the message for the recipient(s).
-- --------------------------------------------------------------------------
type
t_237=array of PCCERT_CONTEXT;

t_238=^BYTE for machine_pointer use true;

procedure CryptEncryptMessage(
    pEncryptPara    : in PCRYPT_ENCRYPT_MESSAGE_PARA; 
    cRecipientCert  : in DWORD; 
    rgpRecipientCert : in t_237; 
    pbToBeEncrypted : in t_238; 
    cbToBeEncrypted : in DWORD; 
    pbEncryptedBlob : out BYTE; 
    pcbEncryptedBlob : in out DWORD)
                      return BOOL;
#pragma convention(CryptEncryptMessage,system);
#pragma import(CryptEncryptMessage,'CryptEncryptMessage','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Decrypts the message.
-- 
--  If pbDecrypted == NULL, then, *pcbDecrypted is implicitly set to 0 on input.
--  For *pcbDecrypted == 0 && ppXchgCert == NULL on input, the message isn't
--  decrypted.
-- 
--  For a successfully decrypted message, *ppXchgCert is updated
--  with the CertContext used to decrypt. It must be freed by calling
--  CertStoreFreeCert. Otherwise, *ppXchgCert is set to NULL.
-- 
--  ppXchgCert can be NULL, indicating the caller isn't interested
--  in getting the CertContext used to decrypt.
-- --------------------------------------------------------------------------
type
t_239=^BYTE for machine_pointer use true;

procedure CryptDecryptMessage(
    pDecryptPara    : in PCRYPT_DECRYPT_MESSAGE_PARA; 
    pbEncryptedBlob : in t_239; 
    cbEncryptedBlob : in DWORD; 
    pbDecrypted     : out {out optional} BYTE; 
    pcbDecrypted    : in out {out optional} DWORD; 
    ppXchgCert      : out {out optional} PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CryptDecryptMessage,system);
#pragma import(CryptDecryptMessage,'CryptDecryptMessage','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Sign the message and encrypt for the recipient(s). Does a CryptSignMessage
--  followed with a CryptEncryptMessage.
-- 
--  Note: this isn't the CMSG_SIGNED_AND_ENVELOPED. Its a CMSG_SIGNED
--  inside of an CMSG_ENVELOPED.
-- --------------------------------------------------------------------------
type
t_240=array of PCCERT_CONTEXT;

t_241=^BYTE for machine_pointer use true;

procedure CryptSignAndEncryptMessage(
    pSignPara       : in PCRYPT_SIGN_MESSAGE_PARA; 
    pEncryptPara    : in PCRYPT_ENCRYPT_MESSAGE_PARA; 
    cRecipientCert  : in DWORD; 
    rgpRecipientCert : in t_240; 
    pbToBeSignedAndEncrypted : in t_241; 
    cbToBeSignedAndEncrypted : in DWORD; 
    pbSignedAndEncryptedBlob : out BYTE; 
    pcbSignedAndEncryptedBlob : in out DWORD)
                      return BOOL;
#pragma convention(CryptSignAndEncryptMessage,system);
#pragma import(CryptSignAndEncryptMessage,'CryptSignAndEncryptMessage','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Decrypts the message and verifies the signer. Does a CryptDecryptMessage
--  followed with a CryptVerifyMessageSignature.
-- 
--  If pbDecrypted == NULL, then, *pcbDecrypted is implicitly set to 0 on input.
--  For *pcbDecrypted == 0 && ppSignerCert == NULL on input, the signer isn't
--  verified.
-- 
--  A message might have more than one signer. Set dwSignerIndex to iterate
--  through all the signers. dwSignerIndex == 0 selects the first signer.
-- 
--  The pVerifyPara's VerifySignerPolicy is called to verify the signer's
--  certificate.
-- 
--  For a successfully decrypted and verified message, *ppXchgCert and
--  *ppSignerCert are updated. They must be freed by calling
--  CertStoreFreeCert. Otherwise, they are set to NULL.
-- 
--  ppXchgCert and/or ppSignerCert can be NULL, indicating the
--  caller isn't interested in getting the CertContext.
-- 
--  Note: this isn't the CMSG_SIGNED_AND_ENVELOPED. Its a CMSG_SIGNED
--  inside of an CMSG_ENVELOPED.
-- 
--  The message always needs to be decrypted to allow access to the
--  signed message. Therefore, if ppXchgCert != NULL, its always updated.
-- --------------------------------------------------------------------------
type
t_242=^BYTE for machine_pointer use true;

procedure CryptDecryptAndVerifyMessageSignature(
    pDecryptPara    : in PCRYPT_DECRYPT_MESSAGE_PARA; 
    pVerifyPara     : in PCRYPT_VERIFY_MESSAGE_PARA; 
    dwSignerIndex   : in DWORD; 
    pbEncryptedBlob : in t_242; 
    cbEncryptedBlob : in DWORD; 
    pbDecrypted     : out {out optional} BYTE; 
    pcbDecrypted    : in out {out optional} DWORD; 
    ppXchgCert      : out {out optional} PCCERT_CONTEXT; 
    ppSignerCert    : out {out optional} PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CryptDecryptAndVerifyMessageSignature,system);
#pragma import(CryptDecryptAndVerifyMessageSignature,'CryptDecryptAndVerifyMessageSignature','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Decodes a cryptographic message which may be one of the following types:
--  CMSG_DATA
--  CMSG_SIGNED
--  CMSG_ENVELOPED
--  CMSG_SIGNED_AND_ENVELOPED
--  CMSG_HASHED
-- 
--  dwMsgTypeFlags specifies the set of allowable messages. For example, to
--  decode either SIGNED or ENVELOPED messages, set dwMsgTypeFlags to:
--  CMSG_SIGNED_FLAG | CMSG_ENVELOPED_FLAG.
-- 
--  dwProvInnerContentType is only applicable when processing nested
--  crytographic messages. When processing an outer crytographic message
--  it must be set to 0. When decoding a nested cryptographic message
--  its the dwInnerContentType returned by a previous CryptDecodeMessage
--  of the outer message. The InnerContentType can be any of the CMSG types,
--  for example, CMSG_DATA, CMSG_SIGNED, ...
-- 
--  The optional *pdwMsgType is updated with the type of message.
-- 
--  The optional *pdwInnerContentType is updated with the type of the inner
--  message. Unless there is cryptographic message nesting, CMSG_DATA
--  is returned.
-- 
--  For CMSG_DATA: returns decoded content.
--  For CMSG_SIGNED: same as CryptVerifyMessageSignature.
--  For CMSG_ENVELOPED: same as CryptDecryptMessage.
--  For CMSG_SIGNED_AND_ENVELOPED: same as CryptDecryptMessage plus
--  CryptVerifyMessageSignature.
--  For CMSG_HASHED: verifies the hash and returns decoded content.
-- --------------------------------------------------------------------------
type
t_243=^BYTE for machine_pointer use true;

procedure CryptDecodeMessage(
    dwMsgTypeFlags  : in DWORD; 
    pDecryptPara    : in PCRYPT_DECRYPT_MESSAGE_PARA; 
    pVerifyPara     : in PCRYPT_VERIFY_MESSAGE_PARA; 
    dwSignerIndex   : in DWORD; 
    pbEncodedBlob   : in t_243; 
    cbEncodedBlob   : in DWORD; 
    dwPrevInnerContentType : in DWORD; 
    pdwMsgType      : out {out optional} DWORD; 
    pdwInnerContentType : out {out optional} DWORD; 
    pbDecoded       : out {out optional} BYTE; 
    pcbDecoded      : in out {out optional} DWORD; 
    ppXchgCert      : out {out optional} PCCERT_CONTEXT; 
    ppSignerCert    : out {out optional} PCCERT_CONTEXT)
                      return BOOL;
#pragma convention(CryptDecodeMessage,system);
#pragma import(CryptDecodeMessage,'CryptDecodeMessage','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Hash the message.
-- 
--  If fDetachedHash is TRUE, only the ComputedHash is encoded in the
--  pbHashedBlob. Otherwise, both the ToBeHashed and ComputedHash
--  are encoded.
-- 
--  pcbHashedBlob or pcbComputedHash can be NULL, indicating the caller
--  isn't interested in getting the output.
-- --------------------------------------------------------------------------
type
t_244=^array of BYTE for machine_pointer use true;

t_245=array of DWORD;

procedure CryptHashMessage(
    pHashPara       : in PCRYPT_HASH_MESSAGE_PARA; 
    fDetachedHash   : in BOOL; 
    cToBeHashed     : in DWORD; 
    rgpbToBeHashed  : in t_244; 
    rgcbToBeHashed  : in t_245; 
    pbHashedBlob    : out {out optional} BYTE; 
    pcbHashedBlob   : in out {out optional} DWORD; 
    pbComputedHash  : out {out optional} BYTE; 
    pcbComputedHash : in out {out optional} DWORD)
                      return BOOL;
#pragma convention(CryptHashMessage,system);
#pragma import(CryptHashMessage,'CryptHashMessage','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify a hashed message.
-- 
--  pcbToBeHashed or pcbComputedHash can be NULL,
--  indicating the caller isn't interested in getting the output.
-- --------------------------------------------------------------------------
type
t_246=^BYTE for machine_pointer use true;

procedure CryptVerifyMessageHash(
    pHashPara       : in PCRYPT_HASH_MESSAGE_PARA; 
    pbHashedBlob    : in t_246; 
    cbHashedBlob    : in DWORD; 
    pbToBeHashed    : out {out optional} BYTE; 
    pcbToBeHashed   : in out {out optional} DWORD; 
    pbComputedHash  : out {out optional} BYTE; 
    pcbComputedHash : in out {out optional} DWORD)
                      return BOOL;
#pragma convention(CryptVerifyMessageHash,system);
#pragma import(CryptVerifyMessageHash,'CryptVerifyMessageHash','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify a hashed message containing a detached hash.
--  The "to be hashed" content is passed in separately. No
--  decoded output. Otherwise, identical to CryptVerifyMessageHash.
-- 
--  pcbComputedHash can be NULL, indicating the caller isn't interested
--  in getting the output.
-- --------------------------------------------------------------------------
type
t_247=^BYTE for machine_pointer use true;

t_248=^array of BYTE for machine_pointer use true;

t_249=array of DWORD;

procedure CryptVerifyDetachedMessageHash(
    pHashPara       : in PCRYPT_HASH_MESSAGE_PARA; 
    pbDetachedHashBlob : in t_247; 
    cbDetachedHashBlob : in DWORD; 
    cToBeHashed     : in DWORD; 
    rgpbToBeHashed  : in t_248; 
    rgcbToBeHashed  : in t_249; 
    pbComputedHash  : out {out optional} BYTE; 
    pcbComputedHash : in out {out optional} DWORD)
                      return BOOL;
#pragma convention(CryptVerifyDetachedMessageHash,system);
#pragma import(CryptVerifyDetachedMessageHash,'CryptVerifyDetachedMessageHash','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Sign the message using the provider's private key specified in the
--  parameters. A dummy SignerId is created and stored in the message.
-- 
--  Normally used until a certificate has been created for the key.
-- --------------------------------------------------------------------------
type
t_250=^BYTE for machine_pointer use true;

procedure CryptSignMessageWithKey(
    pSignPara       : in PCRYPT_KEY_SIGN_MESSAGE_PARA; 
    pbToBeSigned    : in t_250; 
    cbToBeSigned    : in DWORD; 
    pbSignedBlob    : out BYTE; 
    pcbSignedBlob   : in out DWORD)
                      return BOOL;
#pragma convention(CryptSignMessageWithKey,system);
#pragma import(CryptSignMessageWithKey,'CryptSignMessageWithKey','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Verify a signed message using the specified public key info.
-- 
--  Normally called by a CA until it has created a certificate for the
--  key.
-- 
--  pPublicKeyInfo contains the public key to use to verify the signed
--  message. If NULL, the signature isn't verified (for instance, the decoded
--  content may contain the PublicKeyInfo).
-- 
--  pcbDecoded can be NULL, indicating the caller isn't interested
--  in getting the decoded content.
-- --------------------------------------------------------------------------
type
t_251=^BYTE for machine_pointer use true;

procedure CryptVerifyMessageSignatureWithKey(
    pVerifyPara     : in PCRYPT_KEY_VERIFY_MESSAGE_PARA; 
    pPublicKeyInfo  : in {out optional} PCERT_PUBLIC_KEY_INFO; 
    pbSignedBlob    : in t_251; 
    cbSignedBlob    : in DWORD; 
    pbDecoded       : out {out optional} BYTE; 
    pcbDecoded      : in out {out optional} DWORD)
                      return BOOL;
#pragma convention(CryptVerifyMessageSignatureWithKey,system);
#pragma import(CryptVerifyMessageSignatureWithKey,'CryptVerifyMessageSignatureWithKey','crypt32.dll');

-- +=========================================================================
--  System Certificate Store Data Structures and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  Get a system certificate store based on a subsystem protocol.
-- 
--  Current examples of subsystems protocols are:
--  "MY" Cert Store hold certs with associated Private Keys
--  "CA" Certifying Authority certs
--  "ROOT" Root Certs
--  "SPC" Software publisher certs
-- 
-- 
--  If hProv is NULL the default provider "1" is opened for you.
--  When the store is closed the provider is release. Otherwise
--  if hProv is not NULL, no provider is created or released.
-- 
--  The returned Cert Store can be searched for an appropriate Cert
--  using the Cert Store API's (see certstor.h)
-- 
--  When done, the cert store should be closed using CertStoreClose
-- --------------------------------------------------------------------------
procedure CertOpenSystemStoreA(
    hProv           : t_HCRYPTPROV; 
    szSubsystemProtocol : LPCSTR)
                      return t_HCERTSTORE;
#pragma convention(CertOpenSystemStoreA,system);
#pragma import(CertOpenSystemStoreA,'CertOpenSystemStoreA','crypt32.dll');

procedure CertOpenSystemStoreW(
    hProv           : t_HCRYPTPROV; 
    szSubsystemProtocol : LPCWSTR)
                      return t_HCERTSTORE;
#pragma convention(CertOpenSystemStoreW,system);
#pragma import(CertOpenSystemStoreW,'CertOpenSystemStoreW','crypt32.dll');

#if #declared UNICODE; then;
#template CertOpenSystemStore;
  CertOpenSystemStoreW 
#end CertOpenSystemStore;
#else;
#template CertOpenSystemStore;
  CertOpenSystemStoreA 
#end CertOpenSystemStore;
#end if;

type
t_252=^BYTE for machine_pointer use true;

procedure CertAddEncodedCertificateToSystemStoreA(
    szCertStoreName : LPCSTR; 
    pbCertEncoded   : in t_252; 
    cbCertEncoded   : DWORD)
                      return BOOL;
#pragma convention(CertAddEncodedCertificateToSystemStoreA,system);
#pragma import(CertAddEncodedCertificateToSystemStoreA,'CertAddEncodedCertificateToSystemStoreA','crypt32.dll');

type
t_253=^BYTE for machine_pointer use true;

procedure CertAddEncodedCertificateToSystemStoreW(
    szCertStoreName : LPCWSTR; 
    pbCertEncoded   : in t_253; 
    cbCertEncoded   : DWORD)
                      return BOOL;
#pragma convention(CertAddEncodedCertificateToSystemStoreW,system);
#pragma import(CertAddEncodedCertificateToSystemStoreW,'CertAddEncodedCertificateToSystemStoreW','crypt32.dll');

#if #declared UNICODE; then;
#template CertAddEncodedCertificateToSystemStore;
  CertAddEncodedCertificateToSystemStoreW 
#end CertAddEncodedCertificateToSystemStore;
#else;
#template CertAddEncodedCertificateToSystemStore;
  CertAddEncodedCertificateToSystemStoreA 
#end CertAddEncodedCertificateToSystemStore;
#end if;

-- +-------------------------------------------------------------------------
--  Find all certificate chains tying the given issuer name to any certificate
--  that the current user has a private key for.
-- 
--  If no certificate chain is found, FALSE is returned with LastError set
--  to CRYPT_E_NOT_FOUND and the counts zeroed.
-- 
--  IE 3.0 ASSUMPTION:
--  The client certificates are in the "My" system store. The issuer
--  cerificates may be in the "Root", "CA" or "My" system stores.
-- --------------------------------------------------------------------------
type
  _CERT_CHAIN       = record
cCerts          : DWORD;
certs           : PCERT_BLOB;
keyLocatorInfo  : CRYPT_KEY_PROV_INFO;
  end record;
  CERT_CHAIN        = _CERT_CHAIN;
  PCERT_CHAIN       = ^_CERT_CHAIN;

--  WINCRYPT32API This is not exported by crypt32, it is exported by softpub
--  count of certificates chains returned
type
t_254=^BYTE for machine_pointer use true;

--  DER encoded issuer name
--  count in bytes of encoded issuer name
--  "ClientAuth" or "CodeSigning"
--  only return signers supporting this
--  keyspec
procedure FindCertsByIssuer(
    pCertChains     : out _CERT_CHAIN; 
    pcbCertChains   : in out DWORD; 
    pcCertChains    : out DWORD; 
    pbEncodedIssuerName : in t_254; 
    cbEncodedIssuerName : in DWORD; 
    pwszPurpose     : in LPCWSTR; 
    dwKeySpec       : in DWORD)
                      return HRESULT;
#pragma convention(FindCertsByIssuer,system);
#pragma import(FindCertsByIssuer,'FindCertsByIssuer','wintrust.dll');

-- -------------------------------------------------------------------------
-- 
--  CryptQueryObject takes a CERT_BLOB or a file name and returns the
--  information about the content in the blob or in the file.
-- 
--  Parameters:
--  INPUT dwObjectType:
--  Indicate the type of the object. Should be one of the
--  following:
--  CERT_QUERY_OBJECT_FILE
--  CERT_QUERY_OBJECT_BLOB
-- 
--  INPUT pvObject:
--  If dwObjectType == CERT_QUERY_OBJECT_FILE, it is a
--  LPWSTR, that is, the pointer to a wchar file name
--  if dwObjectType == CERT_QUERY_OBJECT_BLOB, it is a
--  PCERT_BLOB, that is, a pointer to a CERT_BLOB
-- 
--  INPUT dwExpectedContentTypeFlags:
--  Indicate the expected contenet type.
--  Can be one of the following:
--  CERT_QUERY_CONTENT_FLAG_ALL (the content can be any type)
--  CERT_QUERY_CONTENT_FLAG_CERT
--  CERT_QUERY_CONTENT_FLAG_CTL
--  CERT_QUERY_CONTENT_FLAG_CRL
--  CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE
--  CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT
--  CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL
--  CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL
--  CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED
--  CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED
--  CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED
--  CERT_QUERY_CONTENT_FLAG_PKCS10
--  CERT_QUERY_CONTENT_FLAG_PFX
--  CERT_QUERY_CONTENT_FLAG_CERT_PAIR
-- 
--  INPUT dwExpectedFormatTypeFlags:
--  Indicate the expected format type.
--  Can be one of the following:
--  CERT_QUERY_FORMAT_FLAG_ALL (the content can be any format)
--  CERT_QUERY_FORMAT_FLAG_BINARY
--  CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED
--  CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED
-- 
-- 
--  INPUT dwFlags
--  Reserved flag. Should always set to 0
-- 
--  OUTPUT pdwMsgAndCertEncodingType
--  Optional output. If NULL != pdwMsgAndCertEncodingType,
--  it contains the encoding type of the content as any
--  combination of the following:
--  X509_ASN_ENCODING
--  PKCS_7_ASN_ENCODING
-- 
--  OUTPUT pdwContentType
--  Optional output. If NULL!=pdwContentType, it contains
--  the content type as one of the the following:
--  CERT_QUERY_CONTENT_CERT
--  CERT_QUERY_CONTENT_CTL
--  CERT_QUERY_CONTENT_CRL
--  CERT_QUERY_CONTENT_SERIALIZED_STORE
--  CERT_QUERY_CONTENT_SERIALIZED_CERT
--  CERT_QUERY_CONTENT_SERIALIZED_CTL
--  CERT_QUERY_CONTENT_SERIALIZED_CRL
--  CERT_QUERY_CONTENT_PKCS7_SIGNED
--  CERT_QUERY_CONTENT_PKCS7_UNSIGNED
--  CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
--  CERT_QUERY_CONTENT_PKCS10
--  CERT_QUERY_CONTENT_PFX
--  CERT_QUERY_CONTENT_CERT_PAIR
-- 
--  OUTPUT pdwFormatType
--  Optional output. If NULL !=pdwFormatType, it
--  contains the format type of the content as one of the
--  following:
--  CERT_QUERY_FORMAT_BINARY
--  CERT_QUERY_FORMAT_BASE64_ENCODED
--  CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED
-- 
-- 
--  OUTPUT phCertStore
--  Optional output. If NULL !=phStore,
--  it contains a cert store that includes all of certificates,
--  CRL, and CTL in the object if the object content type is
--  one of the following:
--  CERT_QUERY_CONTENT_CERT
--  CERT_QUERY_CONTENT_CTL
--  CERT_QUERY_CONTENT_CRL
--  CERT_QUERY_CONTENT_SERIALIZED_STORE
--  CERT_QUERY_CONTENT_SERIALIZED_CERT
--  CERT_QUERY_CONTENT_SERIALIZED_CTL
--  CERT_QUERY_CONTENT_SERIALIZED_CRL
--  CERT_QUERY_CONTENT_PKCS7_SIGNED
--  CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
--  CERT_QUERY_CONTENT_CERT_PAIR
-- 
--  Caller should free *phCertStore via CertCloseStore.
-- 
-- 
--  OUTPUT phMsg Optional output. If NULL != phMsg,
--  it contains a handle to a opened message if
--  the content type is one of the following:
--  CERT_QUERY_CONTENT_PKCS7_SIGNED
--  CERT_QUERY_CONTENT_PKCS7_UNSIGNED
--  CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
-- 
--  Caller should free *phMsg via CryptMsgClose.
-- 
--  OUTPUT pContext Optional output. If NULL != pContext,
--  it contains either a PCCERT_CONTEXT or PCCRL_CONTEXT,
--  or PCCTL_CONTEXT based on the content type.
-- 
--  If the content type is CERT_QUERY_CONTENT_CERT or
--  CERT_QUERY_CONTENT_SERIALIZED_CERT, it is a PCCERT_CONTEXT;
--  Caller should free the pContext via CertFreeCertificateContext.
-- 
--  If the content type is CERT_QUERY_CONTENT_CRL or
--  CERT_QUERY_CONTENT_SERIALIZED_CRL, it is a PCCRL_CONTEXT;
--  Caller should free the pContext via CertFreeCRLContext.
-- 
--  If the content type is CERT_QUERY_CONTENT_CTL or
--  CERT_QUERY_CONTENT_SERIALIZED_CTL, it is a PCCTL_CONTEXT;
--  Caller should free the pContext via CertFreeCTLContext.
-- 
--  If the *pbObject is of type CERT_QUERY_CONTENT_PKCS10 or CERT_QUERY_CONTENT_PFX, CryptQueryObject
--  will not return anything in *phCertstore, *phMsg, or *ppvContext.
-- --------------------------------------------------------------------------
type
t_255=^unchecked for machine_pointer use true;

t_256=^DWORD for machine_pointer use true;

t_257=^DWORD for machine_pointer use true;

t_258=^DWORD for machine_pointer use true;

t_259=^t_HCERTSTORE for machine_pointer use true;

t_260=^t_HCRYPTMSG for machine_pointer use true;

t_261=^^unchecked for machine_pointer use true;

procedure CryptQueryObject(
    dwObjectType    : DWORD; 
    pvObject        : in t_255; 
    dwExpectedContentTypeFlags : DWORD; 
    dwExpectedFormatTypeFlags : DWORD; 
    dwFlags         : DWORD; 
    pdwMsgAndCertEncodingType : t_256; 
    pdwContentType  : t_257; 
    pdwFormatType   : t_258; 
    phCertStore     : t_259; 
    phMsg           : t_260; 
    ppvContext      : in t_261)
                      return BOOL;
#pragma convention(CryptQueryObject,system);
#pragma import(CryptQueryObject,'CryptQueryObject','crypt32.dll');

-- -------------------------------------------------------------------------
-- dwObjectType for CryptQueryObject
-- -------------------------------------------------------------------------
const
  CERT_QUERY_OBJECT_FILE= $01;

const
  CERT_QUERY_OBJECT_BLOB= $02;

-- -------------------------------------------------------------------------
-- dwContentType for CryptQueryObject
-- -------------------------------------------------------------------------
-- encoded single certificate
const
  CERT_QUERY_CONTENT_CERT= 1;

-- encoded single CTL
const
  CERT_QUERY_CONTENT_CTL= 2;

-- encoded single CRL
const
  CERT_QUERY_CONTENT_CRL= 3;

-- serialized store
const
  CERT_QUERY_CONTENT_SERIALIZED_STORE= 4;

-- serialized single certificate
const
  CERT_QUERY_CONTENT_SERIALIZED_CERT= 5;

-- serialized single CTL
const
  CERT_QUERY_CONTENT_SERIALIZED_CTL= 6;

-- serialized single CRL
const
  CERT_QUERY_CONTENT_SERIALIZED_CRL= 7;

-- a PKCS#7 signed message
const
  CERT_QUERY_CONTENT_PKCS7_SIGNED= 8;

-- a PKCS#7 message, such as enveloped message. But it is not a signed message,
const
  CERT_QUERY_CONTENT_PKCS7_UNSIGNED= 9;

-- a PKCS7 signed message embedded in a file
const
  CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED= 10;

-- an encoded PKCS#10
const
  CERT_QUERY_CONTENT_PKCS10= 11;

-- an encoded PKX BLOB
const
  CERT_QUERY_CONTENT_PFX= 12;

-- an encoded CertificatePair (contains forward and/or reverse cross certs)
const
  CERT_QUERY_CONTENT_CERT_PAIR= 13;

-- -------------------------------------------------------------------------
-- dwExpectedConentTypeFlags for CryptQueryObject
-- -------------------------------------------------------------------------
-- encoded single certificate
-- encoded single CTL
-- encoded single CRL
-- serialized store
-- serialized single certificate
-- serialized single CTL
-- serialized single CRL
-- an encoded PKCS#7 signed message
-- an encoded PKCS#7 message. But it is not a signed message
-- the content includes an embedded PKCS7 signed message
-- an encoded PKCS#10
-- an encoded PFX BLOB
-- an encoded CertificatePair (contains forward and/or reverse cross certs)
-- content can be any type
-- -------------------------------------------------------------------------
-- dwFormatType for CryptQueryObject
-- -------------------------------------------------------------------------
-- the content is in binary format
const
  CERT_QUERY_FORMAT_BINARY= 1;

-- the content is base64 encoded
const
  CERT_QUERY_FORMAT_BASE64_ENCODED= 2;

-- the content is ascii hex encoded with "{ASN}" prefix
const
  CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED= 3;

-- -------------------------------------------------------------------------
-- dwExpectedFormatTypeFlags for CryptQueryObject
-- -------------------------------------------------------------------------
-- the content is in binary format
-- the content is base64 encoded
-- the content is ascii hex encoded with "{ASN}" prefix
-- the content can be of any format
-- 
--  Crypt32 Memory Management Routines. All Crypt32 API which return allocated
--  buffers will do so via CryptMemAlloc, CryptMemRealloc. Clients can free
--  those buffers using CryptMemFree. Also included is CryptMemSize
-- 
procedure CryptMemAlloc(
    cbSize          : in ULONG)
                      return LPVOID;
#pragma convention(CryptMemAlloc,system);
#pragma import(CryptMemAlloc,'CryptMemAlloc','crypt32.dll');

procedure CryptMemRealloc(
    pv              : in LPVOID; 
    cbSize          : in ULONG)
                      return LPVOID;
#pragma convention(CryptMemRealloc,system);
#pragma import(CryptMemRealloc,'CryptMemRealloc','crypt32.dll');

procedure CryptMemFree(
    pv              : in LPVOID);
#pragma convention(CryptMemFree,system);
#pragma import(CryptMemFree,'CryptMemFree','crypt32.dll');

-- 
--  Crypt32 Asynchronous Parameter Management Routines. All Crypt32 API which
--  expose asynchronous mode operation use a Crypt32 Async Handle to pass
--  around information about the operation e.g. callback routines. The
--  following API are used for manipulation of the async handle
-- 
type
HCRYPTASYNC       = t_HANDLE;
PHCRYPTASYNC      = ^t_HANDLE for machine_pointer use true;
type
PFN_CRYPT_ASYNC_PARAM_FREE_FUNC = ^procedure (
    pszParamOid     : LPSTR;
    pvParam         : LPVOID) for machine_pointer use true;
procedure CryptCreateAsyncHandle(
    dwFlags         : in DWORD; 
    phAsync         : out t_HANDLE )
                      return BOOL;
#pragma convention(CryptCreateAsyncHandle,system);
#pragma import(CryptCreateAsyncHandle,'CryptCreateAsyncHandle','crypt32.dll');

procedure CryptSetAsyncParam(
    hAsync          : in HCRYPTASYNC; 
    pszParamOid     : in LPSTR; 
    pvParam         : in LPVOID; 
    pfnFree         : in {out optional} PFN_CRYPT_ASYNC_PARAM_FREE_FUNC)
                      return BOOL;
#pragma convention(CryptSetAsyncParam,system);
#pragma import(CryptSetAsyncParam,'CryptSetAsyncParam','crypt32.dll');

procedure CryptGetAsyncParam(
    hAsync          : in HCRYPTASYNC; 
    pszParamOid     : in LPSTR; 
    ppvParam        : out LPVOID; 
    ppfnFree        : out {out optional} PFN_CRYPT_ASYNC_PARAM_FREE_FUNC)
                      return BOOL;
#pragma convention(CryptGetAsyncParam,system);
#pragma import(CryptGetAsyncParam,'CryptGetAsyncParam','crypt32.dll');

procedure CryptCloseAsyncHandle(
    hAsync          : in HCRYPTASYNC)
                      return BOOL;
#pragma convention(CryptCloseAsyncHandle,system);
#pragma import(CryptCloseAsyncHandle,'CryptCloseAsyncHandle','crypt32.dll');

-- 
--  Crypt32 Remote Object Retrieval Routines. This API allows retrieval of
--  remote PKI objects where the location is given by an URL. The remote
--  object retrieval manager exposes two provider models. One is the "Scheme
--  Provider" model which allows for installable protocol providers as defined
--  by the URL scheme e.g. ldap, http, ftp. The scheme provider entry point is
--  the same as the CryptRetrieveObjectByUrl however the *ppvObject returned
--  is ALWAYS a counted array of encoded bits (one per object retrieved). The
--  second provider model is the "Context Provider" model which allows for
--  installable creators of CAPI2 context handles (objects) based on the
--  retrieved encoded bits. These are dispatched based on the object OID given
--  in the call to CryptRetrieveObjectByUrl.
-- 
type
  _CRYPT_BLOB_ARRAY = record
cBlob           : DWORD;
rgBlob          : PCRYPT_DATA_BLOB;
  end record;
  CRYPT_BLOB_ARRAY  = _CRYPT_BLOB_ARRAY;
  PCRYPT_BLOB_ARRAY = ^_CRYPT_BLOB_ARRAY;

type
  _CRYPT_CREDENTIALS = record
cbSize          : DWORD;
pszCredentialsOid : LPCSTR;
pvCredentials   : LPVOID;
  end record;
  CRYPT_CREDENTIALS = _CRYPT_CREDENTIALS;
  PCRYPT_CREDENTIALS = ^_CRYPT_CREDENTIALS;

#if #declared UNICODE; then;
#template CREDENTIAL_OID_PASSWORD_CREDENTIALS;
  ( ( LPCSTR ) 2 ) 
#end CREDENTIAL_OID_PASSWORD_CREDENTIALS;
#else;
#template CREDENTIAL_OID_PASSWORD_CREDENTIALS;
  ( ( LPCSTR ) 1 ) 
#end CREDENTIAL_OID_PASSWORD_CREDENTIALS;
#end if;

type
  _CRYPT_PASSWORD_CREDENTIALSA = record
cbSize          : DWORD;
pszUsername     : LPSTR;
pszPassword     : LPSTR;
  end record;
  CRYPT_PASSWORD_CREDENTIALSA = _CRYPT_PASSWORD_CREDENTIALSA;
  PCRYPT_PASSWORD_CREDENTIALSA = ^_CRYPT_PASSWORD_CREDENTIALSA;

type
  _CRYPT_PASSWORD_CREDENTIALSW = record
cbSize          : DWORD;
pszUsername     : LPWSTR;
pszPassword     : LPWSTR;
  end record;
  CRYPT_PASSWORD_CREDENTIALSW = _CRYPT_PASSWORD_CREDENTIALSW;
  PCRYPT_PASSWORD_CREDENTIALSW = ^_CRYPT_PASSWORD_CREDENTIALSW;

#if #declared UNICODE; then;
type
CRYPT_PASSWORD_CREDENTIALS = CRYPT_PASSWORD_CREDENTIALSW;
type
PCRYPT_PASSWORD_CREDENTIALS = PCRYPT_PASSWORD_CREDENTIALSW;
#else;
type
CRYPT_PASSWORD_CREDENTIALS = CRYPT_PASSWORD_CREDENTIALSA;
type
PCRYPT_PASSWORD_CREDENTIALS = PCRYPT_PASSWORD_CREDENTIALSA;
#end if;

-- 
--  Scheme Provider Signatures
-- 
--  The following is obsolete and has been replaced with the following
--  definition
--  2-8-02 Server 2003 changed to use UNICODE Url strings instead of multibyte
type
PFN_FREE_ENCODED_OBJECT_FUNC = ^procedure (
    pszObjectOid    : LPCSTR;
    pObject         : PCRYPT_BLOB_ARRAY;
    pvFreeContext   : LPVOID) for machine_pointer use true;
-- 
--  SchemeDllRetrieveEncodedObject was replaced in Server 2003 with
--  the following. (Changed to use UNICODE Url Strings.)
-- 
-- 
--  SchemeDllRetrieveEncodedObjectW has the following signature:
-- 
--  BOOL WINAPI SchemeDllRetrieveEncodedObjectW (
--  IN LPCWSTR pwszUrl,
--  IN LPCSTR pszObjectOid,
--  IN DWORD dwRetrievalFlags,
--  IN DWORD dwTimeout, // milliseconds
--  OUT PCRYPT_BLOB_ARRAY pObject,
--  OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
--  OUT LPVOID* ppvFreeContext,
--  IN HCRYPTASYNC hAsyncRetrieve,
--  IN PCRYPT_CREDENTIALS pCredentials,
--  IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
--  )
-- 
-- 
--  Context Provider Signatures
-- 
-- 
--  ContextDllCreateObjectContext has the following signature:
-- 
--  BOOL WINAPI ContextDllCreateObjectContext (
--  IN LPCSTR pszObjectOid,
--  IN DWORD dwRetrievalFlags,
--  IN PCRYPT_BLOB_ARRAY pObject,
--  OUT LPVOID* ppvContext
--  )
-- 
-- 
--  Remote Object Retrieval API
-- 
-- 
--  Retrieval flags
-- 
const
  CRYPT_RETRIEVE_MULTIPLE_OBJECTS= $01;

const
  CRYPT_CACHE_ONLY_RETRIEVAL= $02;

const
  CRYPT_WIRE_ONLY_RETRIEVAL= $04;

const
  CRYPT_DONT_CACHE_RESULT= $08;

const
  CRYPT_ASYNC_RETRIEVAL= $10;

const
  CRYPT_STICKY_CACHE_RETRIEVAL= $1000;

const
  CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL= $2000;

const
  CRYPT_OFFLINE_CHECK_RETRIEVAL= $4000;

--  When the following flag is set, the following 2 NULL terminated ascii
--  strings are inserted at the beginning of each returned blob:
--  "%d\0%s\0", dwEntryIndex, pszAttribute
-- 
--  The first dwEntryIndex is 0, "0\0". 
-- 
--  When set, pszObjectOid must be NULL, so that a PCRYPT_BLOB_ARRAY is returned.
const
  CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE= $8000;

--  Set this flag to digitally sign all of the ldap traffic to and from a
--  Windows 2000 LDAP server using the Kerberos authentication protocol.
--  This feature provides integrity required by some applications. 
const
  CRYPT_LDAP_SIGN_RETRIEVAL= $10000;

--  Set this flag to inhibit automatic authentication handling. See the
--  wininet flag, INTERNET_FLAG_NO_AUTH, for more details.
const
  CRYPT_NO_AUTH_RETRIEVAL= $20000;

--  Performs an A-Record only DNS lookup on the supplied host string.
--  This prevents bogus DNS queries from being generated when resolving host
--  names. Use this flag whenever passing a hostname as opposed to a
--  domain name for the hostname parameter. 
-- 
--  See LDAP_OPT_AREC_EXCLUSIVE defined in winldap.h for more details.
const
  CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL= $40000;

--  Apply AIA URL restrictions, such as, validate retrieved content before
--  writing to cache.
const
  CRYPT_AIA_RETRIEVAL= $80000;

-- 
--  Data verification retrieval flags
-- 
--  CRYPT_VERIFY_CONTEXT_SIGNATURE is used to get signature verification
--  on the context created. In this case pszObjectOid must be non-NULL and
--  pvVerify points to the signer certificate context
-- 
--  CRYPT_VERIFY_DATA_HASH is used to get verification of the blob data
--  retrieved by the protocol. The pvVerify points to an URL_DATA_HASH
--  structure (TBD)
-- 
const
  CRYPT_VERIFY_CONTEXT_SIGNATURE= $20;

const
  CRYPT_VERIFY_DATA_HASH= $40;

-- 
--  Time Valid Object flags
-- 
const
  CRYPT_KEEP_TIME_VALID= $80;

const
  CRYPT_DONT_VERIFY_SIGNATURE= $0100;

const
  CRYPT_DONT_CHECK_TIME_VALIDITY= $0200;

--  The default checks if ftNextUpdate >= ftValidFor. Set this flag to
--  check if ftThisUpdate >= ftValidFor.
const
  CRYPT_CHECK_FRESHNESS_TIME_VALIDITY= $0400;

const
  CRYPT_ACCUMULATIVE_TIMEOUT= $0800;

type
  _CRYPT_RETRIEVE_AUX_INFO = record
cbSize          : DWORD;
pLastSyncTime   : ^t_FILETIME;
dwMaxUrlRetrievalByteCount : DWORD;
  end record;
  CRYPT_RETRIEVE_AUX_INFO = _CRYPT_RETRIEVE_AUX_INFO;
  PCRYPT_RETRIEVE_AUX_INFO = ^_CRYPT_RETRIEVE_AUX_INFO;

--  milliseconds
procedure CryptRetrieveObjectByUrlA(
    pszUrl          : in LPCSTR; 
    pszObjectOid    : in LPCSTR; 
    dwRetrievalFlags : in DWORD; 
    dwTimeout       : in DWORD; 
    ppvObject       : out LPVOID; 
    hAsyncRetrieve  : in HCRYPTASYNC; 
    pCredentials    : in {out optional} PCRYPT_CREDENTIALS; 
    pvVerify        : in {out optional} LPVOID; 
    pAuxInfo        : in {out optional} PCRYPT_RETRIEVE_AUX_INFO)
                      return BOOL;
#pragma convention(CryptRetrieveObjectByUrlA,system);
#pragma import(CryptRetrieveObjectByUrlA,'CryptRetrieveObjectByUrlA','cryptnet.dll');

--  milliseconds
procedure CryptRetrieveObjectByUrlW(
    pszUrl          : in LPCWSTR; 
    pszObjectOid    : in LPCSTR; 
    dwRetrievalFlags : in DWORD; 
    dwTimeout       : in DWORD; 
    ppvObject       : out LPVOID; 
    hAsyncRetrieve  : in HCRYPTASYNC; 
    pCredentials    : in {out optional} PCRYPT_CREDENTIALS; 
    pvVerify        : in {out optional} LPVOID; 
    pAuxInfo        : in {out optional} PCRYPT_RETRIEVE_AUX_INFO)
                      return BOOL;
#pragma convention(CryptRetrieveObjectByUrlW,system);
#pragma import(CryptRetrieveObjectByUrlW,'CryptRetrieveObjectByUrlW','cryptnet.dll');

#if #declared UNICODE; then;
#template CryptRetrieveObjectByUrl;
  CryptRetrieveObjectByUrlW 
#end CryptRetrieveObjectByUrl;
#else;
#template CryptRetrieveObjectByUrl;
  CryptRetrieveObjectByUrlA 
#end CryptRetrieveObjectByUrl;
#end if;

-- 
--  Call back function to cancel object retrieval
-- 
--  The function can be installed on a per thread basis.
--  If CryptInstallCancelRetrieval is called for multiple times, only the most recent
--  installation will be kept.
-- 
--  This is only effective for http, https, gopher, and ftp protocol.
--  It is ignored by the rest of the protocols.
type
t_262=^unchecked for machine_pointer use true;

PFN_CRYPT_CANCEL_RETRIEVAL = ^procedure (
    dwFlags         : in DWORD;
    pvArg           : in t_262)
                      return BOOL for machine_pointer use true;
-- 
--  PFN_CRYPT_CANCEL_RETRIEVAL
-- 
--  This function should return FALSE when the object retrieval should be continued
--  and return TRUE when the object retrieval should be cancelled.
-- 
type
t_263=^unchecked for machine_pointer use true;

t_264=^unchecked for machine_pointer use true;

procedure CryptInstallCancelRetrieval(
    pfnCancel       : in PFN_CRYPT_CANCEL_RETRIEVAL; 
    pvArg           : in t_263; 
    dwFlags         : in DWORD; 
    pvReserved      : in t_264)
                      return BOOL;
#pragma convention(CryptInstallCancelRetrieval,system);
#pragma import(CryptInstallCancelRetrieval,'CryptInstallCancelRetrieval','cryptnet.dll');

type
t_265=^unchecked for machine_pointer use true;

procedure CryptUninstallCancelRetrieval(
    dwFlags         : in DWORD; 
    pvReserved      : in t_265)
                      return BOOL;
#pragma convention(CryptUninstallCancelRetrieval,system);
#pragma import(CryptUninstallCancelRetrieval,'CryptUninstallCancelRetrieval','cryptnet.dll');

-- 
--  Remote Object Async Retrieval parameters
-- 
-- 
--  A client that wants to be notified of asynchronous object retrieval
--  completion sets this parameter on the async handle
-- 
type
PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC = ^procedure (
    pvCompletion    : in LPVOID;
    dwCompletionCode : in DWORD;
    pszUrl          : in LPCSTR;
    pszObjectOid    : in LPSTR;
    pvObject        : in LPVOID) for machine_pointer use true;
type
  _CRYPT_ASYNC_RETRIEVAL_COMPLETION = record
pfnCompletion   : PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC;
pvCompletion    : LPVOID;
  end record;
  CRYPT_ASYNC_RETRIEVAL_COMPLETION = _CRYPT_ASYNC_RETRIEVAL_COMPLETION;
  PCRYPT_ASYNC_RETRIEVAL_COMPLETION = ^_CRYPT_ASYNC_RETRIEVAL_COMPLETION;

-- 
--  This function is set on the async handle by a scheme provider that
--  supports asynchronous retrieval
-- 
type
PFN_CANCEL_ASYNC_RETRIEVAL_FUNC = ^procedure (
    hAsyncRetrieve  : HCRYPTASYNC)
                      return BOOL for machine_pointer use true;
-- 
--  Get the locator for a CAPI object
-- 
const
  CRYPT_GET_URL_FROM_PROPERTY= $01;

const
  CRYPT_GET_URL_FROM_EXTENSION= $02;

const
  CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE= $04;

const
  CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE= $08;

type
  _CRYPT_URL_ARRAY  = record
cUrl            : DWORD;
rgwszUrl        : ^LPWSTR;
  end record;
  CRYPT_URL_ARRAY   = _CRYPT_URL_ARRAY;
  PCRYPT_URL_ARRAY  = ^_CRYPT_URL_ARRAY;

type
  _CRYPT_URL_INFO   = record
cbSize          : DWORD;
dwSyncDeltaTime : DWORD;
cGroup          : DWORD;
rgcGroupEntry   : ^DWORD;
  end record;
  CRYPT_URL_INFO    = _CRYPT_URL_INFO;
  PCRYPT_URL_INFO   = ^_CRYPT_URL_INFO;

procedure CryptGetObjectUrl(
    pszUrlOid       : in LPCSTR; 
    pvPara          : in LPVOID; 
    dwFlags         : in DWORD; 
    pUrlArray       : out {out optional} _CRYPT_URL_ARRAY; 
    pcbUrlArray     : in out DWORD; 
    pUrlInfo        : out {out optional} _CRYPT_URL_INFO; 
    pcbUrlInfo      : in out {out optional} DWORD; 
    pvReserved      : in {out optional} LPVOID)
                      return BOOL;
#pragma convention(CryptGetObjectUrl,system);
#pragma import(CryptGetObjectUrl,'CryptGetObjectUrl','cryptnet.dll');

-- 
--  UrlDllGetObjectUrl has the same signature as CryptGetObjectUrl
-- 
-- 
--  URL_OID_CERTIFICATE_ISSUER
-- 
--  pvPara == PCCERT_CONTEXT, certificate whose issuer's URL is being requested
-- 
--  This will be retrieved from the authority info access extension or property
--  on the certificate
-- 
--  URL_OID_CERTIFICATE_CRL_DIST_POINT
-- 
--  pvPara == PCCERT_CONTEXT, certificate whose CRL distribution point is being
--  requested
-- 
--  This will be retrieved from the CRL distribution point extension or property
--  on the certificate
-- 
--  URL_OID_CTL_ISSUER
-- 
--  pvPara == PCCTL_CONTEXT, Signer Index, CTL whose issuer's URL (identified
--  by the signer index) is being requested
-- 
--  This will be retrieved from an authority info access attribute method encoded
--  in each signer info in the PKCS7 (CTL)
-- 
--  URL_OID_CTL_NEXT_UPDATE
-- 
--  pvPara == PCCTL_CONTEXT, Signer Index, CTL whose next update URL is being
--  requested and an optional signer index in case we need to check signer
--  info attributes
-- 
--  This will be retrieved from an authority info access CTL extension, property,
--  or signer info attribute method
-- 
--  URL_OID_CRL_ISSUER
-- 
--  pvPara == PCCRL_CONTEXT, CRL whose issuer's URL is being requested
-- 
--  This will be retrieved from a property on the CRL which has been inherited
--  from the subject cert (either from the subject cert issuer or the subject
--  cert distribution point extension). It will be encoded as an authority
--  info access extension method.
-- 
--  URL_OID_CERTIFICATE_FRESHEST_CRL
-- 
--  pvPara == PCCERT_CONTEXT, certificate whose freshest CRL distribution point
--  is being requested
-- 
--  This will be retrieved from the freshest CRL extension or property
--  on the certificate
-- 
--  URL_OID_CRL_FRESHEST_CRL
-- 
--  pvPara == PCCERT_CRL_CONTEXT_PAIR, certificate's base CRL whose
--  freshest CRL distribution point is being requested
-- 
--  This will be retrieved from the freshest CRL extension or property
--  on the CRL
-- 
--  URL_OID_CROSS_CERT_DIST_POINT
-- 
--  pvPara == PCCERT_CONTEXT, certificate whose cross certificate distribution
--  point is being requested
-- 
--  This will be retrieved from the cross certificate distribution point
--  extension or property on the certificate
-- 
type
  _CERT_CRL_CONTEXT_PAIR = record
pCertContext    : PCCERT_CONTEXT;
pCrlContext     : PCCRL_CONTEXT;
  end record;
  CERT_CRL_CONTEXT_PAIR = _CERT_CRL_CONTEXT_PAIR;
  PCERT_CRL_CONTEXT_PAIR = ^_CERT_CRL_CONTEXT_PAIR;

type
PCCERT_CRL_CONTEXT_PAIR = ^CERT_CRL_CONTEXT_PAIR for machine_pointer use true;
-- 
--  Get a time valid CAPI2 object
-- 
--  milliseconds
-- 
--  TimeValidDllGetObject has the same signature as CryptGetTimeValidObject
-- 
-- 
--  TIME_VALID_OID_GET_CTL
-- 
--  pvPara == PCCTL_CONTEXT, the current CTL
-- 
--  TIME_VALID_OID_GET_CRL
-- 
--  pvPara == PCCRL_CONTEXT, the current CRL
-- 
--  TIME_VALID_OID_GET_CRL_FROM_CERT
-- 
--  pvPara == PCCERT_CONTEXT, the subject cert
-- 
--  TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT
-- 
--  pvPara == PCCERT_CONTEXT, the subject cert
-- 
--  TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL
-- 
--  pvPara == PCCERT_CRL_CONTEXT_PAIR, the subject cert and its base CRL
-- 
-- 
--  TimeValidDllFlushObject has the same signature as CryptFlushTimeValidObject
-- 
-- 
--  TIME_VALID_OID_FLUSH_CTL
-- 
--  pvPara == PCCTL_CONTEXT, the CTL to flush
-- 
--  TIME_VALID_OID_FLUSH_CRL
-- 
--  pvPara == PCCRL_CONTEXT, the CRL to flush
-- 
--  TIME_VALID_OID_FLUSH_CRL_FROM_CERT
-- 
--  pvPara == PCCERT_CONTEXT, the subject cert's CRL to flush
-- 
--  TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT
-- 
--  pvPara == PCCERT_CONTEXT, the subject cert's freshest CRL to flush
-- 
--  TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL
-- 
--  pvPara == PCCERT_CRL_CONTEXT_PAIR, the subject cert and its base CRL's
--  freshest CRL to flush
-- 
-- -------------------------------------------------------------------------
--  Data Protection APIs
-- -------------------------------------------------------------------------
-- 
--  Data protection APIs enable applications to easily secure data.
-- 
--  The base provider provides protection based on the users' logon
--  credentials. The data secured with these APIs follow the same
--  roaming characteristics as HKCU -- if HKCU roams, the data
--  protected by the base provider may roam as well. This makes
--  the API ideal for the munging of data stored in the registry.
-- 
-- 
--  Prompt struct -- what to tell users about the access
-- 
type
  _CRYPTPROTECT_PROMPTSTRUCT = record
cbSize          : DWORD;
dwPromptFlags   : DWORD;
hwndApp         : t_HWND;
szPrompt        : LPCWSTR;
  end record;
  CRYPTPROTECT_PROMPTSTRUCT = _CRYPTPROTECT_PROMPTSTRUCT;
  PCRYPTPROTECT_PROMPTSTRUCT = ^_CRYPTPROTECT_PROMPTSTRUCT;

-- 
--  base provider action
-- 
-- 
--  CryptProtect PromptStruct dwPromtFlags
-- 
-- 
--  prompt on unprotect
const
  CRYPTPROTECT_PROMPT_ON_UNPROTECT= $01;

-- 
--  prompt on protect
const
  CRYPTPROTECT_PROMPT_ON_PROTECT= $02;

const
  CRYPTPROTECT_PROMPT_RESERVED= $04;

-- 
--  default to strong variant UI protection (user supplied password currently).
const
  CRYPTPROTECT_PROMPT_STRONG= $08;

-- 
--  require strong variant UI protection (user supplied password currently).
const
  CRYPTPROTECT_PROMPT_REQUIRE_STRONG= $10;

-- 
--  CryptProtectData and CryptUnprotectData dwFlags
-- 
--  for remote-access situations where ui is not an option
--  if UI was specified on protect or unprotect operation, the call
--  will fail and GetLastError() will indicate ERROR_PASSWORD_RESTRICTION
const
  CRYPTPROTECT_UI_FORBIDDEN= $01;

-- 
--  per machine protected data -- any user on machine where CryptProtectData
--  took place may CryptUnprotectData
const
  CRYPTPROTECT_LOCAL_MACHINE= $04;

-- 
--  force credential synchronize during CryptProtectData()
--  Synchronize is only operation that occurs during this operation
const
  CRYPTPROTECT_CRED_SYNC= $08;

-- 
--  Generate an Audit on protect and unprotect operations
-- 
const
  CRYPTPROTECT_AUDIT= $10;

-- 
--  Protect data with a non-recoverable key
-- 
const
  CRYPTPROTECT_NO_RECOVERY= $20;

-- 
--  Verify the protection of a protected blob
-- 
const
  CRYPTPROTECT_VERIFY_PROTECTION= $40;

-- 
--  Regenerate the local machine protection
-- 
const
  CRYPTPROTECT_CRED_REGENERATE= $80;

--  flags reserved for system use
const
  CRYPTPROTECT_FIRST_RESERVED_FLAGVAL= $FFFFFFF;

const
  CRYPTPROTECT_LAST_RESERVED_FLAGVAL= $FFFFFFFF;

-- 
--  flags specific to base provider
-- 
type
t_266=^DATA_BLOB for machine_pointer use true;

t_267=^DATA_BLOB for machine_pointer use true;

t_268=^CRYPTPROTECT_PROMPTSTRUCT for machine_pointer use true;

--  out encr blob
procedure CryptProtectData(
    pDataIn         : in t_266; 
    szDataDescr     : in LPCWSTR; 
    pOptionalEntropy : in {out optional} t_267; 
    pvReserved      : in PVOID; 
    pPromptStruct   : in {out optional} t_268; 
    dwFlags         : in DWORD; 
    pDataOut        : out DATA_BLOB)
                      return BOOL;
#pragma convention(CryptProtectData,system);
#pragma import(CryptProtectData,'CryptProtectData','crypt32.dll');

type
t_269=^DATA_BLOB for machine_pointer use true;

--  in encr blob
--  out
t_270=^DATA_BLOB for machine_pointer use true;

t_271=^CRYPTPROTECT_PROMPTSTRUCT for machine_pointer use true;

procedure CryptUnprotectData(
    pDataIn         : in t_269; 
    ppszDataDescr   : out {out optional} LPWSTR; 
    pOptionalEntropy : in {out optional} t_270; 
    pvReserved      : in PVOID; 
    pPromptStruct   : in {out optional} t_271; 
    dwFlags         : in DWORD; 
    pDataOut        : out DATA_BLOB)
                      return BOOL;
#pragma convention(CryptUnprotectData,system);
#pragma import(CryptUnprotectData,'CryptUnprotectData','crypt32.dll');

-- 
--  The buffer length passed into CryptProtectMemory and CryptUnprotectMemory
--  must be a multiple of this length (or zero).
-- 
const
  CRYPTPROTECTMEMORY_BLOCK_SIZE= 16;

-- 
--  CryptProtectMemory/CryptUnprotectMemory dwFlags
-- 
-- 
--  Encrypt/Decrypt within current process context.
-- 
const
  CRYPTPROTECTMEMORY_SAME_PROCESS= $00;

-- 
--  Encrypt/Decrypt across process boundaries.
--  eg: encrypted buffer passed across LPC to another process which calls CryptUnprotectMemory.
-- 
const
  CRYPTPROTECTMEMORY_CROSS_PROCESS= $01;

-- 
--  Encrypt/Decrypt across callers with same LogonId.
--  eg: encrypted buffer passed across LPC to another process which calls CryptUnprotectMemory whilst impersonating.
-- 
const
  CRYPTPROTECTMEMORY_SAME_LOGON= $02;

--  in out data to encrypt
--  multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
procedure CryptProtectMemory(
    pDataIn         : in out unchecked ; 
    cbDataIn        : in DWORD; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(CryptProtectMemory,system);
#pragma import(CryptProtectMemory,'CryptProtectMemory','crypt32.dll');

--  in out data to decrypt
--  multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
procedure CryptUnprotectMemory(
    pDataIn         : in out unchecked ; 
    cbDataIn        : in DWORD; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(CryptUnprotectMemory,system);
#pragma import(CryptUnprotectMemory,'CryptUnprotectMemory','crypt32.dll');

-- +=========================================================================
--  Helper functions to build certificates
-- ==========================================================================
-- +-------------------------------------------------------------------------
-- 
--  Builds a self-signed certificate and returns a PCCERT_CONTEXT representing
--  the certificate. A hProv must be specified to build the cert context.
-- 
--  pSubjectIssuerBlob is the DN for the certifcate. If an alternate subject
--  name is desired it must be specified as an extension in the pExtensions
--  parameter. pSubjectIssuerBlob can NOT be NULL, so minimually an empty DN
--  must be specified.
-- 
--  By default:
--  pKeyProvInfo - The CSP is queried for the KeyProvInfo parameters. Only the Provider,
--  Provider Type and Container is queried. Many CSPs don't support these
--  queries and will cause a failure. In such cases the pKeyProvInfo
--  must be specified (RSA BASE works fine).
-- 
--  pSignatureAlgorithm - will default to SHA1RSA
--  pStartTime will default to the current time
--  pEndTime will default to 1 year
--  pEntensions will be empty.
-- 
--  The returned PCCERT_CONTEXT will reference the private keys by setting the
--  CERT_KEY_PROV_INFO_PROP_ID. However, if this property is not desired specify the
--  CERT_CREATE_SELFSIGN_NO_KEY_INFO in dwFlags.
-- 
--  If the cert being built is only a dummy placeholder cert for speed it may not
--  need to be signed. Signing of the cert is skipped if CERT_CREATE_SELFSIGN_NO_SIGN
--  is specified in dwFlags.
-- 
-- --------------------------------------------------------------------------
procedure CertCreateSelfSignCertificate(
    hProv           : in t_HCRYPTPROV; 
    pSubjectIssuerBlob : in PCERT_NAME_BLOB; 
    dwFlags         : in DWORD; 
    pKeyProvInfo    : {out optional} PCRYPT_KEY_PROV_INFO; 
    pSignatureAlgorithm : {out optional} PCRYPT_ALGORITHM_IDENTIFIER; 
    pStartTime      : {out optional} PSYSTEMTIME; 
    pEndTime        : {out optional} PSYSTEMTIME; 
    pExtensions     : {out optional} PCERT_EXTENSIONS)
                      return PCCERT_CONTEXT;
#pragma convention(CertCreateSelfSignCertificate,system);
#pragma import(CertCreateSelfSignCertificate,'CertCreateSelfSignCertificate','crypt32.dll');

const
  CERT_CREATE_SELFSIGN_NO_SIGN= 1;

const
  CERT_CREATE_SELFSIGN_NO_KEY_INFO= 2;

-- +=========================================================================
--  Key Identifier Property Data Structures and APIs
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  Get the property for the specified Key Identifier.
-- 
--  The Key Identifier is the SHA1 hash of the encoded CERT_PUBLIC_KEY_INFO.
--  The Key Identifier for a certificate can be obtained by getting the
--  certificate's CERT_KEY_IDENTIFIER_PROP_ID. The
--  CryptCreateKeyIdentifierFromCSP API can be called to create the Key
--  Identifier from a CSP Public Key Blob.
-- 
--  A Key Identifier can have the same properties as a certificate context.
--  CERT_KEY_PROV_INFO_PROP_ID is the property of most interest.
--  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO
--  structure. Elements pointed to by fields in the pvData structure follow the
--  structure. Therefore, *pcbData will exceed the size of the structure.
-- 
--  If CRYPT_KEYID_ALLOC_FLAG is set, then, *pvData is updated with a
--  pointer to allocated memory. LocalFree() must be called to free the
--  allocated memory.
-- 
--  By default, searches the CurrentUser's list of Key Identifiers.
--  CRYPT_KEYID_MACHINE_FLAG can be set to search the LocalMachine's list
--  of Key Identifiers. When CRYPT_KEYID_MACHINE_FLAG is set, pwszComputerName
--  can also be set to specify the name of a remote computer to be searched
--  instead of the local machine.
-- --------------------------------------------------------------------------
type
t_272=^CRYPT_HASH_BLOB for machine_pointer use true;

t_273=^unchecked for machine_pointer use true;

t_274=^unchecked for machine_pointer use true;

procedure CryptGetKeyIdentifierProperty(
    pKeyIdentifier  : in t_272; 
    dwPropId        : in DWORD; 
    dwFlags         : in DWORD; 
    pwszComputerName : in {out optional} LPCWSTR; 
    pvReserved      : in {out optional} t_273; 
    pvData          : out {!}t_274; 
    pcbData         : in out DWORD)
                      return BOOL;
#pragma convention(CryptGetKeyIdentifierProperty,system);
#pragma import(CryptGetKeyIdentifierProperty,'CryptGetKeyIdentifierProperty','crypt32.dll');

--  When the following flag is set, searches the LocalMachine instead of the
--  CurrentUser. This flag is applicable to all the KeyIdentifierProperty APIs.
const
  CRYPT_KEYID_MACHINE_FLAG= $20;

--  When the following flag is set, *pvData is updated with a pointer to
--  allocated memory. LocalFree() must be called to free the allocated memory.
const
  CRYPT_KEYID_ALLOC_FLAG= $8000;

-- +-------------------------------------------------------------------------
--  Set the property for the specified Key Identifier.
-- 
--  For CERT_KEY_PROV_INFO_PROP_ID pvData points to the
--  CRYPT_KEY_PROV_INFO data structure. For all other properties, pvData
--  points to a CRYPT_DATA_BLOB.
-- 
--  Setting pvData == NULL, deletes the property.
-- 
--  Set CRYPT_KEYID_MACHINE_FLAG to set the property for a LocalMachine
--  Key Identifier. Set pwszComputerName, to select a remote computer.
-- 
--  If CRYPT_KEYID_DELETE_FLAG is set, the Key Identifier and all its
--  properties is deleted.
-- 
--  If CRYPT_KEYID_SET_NEW_FLAG is set, the set fails if the property already
--  exists. For an existing property, FALSE is returned with LastError set to
--  CRYPT_E_EXISTS.
-- --------------------------------------------------------------------------
type
t_275=^CRYPT_HASH_BLOB for machine_pointer use true;

t_276=^unchecked for machine_pointer use true;

t_277=^unchecked for machine_pointer use true;

procedure CryptSetKeyIdentifierProperty(
    pKeyIdentifier  : in t_275; 
    dwPropId        : in DWORD; 
    dwFlags         : in DWORD; 
    pwszComputerName : in {out optional} LPCWSTR; 
    pvReserved      : in {out optional} t_276; 
    pvData          : in t_277)
                      return BOOL;
#pragma convention(CryptSetKeyIdentifierProperty,system);
#pragma import(CryptSetKeyIdentifierProperty,'CryptSetKeyIdentifierProperty','crypt32.dll');

--  When the following flag is set, the Key Identifier and all its properties
--  are deleted.
const
  CRYPT_KEYID_DELETE_FLAG= $10;

--  When the following flag is set, the set fails if the property already
--  exists.
const
  CRYPT_KEYID_SET_NEW_FLAG= $2000;

-- +-------------------------------------------------------------------------
--  For CERT_KEY_PROV_INFO_PROP_ID, rgppvData[] points to a
--  CRYPT_KEY_PROV_INFO.
-- 
--  Return FALSE to stop the enumeration.
-- --------------------------------------------------------------------------
type
t_278=^CRYPT_HASH_BLOB for machine_pointer use true;
t_279=^unchecked for machine_pointer use true;
t_280=^unchecked for machine_pointer use true;
t_281=^DWORD for machine_pointer use true;
t_282=^^unchecked for machine_pointer use true;
t_283=^DWORD for machine_pointer use true;

PFN_CRYPT_ENUM_KEYID_PROP = ^procedure (
    pKeyIdentifier  : in t_278;
    dwFlags         : in DWORD;
    pvReserved      : in t_279;
    pvArg           : in t_280;
    cProp           : in DWORD;
    rgdwPropId      : in t_281;
    rgpvData        : in t_282;
    rgcbData        : in t_283)
                      return BOOL for machine_pointer use true;
-- +-------------------------------------------------------------------------
--  Enumerate the Key Identifiers.
-- 
--  If pKeyIdentifier is NULL, enumerates all Key Identifers. Otherwise,
--  calls the callback for the specified KeyIdentifier. If dwPropId is
--  0, calls the callback with all the properties. Otherwise, only calls
--  the callback with the specified property (cProp = 1).
--  Furthermore, when dwPropId is specified, skips KeyIdentifiers not
--  having the property.
-- 
--  Set CRYPT_KEYID_MACHINE_FLAG to enumerate the LocalMachine
--  Key Identifiers. Set pwszComputerName, to enumerate Key Identifiers on
--  a remote computer.
-- --------------------------------------------------------------------------
type
t_284=^CRYPT_HASH_BLOB for machine_pointer use true;

t_285=^unchecked for machine_pointer use true;

t_286=^unchecked for machine_pointer use true;

procedure CryptEnumKeyIdentifierProperties(
    pKeyIdentifier  : in {out optional} t_284; 
    dwPropId        : in DWORD; 
    dwFlags         : in DWORD; 
    pwszComputerName : in {out optional} LPCWSTR; 
    pvReserved      : in {out optional} t_285; 
    pvArg           : in {out optional} t_286; 
    pfnEnum         : in PFN_CRYPT_ENUM_KEYID_PROP)
                      return BOOL;
#pragma convention(CryptEnumKeyIdentifierProperties,system);
#pragma import(CryptEnumKeyIdentifierProperties,'CryptEnumKeyIdentifierProperties','crypt32.dll');

-- +-------------------------------------------------------------------------
--  Create a KeyIdentifier from the CSP Public Key Blob.
-- 
--  Converts the CSP PUBLICKEYSTRUC into a X.509 CERT_PUBLIC_KEY_INFO and
--  encodes. The encoded CERT_PUBLIC_KEY_INFO is SHA1 hashed to obtain
--  the Key Identifier.
-- 
--  By default, the pPubKeyStruc->aiKeyAlg is used to find the appropriate
--  public key Object Identifier. pszPubKeyOID can be set to override
--  the default OID obtained from the aiKeyAlg.
-- --------------------------------------------------------------------------
type
t_287=^PUBLICKEYSTRUC for machine_pointer use true;

t_288=^unchecked for machine_pointer use true;

procedure CryptCreateKeyIdentifierFromCSP(
    dwCertEncodingType : in DWORD; 
    pszPubKeyOID    : in {out optional} LPCSTR; 
    pPubKeyStruc    : in t_287; 
    cbPubKeyStruc   : in DWORD; 
    dwFlags         : in DWORD; 
    pvReserved      : in {out optional} t_288; 
    pbHash          : out BYTE; 
    pcbHash         : in out DWORD)
                      return BOOL;
#pragma convention(CryptCreateKeyIdentifierFromCSP,system);
#pragma import(CryptCreateKeyIdentifierFromCSP,'CryptCreateKeyIdentifierFromCSP','crypt32.dll');

-- +=========================================================================
--  Certificate Chaining Infrastructure
-- ==========================================================================
--  The following are REG_DWORD's. These configuration parameters are used
--  to restrict Authority Info Access (AIA) URL retrieval.
--  By default AIA Url Retrieval is enabled. Set this registry value to nonzero
--  to disable
const
  CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT= 5;

const
  CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT= 10;

const
  CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT= 100000;

const
  CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT= 10;

-- 
--  The chain engine defines the store namespace and cache partitioning for
--  the Certificate Chaining infrastructure. A default chain engine
--  is defined for the process which uses all default system stores e.g.
--  Root, CA, Trust, for chain building and caching. If an application
--  wishes to define its own store namespace or have its own partitioned
--  cache then it can create its own chain engine. It is advisable to create
--  a chain engine at application startup and use it throughout the lifetime
--  of the application in order to get optimal caching behavior
-- 
type
HCERTCHAINENGINE  = t_HANDLE;
-- 
--  Create a certificate chain engine.
-- 
-- 
--  Configuration parameters for the certificate chain engine
-- 
--  hRestrictedRoot - restrict the root store (must be a subset of "Root")
-- 
--  hRestrictedTrust - restrict the store for CTLs
-- 
--  hRestrictedOther - restrict the store for certs and CRLs
-- 
--  cAdditionalStore, rghAdditionalStore - additional stores
-- 
--  NOTE: The algorithm used to define the stores for the engine is as
--  follows:
-- 
--  hRoot = hRestrictedRoot or System Store "Root"
-- 
--  hTrust = hRestrictedTrust or hWorld (defined later)
-- 
--  hOther = hRestrictedOther or (hRestrictedTrust == NULL) ? hWorld :
--  hRestrictedTrust + hWorld
-- 
--  hWorld = hRoot + "CA" + "My" + "Trust" + rghAdditionalStore
-- 
--  dwFlags - flags
-- 
--  CERT_CHAIN_CACHE_END_CERT - information will be cached on
--  the end cert as well as the other
--  certs in the chain
-- 
--  CERT_CHAIN_THREAD_STORE_SYNC - use separate thread for store syncs
--  and related cache updates
-- 
--  CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL - don't hit the wire to get
--  URL based objects
-- 
--  dwUrlRetrievalTimeout - timeout for wire based URL object retrievals
--  (milliseconds)
-- 
const
  CERT_CHAIN_CACHE_END_CERT= $01;

const
  CERT_CHAIN_THREAD_STORE_SYNC= $02;

const
  CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL= $04;

const
  CERT_CHAIN_USE_LOCAL_MACHINE_STORE= $08;

const
  CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE= $10;

const
  CERT_CHAIN_ENABLE_SHARE_STORE= $20;

type
  _CERT_CHAIN_ENGINE_CONFIG = record
cbSize          : DWORD;
hRestrictedRoot : t_HCERTSTORE;
hRestrictedTrust : t_HCERTSTORE;
hRestrictedOther : t_HCERTSTORE;
cAdditionalStore : DWORD;
rghAdditionalStore : ^t_HCERTSTORE;
dwFlags         : DWORD;
dwUrlRetrievalTimeout : DWORD;
MaximumCachedCertificates : DWORD;
CycleDetectionModulus : DWORD;
  end record;
  CERT_CHAIN_ENGINE_CONFIG = _CERT_CHAIN_ENGINE_CONFIG;
  PCERT_CHAIN_ENGINE_CONFIG = ^_CERT_CHAIN_ENGINE_CONFIG;

procedure CertCreateCertificateChainEngine(
    pConfig         : in PCERT_CHAIN_ENGINE_CONFIG; 
    phChainEngine   : out HCERTCHAINENGINE)
                      return BOOL;
#pragma convention(CertCreateCertificateChainEngine,system);
#pragma import(CertCreateCertificateChainEngine,'CertCreateCertificateChainEngine','crypt32.dll');

-- 
--  Free a certificate trust engine
-- 
procedure CertFreeCertificateChainEngine(
    hChainEngine    : in HCERTCHAINENGINE);
#pragma convention(CertFreeCertificateChainEngine,system);
#pragma import(CertFreeCertificateChainEngine,'CertFreeCertificateChainEngine','crypt32.dll');

-- 
--  Resync the certificate chain engine. This resync's the stores backing
--  the engine and updates the engine caches.
-- 
procedure CertResyncCertificateChainEngine(
    hChainEngine    : in HCERTCHAINENGINE)
                      return BOOL;
#pragma convention(CertResyncCertificateChainEngine,system);
#pragma import(CertResyncCertificateChainEngine,'CertResyncCertificateChainEngine','crypt32.dll');

-- 
--  When an application requests a certificate chain, the data structure
--  returned is in the form of a CERT_CHAIN_CONTEXT. This contains
--  an array of CERT_SIMPLE_CHAIN where each simple chain goes from
--  an end cert to a self signed cert and the chain context connects simple
--  chains via trust lists. Each simple chain contains the chain of
--  certificates, summary trust information about the chain and trust information
--  about each certificate element in the chain.
-- 
-- 
--  Trust status bits
-- 
type
  _CERT_TRUST_STATUS = record
dwErrorStatus   : DWORD;
dwInfoStatus    : DWORD;
  end record;
  CERT_TRUST_STATUS = _CERT_TRUST_STATUS;
  PCERT_TRUST_STATUS = ^_CERT_TRUST_STATUS;

-- 
--  The following are error status bits
-- 
--  These can be applied to certificates and chains
const
  CERT_TRUST_NO_ERROR= $00;

const
  CERT_TRUST_IS_NOT_TIME_VALID= $01;

const
  CERT_TRUST_IS_NOT_TIME_NESTED= $02;

const
  CERT_TRUST_IS_REVOKED= $04;

const
  CERT_TRUST_IS_NOT_SIGNATURE_VALID= $08;

const
  CERT_TRUST_IS_NOT_VALID_FOR_USAGE= $10;

const
  CERT_TRUST_IS_UNTRUSTED_ROOT= $20;

const
  CERT_TRUST_REVOCATION_STATUS_UNKNOWN= $40;

const
  CERT_TRUST_IS_CYCLIC= $80;

const
  CERT_TRUST_INVALID_EXTENSION= $0100;

const
  CERT_TRUST_INVALID_POLICY_CONSTRAINTS= $0200;

const
  CERT_TRUST_INVALID_BASIC_CONSTRAINTS= $0400;

const
  CERT_TRUST_INVALID_NAME_CONSTRAINTS= $0800;

const
  CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT= $1000;

const
  CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT= $2000;

const
  CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT= $4000;

const
  CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT= $8000;

const
  CERT_TRUST_IS_OFFLINE_REVOCATION= $1000000;

const
  CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY= $2000000;

--  These can be applied to chains only
const
  CERT_TRUST_IS_PARTIAL_CHAIN= $10000;

const
  CERT_TRUST_CTL_IS_NOT_TIME_VALID= $20000;

const
  CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID= $40000;

const
  CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE= $80000;

-- 
--  The following are info status bits
-- 
--  These can be applied to certificates only
const
  CERT_TRUST_HAS_EXACT_MATCH_ISSUER= $01;

const
  CERT_TRUST_HAS_KEY_MATCH_ISSUER= $02;

const
  CERT_TRUST_HAS_NAME_MATCH_ISSUER= $04;

const
  CERT_TRUST_IS_SELF_SIGNED= $08;

--  These can be applied to certificates and chains
const
  CERT_TRUST_HAS_PREFERRED_ISSUER= $0100;

const
  CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY= $0200;

const
  CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS= $0400;

--  These can be applied to chains only
const
  CERT_TRUST_IS_COMPLEX_CHAIN= $10000;

-- 
--  Each certificate context in a simple chain has a corresponding chain element
--  in the simple chain context
-- 
--  dwErrorStatus has CERT_TRUST_IS_REVOKED, pRevocationInfo set
--  dwErrorStatus has CERT_TRUST_REVOCATION_STATUS_UNKNOWN, pRevocationInfo set
-- 
--  Note that the post processing revocation supported in the first
--  version only sets cbSize and dwRevocationResult. Everything else
--  is NULL
-- 
-- 
--  Revocation Information
-- 
type
  _CERT_REVOCATION_INFO = record
cbSize          : DWORD;
dwRevocationResult : DWORD;
pszRevocationOid : LPCSTR;
pvOidSpecificInfo : LPVOID;
fHasFreshnessTime : BOOL;
dwFreshnessTime : DWORD;
pCrlInfo        : PCERT_REVOCATION_CRL_INFO;
  end record;
  CERT_REVOCATION_INFO = _CERT_REVOCATION_INFO;
  PCERT_REVOCATION_INFO = ^_CERT_REVOCATION_INFO;

-- 
--  Trust List Information
-- 
type
  _CERT_TRUST_LIST_INFO = record
cbSize          : DWORD;
pCtlEntry       : PCTL_ENTRY;
pCtlContext     : PCCTL_CONTEXT;
  end record;
  CERT_TRUST_LIST_INFO = _CERT_TRUST_LIST_INFO;
  PCERT_TRUST_LIST_INFO = ^_CERT_TRUST_LIST_INFO;

-- 
--  Chain Element
-- 
type
  _CERT_CHAIN_ELEMENT = record
cbSize          : DWORD;
pCertContext    : PCCERT_CONTEXT;
TrustStatus     : CERT_TRUST_STATUS;
pRevocationInfo : PCERT_REVOCATION_INFO;
pIssuanceUsage  : PCERT_ENHKEY_USAGE;
pApplicationUsage : PCERT_ENHKEY_USAGE;
pwszExtendedErrorInfo : LPCWSTR;
  end record;
  CERT_CHAIN_ELEMENT = _CERT_CHAIN_ELEMENT;
  PCERT_CHAIN_ELEMENT = ^_CERT_CHAIN_ELEMENT;

-- 
--  The simple chain is an array of chain elements and a summary trust status
--  for the chain
-- 
--  rgpElements[0] is the end certificate chain element
-- 
--  rgpElements[cElement-1] is the self-signed "root" certificate chain element
-- 
type
  _CERT_SIMPLE_CHAIN = record
cbSize          : DWORD;
TrustStatus     : CERT_TRUST_STATUS;
cElement        : DWORD;
rgpElement      : ^PCERT_CHAIN_ELEMENT;
pTrustListInfo  : PCERT_TRUST_LIST_INFO;
fHasRevocationFreshnessTime : BOOL;
dwRevocationFreshnessTime : DWORD;
  end record;
  CERT_SIMPLE_CHAIN = _CERT_SIMPLE_CHAIN;
  PCERT_SIMPLE_CHAIN = ^_CERT_SIMPLE_CHAIN;

-- 
--  And the chain context contains an array of simple chains and summary trust
--  status for all the connected simple chains
-- 
--  rgpChains[0] is the end certificate simple chain
-- 
--  rgpChains[cChain-1] is the final (possibly trust list signer) chain which
--  ends in a certificate which is contained in the root store
-- 
type
  CERT_CHAIN_CONTEXT;
  PCERT_CHAIN_CONTEXT = ^CERT_CHAIN_CONTEXT;
type
PCCERT_CHAIN_CONTEXT = ^CERT_CHAIN_CONTEXT for machine_pointer use true;
type
  CERT_CHAIN_CONTEXT = record
cbSize          : DWORD;
TrustStatus     : CERT_TRUST_STATUS;
cChain          : DWORD;
rgpChain        : ^PCERT_SIMPLE_CHAIN;
cLowerQualityChainContext : DWORD;
rgpLowerQualityChainContext : ^PCCERT_CHAIN_CONTEXT;
fHasRevocationFreshnessTime : BOOL;
dwRevocationFreshnessTime : DWORD;
  end record;

-- 
--  When building a chain, the there are various parameters used for finding
--  issuing certificates and trust lists. They are identified in the
--  following structure
-- 
--  Default usage match type is AND with value zero
const
  USAGE_MATCH_TYPE_AND= $00;

const
  USAGE_MATCH_TYPE_OR= $01;

type
  _CERT_USAGE_MATCH = record
dwType          : DWORD;
Usage           : CERT_ENHKEY_USAGE;
  end record;
  CERT_USAGE_MATCH  = _CERT_USAGE_MATCH;
  PCERT_USAGE_MATCH = ^_CERT_USAGE_MATCH;

type
  _CTL_USAGE_MATCH  = record
dwType          : DWORD;
Usage           : CTL_USAGE;
  end record;
  CTL_USAGE_MATCH   = _CTL_USAGE_MATCH;
  PCTL_USAGE_MATCH  = ^_CTL_USAGE_MATCH;

type
  _CERT_CHAIN_PARA  = record
cbSize          : DWORD;
RequestedUsage  : CERT_USAGE_MATCH;
  end record;
  CERT_CHAIN_PARA   = _CERT_CHAIN_PARA;
  PCERT_CHAIN_PARA  = ^_CERT_CHAIN_PARA;

-- 
--  The following API is used for retrieving certificate chains
-- 
--  Parameters:
-- 
--  hChainEngine - the chain engine (namespace and cache) to use, NULL
--  mean use the default chain engine
-- 
--  pCertContext - the context we are retrieving the chain for, it
--  will be the zero index element in the chain
-- 
--  pTime - the point in time that we want the chain validated
--  for. Note that the time does not affect trust list,
--  revocation, or root store checking. NULL means use
--  the current system time
-- 
--  hAdditionalStore - additional store to use when looking up objects
-- 
--  pChainPara - parameters for chain building
-- 
--  dwFlags - flags such as should revocation checking be done
--  on the chain?
-- 
--  pvReserved - reserved parameter, must be NULL
-- 
--  ppChainContext - chain context returned
-- 
--  CERT_CHAIN_CACHE_END_CERT can be used here as well
--  Revocation flags are in the high nibble
const
  CERT_CHAIN_REVOCATION_CHECK_END_CERT= $10000000;

const
  CERT_CHAIN_REVOCATION_CHECK_CHAIN= $20000000;

const
  CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT= $40000000;

const
  CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY= $80000000;

--  By default, the dwUrlRetrievalTimeout in pChainPara is the timeout used
--  for each revocation URL wire retrieval. When the following flag is set,
--  dwUrlRetrievalTimeout is the accumulative timeout across all
--  revocation URL wire retrievals.
const
  CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT= $8000000;

--  First pass determines highest quality based upon:
--  - Chain signature valid (higest quality bit of this set)
--  - Complete chain
--  - Trusted root (lowestest quality bit of this set)
--  By default, second pass only considers paths >= highest first pass quality
const
  CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING= $40;

const
  CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS= $80;

const
  CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE= $0100;

--  When this flag is set, pTime will be used as the timestamp time.
--  pTime will be used to determine if the end certificate was valid at this
--  time. Revocation checking will be relative to pTime.
--  In addition, current time will also be used
--  to determine if the certificate is still time valid. All remaining
--  CA and root certificates will be checked using current time and not pTime.
-- 
--  This flag was added 4/5/01 in WXP.
const
  CERT_CHAIN_TIMESTAMP_TIME= $0200;

procedure CertGetCertificateChain(
    hChainEngine    : in {out optional} HCERTCHAINENGINE; 
    pCertContext    : in PCCERT_CONTEXT; 
    pTime           : in {out optional} p_FILETIME; 
    hAdditionalStore : in {out optional} t_HCERTSTORE; 
    pChainPara      : in PCERT_CHAIN_PARA; 
    dwFlags         : in DWORD; 
    pvReserved      : in LPVOID; 
    ppChainContext  : out PCCERT_CHAIN_CONTEXT)
                      return BOOL;
#pragma convention(CertGetCertificateChain,system);
#pragma import(CertGetCertificateChain,'CertGetCertificateChain','crypt32.dll');

-- 
--  Free a certificate chain
-- 
procedure CertFreeCertificateChain(
    pChainContext   : in PCCERT_CHAIN_CONTEXT);
#pragma convention(CertFreeCertificateChain,system);
#pragma import(CertFreeCertificateChain,'CertFreeCertificateChain','crypt32.dll');

-- 
--  Duplicate (add a reference to) a certificate chain
-- 
procedure CertDuplicateCertificateChain(
    pChainContext   : in PCCERT_CHAIN_CONTEXT)
                      return PCCERT_CHAIN_CONTEXT;
#pragma convention(CertDuplicateCertificateChain,system);
#pragma import(CertDuplicateCertificateChain,'CertDuplicateCertificateChain','crypt32.dll');

-- 
--  Specific Revocation Type OID and structure definitions
-- 
-- 
--  CRL Revocation OID
-- 
-- 
--  For the CRL revocation OID the pvRevocationPara is NULL
-- 
-- 
--  CRL Revocation Info
-- 
type
  _CRL_REVOCATION_INFO = record
pCrlEntry       : PCRL_ENTRY;
pCrlContext     : PCCRL_CONTEXT;
pCrlIssuerChain : PCCERT_CHAIN_CONTEXT;
  end record;
  CRL_REVOCATION_INFO = _CRL_REVOCATION_INFO;
  PCRL_REVOCATION_INFO = ^_CRL_REVOCATION_INFO;

-- +-------------------------------------------------------------------------
--  Find the first or next certificate chain context in the store.
-- 
--  The chain context is found according to the dwFindFlags, dwFindType and
--  its pvFindPara. See below for a list of the find types and its parameters.
-- 
--  If the first or next chain context isn't found, NULL is returned.
--  Otherwise, a pointer to a read only CERT_CHAIN_CONTEXT is returned.
--  CERT_CHAIN_CONTEXT must be freed by calling CertFreeCertificateChain
--  or is freed when passed as the
--  pPrevChainContext on a subsequent call. CertDuplicateCertificateChain
--  can be called to make a duplicate.
-- 
--  pPrevChainContext MUST BE NULL on the first
--  call to find the chain context. To find the next chain context, the
--  pPrevChainContext is set to the CERT_CHAIN_CONTEXT returned by a previous
--  call.
-- 
--  NOTE: a NON-NULL pPrevChainContext is always CertFreeCertificateChain'ed by
--  this function, even for an error.
-- --------------------------------------------------------------------------
type
t_289=^unchecked for machine_pointer use true;

procedure CertFindChainInStore(
    hCertStore      : in t_HCERTSTORE; 
    dwCertEncodingType : in DWORD; 
    dwFindFlags     : in DWORD; 
    dwFindType      : in DWORD; 
    pvFindPara      : in t_289; 
    pPrevChainContext : in PCCERT_CHAIN_CONTEXT)
                      return PCCERT_CHAIN_CONTEXT;
#pragma convention(CertFindChainInStore,system);
#pragma import(CertFindChainInStore,'CertFindChainInStore','crypt32.dll');

const
  CERT_CHAIN_FIND_BY_ISSUER= 1;

-- +-------------------------------------------------------------------------
--  CERT_CHAIN_FIND_BY_ISSUER
-- 
--  Find a certificate chain having a private key for the end certificate and
--  matching one of the given issuer names. A matching dwKeySpec and
--  enhanced key usage can also be specified. Additionally a callback can
--  be provided for even more caller provided filtering before building the
--  chain.
-- 
--  By default, only the issuers in the first simple chain are compared
--  for a name match. CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG can
--  be set in dwFindFlags to match issuers in all the simple chains.
-- 
--  CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG can be set in dwFindFlags to
--  not check if the end certificate has a private key.
-- 
--  CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG can be set in dwFindFlags
--  to compare the public key in the end certificate with the crypto
--  provider's public key. The dwAcquirePrivateKeyFlags can be set
--  in CERT_CHAIN_FIND_BY_ISSUER_PARA to enable caching of the private key's
--  HKEY returned by the CSP.
-- 
--  If dwCertEncodingType == 0, defaults to X509_ASN_ENCODING for the
--  array of encoded issuer names.
-- 
--  By default, the hCertStore passed to CertFindChainInStore, is passed
--  as an additional store to CertGetCertificateChain.
--  CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG can be set in dwFindFlags
--  to improve performance by only searching the cached system stores
--  (root, my, ca, trust) to find the issuer certificates. If you are doing
--  a find in the "my" system store, than, this flag should be set to
--  improve performance.
-- 
--  Setting CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG in dwFindFlags
--  restricts CertGetCertificateChain to search the Local Machine
--  cached system stores instead of the Current User's.
-- 
--  Setting CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG in dwFindFlags
--  restricts CertGetCertificateChain to only search the URL cache
--  and not hit the wire.
-- --------------------------------------------------------------------------
--  Returns FALSE to skip this certificate. Otherwise, returns TRUE to
--  build a chain for this certificate.
type
t_290=^unchecked for machine_pointer use true;

PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK = ^procedure (
    pCert           : in PCCERT_CONTEXT;
    pvFindArg       : in t_290)
                      return BOOL for machine_pointer use true;
type
  _CERT_CHAIN_FIND_BY_ISSUER_PARA = record
cbSize          : DWORD;
pszUsageIdentifier : LPCSTR;
dwKeySpec       : DWORD;
dwAcquirePrivateKeyFlags : DWORD;
cIssuer         : DWORD;
rgIssuer        : ^CERT_NAME_BLOB;
pfnFindCallback : PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK;
pvFindArg       : ^unchecked;
  end record;
  CERT_CHAIN_FIND_ISSUER_PARA = _CERT_CHAIN_FIND_BY_ISSUER_PARA;
  PCERT_CHAIN_FIND_ISSUER_PARA = ^_CERT_CHAIN_FIND_BY_ISSUER_PARA;
  CERT_CHAIN_FIND_BY_ISSUER_PARA = _CERT_CHAIN_FIND_BY_ISSUER_PARA;
  PCERT_CHAIN_FIND_BY_ISSUER_PARA = ^_CERT_CHAIN_FIND_BY_ISSUER_PARA;

--  The following dwFindFlags can be set for CERT_CHAIN_FIND_BY_ISSUER
--  If set, compares the public key in the end certificate with the crypto
--  provider's public key. This comparison is the last check made on the
--  build chain.
const
  CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG= $01;

--  If not set, only checks the first simple chain for an issuer name match.
--  When set, also checks second and subsequent simple chains.
const
  CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG= $02;

--  If set, CertGetCertificateChain only searches the URL cache and
--  doesn't hit the wire.
const
  CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG= $04;

--  If set, CertGetCertificateChain only opens the Local Machine
--  certificate stores instead of the Current User's.
const
  CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG= $08;

--  If set, no check is made to see if the end certificate has a private
--  key associated with it.
const
  CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG= $4000;

--  By default, the hCertStore passed to CertFindChainInStore, is passed
--  as the additional store to CertGetCertificateChain. This flag can be
--  set to improve performance by only searching the cached system stores
--  (root, my, ca, trust) to find the issuer certificates. If not set, then,
--  the hCertStore is always searched in addition to the cached system
--  stores.
const
  CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG= $8000;

-- +=========================================================================
--  Certificate Chain Policy Data Structures and APIs
-- ==========================================================================
type
  _CERT_CHAIN_POLICY_PARA = record
cbSize          : DWORD;
dwFlags         : DWORD;
pvExtraPolicyPara : ^unchecked;
  end record;
  CERT_CHAIN_POLICY_PARA = _CERT_CHAIN_POLICY_PARA;
  PCERT_CHAIN_POLICY_PARA = ^_CERT_CHAIN_POLICY_PARA;

--  If both lChainIndex and lElementIndex are set to -1, the dwError applies
--  to the whole chain context. If only lElementIndex is set to -1, the
--  dwError applies to the lChainIndex'ed chain. Otherwise, the dwError applies
--  to the certificate element at
--  pChainContext->rgpChain[lChainIndex]->rgpElement[lElementIndex].
type
  _CERT_CHAIN_POLICY_STATUS = record
cbSize          : DWORD;
dwError         : DWORD;
lChainIndex     : LONG;
lElementIndex   : LONG;
pvExtraPolicyStatus : ^unchecked;
  end record;
  CERT_CHAIN_POLICY_STATUS = _CERT_CHAIN_POLICY_STATUS;
  PCERT_CHAIN_POLICY_STATUS = ^_CERT_CHAIN_POLICY_STATUS;

--  Common chain policy flags
const
  CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG= $01;

const
  CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG= $02;

const
  CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG= $04;

const
  CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG= $08;

const
  CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG= $10;

const
  CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG= $20;

const
  CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG= $40;

const
  CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG= $80;

const
  CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG= $0100;

const
  CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG= $0200;

const
  CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG= $0400;

const
  CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG= $0800;

const
  CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG= $8000;

const
  CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG= $4000;

-- +-------------------------------------------------------------------------
--  Verify that the certificate chain satisfies the specified policy
--  requirements. If we were able to verify the chain policy, TRUE is returned
--  and the dwError field of the pPolicyStatus is updated. A dwError of 0
--  (ERROR_SUCCESS, S_OK) indicates the chain satisfies the specified policy.
-- 
--  If dwError applies to the entire chain context, both lChainIndex and
--  lElementIndex are set to -1. If dwError applies to a simple chain,
--  lElementIndex is set to -1 and lChainIndex is set to the index of the
--  first offending chain having the error. If dwError applies to a
--  certificate element, lChainIndex and lElementIndex are updated to
--  index the first offending certificate having the error, where, the
--  the certificate element is at:
--  pChainContext->rgpChain[lChainIndex]->rgpElement[lElementIndex].
-- 
--  The dwFlags in pPolicyPara can be set to change the default policy checking
--  behaviour. In addition, policy specific parameters can be passed in
--  the pvExtraPolicyPara field of pPolicyPara.
-- 
--  In addition to returning dwError, in pPolicyStatus, policy OID specific
--  extra status may be returned via pvExtraPolicyStatus.
-- --------------------------------------------------------------------------
procedure CertVerifyCertificateChainPolicy(
    pszPolicyOID    : in LPCSTR; 
    pChainContext   : in PCCERT_CHAIN_CONTEXT; 
    pPolicyPara     : in PCERT_CHAIN_POLICY_PARA; 
    pPolicyStatus   : in out _CERT_CHAIN_POLICY_STATUS)
                      return BOOL;
#pragma convention(CertVerifyCertificateChainPolicy,system);
#pragma import(CertVerifyCertificateChainPolicy,'CertVerifyCertificateChainPolicy','crypt32.dll');

--  Predefined OID Function Names
--  CertDllVerifyCertificateChainPolicy has same function signature as
--  CertVerifyCertificateChainPolicy.
-- +-------------------------------------------------------------------------
--  Predefined verify chain policies
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_CHAIN_POLICY_BASE
-- 
--  Implements the base chain policy verification checks. dwFlags can
--  be set in pPolicyPara to alter the default policy checking behaviour.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_CHAIN_POLICY_AUTHENTICODE
-- 
--  Implements the Authenticode chain policy verification checks.
-- 
--  pvExtraPolicyPara may optionally be set to point to the following
--  AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA.
-- 
--  pvExtraPolicyStatus may optionally be set to point to the following
--  AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS.
-- --------------------------------------------------------------------------
--  dwRegPolicySettings are defined in wintrust.h
type
  _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = record
cbSize          : DWORD;
dwRegPolicySettings : DWORD;
pSignerInfo     : PCMSG_SIGNER_INFO;
  end record;
  AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;
  PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = ^_AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;

type
  _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = record
cbSize          : DWORD;
fCommercial     : BOOL;
  end record;
  AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;
  PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = ^_AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;

-- +-------------------------------------------------------------------------
--  CERT_CHAIN_POLICY_AUTHENTICODE_TS
-- 
--  Implements the Authenticode Time Stamp chain policy verification checks.
-- 
--  pvExtraPolicyPara may optionally be set to point to the following
--  AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA.
-- 
--  pvExtraPolicyStatus isn't used and must be set to NULL.
-- --------------------------------------------------------------------------
--  dwRegPolicySettings are defined in wintrust.h
type
  _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = record
cbSize          : DWORD;
dwRegPolicySettings : DWORD;
fCommercial     : BOOL;
  end record;
  AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;
  PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = ^_AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;

-- +-------------------------------------------------------------------------
--  CERT_CHAIN_POLICY_SSL
-- 
--  Implements the SSL client/server chain policy verification checks.
-- 
--  pvExtraPolicyPara may optionally be set to point to the following
--  SSL_EXTRA_CERT_CHAIN_POLICY_PARA data structure
-- --------------------------------------------------------------------------
--  fdwChecks flags are defined in wininet.h
type
  _HTTPSPolicyCallbackData = record
t_291            : record
      cbStruct      : DWORD for position use 0;
      cbSize        : DWORD for position use 0;
    end record;
dwAuthType      : DWORD;
fdwChecks       : DWORD;
pwszServerName  : ^WCHAR;
  end record;
  HTTPSPolicyCallbackData = _HTTPSPolicyCallbackData;
  PHTTPSPolicyCallbackData = ^_HTTPSPolicyCallbackData;
  SSL_EXTRA_CERT_CHAIN_POLICY_PARA = _HTTPSPolicyCallbackData;
  PSSL_EXTRA_CERT_CHAIN_POLICY_PARA = ^_HTTPSPolicyCallbackData;

-- +-------------------------------------------------------------------------
--  CERT_CHAIN_POLICY_BASIC_CONSTRAINTS
-- 
--  Implements the basic constraints chain policy.
-- 
--  Iterates through all the certificates in the chain checking for either
--  a szOID_BASIC_CONSTRAINTS or a szOID_BASIC_CONSTRAINTS2 extension. If
--  neither extension is present, the certificate is assumed to have
--  valid policy. Otherwise, for the first certificate element, checks if
--  it matches the expected CA_FLAG or END_ENTITY_FLAG specified in
--  pPolicyPara->dwFlags. If neither or both flags are set, then, the first
--  element can be either a CA or END_ENTITY. All other elements must be
--  a CA. If the PathLenConstraint is present in the extension, its
--  checked.
-- 
--  The first elements in the remaining simple chains (ie, the certificate
--  used to sign the CTL) are checked to be an END_ENTITY.
-- 
--  If this verification fails, dwError will be set to
--  TRUST_E_BASIC_CONSTRAINTS.
-- --------------------------------------------------------------------------
const
  BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG= $80000000;

const
  BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG= $40000000;

-- +-------------------------------------------------------------------------
--  CERT_CHAIN_POLICY_NT_AUTH
-- 
--  Implements the NT Authentication chain policy.
-- 
--  The NT Authentication chain policy consists of 3 distinct chain
--  verifications in the following order:
--  [1] CERT_CHAIN_POLICY_BASE - Implements the base chain policy
--  verification checks. The LOWORD of dwFlags can be set in
--  pPolicyPara to alter the default policy checking behaviour. See
--  CERT_CHAIN_POLICY_BASE for more details.
-- 
--  [2] CERT_CHAIN_POLICY_BASIC_CONSTRAINTS - Implements the basic
--  constraints chain policy. The HIWORD of dwFlags can be set
--  to specify if the first element must be either a CA or END_ENTITY.
--  See CERT_CHAIN_POLICY_BASIC_CONSTRAINTS for more details.
-- 
--  [3] Checks if the second element in the chain, the CA that issued
--  the end certificate, is a trusted CA for NT
--  Authentication. A CA is considered to be trusted if it exists in
--  the "NTAuth" system registry store found in the
--  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE store location.
--  If this verification fails, whereby the CA isn't trusted,
--  dwError is set to CERT_E_UNTRUSTEDCA.
-- 
--  If CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG is set
--  in the "Flags" value of the HKLM policy "ProtectedRoots" subkey
--  defined by CERT_PROT_ROOT_FLAGS_REGPATH, then,
--  if the above check fails, checks if the chain
--  has CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS set in dwInfoStatus. This
--  will only be set if there was a valid name constraint for all
--  name spaces including UPN. If the chain doesn't have this info
--  status set, dwError is set to CERT_E_UNTRUSTEDCA.
-- --------------------------------------------------------------------------
-- +-------------------------------------------------------------------------
--  CERT_CHAIN_POLICY_MICROSOFT_ROOT
-- 
--  Checks if the last element of the first simple chain contains a
--  Microsoft root public key. If it doesn't contain a Microsoft root
--  public key, dwError is set to CERT_E_UNTRUSTEDROOT.
-- 
--  pPolicyPara is optional. However,
--  MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG can be set in
--  the dwFlags in pPolicyPara to also check for the Microsoft Test Roots.
-- 
--  pvExtraPolicyPara and pvExtraPolicyStatus aren't used and must be set
--  to NULL.
-- --------------------------------------------------------------------------
const
  MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG= $10000;

-- +-------------------------------------------------------------------------
--  convert formatted string to binary
--  If cchString is 0, then pszString is NULL terminated and
--  cchString is obtained via strlen() + 1.
--  dwFlags defines string format
--  if pbBinary is NULL, *pcbBinary returns the size of required memory
--  *pdwSkip returns the character count of skipped strings, optional
--  *pdwFlags returns the actual format used in the conversion, optional
-- --------------------------------------------------------------------------
type
t_292=^BYTE for machine_pointer use true;

-- OPTIONAL
-- OPTIONAL
procedure CryptStringToBinaryA(
    pszString       : in LPCSTR; 
    cchString       : in DWORD; 
    dwFlags         : in DWORD; 
    pbBinary        : in t_292; 
    pcbBinary       : in out DWORD; 
    pdwSkip         : out DWORD; 
    pdwFlags        : out DWORD)
                      return BOOL;
#pragma convention(CryptStringToBinaryA,system);
#pragma import(CryptStringToBinaryA,'CryptStringToBinaryA','crypt32.dll');

-- +-------------------------------------------------------------------------
--  convert formatted string to binary
--  If cchString is 0, then pszString is NULL terminated and
--  cchString is obtained via strlen() + 1.
--  dwFlags defines string format
--  if pbBinary is NULL, *pcbBinary returns the size of required memory
--  *pdwSkip returns the character count of skipped strings, optional
--  *pdwFlags returns the actual format used in the conversion, optional
-- --------------------------------------------------------------------------
type
t_293=^BYTE for machine_pointer use true;

-- OPTIONAL
-- OPTIONAL
procedure CryptStringToBinaryW(
    pszString       : in LPCWSTR; 
    cchString       : in DWORD; 
    dwFlags         : in DWORD; 
    pbBinary        : in t_293; 
    pcbBinary       : in out DWORD; 
    pdwSkip         : out DWORD; 
    pdwFlags        : out DWORD)
                      return BOOL;
#pragma convention(CryptStringToBinaryW,system);
#pragma import(CryptStringToBinaryW,'CryptStringToBinaryW','crypt32.dll');

#if #declared UNICODE; then;
#template CryptStringToBinary;
  CryptStringToBinaryW 
#end CryptStringToBinary;
#else;
#template CryptStringToBinary;
  CryptStringToBinaryA 
#end CryptStringToBinary;
#end if;

-- +-------------------------------------------------------------------------
--  convert binary to formatted string
--  dwFlags defines string format
--  if pszString is NULL, *pcchString returns size in characters
--  including null-terminator
-- --------------------------------------------------------------------------
type
t_294=^BYTE for machine_pointer use true;

procedure CryptBinaryToStringA(
    pbBinary        : in t_294; 
    cbBinary        : in DWORD; 
    dwFlags         : in DWORD; 
    pszString       : in LPSTR; 
    pcchString      : in out DWORD)
                      return BOOL;
#pragma convention(CryptBinaryToStringA,system);
#pragma import(CryptBinaryToStringA,'CryptBinaryToStringA','crypt32.dll');

-- +-------------------------------------------------------------------------
--  convert binary to formatted string
--  dwFlags defines string format
--  if pszString is NULL, *pcchString returns size in characters
--  including null-terminator
-- --------------------------------------------------------------------------
type
t_295=^BYTE for machine_pointer use true;

procedure CryptBinaryToStringW(
    pbBinary        : in t_295; 
    cbBinary        : in DWORD; 
    dwFlags         : in DWORD; 
    pszString       : in LPWSTR; 
    pcchString      : in out DWORD)
                      return BOOL;
#pragma convention(CryptBinaryToStringW,system);
#pragma import(CryptBinaryToStringW,'CryptBinaryToStringW','crypt32.dll');

#if #declared UNICODE; then;
#template CryptBinaryToString;
  CryptBinaryToStringW 
#end CryptBinaryToString;
#else;
#template CryptBinaryToString;
  CryptBinaryToStringA 
#end CryptBinaryToString;
#end if;

--  dwFlags has the following defines
const
  CRYPT_STRING_BASE64HEADER= $00;

const
  CRYPT_STRING_BASE64= $01;

const
  CRYPT_STRING_BINARY= $02;

const
  CRYPT_STRING_BASE64REQUESTHEADER= $03;

const
  CRYPT_STRING_HEX  = $04;

const
  CRYPT_STRING_HEXASCII= $05;

const
  CRYPT_STRING_BASE64_ANY= $06;

const
  CRYPT_STRING_ANY  = $07;

const
  CRYPT_STRING_HEX_ANY= $08;

const
  CRYPT_STRING_BASE64X509CRLHEADER= $09;

const
  CRYPT_STRING_HEXADDR= $0A;

const
  CRYPT_STRING_HEXASCIIADDR= $0B;

const
  CRYPT_STRING_NOCR = $80000000;

--  CryptBinaryToString uses the following flags
--  CRYPT_STRING_BASE64HEADER - base64 format with certificate begin
--  and end headers
--  CRYPT_STRING_BASE64 - only base64 without headers
--  CRYPT_STRING_BINARY - pure binary copy
--  CRYPT_STRING_BASE64REQUESTHEADER - base64 format with request begin
--  and end headers
--  CRYPT_STRING_BASE64X509CRLHEADER - base64 format with x509 crl begin
--  and end headers
--  CRYPT_STRING_HEX - only hex format
--  CRYPT_STRING_HEXASCII - hex format with ascii char display
--  CRYPT_STRING_HEXADDR - hex format with address display
--  CRYPT_STRING_HEXASCIIADDR - hex format with ascii char and address display
-- 
--  CryptBinaryToString accepts CRYPT_STRING_NOCR or'd into one of the above.
--  When set, line breaks contain only LF, instead of CR-LF pairs.
--  CryptStringToBinary uses the following flags
--  CRYPT_STRING_BASE64_ANY tries the following, in order:
--  CRYPT_STRING_BASE64HEADER
--  CRYPT_STRING_BASE64
--  CRYPT_STRING_ANY tries the following, in order:
--  CRYPT_STRING_BASE64_ANY
--  CRYPT_STRING_BINARY -- should always succeed
--  CRYPT_STRING_HEX_ANY tries the following, in order:
--  CRYPT_STRING_HEXADDR
--  CRYPT_STRING_HEXASCIIADDR
--  CRYPT_STRING_HEXASCII
--  CRYPT_STRING_HEX
-- +=========================================================================
--  PFX (PKCS #12) function defintions and types
-- ==========================================================================
-- +-------------------------------------------------------------------------
--  PFXImportCertStore
-- 
--  Import the PFX blob and return a store containing certificates
-- 
--  If the password parameter is incorrect or any other problems decoding
--  the PFX blob are encountered, the function will return NULL and the
--  error code can be found from GetLastError(). 
-- 
--  The dwFlags parameter may be set to the following:
--  CRYPT_EXPORTABLE - specify that any imported keys should be marked as 
--  exportable (see documentation on CryptImportKey)
--  CRYPT_USER_PROTECTED - (see documentation on CryptImportKey)
--  CRYPT_MACHINE_KEYSET - used to force the private key to be stored in the
--  the local machine and not the current user.
--  CRYPT_USER_KEYSET - used to force the private key to be stored in the
--  the current user and not the local machine, even if
--  the pfx blob specifies that it should go into local
--  machine.
-- --------------------------------------------------------------------------
type
t_296=^CRYPT_DATA_BLOB for machine_pointer use true;

procedure PFXImportCertStore(
    pPFX            : in t_296; 
    szPassword      : in LPCWSTR; 
    dwFlags         : in DWORD)
                      return t_HCERTSTORE;
#pragma convention(PFXImportCertStore,system);
#pragma import(PFXImportCertStore,'PFXImportCertStore','crypt32.dll');

--  dwFlags definitions for PFXImportCertStore
-- #define CRYPT_EXPORTABLE 0x00000001 // CryptImportKey dwFlags
-- #define CRYPT_USER_PROTECTED 0x00000002 // CryptImportKey dwFlags
-- #define CRYPT_MACHINE_KEYSET 0x00000020 // CryptAcquireContext dwFlags
const
  CRYPT_USER_KEYSET = $1000;

const
  PKCS12_IMPORT_RESERVED_MASK= $FFFF0000;

-- +-------------------------------------------------------------------------
--  PFXIsPFXBlob
-- 
--  This function will try to decode the outer layer of the blob as a pfx 
--  blob, and if that works it will return TRUE, it will return FALSE otherwise
-- 
-- --------------------------------------------------------------------------
type
t_297=^CRYPT_DATA_BLOB for machine_pointer use true;

procedure PFXIsPFXBlob(
    pPFX            : in t_297)
                      return BOOL;
#pragma convention(PFXIsPFXBlob,system);
#pragma import(PFXIsPFXBlob,'PFXIsPFXBlob','crypt32.dll');

-- +-------------------------------------------------------------------------
--  PFXVerifyPassword
-- 
--  This function will attempt to decode the outer layer of the blob as a pfx 
--  blob and decrypt with the given password. No data from the blob will be
--  imported.
-- 
--  Return value is TRUE if password appears correct, FALSE otherwise.
-- 
-- --------------------------------------------------------------------------
type
t_298=^CRYPT_DATA_BLOB for machine_pointer use true;

procedure PFXVerifyPassword(
    pPFX            : in t_298; 
    szPassword      : in LPCWSTR; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(PFXVerifyPassword,system);
#pragma import(PFXVerifyPassword,'PFXVerifyPassword','crypt32.dll');

-- +-------------------------------------------------------------------------
--  PFXExportCertStoreEx
-- 
--  Export the certificates and private keys referenced in the passed-in store 
-- 
--  This API encodes the blob under a stronger algorithm. The resulting
--  PKCS12 blobs are incompatible with the earlier PFXExportCertStore API.
-- 
--  The value passed in the password parameter will be used to encrypt and 
--  verify the integrity of the PFX packet. If any problems encoding the store
--  are encountered, the function will return FALSE and the error code can 
--  be found from GetLastError(). 
-- 
--  The dwFlags parameter may be set to any combination of 
--  EXPORT_PRIVATE_KEYS
--  REPORT_NO_PRIVATE_KEY
--  REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
-- 
--  The encoded PFX blob is returned in *pPFX. If pPFX->pbData is NULL upon
--  input, this is a length only calculation, whereby, pPFX->cbData is updated
--  with the number of bytes required for the encoded blob. Otherwise,
--  the memory pointed to by pPFX->pbData is updated with the encoded bytes
--  and pPFX->cbData is updated with the encoded byte length.
-- --------------------------------------------------------------------------
type
t_299=^unchecked for machine_pointer use true;

procedure PFXExportCertStoreEx(
    hStore          : in t_HCERTSTORE; 
    pPFX            : in out CRYPT_DATA_BLOB; 
    szPassword      : in LPCWSTR; 
    pvReserved      : in t_299; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(PFXExportCertStoreEx,system);
#pragma import(PFXExportCertStoreEx,'PFXExportCertStoreEx','crypt32.dll');

--  dwFlags definitions for PFXExportCertStoreEx
const
  REPORT_NO_PRIVATE_KEY= $01;

const
  REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY= $02;

const
  EXPORT_PRIVATE_KEYS= $04;

const
  PKCS12_EXPORT_RESERVED_MASK= $FFFF0000;

-- +-------------------------------------------------------------------------
--  PFXExportCertStore
-- 
--  Export the certificates and private keys referenced in the passed-in store 
-- 
--  This is an old API kept for compatibility with IE4 clients. New applications
--  should call the above PfxExportCertStoreEx for enhanced security.
-- --------------------------------------------------------------------------
procedure PFXExportCertStore(
    hStore          : in t_HCERTSTORE; 
    pPFX            : in out CRYPT_DATA_BLOB; 
    szPassword      : in LPCWSTR; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(PFXExportCertStore,system);
#pragma import(PFXExportCertStore,'PFXExportCertStore','crypt32.dll');

-- #pragma  warning(pop)
-- #pragma  warning(default:4201)

end wincrypt;
