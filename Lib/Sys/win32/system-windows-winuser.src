----------------------------------------------------------------------------------------------------
module winuser =
-- Win32 API Binding
-- Translation to Flex Copyright (C) 2003-2004 A && L soft
----------------------------------------------------------------------------------------------------

with
    windef,winnt,basetsd,wingdi,winbase,stdarg;

-- /****************************************************************************
-- *                                                                           *
-- * winuser.h -- USER procedure declarations, constant definitions and macros *
-- *                                                                           *
-- * Copyright (c) Microsoft Corporation. All rights reserved.                          *
-- *                                                                           *
-- ****************************************************************************/
-- 
--  Define API decoration for direct importing of DLL references.
-- 
type
HDWP              = t_HANDLE;
type
MENUTEMPLATEA     = record end record;
type
MENUTEMPLATEW     = record end record;
#if #declared UNICODE; then;
type
MENUTEMPLATE      = MENUTEMPLATEW;
#else;
type
MENUTEMPLATE      = MENUTEMPLATEA;
#end if;

type
LPMENUTEMPLATEA   = PVOID;
type
LPMENUTEMPLATEW   = PVOID;
#if #declared UNICODE; then;
type
LPMENUTEMPLATE    = LPMENUTEMPLATEW;
#else;
type
LPMENUTEMPLATE    = LPMENUTEMPLATEA;
#end if;

type
WNDPROC           = ^procedure (
    _001            : t_HWND;
    _002            : UINT;
    _003            : t_WPARAM;
    _004            : t_LPARAM)
                      return t_LRESULT for machine_pointer use true;
type
DLGPROC           = FARPROC;
type
TIMERPROC         = FARPROC;
type
GRAYSTRINGPROC    = FARPROC;
type
WNDENUMPROC       = FARPROC;
type
HOOKPROC          = FARPROC;
type
SENDASYNCPROC     = FARPROC;
type
EDITWORDBREAKPROCA = FARPROC;
type
EDITWORDBREAKPROCW = FARPROC;
type
PROPENUMPROCA     = FARPROC;
type
PROPENUMPROCW     = FARPROC;
type
PROPENUMPROCEXA   = FARPROC;
type
PROPENUMPROCEXW   = FARPROC;
type
DRAWSTATEPROC     = FARPROC;
#if #declared UNICODE; then;
type
PROPENUMPROC      = PROPENUMPROCW;
type
PROPENUMPROCEX    = PROPENUMPROCEXW;
type
EDITWORDBREAKPROC = EDITWORDBREAKPROCW;
#else;
type
PROPENUMPROC      = PROPENUMPROCA;
type
PROPENUMPROCEX    = PROPENUMPROCEXA;
type
EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
#end if;

type
NAMEENUMPROCA     = FARPROC;
type
NAMEENUMPROCW     = FARPROC;
type
WINSTAENUMPROCA   = FARPROC;
type
DESKTOPENUMPROCA  = FARPROC;
type
WINSTAENUMPROCW   = FARPROC;
type
DESKTOPENUMPROCW  = FARPROC;
#if #declared UNICODE; then;
type
WINSTAENUMPROC    = WINSTAENUMPROCW;
type
DESKTOPENUMPROC   = DESKTOPENUMPROCW;
#else;
type
WINSTAENUMPROC    = WINSTAENUMPROCA;
type
DESKTOPENUMPROC   = DESKTOPENUMPROCA;
#end if;

#if #declared UNICODE; then;
#template MAKEINTRESOURCE;
  {MAKEINTRESOURCEW(i)} (LPWSTR)((ULONG_PTR)((WORD)(i))) 
#end MAKEINTRESOURCE;
#else;
#template MAKEINTRESOURCE;
  {MAKEINTRESOURCEA(i)} (LPSTR)((ULONG_PTR)((WORD)(i))) 
#end MAKEINTRESOURCE;
#end if;

-- /*
--  * Predefined Resource Types
--  */
const
  DIFFERENCE        = 11;

type
  t_001 = signed 32;

procedure wvsprintfA(
    _001            : out CHARSTR ; 
    _002            : in LPCSTR; 
    arglist         : in va_list)
                      return t_001;
#pragma convention(wvsprintfA,system);
#pragma import(wvsprintfA,'wvsprintfA','user32.dll');

type
  t_002 = signed 32;

procedure wvsprintfW(
    _001            : out WCHARSTR ; 
    _002            : in LPCWSTR; 
    arglist         : in va_list)
                      return t_002;
#pragma convention(wvsprintfW,system);
#pragma import(wvsprintfW,'wvsprintfW','user32.dll');

#if #declared UNICODE; then;
#template wvsprintf;
  wvsprintfW 
#end wvsprintf;
#else;
#template wvsprintf;
  wvsprintfA 
#end wvsprintf;
#end if;

type
  t_003 = signed 32;

procedure wsprintfA(
    _001            : out CHARSTR ; 
    _002            : in LPCSTR)
                      return t_003;
#pragma import(wsprintfA,'wsprintfA','user32.dll');

type
  t_004 = signed 32;

procedure wsprintfW(
    _001            : out WCHARSTR ; 
    _002            : in LPCWSTR)
                      return t_004;
#pragma import(wsprintfW,'wsprintfW','user32.dll');

#if #declared UNICODE; then;
#template wsprintf;
  wsprintfW 
#end wsprintf;
#else;
#template wsprintf;
  wsprintfA 
#end wsprintf;
#end if;

-- /*
--  * SPI_SETDESKWALLPAPER defined constants
--  */
-- /*
--  * Scroll Bar Constants
--  */
const
  SB_HORZ           = 0;

const
  SB_VERT           = 1;

const
  SB_CTL            = 2;

const
  SB_BOTH           = 3;

-- /*
--  * Scroll Bar Commands
--  */
const
  SB_LINEUP         = 0;

const
  SB_LINELEFT       = 0;

const
  SB_LINEDOWN       = 1;

const
  SB_LINERIGHT      = 1;

const
  SB_PAGEUP         = 2;

const
  SB_PAGELEFT       = 2;

const
  SB_PAGEDOWN       = 3;

const
  SB_PAGERIGHT      = 3;

const
  SB_THUMBPOSITION  = 4;

const
  SB_THUMBTRACK     = 5;

const
  SB_TOP            = 6;

const
  SB_LEFT           = 6;

const
  SB_BOTTOM         = 7;

const
  SB_RIGHT          = 7;

const
  SB_ENDSCROLL      = 8;

-- /*
--  * ShowWindow() Commands
--  */
const
  SW_HIDE           = 0;

const
  SW_SHOWNORMAL     = 1;

const
  SW_NORMAL         = 1;

const
  SW_SHOWMINIMIZED  = 2;

const
  SW_SHOWMAXIMIZED  = 3;

const
  SW_MAXIMIZE       = 3;

const
  SW_SHOWNOACTIVATE = 4;

const
  SW_SHOW           = 5;

const
  SW_MINIMIZE       = 6;

const
  SW_SHOWMINNOACTIVE= 7;

const
  SW_SHOWNA         = 8;

const
  SW_RESTORE        = 9;

const
  SW_SHOWDEFAULT    = 10;

const
  SW_FORCEMINIMIZE  = 11;

const
  SW_MAX            = 11;

-- /*
--  * Old ShowWindow() Commands
--  */
const
  HIDE_WINDOW       = 0;

const
  SHOW_OPENWINDOW   = 1;

const
  SHOW_ICONWINDOW   = 2;

const
  SHOW_FULLSCREEN   = 3;

const
  SHOW_OPENNOACTIVATE= 4;

-- /*
--  * Identifiers for the WM_SHOWWINDOW message
--  */
const
  SW_PARENTCLOSING  = 1;

const
  SW_OTHERZOOM      = 2;

const
  SW_PARENTOPENING  = 3;

const
  SW_OTHERUNZOOM    = 4;

-- /*
--  * AnimateWindow() Commands
--  */
const
  AW_HOR_POSITIVE   = $01;

const
  AW_HOR_NEGATIVE   = $02;

const
  AW_VER_POSITIVE   = $04;

const
  AW_VER_NEGATIVE   = $08;

const
  AW_CENTER         = $10;

const
  AW_HIDE           = $10000;

const
  AW_ACTIVATE       = $20000;

const
  AW_SLIDE          = $40000;

const
  AW_BLEND          = $80000;

-- /*
--  * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags
--  */
const
  KF_EXTENDED       = $0100;

const
  KF_DLGMODE        = $0800;

const
  KF_MENUMODE       = $1000;

const
  KF_ALTDOWN        = $2000;

const
  KF_REPEAT         = $4000;

const
  KF_UP             = $8000;

-- /*
--  * Virtual Keys, Standard Set
--  */
const
  VK_LBUTTON        = $01;

const
  VK_RBUTTON        = $02;

const
  VK_CANCEL         = $03;

const
  VK_MBUTTON        = $04;

const
  VK_XBUTTON1       = $05;

const
  VK_XBUTTON2       = $06;

-- /*
--  * 0x07 : unassigned
--  */
const
  VK_BACK           = $08;

const
  VK_TAB            = $09;

-- /*
--  * 0x0A - 0x0B : reserved
--  */
const
  VK_CLEAR          = $0C;

const
  VK_RETURN         = $0D;

const
  VK_SHIFT          = $10;

const
  VK_CONTROL        = $11;

const
  VK_MENU           = $12;

const
  VK_PAUSE          = $13;

const
  VK_CAPITAL        = $14;

const
  VK_KANA           = $15;

const
  VK_HANGEUL        = $15;

const
  VK_HANGUL         = $15;

const
  VK_JUNJA          = $17;

const
  VK_FINAL          = $18;

const
  VK_HANJA          = $19;

const
  VK_KANJI          = $19;

const
  VK_ESCAPE         = $1B;

const
  VK_CONVERT        = $1C;

const
  VK_NONCONVERT     = $1D;

const
  VK_ACCEPT         = $1E;

const
  VK_MODECHANGE     = $1F;

const
  VK_SPACE          = $20;

const
  VK_PRIOR          = $21;

const
  VK_NEXT           = $22;

const
  VK_END            = $23;

const
  VK_HOME           = $24;

const
  VK_LEFT           = $25;

const
  VK_UP             = $26;

const
  VK_RIGHT          = $27;

const
  VK_DOWN           = $28;

const
  VK_SELECT         = $29;

const
  VK_PRINT          = $2A;

const
  VK_EXECUTE        = $2B;

const
  VK_SNAPSHOT       = $2C;

const
  VK_INSERT         = $2D;

const
  VK_DELETE         = $2E;

const
  VK_HELP           = $2F;

-- /*
--  * VK_0 - VK_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
--  * 0x40 : unassigned
--  * VK_A - VK_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
--  */
const
  VK_LWIN           = $5B;

const
  VK_RWIN           = $5C;

const
  VK_APPS           = $5D;

-- /*
--  * 0x5E : reserved
--  */
const
  VK_SLEEP          = $5F;

const
  VK_NUMPAD0        = $60;

const
  VK_NUMPAD1        = $61;

const
  VK_NUMPAD2        = $62;

const
  VK_NUMPAD3        = $63;

const
  VK_NUMPAD4        = $64;

const
  VK_NUMPAD5        = $65;

const
  VK_NUMPAD6        = $66;

const
  VK_NUMPAD7        = $67;

const
  VK_NUMPAD8        = $68;

const
  VK_NUMPAD9        = $69;

const
  VK_MULTIPLY       = $6A;

const
  VK_ADD            = $6B;

const
  VK_SEPARATOR      = $6C;

const
  VK_SUBTRACT       = $6D;

const
  VK_DECIMAL        = $6E;

const
  VK_DIVIDE         = $6F;

const
  VK_F1             = $70;

const
  VK_F2             = $71;

const
  VK_F3             = $72;

const
  VK_F4             = $73;

const
  VK_F5             = $74;

const
  VK_F6             = $75;

const
  VK_F7             = $76;

const
  VK_F8             = $77;

const
  VK_F9             = $78;

const
  VK_F10            = $79;

const
  VK_F11            = $7A;

const
  VK_F12            = $7B;

const
  VK_F13            = $7C;

const
  VK_F14            = $7D;

const
  VK_F15            = $7E;

const
  VK_F16            = $7F;

const
  VK_F17            = $80;

const
  VK_F18            = $81;

const
  VK_F19            = $82;

const
  VK_F20            = $83;

const
  VK_F21            = $84;

const
  VK_F22            = $85;

const
  VK_F23            = $86;

const
  VK_F24            = $87;

-- /*
--  * 0x88 - 0x8F : unassigned
--  */
const
  VK_NUMLOCK        = $90;

const
  VK_SCROLL         = $91;

-- /*
--  * NEC PC-9800 kbd definitions
--  */
const
  VK_OEM_NEC_EQUAL  = $92;

-- /*
--  * Fujitsu/OASYS kbd definitions
--  */
const
  VK_OEM_FJ_JISHO   = $92;

const
  VK_OEM_FJ_MASSHOU = $93;

const
  VK_OEM_FJ_TOUROKU = $94;

const
  VK_OEM_FJ_LOYA    = $95;

const
  VK_OEM_FJ_ROYA    = $96;

-- /*
--  * 0x97 - 0x9F : unassigned
--  */
-- /*
--  * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
--  * Used only as parameters to GetAsyncKeyState() and GetKeyState().
--  * No other API or message will distinguish left and right keys in this way.
--  */
const
  VK_LSHIFT         = $A0;

const
  VK_RSHIFT         = $A1;

const
  VK_LCONTROL       = $A2;

const
  VK_RCONTROL       = $A3;

const
  VK_LMENU          = $A4;

const
  VK_RMENU          = $A5;

const
  VK_BROWSER_BACK   = $A6;

const
  VK_BROWSER_FORWARD= $A7;

const
  VK_BROWSER_REFRESH= $A8;

const
  VK_BROWSER_STOP   = $A9;

const
  VK_BROWSER_SEARCH = $AA;

const
  VK_BROWSER_FAVORITES= $AB;

const
  VK_BROWSER_HOME   = $AC;

const
  VK_VOLUME_MUTE    = $AD;

const
  VK_VOLUME_DOWN    = $AE;

const
  VK_VOLUME_UP      = $AF;

const
  VK_MEDIA_NEXT_TRACK= $B0;

const
  VK_MEDIA_PREV_TRACK= $B1;

const
  VK_MEDIA_STOP     = $B2;

const
  VK_MEDIA_PLAY_PAUSE= $B3;

const
  VK_LAUNCH_MAIL    = $B4;

const
  VK_LAUNCH_MEDIA_SELECT= $B5;

const
  VK_LAUNCH_APP1    = $B6;

const
  VK_LAUNCH_APP2    = $B7;

-- /*
--  * 0xB8 - 0xB9 : reserved
--  */
const
  VK_OEM_1          = $BA;

const
  VK_OEM_PLUS       = $BB;

const
  VK_OEM_COMMA      = $BC;

const
  VK_OEM_MINUS      = $BD;

const
  VK_OEM_PERIOD     = $BE;

const
  VK_OEM_2          = $BF;

const
  VK_OEM_3          = $C0;

-- /*
--  * 0xC1 - 0xD7 : reserved
--  */
-- /*
--  * 0xD8 - 0xDA : unassigned
--  */
const
  VK_OEM_4          = $DB;

const
  VK_OEM_5          = $DC;

const
  VK_OEM_6          = $DD;

const
  VK_OEM_7          = $DE;

const
  VK_OEM_8          = $DF;

-- /*
--  * 0xE0 : reserved
--  */
-- /*
--  * Various extended or enhanced keyboards
--  */
const
  VK_OEM_AX         = $E1;

const
  VK_OEM_102        = $E2;

const
  VK_ICO_HELP       = $E3;

const
  VK_ICO_00         = $E4;

const
  VK_PROCESSKEY     = $E5;

const
  VK_ICO_CLEAR      = $E6;

const
  VK_PACKET         = $E7;

-- /*
--  * 0xE8 : unassigned
--  */
-- /*
--  * Nokia/Ericsson definitions
--  */
const
  VK_OEM_RESET      = $E9;

const
  VK_OEM_JUMP       = $EA;

const
  VK_OEM_PA1        = $EB;

const
  VK_OEM_PA2        = $EC;

const
  VK_OEM_PA3        = $ED;

const
  VK_OEM_WSCTRL     = $EE;

const
  VK_OEM_CUSEL      = $EF;

const
  VK_OEM_ATTN       = $F0;

const
  VK_OEM_FINISH     = $F1;

const
  VK_OEM_COPY       = $F2;

const
  VK_OEM_AUTO       = $F3;

const
  VK_OEM_ENLW       = $F4;

const
  VK_OEM_BACKTAB    = $F5;

const
  VK_ATTN           = $F6;

const
  VK_CRSEL          = $F7;

const
  VK_EXSEL          = $F8;

const
  VK_EREOF          = $F9;

const
  VK_PLAY           = $FA;

const
  VK_ZOOM           = $FB;

const
  VK_NONAME         = $FC;

const
  VK_PA1            = $FD;

const
  VK_OEM_CLEAR      = $FE;

-- /*
--  * 0xFF : reserved
--  */
-- /*
--  * SetWindowsHook() codes
--  */
const
  WH_JOURNALRECORD  = 0;

const
  WH_JOURNALPLAYBACK= 1;

const
  WH_KEYBOARD       = 2;

const
  WH_GETMESSAGE     = 3;

const
  WH_CALLWNDPROC    = 4;

const
  WH_CBT            = 5;

const
  WH_SYSMSGFILTER   = 6;

const
  WH_MOUSE          = 7;

const
  WH_DEBUG          = 9;

const
  WH_SHELL          = 10;

const
  WH_FOREGROUNDIDLE = 11;

const
  WH_CALLWNDPROCRET = 12;

const
  WH_KEYBOARD_LL    = 13;

const
  WH_MOUSE_LL       = 14;

const
  WH_MAX            = 14;

-- /*
--  * Hook Codes
--  */
const
  HC_ACTION         = 0;

const
  HC_GETNEXT        = 1;

const
  HC_SKIP           = 2;

const
  HC_NOREMOVE       = 3;

const
  HC_SYSMODALON     = 4;

const
  HC_SYSMODALOFF    = 5;

-- /*
--  * CBT Hook Codes
--  */
const
  HCBT_MOVESIZE     = 0;

const
  HCBT_MINMAX       = 1;

const
  HCBT_QS           = 2;

const
  HCBT_CREATEWND    = 3;

const
  HCBT_DESTROYWND   = 4;

const
  HCBT_ACTIVATE     = 5;

const
  HCBT_CLICKSKIPPED = 6;

const
  HCBT_KEYSKIPPED   = 7;

const
  HCBT_SYSCOMMAND   = 8;

const
  HCBT_SETFOCUS     = 9;

-- /*
--  * HCBT_CREATEWND parameters pointed to by lParam
--  */
type  tagCREATESTRUCTA;

type
  tagCBT_CREATEWNDA = record
  lpcs              : ^tagCREATESTRUCTA;
hwndInsertAfter : t_HWND;
  end record;
  CBT_CREATEWNDA    = tagCBT_CREATEWNDA;
  LPCBT_CREATEWNDA  = ^tagCBT_CREATEWNDA;

-- /*
--  * HCBT_CREATEWND parameters pointed to by lParam
--  */
type  tagCREATESTRUCTW;

type
  tagCBT_CREATEWNDW = record
  lpcs              : ^tagCREATESTRUCTW;
hwndInsertAfter : t_HWND;
  end record;
  CBT_CREATEWNDW    = tagCBT_CREATEWNDW;
  LPCBT_CREATEWNDW  = ^tagCBT_CREATEWNDW;

#if #declared UNICODE; then;
type
CBT_CREATEWND     = CBT_CREATEWNDW;
type
LPCBT_CREATEWND   = LPCBT_CREATEWNDW;
#else;
type
CBT_CREATEWND     = CBT_CREATEWNDA;
type
LPCBT_CREATEWND   = LPCBT_CREATEWNDA;
#end if;

-- /*
--  * HCBT_ACTIVATE structure pointed to by lParam
--  */
type
  tagCBTACTIVATESTRUCT = record
fMouse          : BOOL;
hWndActive      : t_HWND;
  end record;
  CBTACTIVATESTRUCT = tagCBTACTIVATESTRUCT;
  LPCBTACTIVATESTRUCT = ^tagCBTACTIVATESTRUCT;

-- /*
--  * WTSSESSION_NOTIFICATION struct pointed by lParam, for WM_WTSSESSION_CHANGE
--  */
type
  tagWTSSESSION_NOTIFICATION = record
cbSize          : DWORD;
dwSessionId     : DWORD;
  end record;
  WTSSESSION_NOTIFICATION = tagWTSSESSION_NOTIFICATION;
  PWTSSESSION_NOTIFICATION = ^tagWTSSESSION_NOTIFICATION;

-- /*
--  * codes passed in WPARAM for WM_WTSSESSION_CHANGE
--  */
const
  WTS_CONSOLE_CONNECT= $01;

const
  WTS_CONSOLE_DISCONNECT= $02;

const
  WTS_REMOTE_CONNECT= $03;

const
  WTS_REMOTE_DISCONNECT= $04;

const
  WTS_SESSION_LOGON = $05;

const
  WTS_SESSION_LOGOFF= $06;

const
  WTS_SESSION_LOCK  = $07;

const
  WTS_SESSION_UNLOCK= $08;

const
  WTS_SESSION_REMOTE_CONTROL= $09;

-- /*
--  * WH_MSGFILTER Filter Proc Codes
--  */
const
  MSGF_DIALOGBOX    = 0;

const
  MSGF_MESSAGEBOX   = 1;

const
  MSGF_MENU         = 2;

const
  MSGF_SCROLLBAR    = 5;

const
  MSGF_NEXTWINDOW   = 6;

const
  MSGF_MAX          = 8;

const
  MSGF_USER         = 4096;

-- /*
--  * Shell support
--  */
const
  HSHELL_WINDOWCREATED= 1;

const
  HSHELL_WINDOWDESTROYED= 2;

const
  HSHELL_ACTIVATESHELLWINDOW= 3;

const
  HSHELL_WINDOWACTIVATED= 4;

const
  HSHELL_GETMINRECT = 5;

const
  HSHELL_REDRAW     = 6;

const
  HSHELL_TASKMAN    = 7;

const
  HSHELL_LANGUAGE   = 8;

const
  HSHELL_SYSMENU    = 9;

const
  HSHELL_ENDTASK    = 10;

const
  HSHELL_ACCESSIBILITYSTATE= 11;

const
  HSHELL_APPCOMMAND = 12;

const
  HSHELL_WINDOWREPLACED= 13;

const
  HSHELL_WINDOWREPLACING= 14;

const
  HSHELL_HIGHBIT    = $8000;

-- /* wparam for HSHELL_ACCESSIBILITYSTATE 
const
  ACCESS_STICKYKEYS = $01;

const
  ACCESS_FILTERKEYS = $02;

const
  ACCESS_MOUSEKEYS  = $03;

-- /* cmd for HSHELL_APPCOMMAND and WM_APPCOMMAND 
const
  APPCOMMAND_BROWSER_BACKWARD= 1;

const
  APPCOMMAND_BROWSER_FORWARD= 2;

const
  APPCOMMAND_BROWSER_REFRESH= 3;

const
  APPCOMMAND_BROWSER_STOP= 4;

const
  APPCOMMAND_BROWSER_SEARCH= 5;

const
  APPCOMMAND_BROWSER_FAVORITES= 6;

const
  APPCOMMAND_BROWSER_HOME= 7;

const
  APPCOMMAND_VOLUME_MUTE= 8;

const
  APPCOMMAND_VOLUME_DOWN= 9;

const
  APPCOMMAND_VOLUME_UP= 10;

const
  APPCOMMAND_MEDIA_NEXTTRACK= 11;

const
  APPCOMMAND_MEDIA_PREVIOUSTRACK= 12;

const
  APPCOMMAND_MEDIA_STOP= 13;

const
  APPCOMMAND_MEDIA_PLAY_PAUSE= 14;

const
  APPCOMMAND_LAUNCH_MAIL= 15;

const
  APPCOMMAND_LAUNCH_MEDIA_SELECT= 16;

const
  APPCOMMAND_LAUNCH_APP1= 17;

const
  APPCOMMAND_LAUNCH_APP2= 18;

const
  APPCOMMAND_BASS_DOWN= 19;

const
  APPCOMMAND_BASS_BOOST= 20;

const
  APPCOMMAND_BASS_UP= 21;

const
  APPCOMMAND_TREBLE_DOWN= 22;

const
  APPCOMMAND_TREBLE_UP= 23;

const
  APPCOMMAND_MICROPHONE_VOLUME_MUTE= 24;

const
  APPCOMMAND_MICROPHONE_VOLUME_DOWN= 25;

const
  APPCOMMAND_MICROPHONE_VOLUME_UP= 26;

const
  APPCOMMAND_HELP   = 27;

const
  APPCOMMAND_FIND   = 28;

const
  APPCOMMAND_NEW    = 29;

const
  APPCOMMAND_OPEN   = 30;

const
  APPCOMMAND_CLOSE  = 31;

const
  APPCOMMAND_SAVE   = 32;

const
  APPCOMMAND_PRINT  = 33;

const
  APPCOMMAND_UNDO   = 34;

const
  APPCOMMAND_REDO   = 35;

const
  APPCOMMAND_COPY   = 36;

const
  APPCOMMAND_CUT    = 37;

const
  APPCOMMAND_PASTE  = 38;

const
  APPCOMMAND_REPLY_TO_MAIL= 39;

const
  APPCOMMAND_FORWARD_MAIL= 40;

const
  APPCOMMAND_SEND_MAIL= 41;

const
  APPCOMMAND_SPELL_CHECK= 42;

const
  APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE= 43;

const
  APPCOMMAND_MIC_ON_OFF_TOGGLE= 44;

const
  APPCOMMAND_CORRECTION_LIST= 45;

const
  APPCOMMAND_MEDIA_PLAY= 46;

const
  APPCOMMAND_MEDIA_PAUSE= 47;

const
  APPCOMMAND_MEDIA_RECORD= 48;

const
  APPCOMMAND_MEDIA_FAST_FORWARD= 49;

const
  APPCOMMAND_MEDIA_REWIND= 50;

const
  APPCOMMAND_MEDIA_CHANNEL_UP= 51;

const
  APPCOMMAND_MEDIA_CHANNEL_DOWN= 52;

const
  FAPPCOMMAND_MOUSE = $8000;

const
  FAPPCOMMAND_KEY   = 0;

const
  FAPPCOMMAND_OEM   = $1000;

const
  FAPPCOMMAND_MASK  = $F000;

type
  SHELLHOOKINFO     = record
hwnd            : t_HWND;
rc              : RECT;
  end record;
  LPSHELLHOOKINFO   = ^SHELLHOOKINFO;

-- /*
--  * Message Structure used in Journaling
--  */
type
  tagEVENTMSG       = record
_message        : UINT;
paramL          : UINT;
paramH          : UINT;
time            : DWORD;
hwnd            : t_HWND;
  end record;
  EVENTMSG          = tagEVENTMSG;
  PEVENTMSGMSG      = ^tagEVENTMSG;
  NPEVENTMSGMSG     = ^tagEVENTMSG;
  LPEVENTMSGMSG     = ^tagEVENTMSG;

type
  PEVENTMSG         = ^tagEVENTMSG;
  NPEVENTMSG        = ^tagEVENTMSG;
  LPEVENTMSG        = ^tagEVENTMSG;
-- /*
--  * Message structure used by WH_CALLWNDPROC
--  */
type
  tagCWPSTRUCT      = record
lParam          : t_LPARAM;
wParam          : t_WPARAM;
_message        : UINT;
hwnd            : t_HWND;
  end record;
  CWPSTRUCT         = tagCWPSTRUCT;
  PCWPSTRUCT        = ^tagCWPSTRUCT;
  NPCWPSTRUCT       = ^tagCWPSTRUCT;
  LPCWPSTRUCT       = ^tagCWPSTRUCT;

-- /*
--  * Message structure used by WH_CALLWNDPROCRET
--  */
type
  tagCWPRETSTRUCT   = record
lResult         : t_LRESULT;
lParam          : t_LPARAM;
wParam          : t_WPARAM;
_message        : UINT;
hwnd            : t_HWND;
  end record;
  CWPRETSTRUCT      = tagCWPRETSTRUCT;
  PCWPRETSTRUCT     = ^tagCWPRETSTRUCT;
  NPCWPRETSTRUCT    = ^tagCWPRETSTRUCT;
  LPCWPRETSTRUCT    = ^tagCWPRETSTRUCT;

-- /*
--  * Low level hook flags
--  */
const
  LLKHF_INJECTED    = $10;

const
  LLMHF_INJECTED    = $01;

-- /*
--  * Structure used by WH_KEYBOARD_LL
--  */
type
  tagKBDLLHOOKSTRUCT = record
vkCode          : DWORD;
scanCode        : DWORD;
flags           : DWORD;
time            : DWORD;
dwExtraInfo     : ULONG_PTR;
  end record;
  KBDLLHOOKSTRUCT   = tagKBDLLHOOKSTRUCT;
  LPKBDLLHOOKSTRUCT = ^tagKBDLLHOOKSTRUCT;
  PKBDLLHOOKSTRUCT  = ^tagKBDLLHOOKSTRUCT;

-- /*
--  * Structure used by WH_MOUSE_LL
--  */
type
  tagMSLLHOOKSTRUCT = record
pt              : t_POINT;
mouseData       : DWORD;
flags           : DWORD;
time            : DWORD;
dwExtraInfo     : ULONG_PTR;
  end record;
  MSLLHOOKSTRUCT    = tagMSLLHOOKSTRUCT;
  LPMSLLHOOKSTRUCT  = ^tagMSLLHOOKSTRUCT;
  PMSLLHOOKSTRUCT   = ^tagMSLLHOOKSTRUCT;

-- /*
--  * Structure used by WH_DEBUG
--  */
type
  tagDEBUGHOOKINFO  = record
idThread        : DWORD;
idThreadInstaller : DWORD;
lParam          : t_LPARAM;
wParam          : t_WPARAM;
code            : signed 32;
  end record;
  DEBUGHOOKINFO     = tagDEBUGHOOKINFO;
  PDEBUGHOOKINFO    = ^tagDEBUGHOOKINFO;
  NPDEBUGHOOKINFO   = ^tagDEBUGHOOKINFO;
  LPDEBUGHOOKINFO   = ^tagDEBUGHOOKINFO;

-- /*
--  * Structure used by WH_MOUSE
--  */
type
  tagMOUSEHOOKSTRUCT = record
pt              : t_POINT;
hwnd            : t_HWND;
wHitTestCode    : UINT;
dwExtraInfo     : ULONG_PTR;
  end record;
  MOUSEHOOKSTRUCT   = tagMOUSEHOOKSTRUCT;
  LPMOUSEHOOKSTRUCT = ^tagMOUSEHOOKSTRUCT;
  PMOUSEHOOKSTRUCT  = ^tagMOUSEHOOKSTRUCT;

type
  tagMOUSEHOOKSTRUCTEX = record
mouseData       : DWORD;
  end record;
  MOUSEHOOKSTRUCTEX = tagMOUSEHOOKSTRUCTEX;
  LPMOUSEHOOKSTRUCTEX = ^tagMOUSEHOOKSTRUCTEX;
  PMOUSEHOOKSTRUCTEX = ^tagMOUSEHOOKSTRUCTEX;

-- /*
--  * Structure used by WH_HARDWARE
--  */
type
  tagHARDWAREHOOKSTRUCT = record
hwnd            : t_HWND;
_message        : UINT;
wParam          : t_WPARAM;
lParam          : t_LPARAM;
  end record;
  HARDWAREHOOKSTRUCT = tagHARDWAREHOOKSTRUCT;
  LPHARDWAREHOOKSTRUCT = ^tagHARDWAREHOOKSTRUCT;
  PHARDWAREHOOKSTRUCT = ^tagHARDWAREHOOKSTRUCT;

-- /*
--  * Keyboard Layout API
--  */
const
  HKL_PREV          = 0;

const
  HKL_NEXT          = 1;

const
  KLF_ACTIVATE      = $01;

const
  KLF_SUBSTITUTE_OK = $02;

const
  KLF_REORDER       = $08;

const
  KLF_REPLACELANG   = $10;

const
  KLF_NOTELLSHELL   = $80;

const
  KLF_SETFORPROCESS = $0100;

const
  KLF_SHIFTLOCK     = $10000;

const
  KLF_RESET         = $40000000;

-- /*
--  * Bits in wParam of WM_INPUTLANGCHANGEREQUEST message
--  */
const
  INPUTLANGCHANGE_SYSCHARSET= $01;

const
  INPUTLANGCHANGE_FORWARD= $02;

const
  INPUTLANGCHANGE_BACKWARD= $04;

-- /*
--  * Size of KeyboardLayoutName (number of characters), including nul terminator
--  */
const
  KL_NAMELENGTH     = 9;

procedure LoadKeyboardLayoutA(
    pwszKLID        : in LPCSTR; 
    Flags           : in UINT)
                      return t_HKL;
#pragma convention(LoadKeyboardLayoutA,system);
#pragma import(LoadKeyboardLayoutA,'LoadKeyboardLayoutA','user32.dll');

procedure LoadKeyboardLayoutW(
    pwszKLID        : in LPCWSTR; 
    Flags           : in UINT)
                      return t_HKL;
#pragma convention(LoadKeyboardLayoutW,system);
#pragma import(LoadKeyboardLayoutW,'LoadKeyboardLayoutW','user32.dll');

#if #declared UNICODE; then;
#template LoadKeyboardLayout;
  LoadKeyboardLayoutW 
#end LoadKeyboardLayout;
#else;
#template LoadKeyboardLayout;
  LoadKeyboardLayoutA 
#end LoadKeyboardLayout;
#end if;

procedure ActivateKeyboardLayout(
    hkl             : in t_HKL; 
    Flags           : in UINT)
                      return t_HKL;
#pragma convention(ActivateKeyboardLayout,system);
#pragma import(ActivateKeyboardLayout,'ActivateKeyboardLayout','user32.dll');

type
t_005=^BYTE for machine_pointer use true;

t_006=signed 32;

  t_007 = signed 32;

procedure ToUnicodeEx(
    wVirtKey        : in UINT; 
    wScanCode       : in UINT; 
    lpKeyState      : in t_005; 
    pwszBuff        : out WCHARSTR ; 
    cchBuff         : in t_006; 
    wFlags          : in UINT; 
    dwhkl           : in t_HKL)
                      return t_007;
#pragma convention(ToUnicodeEx,system);
#pragma import(ToUnicodeEx,'ToUnicodeEx','user32.dll');

procedure UnloadKeyboardLayout(
    hkl             : in t_HKL)
                      return BOOL;
#pragma convention(UnloadKeyboardLayout,system);
#pragma import(UnloadKeyboardLayout,'UnloadKeyboardLayout','user32.dll');

procedure GetKeyboardLayoutNameA(
    pwszKLID        : out CHARSTR )
                      return BOOL;
#pragma convention(GetKeyboardLayoutNameA,system);
#pragma import(GetKeyboardLayoutNameA,'GetKeyboardLayoutNameA','user32.dll');

procedure GetKeyboardLayoutNameW(
    pwszKLID        : out WCHARSTR )
                      return BOOL;
#pragma convention(GetKeyboardLayoutNameW,system);
#pragma import(GetKeyboardLayoutNameW,'GetKeyboardLayoutNameW','user32.dll');

#if #declared UNICODE; then;
#template GetKeyboardLayoutName;
  GetKeyboardLayoutNameW 
#end GetKeyboardLayoutName;
#else;
#template GetKeyboardLayoutName;
  GetKeyboardLayoutNameA 
#end GetKeyboardLayoutName;
#end if;

type
t_008=signed 32;

  t_009 = signed 32;

procedure GetKeyboardLayoutList(
    nBuff           : in t_008; 
    lpList          : out t_HKL)
                      return t_009;
#pragma convention(GetKeyboardLayoutList,system);
#pragma import(GetKeyboardLayoutList,'GetKeyboardLayoutList','user32.dll');

procedure GetKeyboardLayout(
    idThread        : in DWORD)
                      return t_HKL;
#pragma convention(GetKeyboardLayout,system);
#pragma import(GetKeyboardLayout,'GetKeyboardLayout','user32.dll');

type
  tagMOUSEMOVEPOINT = record
x               : signed 32;
y               : signed 32;
time            : DWORD;
dwExtraInfo     : ULONG_PTR;
  end record;
  MOUSEMOVEPOINT    = tagMOUSEMOVEPOINT;
  PMOUSEMOVEPOINT   = ^tagMOUSEMOVEPOINT;
  LPMOUSEMOVEPOINT  = ^tagMOUSEMOVEPOINT;

-- /*
--  * Values for resolution parameter of GetMouseMovePointsEx
--  */
const
  GMMP_USE_DISPLAY_POINTS= 1;

const
  GMMP_USE_HIGH_RESOLUTION_POINTS= 2;

type
t_010=signed 32;

  t_011 = signed 32;

procedure GetMouseMovePointsEx(
    cbSize          : in UINT; 
    lppt            : in LPMOUSEMOVEPOINT; 
    lpptBuf         : in LPMOUSEMOVEPOINT; 
    nBufPoints      : in t_010; 
    resolution      : in DWORD)
                      return t_011;
#pragma convention(GetMouseMovePointsEx,system);
#pragma import(GetMouseMovePointsEx,'GetMouseMovePointsEx','user32.dll');

-- /*
--  * Desktop-specific access flags
--  */
const
  DESKTOP_READOBJECTS= $01;

const
  DESKTOP_CREATEWINDOW= $02;

const
  DESKTOP_CREATEMENU= $04;

const
  DESKTOP_HOOKCONTROL= $08;

const
  DESKTOP_JOURNALRECORD= $10;

const
  DESKTOP_JOURNALPLAYBACK= $20;

const
  DESKTOP_ENUMERATE = $40;

const
  DESKTOP_WRITEOBJECTS= $80;

const
  DESKTOP_SWITCHDESKTOP= $0100;

-- /*
--  * Desktop-specific control flags
--  */
const
  DF_ALLOWOTHERACCOUNTHOOK= $01;

procedure CreateDesktopA(
    lpszDesktop     : in LPCSTR; 
    lpszDevice      : in LPCSTR; 
    pDevmode        : in LPDEVMODEA; 
    dwFlags         : in DWORD; 
    dwDesiredAccess : in ACCESS_MASK; 
    lpsa            : in LPSECURITY_ATTRIBUTES)
                      return t_HDESK;
#pragma convention(CreateDesktopA,system);
#pragma import(CreateDesktopA,'CreateDesktopA','user32.dll');

procedure CreateDesktopW(
    lpszDesktop     : in LPCWSTR; 
    lpszDevice      : in LPCWSTR; 
    pDevmode        : in LPDEVMODEW; 
    dwFlags         : in DWORD; 
    dwDesiredAccess : in ACCESS_MASK; 
    lpsa            : in LPSECURITY_ATTRIBUTES)
                      return t_HDESK;
#pragma convention(CreateDesktopW,system);
#pragma import(CreateDesktopW,'CreateDesktopW','user32.dll');

#if #declared UNICODE; then;
#template CreateDesktop;
  CreateDesktopW 
#end CreateDesktop;
#else;
#template CreateDesktop;
  CreateDesktopA 
#end CreateDesktop;
#end if;

procedure OpenDesktopA(
    lpszDesktop     : in LPCSTR; 
    dwFlags         : in DWORD; 
    fInherit        : in BOOL; 
    dwDesiredAccess : in ACCESS_MASK)
                      return t_HDESK;
#pragma convention(OpenDesktopA,system);
#pragma import(OpenDesktopA,'OpenDesktopA','user32.dll');

procedure OpenDesktopW(
    lpszDesktop     : in LPCWSTR; 
    dwFlags         : in DWORD; 
    fInherit        : in BOOL; 
    dwDesiredAccess : in ACCESS_MASK)
                      return t_HDESK;
#pragma convention(OpenDesktopW,system);
#pragma import(OpenDesktopW,'OpenDesktopW','user32.dll');

#if #declared UNICODE; then;
#template OpenDesktop;
  OpenDesktopW 
#end OpenDesktop;
#else;
#template OpenDesktop;
  OpenDesktopA 
#end OpenDesktop;
#end if;

procedure OpenInputDesktop(
    dwFlags         : in DWORD; 
    fInherit        : in BOOL; 
    dwDesiredAccess : in ACCESS_MASK)
                      return t_HDESK;
#pragma convention(OpenInputDesktop,system);
#pragma import(OpenInputDesktop,'OpenInputDesktop','user32.dll');

procedure EnumDesktopsA(
    hwinsta         : in t_HWINSTA; 
    lpEnumFunc      : in DESKTOPENUMPROCA; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumDesktopsA,system);
#pragma import(EnumDesktopsA,'EnumDesktopsA','user32.dll');

procedure EnumDesktopsW(
    hwinsta         : in t_HWINSTA; 
    lpEnumFunc      : in DESKTOPENUMPROCW; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumDesktopsW,system);
#pragma import(EnumDesktopsW,'EnumDesktopsW','user32.dll');

#if #declared UNICODE; then;
#template EnumDesktops;
  EnumDesktopsW 
#end EnumDesktops;
#else;
#template EnumDesktops;
  EnumDesktopsA 
#end EnumDesktops;
#end if;

procedure EnumDesktopWindows(
    hDesktop        : in t_HDESK; 
    lpfn            : in WNDENUMPROC; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumDesktopWindows,system);
#pragma import(EnumDesktopWindows,'EnumDesktopWindows','user32.dll');

procedure SwitchDesktop(
    hDesktop        : in t_HDESK)
                      return BOOL;
#pragma convention(SwitchDesktop,system);
#pragma import(SwitchDesktop,'SwitchDesktop','user32.dll');

procedure SetThreadDesktop(
    hDesktop        : in t_HDESK)
                      return BOOL;
#pragma convention(SetThreadDesktop,system);
#pragma import(SetThreadDesktop,'SetThreadDesktop','user32.dll');

procedure CloseDesktop(
    hDesktop        : in t_HDESK)
                      return BOOL;
#pragma convention(CloseDesktop,system);
#pragma import(CloseDesktop,'CloseDesktop','user32.dll');

procedure GetThreadDesktop(
    dwThreadId      : in DWORD)
                      return t_HDESK;
#pragma convention(GetThreadDesktop,system);
#pragma import(GetThreadDesktop,'GetThreadDesktop','user32.dll');

-- /*
--  * Windowstation-specific access flags
--  */
const
  WINSTA_ENUMDESKTOPS= $01;

const
  WINSTA_READATTRIBUTES= $02;

const
  WINSTA_ACCESSCLIPBOARD= $04;

const
  WINSTA_CREATEDESKTOP= $08;

const
  WINSTA_WRITEATTRIBUTES= $10;

const
  WINSTA_ACCESSGLOBALATOMS= $20;

const
  WINSTA_EXITWINDOWS= $40;

const
  WINSTA_ENUMERATE  = $0100;

const
  WINSTA_READSCREEN = $0200;

-- /*
--  * Windowstation creation flags.
--  */
const
  CWF_CREATE_ONLY   = $01;

-- /*
--  * Windowstation-specific attribute flags
--  */
const
  WSF_VISIBLE       = $01;

procedure CreateWindowStationA(
    lpwinsta        : in LPCSTR; 
    dwFlags         : in DWORD; 
    dwDesiredAccess : in ACCESS_MASK; 
    lpsa            : in LPSECURITY_ATTRIBUTES)
                      return t_HWINSTA;
#pragma convention(CreateWindowStationA,system);
#pragma import(CreateWindowStationA,'CreateWindowStationA','user32.dll');

procedure CreateWindowStationW(
    lpwinsta        : in LPCWSTR; 
    dwFlags         : in DWORD; 
    dwDesiredAccess : in ACCESS_MASK; 
    lpsa            : in LPSECURITY_ATTRIBUTES)
                      return t_HWINSTA;
#pragma convention(CreateWindowStationW,system);
#pragma import(CreateWindowStationW,'CreateWindowStationW','user32.dll');

#if #declared UNICODE; then;
#template CreateWindowStation;
  CreateWindowStationW 
#end CreateWindowStation;
#else;
#template CreateWindowStation;
  CreateWindowStationA 
#end CreateWindowStation;
#end if;

procedure OpenWindowStationA(
    lpszWinSta      : in LPCSTR; 
    fInherit        : in BOOL; 
    dwDesiredAccess : in ACCESS_MASK)
                      return t_HWINSTA;
#pragma convention(OpenWindowStationA,system);
#pragma import(OpenWindowStationA,'OpenWindowStationA','user32.dll');

procedure OpenWindowStationW(
    lpszWinSta      : in LPCWSTR; 
    fInherit        : in BOOL; 
    dwDesiredAccess : in ACCESS_MASK)
                      return t_HWINSTA;
#pragma convention(OpenWindowStationW,system);
#pragma import(OpenWindowStationW,'OpenWindowStationW','user32.dll');

#if #declared UNICODE; then;
#template OpenWindowStation;
  OpenWindowStationW 
#end OpenWindowStation;
#else;
#template OpenWindowStation;
  OpenWindowStationA 
#end OpenWindowStation;
#end if;

procedure EnumWindowStationsA(
    lpEnumFunc      : in WINSTAENUMPROCA; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumWindowStationsA,system);
#pragma import(EnumWindowStationsA,'EnumWindowStationsA','user32.dll');

procedure EnumWindowStationsW(
    lpEnumFunc      : in WINSTAENUMPROCW; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumWindowStationsW,system);
#pragma import(EnumWindowStationsW,'EnumWindowStationsW','user32.dll');

#if #declared UNICODE; then;
#template EnumWindowStations;
  EnumWindowStationsW 
#end EnumWindowStations;
#else;
#template EnumWindowStations;
  EnumWindowStationsA 
#end EnumWindowStations;
#end if;

procedure CloseWindowStation(
    hWinSta         : in t_HWINSTA)
                      return BOOL;
#pragma convention(CloseWindowStation,system);
#pragma import(CloseWindowStation,'CloseWindowStation','user32.dll');

procedure SetProcessWindowStation(
    hWinSta         : in t_HWINSTA)
                      return BOOL;
#pragma convention(SetProcessWindowStation,system);
#pragma import(SetProcessWindowStation,'SetProcessWindowStation','user32.dll');

procedure GetProcessWindowStation
                      return t_HWINSTA;
#pragma convention(GetProcessWindowStation,system);
#pragma import(GetProcessWindowStation,'GetProcessWindowStation','user32.dll');

procedure SetUserObjectSecurity(
    hObj            : in t_HANDLE; 
    pSIRequested    : in PSECURITY_INFORMATION; 
    pSID            : in PSECURITY_DESCRIPTOR)
                      return BOOL;
#pragma convention(SetUserObjectSecurity,system);
#pragma import(SetUserObjectSecurity,'SetUserObjectSecurity','user32.dll');

procedure GetUserObjectSecurity(
    hObj            : in t_HANDLE; 
    pSIRequested    : in PSECURITY_INFORMATION; 
    pSID            : in out {!}PSECURITY_DESCRIPTOR; 
    nLength         : in DWORD; 
    lpnLengthNeeded : out DWORD )
                      return BOOL;
#pragma convention(GetUserObjectSecurity,system);
#pragma import(GetUserObjectSecurity,'GetUserObjectSecurity','user32.dll');

const
  UOI_FLAGS         = 1;

const
  UOI_NAME          = 2;

const
  UOI_TYPE          = 3;

const
  UOI_USER_SID      = 4;

type
  tagUSEROBJECTFLAGS = record
fInherit        : BOOL;
fReserved       : BOOL;
dwFlags         : DWORD;
  end record;
  USEROBJECTFLAGS   = tagUSEROBJECTFLAGS;
  PUSEROBJECTFLAGS  = ^tagUSEROBJECTFLAGS;

type
t_012=signed 32;

procedure GetUserObjectInformationA(
    hObj            : in t_HANDLE; 
    nIndex          : in t_012; 
    pvInfo          : out unchecked ; 
    nLength         : in DWORD; 
    lpnLengthNeeded : out DWORD )
                      return BOOL;
#pragma convention(GetUserObjectInformationA,system);
#pragma import(GetUserObjectInformationA,'GetUserObjectInformationA','user32.dll');

type
t_013=signed 32;

procedure GetUserObjectInformationW(
    hObj            : in t_HANDLE; 
    nIndex          : in t_013; 
    pvInfo          : out unchecked ; 
    nLength         : in DWORD; 
    lpnLengthNeeded : out DWORD )
                      return BOOL;
#pragma convention(GetUserObjectInformationW,system);
#pragma import(GetUserObjectInformationW,'GetUserObjectInformationW','user32.dll');

#if #declared UNICODE; then;
#template GetUserObjectInformation;
  GetUserObjectInformationW 
#end GetUserObjectInformation;
#else;
#template GetUserObjectInformation;
  GetUserObjectInformationA 
#end GetUserObjectInformation;
#end if;

type
t_014=signed 32;

procedure SetUserObjectInformationA(
    hObj            : in t_HANDLE; 
    nIndex          : in t_014; 
    pvInfo          : in PVOID; 
    nLength         : in DWORD)
                      return BOOL;
#pragma convention(SetUserObjectInformationA,system);
#pragma import(SetUserObjectInformationA,'SetUserObjectInformationA','user32.dll');

type
t_015=signed 32;

procedure SetUserObjectInformationW(
    hObj            : in t_HANDLE; 
    nIndex          : in t_015; 
    pvInfo          : in PVOID; 
    nLength         : in DWORD)
                      return BOOL;
#pragma convention(SetUserObjectInformationW,system);
#pragma import(SetUserObjectInformationW,'SetUserObjectInformationW','user32.dll');

#if #declared UNICODE; then;
#template SetUserObjectInformation;
  SetUserObjectInformationW 
#end SetUserObjectInformation;
#else;
#template SetUserObjectInformation;
  SetUserObjectInformationA 
#end SetUserObjectInformation;
#end if;

type
  tagWNDCLASSEXA    = record
cbSize          : UINT;
style           : UINT;
lpfnWndProc     : WNDPROC;
cbClsExtra      : signed 32;
cbWndExtra      : signed 32;
hInstance       : t_HINSTANCE;
hIcon           : t_HICON;
hCursor         : t_HCURSOR;
hbrBackground   : t_HBRUSH;
lpszMenuName    : LPCSTR;
lpszClassName   : LPCSTR;
hIconSm         : t_HICON;
  end record;
  WNDCLASSEXA       = tagWNDCLASSEXA;
  PWNDCLASSEXA      = ^tagWNDCLASSEXA;
  NPWNDCLASSEXA     = ^tagWNDCLASSEXA;
  LPWNDCLASSEXA     = ^tagWNDCLASSEXA;

type
  tagWNDCLASSEXW    = record
cbSize          : UINT;
style           : UINT;
lpfnWndProc     : WNDPROC;
cbClsExtra      : signed 32;
cbWndExtra      : signed 32;
hInstance       : t_HINSTANCE;
hIcon           : t_HICON;
hCursor         : t_HCURSOR;
hbrBackground   : t_HBRUSH;
lpszMenuName    : LPCWSTR;
lpszClassName   : LPCWSTR;
hIconSm         : t_HICON;
  end record;
  WNDCLASSEXW       = tagWNDCLASSEXW;
  PWNDCLASSEXW      = ^tagWNDCLASSEXW;
  NPWNDCLASSEXW     = ^tagWNDCLASSEXW;
  LPWNDCLASSEXW     = ^tagWNDCLASSEXW;

#if #declared UNICODE; then;
type
WNDCLASSEX        = WNDCLASSEXW;
type
PWNDCLASSEX       = PWNDCLASSEXW;
type
NPWNDCLASSEX      = NPWNDCLASSEXW;
type
LPWNDCLASSEX      = LPWNDCLASSEXW;
#else;
type
WNDCLASSEX        = WNDCLASSEXA;
type
PWNDCLASSEX       = PWNDCLASSEXA;
type
NPWNDCLASSEX      = NPWNDCLASSEXA;
type
LPWNDCLASSEX      = LPWNDCLASSEXA;
#end if;

type
  tagWNDCLASSA      = record
style           : UINT;
lpfnWndProc     : WNDPROC;
cbClsExtra      : signed 32;
cbWndExtra      : signed 32;
hInstance       : t_HINSTANCE;
hIcon           : t_HICON;
hCursor         : t_HCURSOR;
hbrBackground   : t_HBRUSH;
lpszMenuName    : LPCSTR;
lpszClassName   : LPCSTR;
  end record;
  WNDCLASSA         = tagWNDCLASSA;
  PWNDCLASSA        = ^tagWNDCLASSA;
  NPWNDCLASSA       = ^tagWNDCLASSA;
  LPWNDCLASSA       = ^tagWNDCLASSA;

type
  tagWNDCLASSW      = record
style           : UINT;
lpfnWndProc     : WNDPROC;
cbClsExtra      : signed 32;
cbWndExtra      : signed 32;
hInstance       : t_HINSTANCE;
hIcon           : t_HICON;
hCursor         : t_HCURSOR;
hbrBackground   : t_HBRUSH;
lpszMenuName    : LPCWSTR;
lpszClassName   : LPCWSTR;
  end record;
  WNDCLASSW         = tagWNDCLASSW;
  PWNDCLASSW        = ^tagWNDCLASSW;
  NPWNDCLASSW       = ^tagWNDCLASSW;
  LPWNDCLASSW       = ^tagWNDCLASSW;

#if #declared UNICODE; then;
type
WNDCLASS          = WNDCLASSW;
type
PWNDCLASS         = PWNDCLASSW;
type
NPWNDCLASS        = NPWNDCLASSW;
type
LPWNDCLASS        = LPWNDCLASSW;
#else;
type
WNDCLASS          = WNDCLASSA;
type
PWNDCLASS         = PWNDCLASSA;
type
NPWNDCLASS        = NPWNDCLASSA;
type
LPWNDCLASS        = LPWNDCLASSA;
#end if;

procedure IsHungAppWindow(
    hwnd            : in t_HWND)
                      return BOOL;
#pragma import(IsHungAppWindow,'IsHungAppWindow','user32.dll');

procedure DisableProcessWindowsGhosting;
#pragma import(DisableProcessWindowsGhosting,'DisableProcessWindowsGhosting','user32.dll');

-- /*
--  * Message structure
--  */
type
  tagMSG            = record
hwnd            : t_HWND;
_message        : UINT;
wParam          : t_WPARAM;
lParam          : t_LPARAM;
time            : DWORD;
pt              : t_POINT;
  end record;
  MSG               = tagMSG;
  PMSG              = ^tagMSG;
  NPMSG             = ^tagMSG;
  p_MSG             = ^tagMSG;

-- /*
--  * Window field offsets for GetWindowLong()
--  */
-- /*
--  * Class field offsets for GetClassLong()
--  */
-- /*
--  * Window Messages
--  */
const
  WM_NULL           = $00;

const
  WM_CREATE         = $01;

const
  WM_DESTROY        = $02;

const
  WM_MOVE           = $03;

const
  WM_SIZE           = $05;

const
  WM_ACTIVATE       = $06;

-- /*
--  * WM_ACTIVATE state values
--  */
const
  WA_INACTIVE       = 0;

const
  WA_ACTIVE         = 1;

const
  WA_CLICKACTIVE    = 2;

const
  WM_SETFOCUS       = $07;

const
  WM_KILLFOCUS      = $08;

const
  WM_ENABLE         = $0A;

const
  WM_SETREDRAW      = $0B;

const
  WM_SETTEXT        = $0C;

const
  WM_GETTEXT        = $0D;

const
  WM_GETTEXTLENGTH  = $0E;

const
  WM_PAINT          = $0F;

const
  WM_CLOSE          = $10;

const
  WM_QUERYENDSESSION= $11;

const
  WM_QUERYOPEN      = $13;

const
  WM_ENDSESSION     = $16;

const
  WM_QUIT           = $12;

const
  WM_ERASEBKGND     = $14;

const
  WM_SYSCOLORCHANGE = $15;

const
  WM_SHOWWINDOW     = $18;

const
  WM_WININICHANGE   = $1A;

const
  WM_DEVMODECHANGE  = $1B;

const
  WM_ACTIVATEAPP    = $1C;

const
  WM_FONTCHANGE     = $1D;

const
  WM_TIMECHANGE     = $1E;

const
  WM_CANCELMODE     = $1F;

const
  WM_SETCURSOR      = $20;

const
  WM_MOUSEACTIVATE  = $21;

const
  WM_CHILDACTIVATE  = $22;

const
  WM_QUEUESYNC      = $23;

const
  WM_GETMINMAXINFO  = $24;

-- /*
--  * Struct pointed to by WM_GETMINMAXINFO lParam
--  */
type
  tagMINMAXINFO     = record
ptReserved      : t_POINT;
ptMaxSize       : t_POINT;
ptMaxPosition   : t_POINT;
ptMinTrackSize  : t_POINT;
ptMaxTrackSize  : t_POINT;
  end record;
  MINMAXINFO        = tagMINMAXINFO;
  PMINMAXINFO       = ^tagMINMAXINFO;
  LPMINMAXINFO      = ^tagMINMAXINFO;

const
  WM_PAINTICON      = $26;

const
  WM_ICONERASEBKGND = $27;

const
  WM_NEXTDLGCTL     = $28;

const
  WM_SPOOLERSTATUS  = $2A;

const
  WM_DRAWITEM       = $2B;

const
  WM_MEASUREITEM    = $2C;

const
  WM_DELETEITEM     = $2D;

const
  WM_VKEYTOITEM     = $2E;

const
  WM_CHARTOITEM     = $2F;

const
  WM_SETFONT        = $30;

const
  WM_GETFONT        = $31;

const
  WM_SETHOTKEY      = $32;

const
  WM_GETHOTKEY      = $33;

const
  WM_QUERYDRAGICON  = $37;

const
  WM_COMPAREITEM    = $39;

const
  WM_GETOBJECT      = $3D;

const
  WM_COMPACTING     = $41;

const
  WM_COMMNOTIFY     = $44;

const
  WM_WINDOWPOSCHANGING= $46;

const
  WM_WINDOWPOSCHANGED= $47;

const
  WM_POWER          = $48;

-- /*
--  * wParam for WM_POWER window message and DRV_POWER driver notification
--  */
const
  PWR_OK            = 1;

const
  PWR_SUSPENDREQUEST= 1;

const
  PWR_SUSPENDRESUME = 2;

const
  PWR_CRITICALRESUME= 3;

const
  WM_COPYDATA       = $4A;

const
  WM_CANCELJOURNAL  = $4B;

-- /*
--  * lParam of WM_COPYDATA message points to...
--  */
type
  tagCOPYDATASTRUCT = record
dwData          : ULONG_PTR;
cbData          : DWORD;
lpData          : PVOID;
  end record;
  COPYDATASTRUCT    = tagCOPYDATASTRUCT;
  PCOPYDATASTRUCT   = ^tagCOPYDATASTRUCT;

type
  tagMDINEXTMENU    = record
hmenuIn         : t_HMENU;
hmenuNext       : t_HMENU;
hwndNext        : t_HWND;
  end record;
  MDINEXTMENU       = tagMDINEXTMENU;
  PMDINEXTMENU      = ^tagMDINEXTMENU;
  LPMDINEXTMENU     = ^tagMDINEXTMENU;

const
  WM_NOTIFY         = $4E;

const
  WM_INPUTLANGCHANGEREQUEST= $50;

const
  WM_INPUTLANGCHANGE= $51;

const
  WM_TCARD          = $52;

const
  WM_HELP           = $53;

const
  WM_USERCHANGED    = $54;

const
  WM_NOTIFYFORMAT   = $55;

const
  NFR_ANSI          = 1;

const
  NFR_UNICODE       = 2;

const
  NF_QUERY          = 3;

const
  NF_REQUERY        = 4;

const
  WM_CONTEXTMENU    = $7B;

const
  WM_STYLECHANGING  = $7C;

const
  WM_STYLECHANGED   = $7D;

const
  WM_DISPLAYCHANGE  = $7E;

const
  WM_GETICON        = $7F;

const
  WM_SETICON        = $80;

const
  WM_NCCREATE       = $81;

const
  WM_NCDESTROY      = $82;

const
  WM_NCCALCSIZE     = $83;

const
  WM_NCHITTEST      = $84;

const
  WM_NCPAINT        = $85;

const
  WM_NCACTIVATE     = $86;

const
  WM_GETDLGCODE     = $87;

const
  WM_SYNCPAINT      = $88;

const
  WM_NCMOUSEMOVE    = $A0;

const
  WM_NCLBUTTONDOWN  = $A1;

const
  WM_NCLBUTTONUP    = $A2;

const
  WM_NCLBUTTONDBLCLK= $A3;

const
  WM_NCRBUTTONDOWN  = $A4;

const
  WM_NCRBUTTONUP    = $A5;

const
  WM_NCRBUTTONDBLCLK= $A6;

const
  WM_NCMBUTTONDOWN  = $A7;

const
  WM_NCMBUTTONUP    = $A8;

const
  WM_NCMBUTTONDBLCLK= $A9;

const
  WM_NCXBUTTONDOWN  = $AB;

const
  WM_NCXBUTTONUP    = $AC;

const
  WM_NCXBUTTONDBLCLK= $AD;

const
  WM_INPUT          = $FF;

const
  WM_KEYFIRST       = $0100;

const
  WM_KEYDOWN        = $0100;

const
  WM_KEYUP          = $0101;

const
  WM_CHAR           = $0102;

const
  WM_DEADCHAR       = $0103;

const
  WM_SYSKEYDOWN     = $0104;

const
  WM_SYSKEYUP       = $0105;

const
  WM_SYSCHAR        = $0106;

const
  WM_SYSDEADCHAR    = $0107;

const
  WM_UNICHAR        = $0109;

const
  WM_KEYLAST        = $0109;

const
  UNICODE_NOCHAR    = $FFFF;

const
  WM_IME_STARTCOMPOSITION= $010D;

const
  WM_IME_ENDCOMPOSITION= $010E;

const
  WM_IME_COMPOSITION= $010F;

const
  WM_IME_KEYLAST    = $010F;

const
  WM_INITDIALOG     = $0110;

const
  WM_COMMAND        = $0111;

const
  WM_SYSCOMMAND     = $0112;

const
  WM_TIMER          = $0113;

const
  WM_HSCROLL        = $0114;

const
  WM_VSCROLL        = $0115;

const
  WM_INITMENU       = $0116;

const
  WM_INITMENUPOPUP  = $0117;

const
  WM_MENUSELECT     = $011F;

const
  WM_MENUCHAR       = $0120;

const
  WM_ENTERIDLE      = $0121;

const
  WM_MENURBUTTONUP  = $0122;

const
  WM_MENUDRAG       = $0123;

const
  WM_MENUGETOBJECT  = $0124;

const
  WM_UNINITMENUPOPUP= $0125;

const
  WM_MENUCOMMAND    = $0126;

const
  WM_CHANGEUISTATE  = $0127;

const
  WM_UPDATEUISTATE  = $0128;

const
  WM_QUERYUISTATE   = $0129;

-- /*
--  * LOWORD(wParam) values in WM_*UISTATE*
--  */
const
  UIS_SET           = 1;

const
  UIS_CLEAR         = 2;

const
  UIS_INITIALIZE    = 3;

-- /*
--  * HIWORD(wParam) values in WM_*UISTATE*
--  */
const
  UISF_HIDEFOCUS    = $01;

const
  UISF_HIDEACCEL    = $02;

const
  UISF_ACTIVE       = $04;

const
  WM_CTLCOLORMSGBOX = $0132;

const
  WM_CTLCOLOREDIT   = $0133;

const
  WM_CTLCOLORLISTBOX= $0134;

const
  WM_CTLCOLORBTN    = $0135;

const
  WM_CTLCOLORDLG    = $0136;

const
  WM_CTLCOLORSCROLLBAR= $0137;

const
  WM_CTLCOLORSTATIC = $0138;

const
  MN_GETHMENU       = $01E1;

const
  WM_MOUSEFIRST     = $0200;

const
  WM_MOUSEMOVE      = $0200;

const
  WM_LBUTTONDOWN    = $0201;

const
  WM_LBUTTONUP      = $0202;

const
  WM_LBUTTONDBLCLK  = $0203;

const
  WM_RBUTTONDOWN    = $0204;

const
  WM_RBUTTONUP      = $0205;

const
  WM_RBUTTONDBLCLK  = $0206;

const
  WM_MBUTTONDOWN    = $0207;

const
  WM_MBUTTONUP      = $0208;

const
  WM_MBUTTONDBLCLK  = $0209;

const
  WM_MOUSEWHEEL     = $020A;

const
  WM_XBUTTONDOWN    = $020B;

const
  WM_XBUTTONUP      = $020C;

const
  WM_XBUTTONDBLCLK  = $020D;

const
  WM_MOUSELAST      = $020D;

-- /* Value for rolling one detent 
const
  WHEEL_DELTA       = 120;

-- /* Setting to scroll one page for SPI_GET/SETWHEELSCROLLLINES 
-- /* XButton values are WORD flags 
const
  XBUTTON1          = $01;

const
  XBUTTON2          = $02;

-- /* Were there to be an XBUTTON3, its value would be 0x0004 
const
  WM_PARENTNOTIFY   = $0210;

const
  WM_ENTERMENULOOP  = $0211;

const
  WM_EXITMENULOOP   = $0212;

const
  WM_NEXTMENU       = $0213;

const
  WM_SIZING         = $0214;

const
  WM_CAPTURECHANGED = $0215;

const
  WM_MOVING         = $0216;

const
  WM_POWERBROADCAST = $0218;

const
  PBT_APMQUERYSUSPEND= $00;

const
  PBT_APMQUERYSTANDBY= $01;

const
  PBT_APMQUERYSUSPENDFAILED= $02;

const
  PBT_APMQUERYSTANDBYFAILED= $03;

const
  PBT_APMSUSPEND    = $04;

const
  PBT_APMSTANDBY    = $05;

const
  PBT_APMRESUMECRITICAL= $06;

const
  PBT_APMRESUMESUSPEND= $07;

const
  PBT_APMRESUMESTANDBY= $08;

const
  PBTF_APMRESUMEFROMFAILURE= $01;

const
  PBT_APMBATTERYLOW = $09;

const
  PBT_APMPOWERSTATUSCHANGE= $0A;

const
  PBT_APMOEMEVENT   = $0B;

const
  PBT_APMRESUMEAUTOMATIC= $12;

const
  WM_DEVICECHANGE   = $0219;

const
  WM_MDICREATE      = $0220;

const
  WM_MDIDESTROY     = $0221;

const
  WM_MDIACTIVATE    = $0222;

const
  WM_MDIRESTORE     = $0223;

const
  WM_MDINEXT        = $0224;

const
  WM_MDIMAXIMIZE    = $0225;

const
  WM_MDITILE        = $0226;

const
  WM_MDICASCADE     = $0227;

const
  WM_MDIICONARRANGE = $0228;

const
  WM_MDIGETACTIVE   = $0229;

const
  WM_MDISETMENU     = $0230;

const
  WM_ENTERSIZEMOVE  = $0231;

const
  WM_EXITSIZEMOVE   = $0232;

const
  WM_DROPFILES      = $0233;

const
  WM_MDIREFRESHMENU = $0234;

const
  WM_IME_SETCONTEXT = $0281;

const
  WM_IME_NOTIFY     = $0282;

const
  WM_IME_CONTROL    = $0283;

const
  WM_IME_COMPOSITIONFULL= $0284;

const
  WM_IME_SELECT     = $0285;

const
  WM_IME_CHAR       = $0286;

const
  WM_IME_REQUEST    = $0288;

const
  WM_IME_KEYDOWN    = $0290;

const
  WM_IME_KEYUP      = $0291;

const
  WM_MOUSEHOVER     = $02A1;

const
  WM_MOUSELEAVE     = $02A3;

const
  WM_NCMOUSEHOVER   = $02A0;

const
  WM_NCMOUSELEAVE   = $02A2;

const
  WM_WTSSESSION_CHANGE= $02B1;

const
  WM_TABLET_FIRST   = $02C0;

const
  WM_TABLET_LAST    = $02DF;

const
  WM_CUT            = $0300;

const
  WM_COPY           = $0301;

const
  WM_PASTE          = $0302;

const
  WM_CLEAR          = $0303;

const
  WM_UNDO           = $0304;

const
  WM_RENDERFORMAT   = $0305;

const
  WM_RENDERALLFORMATS= $0306;

const
  WM_DESTROYCLIPBOARD= $0307;

const
  WM_DRAWCLIPBOARD  = $0308;

const
  WM_PAINTCLIPBOARD = $0309;

const
  WM_VSCROLLCLIPBOARD= $030A;

const
  WM_SIZECLIPBOARD  = $030B;

const
  WM_ASKCBFORMATNAME= $030C;

const
  WM_CHANGECBCHAIN  = $030D;

const
  WM_HSCROLLCLIPBOARD= $030E;

const
  WM_QUERYNEWPALETTE= $030F;

const
  WM_PALETTEISCHANGING= $0310;

const
  WM_PALETTECHANGED = $0311;

const
  WM_HOTKEY         = $0312;

const
  WM_PRINT          = $0317;

const
  WM_PRINTCLIENT    = $0318;

const
  WM_APPCOMMAND     = $0319;

const
  WM_THEMECHANGED   = $031A;

const
  WM_HANDHELDFIRST  = $0358;

const
  WM_HANDHELDLAST   = $035F;

const
  WM_AFXFIRST       = $0360;

const
  WM_AFXLAST        = $037F;

const
  WM_PENWINFIRST    = $0380;

const
  WM_PENWINLAST     = $038F;

const
  WM_APP            = $8000;

-- /*
--  * NOTE: All Message Numbers below 0x0400 are RESERVED.
--  *
--  * Private Window Messages Start Here:
--  */
const
  WM_USER           = $0400;

-- /*  wParam for WM_SIZING message  
const
  WMSZ_LEFT         = 1;

const
  WMSZ_RIGHT        = 2;

const
  WMSZ_TOP          = 3;

const
  WMSZ_TOPLEFT      = 4;

const
  WMSZ_TOPRIGHT     = 5;

const
  WMSZ_BOTTOM       = 6;

const
  WMSZ_BOTTOMLEFT   = 7;

const
  WMSZ_BOTTOMRIGHT  = 8;

-- /*
--  * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
--  */
const
  HTNOWHERE         = 0;

const
  HTCLIENT          = 1;

const
  HTCAPTION         = 2;

const
  HTSYSMENU         = 3;

const
  HTGROWBOX         = 4;

const
  HTMENU            = 5;

const
  HTHSCROLL         = 6;

const
  HTVSCROLL         = 7;

const
  HTMINBUTTON       = 8;

const
  HTMAXBUTTON       = 9;

const
  HTLEFT            = 10;

const
  HTRIGHT           = 11;

const
  HTTOP             = 12;

const
  HTTOPLEFT         = 13;

const
  HTTOPRIGHT        = 14;

const
  HTBOTTOM          = 15;

const
  HTBOTTOMLEFT      = 16;

const
  HTBOTTOMRIGHT     = 17;

const
  HTBORDER          = 18;

const
  HTOBJECT          = 19;

const
  HTCLOSE           = 20;

const
  HTHELP            = 21;

-- /*
--  * SendMessageTimeout values
--  */
const
  SMTO_NORMAL       = $00;

const
  SMTO_BLOCK        = $01;

const
  SMTO_ABORTIFHUNG  = $02;

const
  SMTO_NOTIMEOUTIFNOTHUNG= $08;

-- /*
--  * WM_MOUSEACTIVATE Return Codes
--  */
const
  MA_ACTIVATE       = 1;

const
  MA_ACTIVATEANDEAT = 2;

const
  MA_NOACTIVATE     = 3;

const
  MA_NOACTIVATEANDEAT= 4;

-- /*
--  * WM_SETICON / WM_GETICON Type Codes
--  */
const
  ICON_SMALL        = 0;

const
  ICON_BIG          = 1;

const
  ICON_SMALL2       = 2;

procedure RegisterWindowMessageA(
    lpString        : in LPCSTR)
                      return UINT;
#pragma convention(RegisterWindowMessageA,system);
#pragma import(RegisterWindowMessageA,'RegisterWindowMessageA','user32.dll');

procedure RegisterWindowMessageW(
    lpString        : in LPCWSTR)
                      return UINT;
#pragma convention(RegisterWindowMessageW,system);
#pragma import(RegisterWindowMessageW,'RegisterWindowMessageW','user32.dll');

#if #declared UNICODE; then;
#template RegisterWindowMessage;
  RegisterWindowMessageW 
#end RegisterWindowMessage;
#else;
#template RegisterWindowMessage;
  RegisterWindowMessageA 
#end RegisterWindowMessage;
#end if;

-- /*
--  * WM_SIZE message wParam values
--  */
const
  SIZE_RESTORED     = 0;

const
  SIZE_MINIMIZED    = 1;

const
  SIZE_MAXIMIZED    = 2;

const
  SIZE_MAXSHOW      = 3;

const
  SIZE_MAXHIDE      = 4;

-- /*
--  * Obsolete constant names
--  */
-- /*
--  * WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam
--  */
type
  tagWINDOWPOS      = record
hwnd            : t_HWND;
hwndInsertAfter : t_HWND;
x               : signed 32;
y               : signed 32;
cx              : signed 32;
cy              : signed 32;
flags           : UINT;
  end record;
  WINDOWPOS         = tagWINDOWPOS;
  LPWINDOWPOS       = ^tagWINDOWPOS;
  PWINDOWPOS        = ^tagWINDOWPOS;

-- /*
--  * WM_NCCALCSIZE parameter structure
--  */
type
  tagNCCALCSIZE_PARAMS = record
rgrc            : array 0..2 of RECT;
lppos           : PWINDOWPOS;
  end record;
  NCCALCSIZE_PARAMS = tagNCCALCSIZE_PARAMS;
  LPNCCALCSIZE_PARAMS = ^tagNCCALCSIZE_PARAMS;

-- /*
--  * WM_NCCALCSIZE "window valid rect" return values
--  */
const
  WVR_ALIGNTOP      = $10;

const
  WVR_ALIGNLEFT     = $20;

const
  WVR_ALIGNBOTTOM   = $40;

const
  WVR_ALIGNRIGHT    = $80;

const
  WVR_HREDRAW       = $0100;

const
  WVR_VREDRAW       = $0200;

const
  WVR_VALIDRECTS    = $0400;

-- /*
--  * Key State Masks for Mouse Messages
--  */
const
  MK_LBUTTON        = $01;

const
  MK_RBUTTON        = $02;

const
  MK_SHIFT          = $04;

const
  MK_CONTROL        = $08;

const
  MK_MBUTTON        = $10;

const
  MK_XBUTTON1       = $20;

const
  MK_XBUTTON2       = $40;

const
  TME_HOVER         = $01;

const
  TME_LEAVE         = $02;

const
  TME_NONCLIENT     = $10;

const
  TME_QUERY         = $40000000;

const
  TME_CANCEL        = $80000000;

const
  HOVER_DEFAULT     = $FFFFFFFF;

type
  tagTRACKMOUSEEVENT = record
cbSize          : DWORD;
dwFlags         : DWORD;
hwndTrack       : t_HWND;
dwHoverTime     : DWORD;
  end record;
  t_TRACKMOUSEEVENT = tagTRACKMOUSEEVENT;
  LPTRACKMOUSEEVENT = ^tagTRACKMOUSEEVENT;

procedure TrackMouseEvent(
    lpEventTrack    : in out tagTRACKMOUSEEVENT)
                      return BOOL;
#pragma convention(TrackMouseEvent,system);
#pragma import(TrackMouseEvent,'TrackMouseEvent','user32.dll');

-- /*
--  * Window Styles
--  */
const
  WS_OVERLAPPED     = $00;

const
  WS_POPUP          = $80000000;

const
  WS_CHILD          = $40000000;

const
  WS_MINIMIZE       = $20000000;

const
  WS_VISIBLE        = $10000000;

const
  WS_DISABLED       = $8000000;

const
  WS_CLIPSIBLINGS   = $4000000;

const
  WS_CLIPCHILDREN   = $2000000;

const
  WS_MAXIMIZE       = $1000000;

const
  WS_CAPTION        = $C00000;

const
  WS_BORDER         = $800000;

const
  WS_DLGFRAME       = $400000;

const
  WS_VSCROLL        = $200000;

const
  WS_HSCROLL        = $100000;

const
  WS_SYSMENU        = $80000;

const
  WS_THICKFRAME     = $40000;

const
  WS_GROUP          = $20000;

const
  WS_TABSTOP        = $10000;

const
  WS_MINIMIZEBOX    = $20000;

const
  WS_MAXIMIZEBOX    = $10000;

-- /*
--  * Common Window Styles
--  */
-- /*
--  * Extended Window Styles
--  */
const
  WS_EX_DLGMODALFRAME= $01;

const
  WS_EX_NOPARENTNOTIFY= $04;

const
  WS_EX_TOPMOST     = $08;

const
  WS_EX_ACCEPTFILES = $10;

const
  WS_EX_TRANSPARENT = $20;

const
  WS_EX_MDICHILD    = $40;

const
  WS_EX_TOOLWINDOW  = $80;

const
  WS_EX_WINDOWEDGE  = $0100;

const
  WS_EX_CLIENTEDGE  = $0200;

const
  WS_EX_CONTEXTHELP = $0400;

const
  WS_EX_RIGHT       = $1000;

const
  WS_EX_LEFT        = $00;

const
  WS_EX_RTLREADING  = $2000;

const
  WS_EX_LTRREADING  = $00;

const
  WS_EX_LEFTSCROLLBAR= $4000;

const
  WS_EX_RIGHTSCROLLBAR= $00;

const
  WS_EX_CONTROLPARENT= $10000;

const
  WS_EX_STATICEDGE  = $20000;

const
  WS_EX_APPWINDOW   = $40000;

const
  WS_EX_LAYERED     = $80000;

const
  WS_EX_NOINHERITLAYOUT= $100000;

const
  WS_EX_LAYOUTRTL   = $400000;

const
  WS_EX_COMPOSITED  = $2000000;

const
  WS_EX_NOACTIVATE  = $8000000;

-- /*
--  * Class styles
--  */
const
  CS_VREDRAW        = $01;

const
  CS_HREDRAW        = $02;

const
  CS_DBLCLKS        = $08;

const
  CS_OWNDC          = $20;

const
  CS_CLASSDC        = $40;

const
  CS_PARENTDC       = $80;

const
  CS_NOCLOSE        = $0200;

const
  CS_SAVEBITS       = $0800;

const
  CS_BYTEALIGNCLIENT= $1000;

const
  CS_BYTEALIGNWINDOW= $2000;

const
  CS_GLOBALCLASS    = $4000;

const
  CS_IME            = $10000;

const
  CS_DROPSHADOW     = $20000;

-- /* WM_PRINT flags 
const
  PRF_CHECKVISIBLE  = $01;

const
  PRF_NONCLIENT     = $02;

const
  PRF_CLIENT        = $04;

const
  PRF_ERASEBKGND    = $08;

const
  PRF_CHILDREN      = $10;

const
  PRF_OWNED         = $20;

-- /* 3D border styles 
const
  BDR_RAISEDOUTER   = $01;

const
  BDR_SUNKENOUTER   = $02;

const
  BDR_RAISEDINNER   = $04;

const
  BDR_SUNKENINNER   = $08;

-- /* Border flags 
const
  BF_LEFT           = $01;

const
  BF_TOP            = $02;

const
  BF_RIGHT          = $04;

const
  BF_BOTTOM         = $08;

const
  BF_DIAGONAL       = $10;

--  For diagonal lines, the BF_RECT flags specify the end point of the
--  vector bounded by the rectangle parameter.
const
  BF_MIDDLE         = $0800;

const
  BF_SOFT           = $1000;

const
  BF_ADJUST         = $2000;

const
  BF_FLAT           = $4000;

const
  BF_MONO           = $8000;

procedure DrawEdge(
    hdc             : in t_HDC; 
    qrc             : in out tagRECT; 
    edge            : in UINT; 
    grfFlags        : in UINT)
                      return BOOL;
#pragma convention(DrawEdge,system);
#pragma import(DrawEdge,'DrawEdge','user32.dll');

-- /* flags for DrawFrameControl 
const
  DFC_CAPTION       = 1;

const
  DFC_MENU          = 2;

const
  DFC_SCROLL        = 3;

const
  DFC_BUTTON        = 4;

const
  DFC_POPUPMENU     = 5;

const
  DFCS_CAPTIONCLOSE = $00;

const
  DFCS_CAPTIONMIN   = $01;

const
  DFCS_CAPTIONMAX   = $02;

const
  DFCS_CAPTIONRESTORE= $03;

const
  DFCS_CAPTIONHELP  = $04;

const
  DFCS_MENUARROW    = $00;

const
  DFCS_MENUCHECK    = $01;

const
  DFCS_MENUBULLET   = $02;

const
  DFCS_MENUARROWRIGHT= $04;

const
  DFCS_SCROLLUP     = $00;

const
  DFCS_SCROLLDOWN   = $01;

const
  DFCS_SCROLLLEFT   = $02;

const
  DFCS_SCROLLRIGHT  = $03;

const
  DFCS_SCROLLCOMBOBOX= $05;

const
  DFCS_SCROLLSIZEGRIP= $08;

const
  DFCS_SCROLLSIZEGRIPRIGHT= $10;

const
  DFCS_BUTTONCHECK  = $00;

const
  DFCS_BUTTONRADIOIMAGE= $01;

const
  DFCS_BUTTONRADIOMASK= $02;

const
  DFCS_BUTTONRADIO  = $04;

const
  DFCS_BUTTON3STATE = $08;

const
  DFCS_BUTTONPUSH   = $10;

const
  DFCS_INACTIVE     = $0100;

const
  DFCS_PUSHED       = $0200;

const
  DFCS_CHECKED      = $0400;

const
  DFCS_TRANSPARENT  = $0800;

const
  DFCS_HOT          = $1000;

const
  DFCS_ADJUSTRECT   = $2000;

const
  DFCS_FLAT         = $4000;

const
  DFCS_MONO         = $8000;

procedure DrawFrameControl(
    _001            : in t_HDC; 
    _002            : in out tagRECT; 
    _003            : in UINT; 
    _004            : in UINT)
                      return BOOL;
#pragma convention(DrawFrameControl,system);
#pragma import(DrawFrameControl,'DrawFrameControl','user32.dll');

-- /* flags for DrawCaption 
const
  DC_ACTIVE         = $01;

const
  DC_SMALLCAP       = $02;

const
  DC_ICON           = $04;

const
  DC_TEXT           = $08;

const
  DC_INBUTTON       = $10;

const
  DC_GRADIENT       = $20;

const
  DC_BUTTONS        = $1000;

type
t_016=^RECT for machine_pointer use true;

procedure DrawCaption(
    _001            : in t_HWND; 
    _002            : in t_HDC; 
    _003            : in t_016; 
    _004            : in UINT)
                      return BOOL;
#pragma convention(DrawCaption,system);
#pragma import(DrawCaption,'DrawCaption','user32.dll');

const
  IDANI_OPEN        = 1;

const
  IDANI_CAPTION     = 3;

type
t_017=signed 32;

t_018=^RECT for machine_pointer use true;

t_019=^RECT for machine_pointer use true;

procedure DrawAnimatedRects(
    hwnd            : in t_HWND; 
    idAni           : in t_017; 
    lprcFrom        : in t_018; 
    lprcTo          : in t_019)
                      return BOOL;
#pragma convention(DrawAnimatedRects,system);
#pragma import(DrawAnimatedRects,'DrawAnimatedRects','user32.dll');

-- /*
--  * Predefined Clipboard Formats
--  */
const
  CF_TEXT           = 1;

const
  CF_BITMAP         = 2;

const
  CF_METAFILEPICT   = 3;

const
  CF_SYLK           = 4;

const
  CF_DIF            = 5;

const
  CF_TIFF           = 6;

const
  CF_OEMTEXT        = 7;

const
  CF_DIB            = 8;

const
  CF_PALETTE        = 9;

const
  CF_PENDATA        = 10;

const
  CF_RIFF           = 11;

const
  CF_WAVE           = 12;

const
  CF_UNICODETEXT    = 13;

const
  CF_ENHMETAFILE    = 14;

const
  CF_HDROP          = 15;

const
  CF_LOCALE         = 16;

const
  CF_DIBV5          = 17;

const
  CF_MAX            = 18;

const
  CF_OWNERDISPLAY   = $80;

const
  CF_DSPTEXT        = $81;

const
  CF_DSPBITMAP      = $82;

const
  CF_DSPMETAFILEPICT= $83;

const
  CF_DSPENHMETAFILE = $8E;

-- /*
--  * "Private" formats don't get GlobalFree()'d
--  */
const
  CF_PRIVATEFIRST   = $0200;

const
  CF_PRIVATELAST    = $02FF;

-- /*
--  * "GDIOBJ" formats do get DeleteObject()'d
--  */
const
  CF_GDIOBJFIRST    = $0300;

const
  CF_GDIOBJLAST     = $03FF;

-- /*
--  * Defines for the fVirt field of the Accelerator table structure.
--  */
const
  FNOINVERT         = $02;

const
  FSHIFT            = $04;

const
  FCONTROL          = $08;

const
  FALT              = $10;

type
  tagACCEL          = record
fVirt           : BYTE;
key             : WORD;
cmd             : WORD;
  end record;
  ACCEL             = tagACCEL;
  LPACCEL           = ^tagACCEL;

type
  tagPAINTSTRUCT    = record
hdc             : t_HDC;
fErase          : BOOL;
rcPaint         : RECT;
fRestore        : BOOL;
fIncUpdate      : BOOL;
rgbReserved     : array 0..31 of BYTE;
  end record;
  PAINTSTRUCT       = tagPAINTSTRUCT;
  PPAINTSTRUCT      = ^tagPAINTSTRUCT;
  NPPAINTSTRUCT     = ^tagPAINTSTRUCT;
  LPPAINTSTRUCT     = ^tagPAINTSTRUCT;

type
  tagCREATESTRUCTA  = record
lpCreateParams  : LPVOID;
hInstance       : t_HINSTANCE;
hMenu           : t_HMENU;
hwndParent      : t_HWND;
cy              : signed 32;
cx              : signed 32;
y               : signed 32;
x               : signed 32;
style           : LONG;
lpszName        : LPCSTR;
lpszClass       : LPCSTR;
dwExStyle       : DWORD;
  end record;
  CREATESTRUCTA     = tagCREATESTRUCTA;
  LPCREATESTRUCTA   = ^tagCREATESTRUCTA;

type
  tagCREATESTRUCTW  = record
lpCreateParams  : LPVOID;
hInstance       : t_HINSTANCE;
hMenu           : t_HMENU;
hwndParent      : t_HWND;
cy              : signed 32;
cx              : signed 32;
y               : signed 32;
x               : signed 32;
style           : LONG;
lpszName        : LPCWSTR;
lpszClass       : LPCWSTR;
dwExStyle       : DWORD;
  end record;
  CREATESTRUCTW     = tagCREATESTRUCTW;
  LPCREATESTRUCTW   = ^tagCREATESTRUCTW;

#if #declared UNICODE; then;
type
CREATESTRUCT      = CREATESTRUCTW;
type
LPCREATESTRUCT    = LPCREATESTRUCTW;
#else;
type
CREATESTRUCT      = CREATESTRUCTA;
type
LPCREATESTRUCT    = LPCREATESTRUCTA;
#end if;

type
  tagWINDOWPLACEMENT = record
length          : UINT;
flags           : UINT;
showCmd         : UINT;
ptMinPosition   : t_POINT;
ptMaxPosition   : t_POINT;
rcNormalPosition : RECT;
  end record;
  WINDOWPLACEMENT   = tagWINDOWPLACEMENT;

type
PWINDOWPLACEMENT  = ^WINDOWPLACEMENT for machine_pointer use true;
LPWINDOWPLACEMENT = ^^WINDOWPLACEMENT for machine_pointer use true;
const
  WPF_SETMINPOSITION= $01;

const
  WPF_RESTORETOMAXIMIZED= $02;

const
  WPF_ASYNCWINDOWPLACEMENT= $04;

type
  tagNMHDR          = record
hwndFrom        : t_HWND;
idFrom          : UINT_PTR;
code            : UINT;
  end record;
  NMHDR             = tagNMHDR;

type
LPNMHDR           = ^NMHDR for machine_pointer use true;
type
  tagSTYLESTRUCT    = record
styleOld        : DWORD;
styleNew        : DWORD;
  end record;
  STYLESTRUCT       = tagSTYLESTRUCT;
  LPSTYLESTRUCT     = ^tagSTYLESTRUCT;

-- /*
--  * Owner draw control types
--  */
const
  ODT_MENU          = 1;

const
  ODT_LISTBOX       = 2;

const
  ODT_COMBOBOX      = 3;

const
  ODT_BUTTON        = 4;

const
  ODT_STATIC        = 5;

-- /*
--  * Owner draw actions
--  */
const
  ODA_DRAWENTIRE    = $01;

const
  ODA_SELECT        = $02;

const
  ODA_FOCUS         = $04;

-- /*
--  * Owner draw state
--  */
const
  ODS_SELECTED      = $01;

const
  ODS_GRAYED        = $02;

const
  ODS_DISABLED      = $04;

const
  ODS_CHECKED       = $08;

const
  ODS_FOCUS         = $10;

const
  ODS_DEFAULT       = $20;

const
  ODS_COMBOBOXEDIT  = $1000;

const
  ODS_HOTLIGHT      = $40;

const
  ODS_INACTIVE      = $80;

const
  ODS_NOACCEL       = $0100;

const
  ODS_NOFOCUSRECT   = $0200;

-- /*
--  * MEASUREITEMSTRUCT for ownerdraw
--  */
type
  tagMEASUREITEMSTRUCT = record
CtlType         : UINT;
CtlID           : UINT;
itemID          : UINT;
itemWidth       : UINT;
itemHeight      : UINT;
itemData        : ULONG_PTR;
  end record;
  MEASUREITEMSTRUCT = tagMEASUREITEMSTRUCT;
  PMEASUREITEMSTRUCT = ^tagMEASUREITEMSTRUCT;
  LPMEASUREITEMSTRUCT = ^tagMEASUREITEMSTRUCT;

-- /*
--  * DRAWITEMSTRUCT for ownerdraw
--  */
type
  tagDRAWITEMSTRUCT = record
CtlType         : UINT;
CtlID           : UINT;
itemID          : UINT;
itemAction      : UINT;
itemState       : UINT;
hwndItem        : t_HWND;
hDC             : t_HDC;
rcItem          : RECT;
itemData        : ULONG_PTR;
  end record;
  DRAWITEMSTRUCT    = tagDRAWITEMSTRUCT;
  PDRAWITEMSTRUCT   = ^tagDRAWITEMSTRUCT;
  LPDRAWITEMSTRUCT  = ^tagDRAWITEMSTRUCT;

-- /*
--  * DELETEITEMSTRUCT for ownerdraw
--  */
type
  tagDELETEITEMSTRUCT = record
CtlType         : UINT;
CtlID           : UINT;
itemID          : UINT;
hwndItem        : t_HWND;
itemData        : ULONG_PTR;
  end record;
  DELETEITEMSTRUCT  = tagDELETEITEMSTRUCT;
  PDELETEITEMSTRUCT = ^tagDELETEITEMSTRUCT;
  LPDELETEITEMSTRUCT = ^tagDELETEITEMSTRUCT;

-- /*
--  * COMPAREITEMSTUCT for ownerdraw sorting
--  */
type
  tagCOMPAREITEMSTRUCT = record
CtlType         : UINT;
CtlID           : UINT;
hwndItem        : t_HWND;
itemID1         : UINT;
itemData1       : ULONG_PTR;
itemID2         : UINT;
itemData2       : ULONG_PTR;
dwLocaleId      : DWORD;
  end record;
  COMPAREITEMSTRUCT = tagCOMPAREITEMSTRUCT;
  PCOMPAREITEMSTRUCT = ^tagCOMPAREITEMSTRUCT;
  LPCOMPAREITEMSTRUCT = ^tagCOMPAREITEMSTRUCT;

-- /*
--  * Message Function Templates
--  */
procedure GetMessageA(
    lpMsg           : out tagMSG; 
    hWnd            : in t_HWND; 
    wMsgFilterMin   : in UINT; 
    wMsgFilterMax   : in UINT)
                      return BOOL;
#pragma convention(GetMessageA,system);
#pragma import(GetMessageA,'GetMessageA','user32.dll');

procedure GetMessageW(
    lpMsg           : out tagMSG; 
    hWnd            : in t_HWND; 
    wMsgFilterMin   : in UINT; 
    wMsgFilterMax   : in UINT)
                      return BOOL;
#pragma convention(GetMessageW,system);
#pragma import(GetMessageW,'GetMessageW','user32.dll');

#if #declared UNICODE; then;
#template GetMessage;
  GetMessageW 
#end GetMessage;
#else;
#template GetMessage;
  GetMessageA 
#end GetMessage;
#end if;

type
t_020=^MSG for machine_pointer use true;

procedure TranslateMessage(
    lpMsg           : in t_020)
                      return BOOL;
#pragma convention(TranslateMessage,system);
#pragma import(TranslateMessage,'TranslateMessage','user32.dll');

type
t_021=^MSG for machine_pointer use true;

procedure DispatchMessageA(
    lpMsg           : in t_021)
                      return t_LRESULT;
#pragma convention(DispatchMessageA,system);
#pragma import(DispatchMessageA,'DispatchMessageA','user32.dll');

type
t_022=^MSG for machine_pointer use true;

procedure DispatchMessageW(
    lpMsg           : in t_022)
                      return t_LRESULT;
#pragma convention(DispatchMessageW,system);
#pragma import(DispatchMessageW,'DispatchMessageW','user32.dll');

#if #declared UNICODE; then;
#template DispatchMessage;
  DispatchMessageW 
#end DispatchMessage;
#else;
#template DispatchMessage;
  DispatchMessageA 
#end DispatchMessage;
#end if;

type
t_023=signed 32;

procedure SetMessageQueue(
    cMessagesMax    : in t_023)
                      return BOOL;
#pragma convention(SetMessageQueue,system);
#pragma import(SetMessageQueue,'SetMessageQueue','user32.dll');

procedure PeekMessageA(
    lpMsg           : out tagMSG; 
    hWnd            : in t_HWND; 
    wMsgFilterMin   : in UINT; 
    wMsgFilterMax   : in UINT; 
    wRemoveMsg      : in UINT)
                      return BOOL;
#pragma convention(PeekMessageA,system);
#pragma import(PeekMessageA,'PeekMessageA','user32.dll');

procedure PeekMessageW(
    lpMsg           : out tagMSG; 
    hWnd            : in t_HWND; 
    wMsgFilterMin   : in UINT; 
    wMsgFilterMax   : in UINT; 
    wRemoveMsg      : in UINT)
                      return BOOL;
#pragma convention(PeekMessageW,system);
#pragma import(PeekMessageW,'PeekMessageW','user32.dll');

#if #declared UNICODE; then;
#template PeekMessage;
  PeekMessageW 
#end PeekMessage;
#else;
#template PeekMessage;
  PeekMessageA 
#end PeekMessage;
#end if;

-- /*
--  * PeekMessage() Options
--  */
const
  PM_NOREMOVE       = $00;

const
  PM_REMOVE         = $01;

const
  PM_NOYIELD        = $02;

type
t_024=signed 32;

procedure RegisterHotKey(
    hWnd            : in t_HWND; 
    id              : in t_024; 
    fsModifiers     : in UINT; 
    vk              : in UINT)
                      return BOOL;
#pragma convention(RegisterHotKey,system);
#pragma import(RegisterHotKey,'RegisterHotKey','user32.dll');

type
t_025=signed 32;

procedure UnregisterHotKey(
    hWnd            : in t_HWND; 
    id              : in t_025)
                      return BOOL;
#pragma convention(UnregisterHotKey,system);
#pragma import(UnregisterHotKey,'UnregisterHotKey','user32.dll');

const
  MOD_ALT           = $01;

const
  MOD_CONTROL       = $02;

const
  MOD_SHIFT         = $04;

const
  MOD_WIN           = $08;

const
  ENDSESSION_LOGOFF = $80000000;

const
  EWX_LOGOFF        = 0;

const
  EWX_SHUTDOWN      = $01;

const
  EWX_REBOOT        = $02;

const
  EWX_FORCE         = $04;

const
  EWX_POWEROFF      = $08;

const
  EWX_FORCEIFHUNG   = $10;

procedure ExitWindowsEx(
    uFlags          : in UINT; 
    dwReserved      : in DWORD)
                      return BOOL;
#pragma convention(ExitWindowsEx,system);
#pragma import(ExitWindowsEx,'ExitWindowsEx','user32.dll');

procedure SwapMouseButton(
    fSwap           : in BOOL)
                      return BOOL;
#pragma convention(SwapMouseButton,system);
#pragma import(SwapMouseButton,'SwapMouseButton','user32.dll');

procedure GetMessagePos
                      return DWORD;
#pragma convention(GetMessagePos,system);
#pragma import(GetMessagePos,'GetMessagePos','user32.dll');

procedure GetMessageTime
                      return LONG;
#pragma convention(GetMessageTime,system);
#pragma import(GetMessageTime,'GetMessageTime','user32.dll');

procedure GetMessageExtraInfo
                      return t_LPARAM;
#pragma convention(GetMessageExtraInfo,system);
#pragma import(GetMessageExtraInfo,'GetMessageExtraInfo','user32.dll');

procedure SetMessageExtraInfo(
    lParam          : in t_LPARAM)
                      return t_LPARAM;
#pragma convention(SetMessageExtraInfo,system);
#pragma import(SetMessageExtraInfo,'SetMessageExtraInfo','user32.dll');

procedure SendMessageA(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(SendMessageA,system);
#pragma import(SendMessageA,'SendMessageA','user32.dll');

procedure SendMessageW(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(SendMessageW,system);
#pragma import(SendMessageW,'SendMessageW','user32.dll');

#if #declared UNICODE; then;
#template SendMessage;
  SendMessageW 
#end SendMessage;
#else;
#template SendMessage;
  SendMessageA 
#end SendMessage;
#end if;

procedure SendMessageTimeoutA(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM; 
    fuFlags         : in UINT; 
    uTimeout        : in UINT; 
    lpdwResult      : out ULONG_PTR )
                      return t_LRESULT;
#pragma convention(SendMessageTimeoutA,system);
#pragma import(SendMessageTimeoutA,'SendMessageTimeoutA','user32.dll');

procedure SendMessageTimeoutW(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM; 
    fuFlags         : in UINT; 
    uTimeout        : in UINT; 
    lpdwResult      : out ULONG_PTR )
                      return t_LRESULT;
#pragma convention(SendMessageTimeoutW,system);
#pragma import(SendMessageTimeoutW,'SendMessageTimeoutW','user32.dll');

#if #declared UNICODE; then;
#template SendMessageTimeout;
  SendMessageTimeoutW 
#end SendMessageTimeout;
#else;
#template SendMessageTimeout;
  SendMessageTimeoutA 
#end SendMessageTimeout;
#end if;

procedure SendNotifyMessageA(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(SendNotifyMessageA,system);
#pragma import(SendNotifyMessageA,'SendNotifyMessageA','user32.dll');

procedure SendNotifyMessageW(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(SendNotifyMessageW,system);
#pragma import(SendNotifyMessageW,'SendNotifyMessageW','user32.dll');

#if #declared UNICODE; then;
#template SendNotifyMessage;
  SendNotifyMessageW 
#end SendNotifyMessage;
#else;
#template SendNotifyMessage;
  SendNotifyMessageA 
#end SendNotifyMessage;
#end if;

procedure SendMessageCallbackA(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM; 
    lpResultCallBack : in SENDASYNCPROC; 
    dwData          : in ULONG_PTR)
                      return BOOL;
#pragma convention(SendMessageCallbackA,system);
#pragma import(SendMessageCallbackA,'SendMessageCallbackA','user32.dll');

procedure SendMessageCallbackW(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM; 
    lpResultCallBack : in SENDASYNCPROC; 
    dwData          : in ULONG_PTR)
                      return BOOL;
#pragma convention(SendMessageCallbackW,system);
#pragma import(SendMessageCallbackW,'SendMessageCallbackW','user32.dll');

#if #declared UNICODE; then;
#template SendMessageCallback;
  SendMessageCallbackW 
#end SendMessageCallback;
#else;
#template SendMessageCallback;
  SendMessageCallbackA 
#end SendMessageCallback;
#end if;

type
  BSMINFO           = record
cbSize          : UINT;
hdesk           : t_HDESK;
hwnd            : t_HWND;
luid            : t_LUID;
  end record;
  PBSMINFO          = ^BSMINFO;

type
  t_026 = signed 32;

procedure BroadcastSystemMessageExA(
    _001            : in DWORD; 
    _002            : in LPDWORD; 
    _003            : in UINT; 
    _004            : in t_WPARAM; 
    _005            : in t_LPARAM; 
    _006            : out BSMINFO)
                      return t_026;
#pragma convention(BroadcastSystemMessageExA,system);
#pragma import(BroadcastSystemMessageExA,'BroadcastSystemMessageExA','user32.dll');

type
  t_027 = signed 32;

procedure BroadcastSystemMessageExW(
    _001            : in DWORD; 
    _002            : in LPDWORD; 
    _003            : in UINT; 
    _004            : in t_WPARAM; 
    _005            : in t_LPARAM; 
    _006            : out BSMINFO)
                      return t_027;
#pragma convention(BroadcastSystemMessageExW,system);
#pragma import(BroadcastSystemMessageExW,'BroadcastSystemMessageExW','user32.dll');

#if #declared UNICODE; then;
#template BroadcastSystemMessageEx;
  BroadcastSystemMessageExW 
#end BroadcastSystemMessageEx;
#else;
#template BroadcastSystemMessageEx;
  BroadcastSystemMessageExA 
#end BroadcastSystemMessageEx;
#end if;

type
  t_028 = signed 32;

procedure BroadcastSystemMessageA(
    _001            : in DWORD; 
    _002            : in LPDWORD; 
    _003            : in UINT; 
    _004            : in t_WPARAM; 
    _005            : in t_LPARAM)
                      return t_028;
#pragma convention(BroadcastSystemMessageA,system);
#pragma import(BroadcastSystemMessageA,'BroadcastSystemMessageA','user32.dll');

type
  t_029 = signed 32;

procedure BroadcastSystemMessageW(
    _001            : in DWORD; 
    _002            : in LPDWORD; 
    _003            : in UINT; 
    _004            : in t_WPARAM; 
    _005            : in t_LPARAM)
                      return t_029;
#pragma convention(BroadcastSystemMessageW,system);
#pragma import(BroadcastSystemMessageW,'BroadcastSystemMessageW','user32.dll');

#if #declared UNICODE; then;
#template BroadcastSystemMessage;
  BroadcastSystemMessageW 
#end BroadcastSystemMessage;
#else;
#template BroadcastSystemMessage;
  BroadcastSystemMessageA 
#end BroadcastSystemMessage;
#end if;

-- Broadcast Special Message Recipient list
const
  BSM_ALLCOMPONENTS = $00;

const
  BSM_VXDS          = $01;

const
  BSM_NETDRIVER     = $02;

const
  BSM_INSTALLABLEDRIVERS= $04;

const
  BSM_APPLICATIONS  = $08;

const
  BSM_ALLDESKTOPS   = $10;

-- Broadcast Special Message Flags
const
  BSF_QUERY         = $01;

const
  BSF_IGNORECURRENTTASK= $02;

const
  BSF_FLUSHDISK     = $04;

const
  BSF_NOHANG        = $08;

const
  BSF_POSTMESSAGE   = $10;

const
  BSF_FORCEIFHUNG   = $20;

const
  BSF_NOTIMEOUTIFNOTHUNG= $40;

const
  BSF_ALLOWSFW      = $80;

const
  BSF_SENDNOTIFYMESSAGE= $0100;

const
  BSF_RETURNHDESK   = $0200;

const
  BSF_LUID          = $0400;

const
  BROADCAST_QUERY_DENY= $424D5144;

--  RegisterDeviceNotification
type
HDEVNOTIFY        = PVOID;
type
PHDEVNOTIFY       = ^HDEVNOTIFY for machine_pointer use true;
const
  DEVICE_NOTIFY_WINDOW_HANDLE= $00;

const
  DEVICE_NOTIFY_SERVICE_HANDLE= $01;

const
  DEVICE_NOTIFY_ALL_INTERFACE_CLASSES= $04;

procedure RegisterDeviceNotificationA(
    hRecipient      : in t_HANDLE; 
    NotificationFilter : in LPVOID; 
    Flags           : in DWORD)
                      return HDEVNOTIFY;
#pragma convention(RegisterDeviceNotificationA,system);
#pragma import(RegisterDeviceNotificationA,'RegisterDeviceNotificationA','user32.dll');

procedure RegisterDeviceNotificationW(
    hRecipient      : in t_HANDLE; 
    NotificationFilter : in LPVOID; 
    Flags           : in DWORD)
                      return HDEVNOTIFY;
#pragma convention(RegisterDeviceNotificationW,system);
#pragma import(RegisterDeviceNotificationW,'RegisterDeviceNotificationW','user32.dll');

#if #declared UNICODE; then;
#template RegisterDeviceNotification;
  RegisterDeviceNotificationW 
#end RegisterDeviceNotification;
#else;
#template RegisterDeviceNotification;
  RegisterDeviceNotificationA 
#end RegisterDeviceNotification;
#end if;

procedure UnregisterDeviceNotification(
    Handle          : in HDEVNOTIFY)
                      return BOOL;
#pragma convention(UnregisterDeviceNotification,system);
#pragma import(UnregisterDeviceNotification,'UnregisterDeviceNotification','user32.dll');

procedure PostMessageA(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(PostMessageA,system);
#pragma import(PostMessageA,'PostMessageA','user32.dll');

procedure PostMessageW(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(PostMessageW,system);
#pragma import(PostMessageW,'PostMessageW','user32.dll');

#if #declared UNICODE; then;
#template PostMessage;
  PostMessageW 
#end PostMessage;
#else;
#template PostMessage;
  PostMessageA 
#end PostMessage;
#end if;

procedure PostThreadMessageA(
    idThread        : in DWORD; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(PostThreadMessageA,system);
#pragma import(PostThreadMessageA,'PostThreadMessageA','user32.dll');

procedure PostThreadMessageW(
    idThread        : in DWORD; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(PostThreadMessageW,system);
#pragma import(PostThreadMessageW,'PostThreadMessageW','user32.dll');

#if #declared UNICODE; then;
#template PostThreadMessage;
  PostThreadMessageW 
#end PostThreadMessage;
#else;
#template PostThreadMessage;
  PostThreadMessageA 
#end PostThreadMessage;
#end if;

#if #declared UNICODE; then;
#template PostAppMessage;
  {PostAppMessageW(idThread,wMsg,wParam,lParam)} PostThreadMessageW((DWORD)idThread,wMsg,wParam,lParam) 
#end PostAppMessage;
#else;
#template PostAppMessage;
  {PostAppMessageA(idThread,wMsg,wParam,lParam)} PostThreadMessageA((DWORD)idThread,wMsg,wParam,lParam) 
#end PostAppMessage;
#end if;

-- /*
--  * Special HWND value for use with PostMessage() and SendMessage()
--  */
procedure AttachThreadInput(
    idAttach        : in DWORD; 
    idAttachTo      : in DWORD; 
    fAttach         : in BOOL)
                      return BOOL;
#pragma convention(AttachThreadInput,system);
#pragma import(AttachThreadInput,'AttachThreadInput','user32.dll');

procedure ReplyMessage(
    lResult         : in t_LRESULT)
                      return BOOL;
#pragma convention(ReplyMessage,system);
#pragma import(ReplyMessage,'ReplyMessage','user32.dll');

procedure WaitMessage
                      return BOOL;
#pragma convention(WaitMessage,system);
#pragma import(WaitMessage,'WaitMessage','user32.dll');

procedure WaitForInputIdle(
    hProcess        : in t_HANDLE; 
    dwMilliseconds  : in DWORD)
                      return DWORD;
#pragma convention(WaitForInputIdle,system);
#pragma import(WaitForInputIdle,'WaitForInputIdle','user32.dll');

procedure DefWindowProcA(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(DefWindowProcA,system);
#pragma import(DefWindowProcA,'DefWindowProcA','user32.dll');

procedure DefWindowProcW(
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(DefWindowProcW,system);
#pragma import(DefWindowProcW,'DefWindowProcW','user32.dll');

#if #declared UNICODE; then;
#template DefWindowProc;
  DefWindowProcW 
#end DefWindowProc;
#else;
#template DefWindowProc;
  DefWindowProcA 
#end DefWindowProc;
#end if;

type
t_030=signed 32;

procedure PostQuitMessage(
    nExitCode       : in t_030);
#pragma convention(PostQuitMessage,system);
#pragma import(PostQuitMessage,'PostQuitMessage','user32.dll');

procedure CallWindowProcA(
    lpPrevWndFunc   : in FARPROC; 
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(CallWindowProcA,system);
#pragma import(CallWindowProcA,'CallWindowProcA','user32.dll');

procedure CallWindowProcW(
    lpPrevWndFunc   : in FARPROC; 
    hWnd            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(CallWindowProcW,system);
#pragma import(CallWindowProcW,'CallWindowProcW','user32.dll');

#if #declared UNICODE; then;
#template CallWindowProc;
  CallWindowProcW 
#end CallWindowProc;
#else;
#template CallWindowProc;
  CallWindowProcA 
#end CallWindowProc;
#end if;

procedure InSendMessage
                      return BOOL;
#pragma convention(InSendMessage,system);
#pragma import(InSendMessage,'InSendMessage','user32.dll');

procedure InSendMessageEx(
    lpReserved      : in LPVOID)
                      return DWORD;
#pragma convention(InSendMessageEx,system);
#pragma import(InSendMessageEx,'InSendMessageEx','user32.dll');

-- /*
--  * InSendMessageEx return value
--  */
const
  ISMEX_NOSEND      = $00;

const
  ISMEX_SEND        = $01;

const
  ISMEX_NOTIFY      = $02;

const
  ISMEX_CALLBACK    = $04;

const
  ISMEX_REPLIED     = $08;

procedure GetDoubleClickTime
                      return UINT;
#pragma convention(GetDoubleClickTime,system);
#pragma import(GetDoubleClickTime,'GetDoubleClickTime','user32.dll');

procedure SetDoubleClickTime(
    _001            : in UINT)
                      return BOOL;
#pragma convention(SetDoubleClickTime,system);
#pragma import(SetDoubleClickTime,'SetDoubleClickTime','user32.dll');

type
t_031=^WNDCLASSA for machine_pointer use true;

procedure RegisterClassA(
    lpWndClass      : in t_031)
                      return ATOM;
#pragma convention(RegisterClassA,system);
#pragma import(RegisterClassA,'RegisterClassA','user32.dll');

type
t_032=^WNDCLASSW for machine_pointer use true;

procedure RegisterClassW(
    lpWndClass      : in t_032)
                      return ATOM;
#pragma convention(RegisterClassW,system);
#pragma import(RegisterClassW,'RegisterClassW','user32.dll');

#if #declared UNICODE; then;
#template RegisterClass;
  RegisterClassW 
#end RegisterClass;
#else;
#template RegisterClass;
  RegisterClassA 
#end RegisterClass;
#end if;

procedure UnregisterClassA(
    lpClassName     : in LPCSTR; 
    hInstance       : in t_HINSTANCE)
                      return BOOL;
#pragma convention(UnregisterClassA,system);
#pragma import(UnregisterClassA,'UnregisterClassA','user32.dll');

procedure UnregisterClassW(
    lpClassName     : in LPCWSTR; 
    hInstance       : in t_HINSTANCE)
                      return BOOL;
#pragma convention(UnregisterClassW,system);
#pragma import(UnregisterClassW,'UnregisterClassW','user32.dll');

#if #declared UNICODE; then;
#template UnregisterClass;
  UnregisterClassW 
#end UnregisterClass;
#else;
#template UnregisterClass;
  UnregisterClassA 
#end UnregisterClass;
#end if;

procedure GetClassInfoA(
    hInstance       : in t_HINSTANCE; 
    lpClassName     : in LPCSTR; 
    lpWndClass      : out tagWNDCLASSA)
                      return BOOL;
#pragma convention(GetClassInfoA,system);
#pragma import(GetClassInfoA,'GetClassInfoA','user32.dll');

procedure GetClassInfoW(
    hInstance       : in t_HINSTANCE; 
    lpClassName     : in LPCWSTR; 
    lpWndClass      : out tagWNDCLASSW)
                      return BOOL;
#pragma convention(GetClassInfoW,system);
#pragma import(GetClassInfoW,'GetClassInfoW','user32.dll');

#if #declared UNICODE; then;
#template GetClassInfo;
  GetClassInfoW 
#end GetClassInfo;
#else;
#template GetClassInfo;
  GetClassInfoA 
#end GetClassInfo;
#end if;

type
t_033=^WNDCLASSEXA for machine_pointer use true;

procedure RegisterClassExA(
    _001            : in t_033)
                      return ATOM;
#pragma convention(RegisterClassExA,system);
#pragma import(RegisterClassExA,'RegisterClassExA','user32.dll');

type
t_034=^WNDCLASSEXW for machine_pointer use true;

procedure RegisterClassExW(
    _001            : in t_034)
                      return ATOM;
#pragma convention(RegisterClassExW,system);
#pragma import(RegisterClassExW,'RegisterClassExW','user32.dll');

#if #declared UNICODE; then;
#template RegisterClassEx;
  RegisterClassExW 
#end RegisterClassEx;
#else;
#template RegisterClassEx;
  RegisterClassExA 
#end RegisterClassEx;
#end if;

procedure GetClassInfoExA(
    _001            : in t_HINSTANCE; 
    _002            : in LPCSTR; 
    _003            : out tagWNDCLASSEXA)
                      return BOOL;
#pragma convention(GetClassInfoExA,system);
#pragma import(GetClassInfoExA,'GetClassInfoExA','user32.dll');

procedure GetClassInfoExW(
    _001            : in t_HINSTANCE; 
    _002            : in LPCWSTR; 
    _003            : out tagWNDCLASSEXW)
                      return BOOL;
#pragma convention(GetClassInfoExW,system);
#pragma import(GetClassInfoExW,'GetClassInfoExW','user32.dll');

#if #declared UNICODE; then;
#template GetClassInfoEx;
  GetClassInfoExW 
#end GetClassInfoEx;
#else;
#template GetClassInfoEx;
  GetClassInfoExA 
#end GetClassInfoEx;
#end if;

-- /*
--  * Special value for CreateWindow, et al.
--  */
type
PREGISTERCLASSNAMEW = ^procedure (
    _001            : LPCWSTR)
                      return BOOLEAN for machine_pointer use true;
type
t_035=signed 32;

t_036=signed 32;

t_037=signed 32;

t_038=signed 32;

procedure CreateWindowExA(
    dwExStyle       : in DWORD; 
    lpClassName     : in LPCSTR; 
    lpWindowName    : in LPCSTR; 
    dwStyle         : in DWORD; 
    X               : in t_035; 
    Y               : in t_036; 
    nWidth          : in t_037; 
    nHeight         : in t_038; 
    hWndParent      : in t_HWND; 
    hMenu           : in t_HMENU; 
    hInstance       : in t_HINSTANCE; 
    lpParam         : in LPVOID)
                      return t_HWND;
#pragma convention(CreateWindowExA,system);
#pragma import(CreateWindowExA,'CreateWindowExA','user32.dll');

type
t_039=signed 32;

t_040=signed 32;

t_041=signed 32;

t_042=signed 32;

procedure CreateWindowExW(
    dwExStyle       : in DWORD; 
    lpClassName     : in LPCWSTR; 
    lpWindowName    : in LPCWSTR; 
    dwStyle         : in DWORD; 
    X               : in t_039; 
    Y               : in t_040; 
    nWidth          : in t_041; 
    nHeight         : in t_042; 
    hWndParent      : in t_HWND; 
    hMenu           : in t_HMENU; 
    hInstance       : in t_HINSTANCE; 
    lpParam         : in LPVOID)
                      return t_HWND;
#pragma convention(CreateWindowExW,system);
#pragma import(CreateWindowExW,'CreateWindowExW','user32.dll');

#if #declared UNICODE; then;
#template CreateWindowEx;
  CreateWindowExW 
#end CreateWindowEx;
#else;
#template CreateWindowEx;
  CreateWindowExA 
#end CreateWindowEx;
#end if;

#if #declared UNICODE; then;
#template CreateWindow;
  {CreateWindowW(lpClassName,lpWindowName,dwStyle,x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam)} CreateWindowExW(0 ,lpClassName,lpWindowName,dwStyle,x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam) 
#end CreateWindow;
#else;
#template CreateWindow;
  {CreateWindowA(lpClassName,lpWindowName,dwStyle,x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam)} CreateWindowExA(0 ,lpClassName,lpWindowName,dwStyle,x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam) 
#end CreateWindow;
#end if;

procedure IsWindow(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(IsWindow,system);
#pragma import(IsWindow,'IsWindow','user32.dll');

procedure IsMenu(
    hMenu           : in t_HMENU)
                      return BOOL;
#pragma convention(IsMenu,system);
#pragma import(IsMenu,'IsMenu','user32.dll');

procedure IsChild(
    hWndParent      : in t_HWND; 
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(IsChild,system);
#pragma import(IsChild,'IsChild','user32.dll');

procedure DestroyWindow(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(DestroyWindow,system);
#pragma import(DestroyWindow,'DestroyWindow','user32.dll');

type
t_043=signed 32;

procedure ShowWindow(
    hWnd            : in t_HWND; 
    nCmdShow        : in t_043)
                      return BOOL;
#pragma convention(ShowWindow,system);
#pragma import(ShowWindow,'ShowWindow','user32.dll');

procedure AnimateWindow(
    hWnd            : in t_HWND; 
    dwTime          : in DWORD; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(AnimateWindow,system);
#pragma import(AnimateWindow,'AnimateWindow','user32.dll');

type
t_044=^t_POINT for machine_pointer use true;

t_045=^SIZE for machine_pointer use true;

t_046=^t_POINT for machine_pointer use true;

t_047=^BLENDFUNCTION for machine_pointer use true;

procedure UpdateLayeredWindow(
    hWnd            : t_HWND; 
    hdcDst          : t_HDC; 
    pptDst          : t_044; 
    psize           : t_045; 
    hdcSrc          : t_HDC; 
    pptSrc          : t_046; 
    crKey           : COLORREF; 
    pblend          : t_047; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(UpdateLayeredWindow,system);
#pragma import(UpdateLayeredWindow,'UpdateLayeredWindow','user32.dll');

type
t_048=^COLORREF for machine_pointer use true;

t_049=^BYTE for machine_pointer use true;

t_050=^DWORD for machine_pointer use true;

procedure GetLayeredWindowAttributes(
    hwnd            : t_HWND; 
    pcrKey          : t_048; 
    pbAlpha         : t_049; 
    pdwFlags        : t_050)
                      return BOOL;
#pragma convention(GetLayeredWindowAttributes,system);
#pragma import(GetLayeredWindowAttributes,'GetLayeredWindowAttributes','user32.dll');

const
  PW_CLIENTONLY     = $01;

procedure PrintWindow(
    hwnd            : in t_HWND; 
    hdcBlt          : in t_HDC; 
    nFlags          : in UINT)
                      return BOOL;
#pragma convention(PrintWindow,system);
#pragma import(PrintWindow,'PrintWindow','user32.dll');

procedure SetLayeredWindowAttributes(
    hwnd            : t_HWND; 
    crKey           : COLORREF; 
    bAlpha          : BYTE; 
    dwFlags         : DWORD)
                      return BOOL;
#pragma convention(SetLayeredWindowAttributes,system);
#pragma import(SetLayeredWindowAttributes,'SetLayeredWindowAttributes','user32.dll');

const
  LWA_COLORKEY      = $01;

const
  LWA_ALPHA         = $02;

const
  ULW_COLORKEY      = $01;

const
  ULW_ALPHA         = $02;

const
  ULW_OPAQUE        = $04;

type
t_051=signed 32;

procedure ShowWindowAsync(
    hWnd            : in t_HWND; 
    nCmdShow        : in t_051)
                      return BOOL;
#pragma convention(ShowWindowAsync,system);
#pragma import(ShowWindowAsync,'ShowWindowAsync','user32.dll');

procedure FlashWindow(
    hWnd            : in t_HWND; 
    bInvert         : in BOOL)
                      return BOOL;
#pragma convention(FlashWindow,system);
#pragma import(FlashWindow,'FlashWindow','user32.dll');

type
  FLASHWINFO        = record
cbSize          : UINT;
hwnd            : t_HWND;
dwFlags         : DWORD;
uCount          : UINT;
dwTimeout       : DWORD;
  end record;
  PFLASHWINFO       = ^FLASHWINFO;

procedure FlashWindowEx(
    pfwi            : PFLASHWINFO)
                      return BOOL;
#pragma convention(FlashWindowEx,system);
#pragma import(FlashWindowEx,'FlashWindowEx','user32.dll');

const
  FLASHW_STOP       = 0;

const
  FLASHW_CAPTION    = $01;

const
  FLASHW_TRAY       = $02;

const
  FLASHW_TIMER      = $04;

const
  FLASHW_TIMERNOFG  = $0C;

procedure ShowOwnedPopups(
    hWnd            : in t_HWND; 
    fShow           : in BOOL)
                      return BOOL;
#pragma convention(ShowOwnedPopups,system);
#pragma import(ShowOwnedPopups,'ShowOwnedPopups','user32.dll');

procedure OpenIcon(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(OpenIcon,system);
#pragma import(OpenIcon,'OpenIcon','user32.dll');

procedure CloseWindow(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(CloseWindow,system);
#pragma import(CloseWindow,'CloseWindow','user32.dll');

type
t_052=signed 32;

t_053=signed 32;

t_054=signed 32;

t_055=signed 32;

procedure MoveWindow(
    hWnd            : in t_HWND; 
    X               : in t_052; 
    Y               : in t_053; 
    nWidth          : in t_054; 
    nHeight         : in t_055; 
    bRepaint        : in BOOL)
                      return BOOL;
#pragma convention(MoveWindow,system);
#pragma import(MoveWindow,'MoveWindow','user32.dll');

type
t_056=signed 32;

t_057=signed 32;

t_058=signed 32;

t_059=signed 32;

procedure SetWindowPos(
    hWnd            : in t_HWND; 
    hWndInsertAfter : in t_HWND; 
    X               : in t_056; 
    Y               : in t_057; 
    cx              : in t_058; 
    cy              : in t_059; 
    uFlags          : in UINT)
                      return BOOL;
#pragma convention(SetWindowPos,system);
#pragma import(SetWindowPos,'SetWindowPos','user32.dll');

procedure GetWindowPlacement(
    hWnd            : in t_HWND; 
    lpwndpl         : out WINDOWPLACEMENT)
                      return BOOL;
#pragma convention(GetWindowPlacement,system);
#pragma import(GetWindowPlacement,'GetWindowPlacement','user32.dll');

type
t_060=^WINDOWPLACEMENT for machine_pointer use true;

procedure SetWindowPlacement(
    hWnd            : in t_HWND; 
    lpwndpl         : in t_060)
                      return BOOL;
#pragma convention(SetWindowPlacement,system);
#pragma import(SetWindowPlacement,'SetWindowPlacement','user32.dll');

type
t_061=signed 32;

procedure BeginDeferWindowPos(
    nNumWindows     : in t_061)
                      return HDWP;
#pragma convention(BeginDeferWindowPos,system);
#pragma import(BeginDeferWindowPos,'BeginDeferWindowPos','user32.dll');

type
t_062=signed 32;

t_063=signed 32;

t_064=signed 32;

t_065=signed 32;

procedure DeferWindowPos(
    hWinPosInfo     : in HDWP; 
    hWnd            : in t_HWND; 
    hWndInsertAfter : in t_HWND; 
    x               : in t_062; 
    y               : in t_063; 
    cx              : in t_064; 
    cy              : in t_065; 
    uFlags          : in UINT)
                      return HDWP;
#pragma convention(DeferWindowPos,system);
#pragma import(DeferWindowPos,'DeferWindowPos','user32.dll');

procedure EndDeferWindowPos(
    hWinPosInfo     : in HDWP)
                      return BOOL;
#pragma convention(EndDeferWindowPos,system);
#pragma import(EndDeferWindowPos,'EndDeferWindowPos','user32.dll');

procedure IsWindowVisible(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(IsWindowVisible,system);
#pragma import(IsWindowVisible,'IsWindowVisible','user32.dll');

procedure IsIconic(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(IsIconic,system);
#pragma import(IsIconic,'IsIconic','user32.dll');

procedure AnyPopup
                      return BOOL;
#pragma convention(AnyPopup,system);
#pragma import(AnyPopup,'AnyPopup','user32.dll');

procedure BringWindowToTop(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(BringWindowToTop,system);
#pragma import(BringWindowToTop,'BringWindowToTop','user32.dll');

procedure IsZoomed(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(IsZoomed,system);
#pragma import(IsZoomed,'IsZoomed','user32.dll');

-- /*
--  * SetWindowPos Flags
--  */
const
  SWP_NOSIZE        = $01;

const
  SWP_NOMOVE        = $02;

const
  SWP_NOZORDER      = $04;

const
  SWP_NOREDRAW      = $08;

const
  SWP_NOACTIVATE    = $10;

const
  SWP_FRAMECHANGED  = $20;

const
  SWP_SHOWWINDOW    = $40;

const
  SWP_HIDEWINDOW    = $80;

const
  SWP_NOCOPYBITS    = $0100;

const
  SWP_NOOWNERZORDER = $0200;

const
  SWP_NOSENDCHANGING= $0400;

const
  SWP_DEFERERASE    = $2000;

const
  SWP_ASYNCWINDOWPOS= $4000;

-- /*
--  * WARNING:
--  * The following structures must NOT be DWORD padded because they are
--  * followed by strings, etc that do not have to be DWORD aligned.
--  */
-- ignored #include <pshpack2.h>
-- /*
--  * original NT 32 bit dialog template:
--  */
type
  DLGTEMPLATE       = record
style           : DWORD;
dwExtendedStyle : DWORD;
cdit            : WORD;
x               : signed 16;
y               : signed 16;
cx              : signed 16;
cy              : signed 16;
  end record;

type
LPDLGTEMPLATEA    = ^DLGTEMPLATE for machine_pointer use true;
type
LPDLGTEMPLATEW    = ^DLGTEMPLATE for machine_pointer use true;
#if #declared UNICODE; then;
type
LPDLGTEMPLATE     = LPDLGTEMPLATEW;
#else;
type
LPDLGTEMPLATE     = LPDLGTEMPLATEA;
#end if;

type
LPCDLGTEMPLATEA   = ^DLGTEMPLATE for machine_pointer use true;
type
LPCDLGTEMPLATEW   = ^DLGTEMPLATE for machine_pointer use true;
#if #declared UNICODE; then;
type
LPCDLGTEMPLATE    = LPCDLGTEMPLATEW;
#else;
type
LPCDLGTEMPLATE    = LPCDLGTEMPLATEA;
#end if;

-- /*
--  * 32 bit Dialog item template.
--  */
type
  DLGITEMTEMPLATE   = record
style           : DWORD;
dwExtendedStyle : DWORD;
x               : signed 16;
y               : signed 16;
cx              : signed 16;
cy              : signed 16;
id              : WORD;
  end record;

type
PDLGITEMTEMPLATEA = ^DLGITEMTEMPLATE for machine_pointer use true;
type
PDLGITEMTEMPLATEW = ^DLGITEMTEMPLATE for machine_pointer use true;
#if #declared UNICODE; then;
type
PDLGITEMTEMPLATE  = PDLGITEMTEMPLATEW;
#else;
type
PDLGITEMTEMPLATE  = PDLGITEMTEMPLATEA;
#end if;

type
LPDLGITEMTEMPLATEA = ^DLGITEMTEMPLATE for machine_pointer use true;
type
LPDLGITEMTEMPLATEW = ^DLGITEMTEMPLATE for machine_pointer use true;
#if #declared UNICODE; then;
type
LPDLGITEMTEMPLATE = LPDLGITEMTEMPLATEW;
#else;
type
LPDLGITEMTEMPLATE = LPDLGITEMTEMPLATEA;
#end if;

-- ignored #include <poppack.h>
-- /* Resume normal packing 
procedure CreateDialogParamA(
    hInstance       : in t_HINSTANCE; 
    lpTemplateName  : in LPCSTR; 
    hWndParent      : in t_HWND; 
    lpDialogFunc    : in DLGPROC; 
    dwInitParam     : in t_LPARAM)
                      return t_HWND;
#pragma convention(CreateDialogParamA,system);
#pragma import(CreateDialogParamA,'CreateDialogParamA','user32.dll');

procedure CreateDialogParamW(
    hInstance       : in t_HINSTANCE; 
    lpTemplateName  : in LPCWSTR; 
    hWndParent      : in t_HWND; 
    lpDialogFunc    : in DLGPROC; 
    dwInitParam     : in t_LPARAM)
                      return t_HWND;
#pragma convention(CreateDialogParamW,system);
#pragma import(CreateDialogParamW,'CreateDialogParamW','user32.dll');

#if #declared UNICODE; then;
#template CreateDialogParam;
  CreateDialogParamW 
#end CreateDialogParam;
#else;
#template CreateDialogParam;
  CreateDialogParamA 
#end CreateDialogParam;
#end if;

procedure CreateDialogIndirectParamA(
    hInstance       : in t_HINSTANCE; 
    lpTemplate      : in LPCDLGTEMPLATEA; 
    hWndParent      : in t_HWND; 
    lpDialogFunc    : in DLGPROC; 
    dwInitParam     : in t_LPARAM)
                      return t_HWND;
#pragma convention(CreateDialogIndirectParamA,system);
#pragma import(CreateDialogIndirectParamA,'CreateDialogIndirectParamA','user32.dll');

procedure CreateDialogIndirectParamW(
    hInstance       : in t_HINSTANCE; 
    lpTemplate      : in LPCDLGTEMPLATEW; 
    hWndParent      : in t_HWND; 
    lpDialogFunc    : in DLGPROC; 
    dwInitParam     : in t_LPARAM)
                      return t_HWND;
#pragma convention(CreateDialogIndirectParamW,system);
#pragma import(CreateDialogIndirectParamW,'CreateDialogIndirectParamW','user32.dll');

#if #declared UNICODE; then;
#template CreateDialogIndirectParam;
  CreateDialogIndirectParamW 
#end CreateDialogIndirectParam;
#else;
#template CreateDialogIndirectParam;
  CreateDialogIndirectParamA 
#end CreateDialogIndirectParam;
#end if;

#if #declared UNICODE; then;
#template CreateDialog;
  {CreateDialogW(hInstance,lpName,hWndParent,lpDialogFunc)} CreateDialogParamW(hInstance,lpName,hWndParent,lpDialogFunc,0 ) 
#end CreateDialog;
#else;
#template CreateDialog;
  {CreateDialogA(hInstance,lpName,hWndParent,lpDialogFunc)} CreateDialogParamA(hInstance,lpName,hWndParent,lpDialogFunc,0 ) 
#end CreateDialog;
#end if;

#if #declared UNICODE; then;
#template CreateDialogIndirect;
  {CreateDialogIndirectW(hInstance,lpTemplate,hWndParent,lpDialogFunc)} CreateDialogIndirectParamW(hInstance,lpTemplate,hWndParent,lpDialogFunc,0 ) 
#end CreateDialogIndirect;
#else;
#template CreateDialogIndirect;
  {CreateDialogIndirectA(hInstance,lpTemplate,hWndParent,lpDialogFunc)} CreateDialogIndirectParamA(hInstance,lpTemplate,hWndParent,lpDialogFunc,0 ) 
#end CreateDialogIndirect;
#end if;

procedure DialogBoxParamA(
    hInstance       : in t_HINSTANCE; 
    lpTemplateName  : in LPCSTR; 
    hWndParent      : in t_HWND; 
    lpDialogFunc    : in DLGPROC; 
    dwInitParam     : in t_LPARAM)
                      return INT_PTR;
#pragma convention(DialogBoxParamA,system);
#pragma import(DialogBoxParamA,'DialogBoxParamA','user32.dll');

procedure DialogBoxParamW(
    hInstance       : in t_HINSTANCE; 
    lpTemplateName  : in LPCWSTR; 
    hWndParent      : in t_HWND; 
    lpDialogFunc    : in DLGPROC; 
    dwInitParam     : in t_LPARAM)
                      return INT_PTR;
#pragma convention(DialogBoxParamW,system);
#pragma import(DialogBoxParamW,'DialogBoxParamW','user32.dll');

#if #declared UNICODE; then;
#template DialogBoxParam;
  DialogBoxParamW 
#end DialogBoxParam;
#else;
#template DialogBoxParam;
  DialogBoxParamA 
#end DialogBoxParam;
#end if;

procedure DialogBoxIndirectParamA(
    hInstance       : in t_HINSTANCE; 
    hDialogTemplate : in LPCDLGTEMPLATEA; 
    hWndParent      : in t_HWND; 
    lpDialogFunc    : in DLGPROC; 
    dwInitParam     : in t_LPARAM)
                      return INT_PTR;
#pragma convention(DialogBoxIndirectParamA,system);
#pragma import(DialogBoxIndirectParamA,'DialogBoxIndirectParamA','user32.dll');

procedure DialogBoxIndirectParamW(
    hInstance       : in t_HINSTANCE; 
    hDialogTemplate : in LPCDLGTEMPLATEW; 
    hWndParent      : in t_HWND; 
    lpDialogFunc    : in DLGPROC; 
    dwInitParam     : in t_LPARAM)
                      return INT_PTR;
#pragma convention(DialogBoxIndirectParamW,system);
#pragma import(DialogBoxIndirectParamW,'DialogBoxIndirectParamW','user32.dll');

#if #declared UNICODE; then;
#template DialogBoxIndirectParam;
  DialogBoxIndirectParamW 
#end DialogBoxIndirectParam;
#else;
#template DialogBoxIndirectParam;
  DialogBoxIndirectParamA 
#end DialogBoxIndirectParam;
#end if;

#if #declared UNICODE; then;
#template DialogBox;
  {DialogBoxW(hInstance,lpTemplate,hWndParent,lpDialogFunc)} DialogBoxParamW(hInstance,lpTemplate,hWndParent,lpDialogFunc,0 ) 
#end DialogBox;
#else;
#template DialogBox;
  {DialogBoxA(hInstance,lpTemplate,hWndParent,lpDialogFunc)} DialogBoxParamA(hInstance,lpTemplate,hWndParent,lpDialogFunc,0 ) 
#end DialogBox;
#end if;

#if #declared UNICODE; then;
#template DialogBoxIndirect;
  {DialogBoxIndirectW(hInstance,lpTemplate,hWndParent,lpDialogFunc)} DialogBoxIndirectParamW(hInstance,lpTemplate,hWndParent,lpDialogFunc,0 ) 
#end DialogBoxIndirect;
#else;
#template DialogBoxIndirect;
  {DialogBoxIndirectA(hInstance,lpTemplate,hWndParent,lpDialogFunc)} DialogBoxIndirectParamA(hInstance,lpTemplate,hWndParent,lpDialogFunc,0 ) 
#end DialogBoxIndirect;
#end if;

procedure EndDialog(
    hDlg            : in t_HWND; 
    nResult         : in INT_PTR)
                      return BOOL;
#pragma convention(EndDialog,system);
#pragma import(EndDialog,'EndDialog','user32.dll');

type
t_066=signed 32;

procedure GetDlgItem(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_066)
                      return t_HWND;
#pragma convention(GetDlgItem,system);
#pragma import(GetDlgItem,'GetDlgItem','user32.dll');

type
t_067=signed 32;

procedure SetDlgItemInt(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_067; 
    uValue          : in UINT; 
    bSigned         : in BOOL)
                      return BOOL;
#pragma convention(SetDlgItemInt,system);
#pragma import(SetDlgItemInt,'SetDlgItemInt','user32.dll');

type
t_068=signed 32;

procedure GetDlgItemInt(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_068; 
    lpTranslated    : out BOOL; 
    bSigned         : in BOOL)
                      return UINT;
#pragma convention(GetDlgItemInt,system);
#pragma import(GetDlgItemInt,'GetDlgItemInt','user32.dll');

type
t_069=signed 32;

procedure SetDlgItemTextA(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_069; 
    lpString        : in LPCSTR)
                      return BOOL;
#pragma convention(SetDlgItemTextA,system);
#pragma import(SetDlgItemTextA,'SetDlgItemTextA','user32.dll');

type
t_070=signed 32;

procedure SetDlgItemTextW(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_070; 
    lpString        : in LPCWSTR)
                      return BOOL;
#pragma convention(SetDlgItemTextW,system);
#pragma import(SetDlgItemTextW,'SetDlgItemTextW','user32.dll');

#if #declared UNICODE; then;
#template SetDlgItemText;
  SetDlgItemTextW 
#end SetDlgItemText;
#else;
#template SetDlgItemText;
  SetDlgItemTextA 
#end SetDlgItemText;
#end if;

type
t_071=signed 32;

t_072=signed 32;

procedure GetDlgItemTextA(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_071; 
    lpString        : out CHARSTR ; 
    nMaxCount       : in t_072)
                      return UINT;
#pragma convention(GetDlgItemTextA,system);
#pragma import(GetDlgItemTextA,'GetDlgItemTextA','user32.dll');

type
t_073=signed 32;

t_074=signed 32;

procedure GetDlgItemTextW(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_073; 
    lpString        : out WCHARSTR ; 
    nMaxCount       : in t_074)
                      return UINT;
#pragma convention(GetDlgItemTextW,system);
#pragma import(GetDlgItemTextW,'GetDlgItemTextW','user32.dll');

#if #declared UNICODE; then;
#template GetDlgItemText;
  GetDlgItemTextW 
#end GetDlgItemText;
#else;
#template GetDlgItemText;
  GetDlgItemTextA 
#end GetDlgItemText;
#end if;

type
t_075=signed 32;

procedure CheckDlgButton(
    hDlg            : in t_HWND; 
    nIDButton       : in t_075; 
    uCheck          : in UINT)
                      return BOOL;
#pragma convention(CheckDlgButton,system);
#pragma import(CheckDlgButton,'CheckDlgButton','user32.dll');

type
t_076=signed 32;

t_077=signed 32;

t_078=signed 32;

procedure CheckRadioButton(
    hDlg            : in t_HWND; 
    nIDFirstButton  : in t_076; 
    nIDLastButton   : in t_077; 
    nIDCheckButton  : in t_078)
                      return BOOL;
#pragma convention(CheckRadioButton,system);
#pragma import(CheckRadioButton,'CheckRadioButton','user32.dll');

type
t_079=signed 32;

procedure IsDlgButtonChecked(
    hDlg            : in t_HWND; 
    nIDButton       : in t_079)
                      return UINT;
#pragma convention(IsDlgButtonChecked,system);
#pragma import(IsDlgButtonChecked,'IsDlgButtonChecked','user32.dll');

type
t_080=signed 32;

procedure SendDlgItemMessageA(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_080; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(SendDlgItemMessageA,system);
#pragma import(SendDlgItemMessageA,'SendDlgItemMessageA','user32.dll');

type
t_081=signed 32;

procedure SendDlgItemMessageW(
    hDlg            : in t_HWND; 
    nIDDlgItem      : in t_081; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(SendDlgItemMessageW,system);
#pragma import(SendDlgItemMessageW,'SendDlgItemMessageW','user32.dll');

#if #declared UNICODE; then;
#template SendDlgItemMessage;
  SendDlgItemMessageW 
#end SendDlgItemMessage;
#else;
#template SendDlgItemMessage;
  SendDlgItemMessageA 
#end SendDlgItemMessage;
#end if;

procedure GetNextDlgGroupItem(
    hDlg            : in t_HWND; 
    hCtl            : in t_HWND; 
    bPrevious       : in BOOL)
                      return t_HWND;
#pragma convention(GetNextDlgGroupItem,system);
#pragma import(GetNextDlgGroupItem,'GetNextDlgGroupItem','user32.dll');

procedure GetNextDlgTabItem(
    hDlg            : in t_HWND; 
    hCtl            : in t_HWND; 
    bPrevious       : in BOOL)
                      return t_HWND;
#pragma convention(GetNextDlgTabItem,system);
#pragma import(GetNextDlgTabItem,'GetNextDlgTabItem','user32.dll');

type
  t_082 = signed 32;

procedure GetDlgCtrlID(
    hWnd            : in t_HWND)
                      return t_082;
#pragma convention(GetDlgCtrlID,system);
#pragma import(GetDlgCtrlID,'GetDlgCtrlID','user32.dll');

type
  t_083 = signed 32;

procedure GetDialogBaseUnits
                      return t_083;
#pragma convention(GetDialogBaseUnits,system);
#pragma import(GetDialogBaseUnits,'GetDialogBaseUnits','user32.dll');

procedure DefDlgProcA(
    hDlg            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(DefDlgProcA,system);
#pragma import(DefDlgProcA,'DefDlgProcA','user32.dll');

procedure DefDlgProcW(
    hDlg            : in t_HWND; 
    Msg             : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(DefDlgProcW,system);
#pragma import(DefDlgProcW,'DefDlgProcW','user32.dll');

#if #declared UNICODE; then;
#template DefDlgProc;
  DefDlgProcW 
#end DefDlgProc;
#else;
#template DefDlgProc;
  DefDlgProcA 
#end DefDlgProc;
#end if;

-- /*
--  * Window extra byted needed for private dialog classes.
--  */
const
  DLGWINDOWEXTRA    = 30;

type
t_084=signed 32;

procedure CallMsgFilterA(
    lpMsg           : in p_MSG; 
    nCode           : in t_084)
                      return BOOL;
#pragma convention(CallMsgFilterA,system);
#pragma import(CallMsgFilterA,'CallMsgFilterA','user32.dll');

type
t_085=signed 32;

procedure CallMsgFilterW(
    lpMsg           : in p_MSG; 
    nCode           : in t_085)
                      return BOOL;
#pragma convention(CallMsgFilterW,system);
#pragma import(CallMsgFilterW,'CallMsgFilterW','user32.dll');

#if #declared UNICODE; then;
#template CallMsgFilter;
  CallMsgFilterW 
#end CallMsgFilter;
#else;
#template CallMsgFilter;
  CallMsgFilterA 
#end CallMsgFilter;
#end if;

-- /*
--  * Clipboard Manager Functions
--  */
procedure OpenClipboard(
    hWndNewOwner    : in t_HWND)
                      return BOOL;
#pragma convention(OpenClipboard,system);
#pragma import(OpenClipboard,'OpenClipboard','user32.dll');

procedure CloseClipboard
                      return BOOL;
#pragma convention(CloseClipboard,system);
#pragma import(CloseClipboard,'CloseClipboard','user32.dll');

procedure GetClipboardSequenceNumber
                      return DWORD;
#pragma convention(GetClipboardSequenceNumber,system);
#pragma import(GetClipboardSequenceNumber,'GetClipboardSequenceNumber','user32.dll');

procedure GetClipboardOwner
                      return t_HWND;
#pragma convention(GetClipboardOwner,system);
#pragma import(GetClipboardOwner,'GetClipboardOwner','user32.dll');

procedure SetClipboardViewer(
    hWndNewViewer   : in t_HWND)
                      return t_HWND;
#pragma convention(SetClipboardViewer,system);
#pragma import(SetClipboardViewer,'SetClipboardViewer','user32.dll');

procedure GetClipboardViewer
                      return t_HWND;
#pragma convention(GetClipboardViewer,system);
#pragma import(GetClipboardViewer,'GetClipboardViewer','user32.dll');

procedure ChangeClipboardChain(
    hWndRemove      : in t_HWND; 
    hWndNewNext     : in t_HWND)
                      return BOOL;
#pragma convention(ChangeClipboardChain,system);
#pragma import(ChangeClipboardChain,'ChangeClipboardChain','user32.dll');

procedure SetClipboardData(
    uFormat         : in UINT; 
    hMem            : in t_HANDLE)
                      return t_HANDLE;
#pragma convention(SetClipboardData,system);
#pragma import(SetClipboardData,'SetClipboardData','user32.dll');

procedure GetClipboardData(
    uFormat         : in UINT)
                      return t_HANDLE;
#pragma convention(GetClipboardData,system);
#pragma import(GetClipboardData,'GetClipboardData','user32.dll');

procedure RegisterClipboardFormatA(
    lpszFormat      : in LPCSTR)
                      return UINT;
#pragma convention(RegisterClipboardFormatA,system);
#pragma import(RegisterClipboardFormatA,'RegisterClipboardFormatA','user32.dll');

procedure RegisterClipboardFormatW(
    lpszFormat      : in LPCWSTR)
                      return UINT;
#pragma convention(RegisterClipboardFormatW,system);
#pragma import(RegisterClipboardFormatW,'RegisterClipboardFormatW','user32.dll');

#if #declared UNICODE; then;
#template RegisterClipboardFormat;
  RegisterClipboardFormatW 
#end RegisterClipboardFormat;
#else;
#template RegisterClipboardFormat;
  RegisterClipboardFormatA 
#end RegisterClipboardFormat;
#end if;

type
  t_086 = signed 32;

procedure CountClipboardFormats
                      return t_086;
#pragma convention(CountClipboardFormats,system);
#pragma import(CountClipboardFormats,'CountClipboardFormats','user32.dll');

procedure EnumClipboardFormats(
    format          : in UINT)
                      return UINT;
#pragma convention(EnumClipboardFormats,system);
#pragma import(EnumClipboardFormats,'EnumClipboardFormats','user32.dll');

type
t_087=signed 32;

  t_088 = signed 32;

procedure GetClipboardFormatNameA(
    format          : in UINT; 
    lpszFormatName  : out CHARSTR ; 
    cchMaxCount     : in t_087)
                      return t_088;
#pragma convention(GetClipboardFormatNameA,system);
#pragma import(GetClipboardFormatNameA,'GetClipboardFormatNameA','user32.dll');

type
t_089=signed 32;

  t_090 = signed 32;

procedure GetClipboardFormatNameW(
    format          : in UINT; 
    lpszFormatName  : out WCHARSTR ; 
    cchMaxCount     : in t_089)
                      return t_090;
#pragma convention(GetClipboardFormatNameW,system);
#pragma import(GetClipboardFormatNameW,'GetClipboardFormatNameW','user32.dll');

#if #declared UNICODE; then;
#template GetClipboardFormatName;
  GetClipboardFormatNameW 
#end GetClipboardFormatName;
#else;
#template GetClipboardFormatName;
  GetClipboardFormatNameA 
#end GetClipboardFormatName;
#end if;

procedure EmptyClipboard
                      return BOOL;
#pragma convention(EmptyClipboard,system);
#pragma import(EmptyClipboard,'EmptyClipboard','user32.dll');

procedure IsClipboardFormatAvailable(
    format          : in UINT)
                      return BOOL;
#pragma convention(IsClipboardFormatAvailable,system);
#pragma import(IsClipboardFormatAvailable,'IsClipboardFormatAvailable','user32.dll');

type
t_091=signed 32;

  t_092 = signed 32;

procedure GetPriorityClipboardFormat(
    paFormatPriorityList : out UINT; 
    cFormats        : in t_091)
                      return t_092;
#pragma convention(GetPriorityClipboardFormat,system);
#pragma import(GetPriorityClipboardFormat,'GetPriorityClipboardFormat','user32.dll');

procedure GetOpenClipboardWindow
                      return t_HWND;
#pragma convention(GetOpenClipboardWindow,system);
#pragma import(GetOpenClipboardWindow,'GetOpenClipboardWindow','user32.dll');

-- /*
--  * Character Translation Routines
--  */
procedure CharToOemA(
    lpszSrc         : in LPCSTR; 
    lpszDst         : out CHARSTR )
                      return BOOL;
#pragma convention(CharToOemA,system);
#pragma import(CharToOemA,'CharToOemA','user32.dll');

procedure CharToOemW(
    lpszSrc         : in LPCWSTR; 
    lpszDst         : out CHARSTR )
                      return BOOL;
#pragma convention(CharToOemW,system);
#pragma import(CharToOemW,'CharToOemW','user32.dll');

#if #declared UNICODE; then;
#template CharToOem;
  CharToOemW 
#end CharToOem;
#else;
#template CharToOem;
  CharToOemA 
#end CharToOem;
#end if;

procedure OemToCharA(
    lpszSrc         : in LPCSTR; 
    lpszDst         : out CHARSTR )
                      return BOOL;
#pragma convention(OemToCharA,system);
#pragma import(OemToCharA,'OemToCharA','user32.dll');

procedure OemToCharW(
    lpszSrc         : in LPCSTR; 
    lpszDst         : out WCHARSTR )
                      return BOOL;
#pragma convention(OemToCharW,system);
#pragma import(OemToCharW,'OemToCharW','user32.dll');

#if #declared UNICODE; then;
#template OemToChar;
  OemToCharW 
#end OemToChar;
#else;
#template OemToChar;
  OemToCharA 
#end OemToChar;
#end if;

procedure CharToOemBuffA(
    lpszSrc         : in LPCSTR; 
    lpszDst         : out CHARSTR ; 
    cchDstLength    : in DWORD)
                      return BOOL;
#pragma convention(CharToOemBuffA,system);
#pragma import(CharToOemBuffA,'CharToOemBuffA','user32.dll');

procedure CharToOemBuffW(
    lpszSrc         : in LPCWSTR; 
    lpszDst         : out CHARSTR ; 
    cchDstLength    : in DWORD)
                      return BOOL;
#pragma convention(CharToOemBuffW,system);
#pragma import(CharToOemBuffW,'CharToOemBuffW','user32.dll');

#if #declared UNICODE; then;
#template CharToOemBuff;
  CharToOemBuffW 
#end CharToOemBuff;
#else;
#template CharToOemBuff;
  CharToOemBuffA 
#end CharToOemBuff;
#end if;

procedure OemToCharBuffA(
    lpszSrc         : in LPCSTR; 
    lpszDst         : out CHARSTR ; 
    cchDstLength    : in DWORD)
                      return BOOL;
#pragma convention(OemToCharBuffA,system);
#pragma import(OemToCharBuffA,'OemToCharBuffA','user32.dll');

procedure OemToCharBuffW(
    lpszSrc         : in LPCSTR; 
    lpszDst         : out WCHARSTR ; 
    cchDstLength    : in DWORD)
                      return BOOL;
#pragma convention(OemToCharBuffW,system);
#pragma import(OemToCharBuffW,'OemToCharBuffW','user32.dll');

#if #declared UNICODE; then;
#template OemToCharBuff;
  OemToCharBuffW 
#end OemToCharBuff;
#else;
#template OemToCharBuff;
  OemToCharBuffA 
#end OemToCharBuff;
#end if;

procedure CharUpperA(
    lpsz            : in out CHARSTR )
                      return LPSTR;
#pragma convention(CharUpperA,system);
#pragma import(CharUpperA,'CharUpperA','user32.dll');

procedure CharUpperW(
    lpsz            : in out WCHARSTR )
                      return LPWSTR;
#pragma convention(CharUpperW,system);
#pragma import(CharUpperW,'CharUpperW','user32.dll');

#if #declared UNICODE; then;
#template CharUpper;
  CharUpperW 
#end CharUpper;
#else;
#template CharUpper;
  CharUpperA 
#end CharUpper;
#end if;

procedure CharUpperBuffA(
    lpsz            : in out CHARSTR ; 
    cchLength       : in DWORD)
                      return DWORD;
#pragma convention(CharUpperBuffA,system);
#pragma import(CharUpperBuffA,'CharUpperBuffA','user32.dll');

procedure CharUpperBuffW(
    lpsz            : in out WCHARSTR ; 
    cchLength       : in DWORD)
                      return DWORD;
#pragma convention(CharUpperBuffW,system);
#pragma import(CharUpperBuffW,'CharUpperBuffW','user32.dll');

#if #declared UNICODE; then;
#template CharUpperBuff;
  CharUpperBuffW 
#end CharUpperBuff;
#else;
#template CharUpperBuff;
  CharUpperBuffA 
#end CharUpperBuff;
#end if;

procedure CharLowerA(
    lpsz            : in out CHARSTR )
                      return LPSTR;
#pragma convention(CharLowerA,system);
#pragma import(CharLowerA,'CharLowerA','user32.dll');

procedure CharLowerW(
    lpsz            : in out WCHARSTR )
                      return LPWSTR;
#pragma convention(CharLowerW,system);
#pragma import(CharLowerW,'CharLowerW','user32.dll');

#if #declared UNICODE; then;
#template CharLower;
  CharLowerW 
#end CharLower;
#else;
#template CharLower;
  CharLowerA 
#end CharLower;
#end if;

procedure CharLowerBuffA(
    lpsz            : in out CHARSTR ; 
    cchLength       : in DWORD)
                      return DWORD;
#pragma convention(CharLowerBuffA,system);
#pragma import(CharLowerBuffA,'CharLowerBuffA','user32.dll');

procedure CharLowerBuffW(
    lpsz            : in out WCHARSTR ; 
    cchLength       : in DWORD)
                      return DWORD;
#pragma convention(CharLowerBuffW,system);
#pragma import(CharLowerBuffW,'CharLowerBuffW','user32.dll');

#if #declared UNICODE; then;
#template CharLowerBuff;
  CharLowerBuffW 
#end CharLowerBuff;
#else;
#template CharLowerBuff;
  CharLowerBuffA 
#end CharLowerBuff;
#end if;

procedure CharNextA(
    lpsz            : in LPCSTR)
                      return LPSTR;
#pragma convention(CharNextA,system);
#pragma import(CharNextA,'CharNextA','user32.dll');

procedure CharNextW(
    lpsz            : in LPCWSTR)
                      return LPWSTR;
#pragma convention(CharNextW,system);
#pragma import(CharNextW,'CharNextW','user32.dll');

#if #declared UNICODE; then;
#template CharNext;
  CharNextW 
#end CharNext;
#else;
#template CharNext;
  CharNextA 
#end CharNext;
#end if;

procedure CharPrevA(
    lpszStart       : in LPCSTR; 
    lpszCurrent     : in LPCSTR)
                      return LPSTR;
#pragma convention(CharPrevA,system);
#pragma import(CharPrevA,'CharPrevA','user32.dll');

procedure CharPrevW(
    lpszStart       : in LPCWSTR; 
    lpszCurrent     : in LPCWSTR)
                      return LPWSTR;
#pragma convention(CharPrevW,system);
#pragma import(CharPrevW,'CharPrevW','user32.dll');

#if #declared UNICODE; then;
#template CharPrev;
  CharPrevW 
#end CharPrev;
#else;
#template CharPrev;
  CharPrevA 
#end CharPrev;
#end if;

procedure CharNextExA(
    CodePage        : in WORD; 
    lpCurrentChar   : in LPCSTR; 
    dwFlags         : in DWORD)
                      return LPSTR;
#pragma convention(CharNextExA,system);
#pragma import(CharNextExA,'CharNextExA','user32.dll');

procedure CharPrevExA(
    CodePage        : in WORD; 
    lpStart         : in LPCSTR; 
    lpCurrentChar   : in LPCSTR; 
    dwFlags         : in DWORD)
                      return LPSTR;
#pragma convention(CharPrevExA,system);
#pragma import(CharPrevExA,'CharPrevExA','user32.dll');

-- /*
--  * Compatibility defines for character translation routines
--  */
-- /*
--  * Language dependent Routines
--  */
procedure IsCharAlphaA(
    ch              : in CHAR)
                      return BOOL;
#pragma convention(IsCharAlphaA,system);
#pragma import(IsCharAlphaA,'IsCharAlphaA','user32.dll');

procedure IsCharAlphaW(
    ch              : in WCHAR)
                      return BOOL;
#pragma convention(IsCharAlphaW,system);
#pragma import(IsCharAlphaW,'IsCharAlphaW','user32.dll');

#if #declared UNICODE; then;
#template IsCharAlpha;
  IsCharAlphaW 
#end IsCharAlpha;
#else;
#template IsCharAlpha;
  IsCharAlphaA 
#end IsCharAlpha;
#end if;

procedure IsCharAlphaNumericA(
    ch              : in CHAR)
                      return BOOL;
#pragma convention(IsCharAlphaNumericA,system);
#pragma import(IsCharAlphaNumericA,'IsCharAlphaNumericA','user32.dll');

procedure IsCharAlphaNumericW(
    ch              : in WCHAR)
                      return BOOL;
#pragma convention(IsCharAlphaNumericW,system);
#pragma import(IsCharAlphaNumericW,'IsCharAlphaNumericW','user32.dll');

#if #declared UNICODE; then;
#template IsCharAlphaNumeric;
  IsCharAlphaNumericW 
#end IsCharAlphaNumeric;
#else;
#template IsCharAlphaNumeric;
  IsCharAlphaNumericA 
#end IsCharAlphaNumeric;
#end if;

procedure IsCharUpperA(
    ch              : in CHAR)
                      return BOOL;
#pragma convention(IsCharUpperA,system);
#pragma import(IsCharUpperA,'IsCharUpperA','user32.dll');

procedure IsCharUpperW(
    ch              : in WCHAR)
                      return BOOL;
#pragma convention(IsCharUpperW,system);
#pragma import(IsCharUpperW,'IsCharUpperW','user32.dll');

#if #declared UNICODE; then;
#template IsCharUpper;
  IsCharUpperW 
#end IsCharUpper;
#else;
#template IsCharUpper;
  IsCharUpperA 
#end IsCharUpper;
#end if;

procedure IsCharLowerA(
    ch              : in CHAR)
                      return BOOL;
#pragma convention(IsCharLowerA,system);
#pragma import(IsCharLowerA,'IsCharLowerA','user32.dll');

procedure IsCharLowerW(
    ch              : in WCHAR)
                      return BOOL;
#pragma convention(IsCharLowerW,system);
#pragma import(IsCharLowerW,'IsCharLowerW','user32.dll');

#if #declared UNICODE; then;
#template IsCharLower;
  IsCharLowerW 
#end IsCharLower;
#else;
#template IsCharLower;
  IsCharLowerA 
#end IsCharLower;
#end if;

procedure SetFocus(
    hWnd            : in t_HWND)
                      return t_HWND;
#pragma convention(SetFocus,system);
#pragma import(SetFocus,'SetFocus','user32.dll');

procedure GetActiveWindow
                      return t_HWND;
#pragma convention(GetActiveWindow,system);
#pragma import(GetActiveWindow,'GetActiveWindow','user32.dll');

procedure GetFocus
                      return t_HWND;
#pragma convention(GetFocus,system);
#pragma import(GetFocus,'GetFocus','user32.dll');

procedure GetKBCodePage
                      return UINT;
#pragma convention(GetKBCodePage,system);
#pragma import(GetKBCodePage,'GetKBCodePage','user32.dll');

type
t_093=signed 32;

procedure GetKeyState(
    nVirtKey        : in t_093)
                      return SHORT;
#pragma convention(GetKeyState,system);
#pragma import(GetKeyState,'GetKeyState','user32.dll');

type
t_094=signed 32;

procedure GetAsyncKeyState(
    vKey            : in t_094)
                      return SHORT;
#pragma convention(GetAsyncKeyState,system);
#pragma import(GetAsyncKeyState,'GetAsyncKeyState','user32.dll');

procedure GetKeyboardState(
    lpKeyState      : out BYTE )
                      return BOOL;
#pragma convention(GetKeyboardState,system);
#pragma import(GetKeyboardState,'GetKeyboardState','user32.dll');

procedure SetKeyboardState(
    lpKeyState      : in LPBYTE)
                      return BOOL;
#pragma convention(SetKeyboardState,system);
#pragma import(SetKeyboardState,'SetKeyboardState','user32.dll');

type
t_095=signed 32;

  t_096 = signed 32;

procedure GetKeyNameTextA(
    lParam          : in LONG; 
    lpString        : out CHARSTR ; 
    nSize           : in t_095)
                      return t_096;
#pragma convention(GetKeyNameTextA,system);
#pragma import(GetKeyNameTextA,'GetKeyNameTextA','user32.dll');

type
t_097=signed 32;

  t_098 = signed 32;

procedure GetKeyNameTextW(
    lParam          : in LONG; 
    lpString        : out WCHARSTR ; 
    nSize           : in t_097)
                      return t_098;
#pragma convention(GetKeyNameTextW,system);
#pragma import(GetKeyNameTextW,'GetKeyNameTextW','user32.dll');

#if #declared UNICODE; then;
#template GetKeyNameText;
  GetKeyNameTextW 
#end GetKeyNameText;
#else;
#template GetKeyNameText;
  GetKeyNameTextA 
#end GetKeyNameText;
#end if;

type
t_099=signed 32;

  t_100 = signed 32;

procedure GetKeyboardType(
    nTypeFlag       : in t_099)
                      return t_100;
#pragma convention(GetKeyboardType,system);
#pragma import(GetKeyboardType,'GetKeyboardType','user32.dll');

type
t_101=^BYTE for machine_pointer use true;

  t_102 = signed 32;

procedure ToAscii(
    uVirtKey        : in UINT; 
    uScanCode       : in UINT; 
    lpKeyState      : in t_101; 
    lpChar          : out WORD ; 
    uFlags          : in UINT)
                      return t_102;
#pragma convention(ToAscii,system);
#pragma import(ToAscii,'ToAscii','user32.dll');

type
t_103=^BYTE for machine_pointer use true;

  t_104 = signed 32;

procedure ToAsciiEx(
    uVirtKey        : in UINT; 
    uScanCode       : in UINT; 
    lpKeyState      : in t_103; 
    lpChar          : out WORD ; 
    uFlags          : in UINT; 
    dwhkl           : in t_HKL)
                      return t_104;
#pragma convention(ToAsciiEx,system);
#pragma import(ToAsciiEx,'ToAsciiEx','user32.dll');

type
t_105=^BYTE for machine_pointer use true;

t_106=signed 32;

  t_107 = signed 32;

procedure ToUnicode(
    wVirtKey        : in UINT; 
    wScanCode       : in UINT; 
    lpKeyState      : in t_105; 
    pwszBuff        : out WCHARSTR ; 
    cchBuff         : in t_106; 
    wFlags          : in UINT)
                      return t_107;
#pragma convention(ToUnicode,system);
#pragma import(ToUnicode,'ToUnicode','user32.dll');

procedure OemKeyScan(
    wOemChar        : in WORD)
                      return DWORD;
#pragma convention(OemKeyScan,system);
#pragma import(OemKeyScan,'OemKeyScan','user32.dll');

procedure VkKeyScanA(
    ch              : in CHAR)
                      return SHORT;
#pragma convention(VkKeyScanA,system);
#pragma import(VkKeyScanA,'VkKeyScanA','user32.dll');

procedure VkKeyScanW(
    ch              : in WCHAR)
                      return SHORT;
#pragma convention(VkKeyScanW,system);
#pragma import(VkKeyScanW,'VkKeyScanW','user32.dll');

#if #declared UNICODE; then;
#template VkKeyScan;
  VkKeyScanW 
#end VkKeyScan;
#else;
#template VkKeyScan;
  VkKeyScanA 
#end VkKeyScan;
#end if;

procedure VkKeyScanExA(
    ch              : in CHAR; 
    dwhkl           : in t_HKL)
                      return SHORT;
#pragma convention(VkKeyScanExA,system);
#pragma import(VkKeyScanExA,'VkKeyScanExA','user32.dll');

procedure VkKeyScanExW(
    ch              : in WCHAR; 
    dwhkl           : in t_HKL)
                      return SHORT;
#pragma convention(VkKeyScanExW,system);
#pragma import(VkKeyScanExW,'VkKeyScanExW','user32.dll');

#if #declared UNICODE; then;
#template VkKeyScanEx;
  VkKeyScanExW 
#end VkKeyScanEx;
#else;
#template VkKeyScanEx;
  VkKeyScanExA 
#end VkKeyScanEx;
#end if;

const
  KEYEVENTF_EXTENDEDKEY= $01;

const
  KEYEVENTF_KEYUP   = $02;

const
  KEYEVENTF_UNICODE = $04;

const
  KEYEVENTF_SCANCODE= $08;

procedure keybd_event(
    bVk             : in BYTE; 
    bScan           : in BYTE; 
    dwFlags         : in DWORD; 
    dwExtraInfo     : in ULONG_PTR);
#pragma convention(keybd_event,system);
#pragma import(keybd_event,'keybd_event','user32.dll');

const
  MOUSEEVENTF_MOVE  = $01;

const
  MOUSEEVENTF_LEFTDOWN= $02;

const
  MOUSEEVENTF_LEFTUP= $04;

const
  MOUSEEVENTF_RIGHTDOWN= $08;

const
  MOUSEEVENTF_RIGHTUP= $10;

const
  MOUSEEVENTF_MIDDLEDOWN= $20;

const
  MOUSEEVENTF_MIDDLEUP= $40;

const
  MOUSEEVENTF_XDOWN = $80;

const
  MOUSEEVENTF_XUP   = $0100;

const
  MOUSEEVENTF_WHEEL = $0800;

const
  MOUSEEVENTF_VIRTUALDESK= $4000;

const
  MOUSEEVENTF_ABSOLUTE= $8000;

procedure mouse_event(
    dwFlags         : in DWORD; 
    dx              : in DWORD; 
    dy              : in DWORD; 
    dwData          : in DWORD; 
    dwExtraInfo     : in ULONG_PTR);
#pragma convention(mouse_event,system);
#pragma import(mouse_event,'mouse_event','user32.dll');

type
  tagMOUSEINPUT     = record
dx              : LONG;
dy              : LONG;
mouseData       : DWORD;
dwFlags         : DWORD;
time            : DWORD;
dwExtraInfo     : ULONG_PTR;
  end record;
  MOUSEINPUT        = tagMOUSEINPUT;
  PMOUSEINPUT       = ^tagMOUSEINPUT;
  LPMOUSEINPUT      = ^tagMOUSEINPUT;

type
  tagKEYBDINPUT     = record
wVk             : WORD;
wScan           : WORD;
dwFlags         : DWORD;
time            : DWORD;
dwExtraInfo     : ULONG_PTR;
  end record;
  KEYBDINPUT        = tagKEYBDINPUT;
  PKEYBDINPUT       = ^tagKEYBDINPUT;
  LPKEYBDINPUT      = ^tagKEYBDINPUT;

type
  tagHARDWAREINPUT  = record
uMsg            : DWORD;
wParamL         : WORD;
wParamH         : WORD;
  end record;
  HARDWAREINPUT     = tagHARDWAREINPUT;
  PHARDWAREINPUT    = ^tagHARDWAREINPUT;
  LPHARDWAREINPUT   = ^tagHARDWAREINPUT;

const
  INPUT_MOUSE       = 0;

const
  INPUT_KEYBOARD    = 1;

const
  INPUT_HARDWARE    = 2;

type
  tagINPUT          = record
_type           : DWORD;
t_108            : record
      mi            : MOUSEINPUT for position use 0;
      ki            : KEYBDINPUT for position use 0;
      hi            : HARDWAREINPUT for position use 0;
    end record;
  end record;
  INPUT             = tagINPUT;
  PINPUT            = ^tagINPUT;
  LPINPUT           = ^tagINPUT;

--  number of input in the array
--  array of inputs
type
t_109=signed 32;

procedure SendInput(
    cInputs         : in UINT; 
    pInputs         : in LPINPUT; 
    cbSize          : in t_109)
                      return UINT;
#pragma convention(SendInput,system);
#pragma import(SendInput,'SendInput','user32.dll');

--  sizeof(INPUT)
type
  tagLASTINPUTINFO  = record
cbSize          : UINT;
dwTime          : DWORD;
  end record;
  LASTINPUTINFO     = tagLASTINPUTINFO;
  PLASTINPUTINFO    = ^tagLASTINPUTINFO;

procedure GetLastInputInfo(
    plii            : out tagLASTINPUTINFO)
                      return BOOL;
#pragma convention(GetLastInputInfo,system);
#pragma import(GetLastInputInfo,'GetLastInputInfo','user32.dll');

procedure MapVirtualKeyA(
    uCode           : in UINT; 
    uMapType        : in UINT)
                      return UINT;
#pragma convention(MapVirtualKeyA,system);
#pragma import(MapVirtualKeyA,'MapVirtualKeyA','user32.dll');

procedure MapVirtualKeyW(
    uCode           : in UINT; 
    uMapType        : in UINT)
                      return UINT;
#pragma convention(MapVirtualKeyW,system);
#pragma import(MapVirtualKeyW,'MapVirtualKeyW','user32.dll');

#if #declared UNICODE; then;
#template MapVirtualKey;
  MapVirtualKeyW 
#end MapVirtualKey;
#else;
#template MapVirtualKey;
  MapVirtualKeyA 
#end MapVirtualKey;
#end if;

procedure MapVirtualKeyExA(
    uCode           : in UINT; 
    uMapType        : in UINT; 
    dwhkl           : in t_HKL)
                      return UINT;
#pragma convention(MapVirtualKeyExA,system);
#pragma import(MapVirtualKeyExA,'MapVirtualKeyExA','user32.dll');

procedure MapVirtualKeyExW(
    uCode           : in UINT; 
    uMapType        : in UINT; 
    dwhkl           : in t_HKL)
                      return UINT;
#pragma convention(MapVirtualKeyExW,system);
#pragma import(MapVirtualKeyExW,'MapVirtualKeyExW','user32.dll');

#if #declared UNICODE; then;
#template MapVirtualKeyEx;
  MapVirtualKeyExW 
#end MapVirtualKeyEx;
#else;
#template MapVirtualKeyEx;
  MapVirtualKeyExA 
#end MapVirtualKeyEx;
#end if;

procedure GetInputState
                      return BOOL;
#pragma convention(GetInputState,system);
#pragma import(GetInputState,'GetInputState','user32.dll');

procedure GetQueueStatus(
    flags           : in UINT)
                      return DWORD;
#pragma convention(GetQueueStatus,system);
#pragma import(GetQueueStatus,'GetQueueStatus','user32.dll');

procedure GetCapture
                      return t_HWND;
#pragma convention(GetCapture,system);
#pragma import(GetCapture,'GetCapture','user32.dll');

procedure SetCapture(
    hWnd            : in t_HWND)
                      return t_HWND;
#pragma convention(SetCapture,system);
#pragma import(SetCapture,'SetCapture','user32.dll');

procedure ReleaseCapture
                      return BOOL;
#pragma convention(ReleaseCapture,system);
#pragma import(ReleaseCapture,'ReleaseCapture','user32.dll');

type
t_110=^t_HANDLE for machine_pointer use true;

procedure MsgWaitForMultipleObjects(
    nCount          : in DWORD; 
    pHandles        : in t_110; 
    fWaitAll        : in BOOL; 
    dwMilliseconds  : in DWORD; 
    dwWakeMask      : in DWORD)
                      return DWORD;
#pragma convention(MsgWaitForMultipleObjects,system);
#pragma import(MsgWaitForMultipleObjects,'MsgWaitForMultipleObjects','user32.dll');

type
t_111=^t_HANDLE for machine_pointer use true;

procedure MsgWaitForMultipleObjectsEx(
    nCount          : in DWORD; 
    pHandles        : in t_111; 
    dwMilliseconds  : in DWORD; 
    dwWakeMask      : in DWORD; 
    dwFlags         : in DWORD)
                      return DWORD;
#pragma convention(MsgWaitForMultipleObjectsEx,system);
#pragma import(MsgWaitForMultipleObjectsEx,'MsgWaitForMultipleObjectsEx','user32.dll');

const
  MWMO_WAITALL      = $01;

const
  MWMO_ALERTABLE    = $02;

const
  MWMO_INPUTAVAILABLE= $04;

-- /*
--  * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
--  */
const
  QS_KEY            = $01;

const
  QS_MOUSEMOVE      = $02;

const
  QS_MOUSEBUTTON    = $04;

const
  QS_POSTMESSAGE    = $08;

const
  QS_TIMER          = $10;

const
  QS_PAINT          = $20;

const
  QS_SENDMESSAGE    = $40;

const
  QS_HOTKEY         = $80;

const
  QS_ALLPOSTMESSAGE = $0100;

const
  QS_RAWINPUT       = $0400;

-- /*
--  * Windows Functions
--  */
procedure SetTimer(
    hWnd            : in t_HWND; 
    nIDEvent        : in UINT_PTR; 
    uElapse         : in UINT; 
    lpTimerFunc     : in TIMERPROC)
                      return UINT_PTR;
#pragma convention(SetTimer,system);
#pragma import(SetTimer,'SetTimer','user32.dll');

procedure KillTimer(
    hWnd            : in t_HWND; 
    uIDEvent        : in UINT_PTR)
                      return BOOL;
#pragma convention(KillTimer,system);
#pragma import(KillTimer,'KillTimer','user32.dll');

procedure IsWindowUnicode(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(IsWindowUnicode,system);
#pragma import(IsWindowUnicode,'IsWindowUnicode','user32.dll');

procedure EnableWindow(
    hWnd            : in t_HWND; 
    bEnable         : in BOOL)
                      return BOOL;
#pragma convention(EnableWindow,system);
#pragma import(EnableWindow,'EnableWindow','user32.dll');

procedure IsWindowEnabled(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(IsWindowEnabled,system);
#pragma import(IsWindowEnabled,'IsWindowEnabled','user32.dll');

procedure LoadAcceleratorsA(
    hInstance       : in t_HINSTANCE; 
    lpTableName     : in LPCSTR)
                      return t_HACCEL;
#pragma convention(LoadAcceleratorsA,system);
#pragma import(LoadAcceleratorsA,'LoadAcceleratorsA','user32.dll');

procedure LoadAcceleratorsW(
    hInstance       : in t_HINSTANCE; 
    lpTableName     : in LPCWSTR)
                      return t_HACCEL;
#pragma convention(LoadAcceleratorsW,system);
#pragma import(LoadAcceleratorsW,'LoadAcceleratorsW','user32.dll');

#if #declared UNICODE; then;
#template LoadAccelerators;
  LoadAcceleratorsW 
#end LoadAccelerators;
#else;
#template LoadAccelerators;
  LoadAcceleratorsA 
#end LoadAccelerators;
#end if;

type
t_112=signed 32;

procedure CreateAcceleratorTableA(
    _001            : in LPACCEL; 
    _002            : in t_112)
                      return t_HACCEL;
#pragma convention(CreateAcceleratorTableA,system);
#pragma import(CreateAcceleratorTableA,'CreateAcceleratorTableA','user32.dll');

type
t_113=signed 32;

procedure CreateAcceleratorTableW(
    _001            : in LPACCEL; 
    _002            : in t_113)
                      return t_HACCEL;
#pragma convention(CreateAcceleratorTableW,system);
#pragma import(CreateAcceleratorTableW,'CreateAcceleratorTableW','user32.dll');

#if #declared UNICODE; then;
#template CreateAcceleratorTable;
  CreateAcceleratorTableW 
#end CreateAcceleratorTable;
#else;
#template CreateAcceleratorTable;
  CreateAcceleratorTableA 
#end CreateAcceleratorTable;
#end if;

procedure DestroyAcceleratorTable(
    hAccel          : in t_HACCEL)
                      return BOOL;
#pragma convention(DestroyAcceleratorTable,system);
#pragma import(DestroyAcceleratorTable,'DestroyAcceleratorTable','user32.dll');

type
t_114=signed 32;

  t_115 = signed 32;

procedure CopyAcceleratorTableA(
    hAccelSrc       : in t_HACCEL; 
    lpAccelDst      : out tagACCEL; 
    cAccelEntries   : in t_114)
                      return t_115;
#pragma convention(CopyAcceleratorTableA,system);
#pragma import(CopyAcceleratorTableA,'CopyAcceleratorTableA','user32.dll');

type
t_116=signed 32;

  t_117 = signed 32;

procedure CopyAcceleratorTableW(
    hAccelSrc       : in t_HACCEL; 
    lpAccelDst      : out tagACCEL; 
    cAccelEntries   : in t_116)
                      return t_117;
#pragma convention(CopyAcceleratorTableW,system);
#pragma import(CopyAcceleratorTableW,'CopyAcceleratorTableW','user32.dll');

#if #declared UNICODE; then;
#template CopyAcceleratorTable;
  CopyAcceleratorTableW 
#end CopyAcceleratorTable;
#else;
#template CopyAcceleratorTable;
  CopyAcceleratorTableA 
#end CopyAcceleratorTable;
#end if;

type
  t_118 = signed 32;

procedure TranslateAcceleratorA(
    hWnd            : in t_HWND; 
    hAccTable       : in t_HACCEL; 
    lpMsg           : in p_MSG)
                      return t_118;
#pragma convention(TranslateAcceleratorA,system);
#pragma import(TranslateAcceleratorA,'TranslateAcceleratorA','user32.dll');

type
  t_119 = signed 32;

procedure TranslateAcceleratorW(
    hWnd            : in t_HWND; 
    hAccTable       : in t_HACCEL; 
    lpMsg           : in p_MSG)
                      return t_119;
#pragma convention(TranslateAcceleratorW,system);
#pragma import(TranslateAcceleratorW,'TranslateAcceleratorW','user32.dll');

#if #declared UNICODE; then;
#template TranslateAccelerator;
  TranslateAcceleratorW 
#end TranslateAccelerator;
#else;
#template TranslateAccelerator;
  TranslateAcceleratorA 
#end TranslateAccelerator;
#end if;

-- /*
--  * GetSystemMetrics() codes
--  */
const
  SM_CXSCREEN       = 0;

const
  SM_CYSCREEN       = 1;

const
  SM_CXVSCROLL      = 2;

const
  SM_CYHSCROLL      = 3;

const
  SM_CYCAPTION      = 4;

const
  SM_CXBORDER       = 5;

const
  SM_CYBORDER       = 6;

const
  SM_CXDLGFRAME     = 7;

const
  SM_CYDLGFRAME     = 8;

const
  SM_CYVTHUMB       = 9;

const
  SM_CXHTHUMB       = 10;

const
  SM_CXICON         = 11;

const
  SM_CYICON         = 12;

const
  SM_CXCURSOR       = 13;

const
  SM_CYCURSOR       = 14;

const
  SM_CYMENU         = 15;

const
  SM_CXFULLSCREEN   = 16;

const
  SM_CYFULLSCREEN   = 17;

const
  SM_CYKANJIWINDOW  = 18;

const
  SM_MOUSEPRESENT   = 19;

const
  SM_CYVSCROLL      = 20;

const
  SM_CXHSCROLL      = 21;

const
  SM_DEBUG          = 22;

const
  SM_SWAPBUTTON     = 23;

const
  SM_RESERVED1      = 24;

const
  SM_RESERVED2      = 25;

const
  SM_RESERVED3      = 26;

const
  SM_RESERVED4      = 27;

const
  SM_CXMIN          = 28;

const
  SM_CYMIN          = 29;

const
  SM_CXSIZE         = 30;

const
  SM_CYSIZE         = 31;

const
  SM_CXFRAME        = 32;

const
  SM_CYFRAME        = 33;

const
  SM_CXMINTRACK     = 34;

const
  SM_CYMINTRACK     = 35;

const
  SM_CXDOUBLECLK    = 36;

const
  SM_CYDOUBLECLK    = 37;

const
  SM_CXICONSPACING  = 38;

const
  SM_CYICONSPACING  = 39;

const
  SM_MENUDROPALIGNMENT= 40;

const
  SM_PENWINDOWS     = 41;

const
  SM_DBCSENABLED    = 42;

const
  SM_CMOUSEBUTTONS  = 43;

const
  SM_SECURE         = 44;

const
  SM_CXEDGE         = 45;

const
  SM_CYEDGE         = 46;

const
  SM_CXMINSPACING   = 47;

const
  SM_CYMINSPACING   = 48;

const
  SM_CXSMICON       = 49;

const
  SM_CYSMICON       = 50;

const
  SM_CYSMCAPTION    = 51;

const
  SM_CXSMSIZE       = 52;

const
  SM_CYSMSIZE       = 53;

const
  SM_CXMENUSIZE     = 54;

const
  SM_CYMENUSIZE     = 55;

const
  SM_ARRANGE        = 56;

const
  SM_CXMINIMIZED    = 57;

const
  SM_CYMINIMIZED    = 58;

const
  SM_CXMAXTRACK     = 59;

const
  SM_CYMAXTRACK     = 60;

const
  SM_CXMAXIMIZED    = 61;

const
  SM_CYMAXIMIZED    = 62;

const
  SM_NETWORK        = 63;

const
  SM_CLEANBOOT      = 67;

const
  SM_CXDRAG         = 68;

const
  SM_CYDRAG         = 69;

const
  SM_SHOWSOUNDS     = 70;

const
  SM_CXMENUCHECK    = 71;

const
  SM_CYMENUCHECK    = 72;

const
  SM_SLOWMACHINE    = 73;

const
  SM_MIDEASTENABLED = 74;

const
  SM_MOUSEWHEELPRESENT= 75;

const
  SM_XVIRTUALSCREEN = 76;

const
  SM_YVIRTUALSCREEN = 77;

const
  SM_CXVIRTUALSCREEN= 78;

const
  SM_CYVIRTUALSCREEN= 79;

const
  SM_CMONITORS      = 80;

const
  SM_SAMEDISPLAYFORMAT= 81;

const
  SM_IMMENABLED     = 82;

const
  SM_CXFOCUSBORDER  = 83;

const
  SM_CYFOCUSBORDER  = 84;

const
  SM_TABLETPC       = 86;

const
  SM_MEDIACENTER    = 87;

const
  SM_CMETRICS       = 88;

const
  SM_REMOTESESSION  = $1000;

const
  SM_SHUTTINGDOWN   = $2000;

const
  SM_REMOTECONTROL  = $2001;

type
t_120=signed 32;

  t_121 = signed 32;

procedure GetSystemMetrics(
    nIndex          : in t_120)
                      return t_121;
#pragma convention(GetSystemMetrics,system);
#pragma import(GetSystemMetrics,'GetSystemMetrics','user32.dll');

procedure LoadMenuA(
    hInstance       : in t_HINSTANCE; 
    lpMenuName      : in LPCSTR)
                      return t_HMENU;
#pragma convention(LoadMenuA,system);
#pragma import(LoadMenuA,'LoadMenuA','user32.dll');

procedure LoadMenuW(
    hInstance       : in t_HINSTANCE; 
    lpMenuName      : in LPCWSTR)
                      return t_HMENU;
#pragma convention(LoadMenuW,system);
#pragma import(LoadMenuW,'LoadMenuW','user32.dll');

#if #declared UNICODE; then;
#template LoadMenu;
  LoadMenuW 
#end LoadMenu;
#else;
#template LoadMenu;
  LoadMenuA 
#end LoadMenu;
#end if;

type
t_122=^MENUTEMPLATEA for machine_pointer use true;

procedure LoadMenuIndirectA(
    lpMenuTemplate  : in t_122)
                      return t_HMENU;
#pragma convention(LoadMenuIndirectA,system);
#pragma import(LoadMenuIndirectA,'LoadMenuIndirectA','user32.dll');

type
t_123=^MENUTEMPLATEW for machine_pointer use true;

procedure LoadMenuIndirectW(
    lpMenuTemplate  : in t_123)
                      return t_HMENU;
#pragma convention(LoadMenuIndirectW,system);
#pragma import(LoadMenuIndirectW,'LoadMenuIndirectW','user32.dll');

#if #declared UNICODE; then;
#template LoadMenuIndirect;
  LoadMenuIndirectW 
#end LoadMenuIndirect;
#else;
#template LoadMenuIndirect;
  LoadMenuIndirectA 
#end LoadMenuIndirect;
#end if;

procedure GetMenu(
    hWnd            : in t_HWND)
                      return t_HMENU;
#pragma convention(GetMenu,system);
#pragma import(GetMenu,'GetMenu','user32.dll');

procedure SetMenu(
    hWnd            : in t_HWND; 
    hMenu           : in t_HMENU)
                      return BOOL;
#pragma convention(SetMenu,system);
#pragma import(SetMenu,'SetMenu','user32.dll');

procedure ChangeMenuA(
    hMenu           : in t_HMENU; 
    cmd             : in UINT; 
    lpszNewItem     : in LPCSTR; 
    cmdInsert       : in UINT; 
    flags           : in UINT)
                      return BOOL;
#pragma convention(ChangeMenuA,system);
#pragma import(ChangeMenuA,'ChangeMenuA','user32.dll');

procedure ChangeMenuW(
    hMenu           : in t_HMENU; 
    cmd             : in UINT; 
    lpszNewItem     : in LPCWSTR; 
    cmdInsert       : in UINT; 
    flags           : in UINT)
                      return BOOL;
#pragma convention(ChangeMenuW,system);
#pragma import(ChangeMenuW,'ChangeMenuW','user32.dll');

#if #declared UNICODE; then;
#template ChangeMenu;
  ChangeMenuW 
#end ChangeMenu;
#else;
#template ChangeMenu;
  ChangeMenuA 
#end ChangeMenu;
#end if;

procedure HiliteMenuItem(
    hWnd            : in t_HWND; 
    hMenu           : in t_HMENU; 
    uIDHiliteItem   : in UINT; 
    uHilite         : in UINT)
                      return BOOL;
#pragma convention(HiliteMenuItem,system);
#pragma import(HiliteMenuItem,'HiliteMenuItem','user32.dll');

type
t_124=signed 32;

  t_125 = signed 32;

procedure GetMenuStringA(
    hMenu           : in t_HMENU; 
    uIDItem         : in UINT; 
    lpString        : out CHARSTR ; 
    nMaxCount       : in t_124; 
    uFlag           : in UINT)
                      return t_125;
#pragma convention(GetMenuStringA,system);
#pragma import(GetMenuStringA,'GetMenuStringA','user32.dll');

type
t_126=signed 32;

  t_127 = signed 32;

procedure GetMenuStringW(
    hMenu           : in t_HMENU; 
    uIDItem         : in UINT; 
    lpString        : out WCHARSTR ; 
    nMaxCount       : in t_126; 
    uFlag           : in UINT)
                      return t_127;
#pragma convention(GetMenuStringW,system);
#pragma import(GetMenuStringW,'GetMenuStringW','user32.dll');

#if #declared UNICODE; then;
#template GetMenuString;
  GetMenuStringW 
#end GetMenuString;
#else;
#template GetMenuString;
  GetMenuStringA 
#end GetMenuString;
#end if;

procedure GetMenuState(
    hMenu           : in t_HMENU; 
    uId             : in UINT; 
    uFlags          : in UINT)
                      return UINT;
#pragma convention(GetMenuState,system);
#pragma import(GetMenuState,'GetMenuState','user32.dll');

procedure DrawMenuBar(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(DrawMenuBar,system);
#pragma import(DrawMenuBar,'DrawMenuBar','user32.dll');

const
  PMB_ACTIVE        = $01;

procedure GetSystemMenu(
    hWnd            : in t_HWND; 
    bRevert         : in BOOL)
                      return t_HMENU;
#pragma convention(GetSystemMenu,system);
#pragma import(GetSystemMenu,'GetSystemMenu','user32.dll');

procedure CreateMenu
                      return t_HMENU;
#pragma convention(CreateMenu,system);
#pragma import(CreateMenu,'CreateMenu','user32.dll');

procedure CreatePopupMenu
                      return t_HMENU;
#pragma convention(CreatePopupMenu,system);
#pragma import(CreatePopupMenu,'CreatePopupMenu','user32.dll');

procedure DestroyMenu(
    hMenu           : in t_HMENU)
                      return BOOL;
#pragma convention(DestroyMenu,system);
#pragma import(DestroyMenu,'DestroyMenu','user32.dll');

procedure CheckMenuItem(
    hMenu           : in t_HMENU; 
    uIDCheckItem    : in UINT; 
    uCheck          : in UINT)
                      return DWORD;
#pragma convention(CheckMenuItem,system);
#pragma import(CheckMenuItem,'CheckMenuItem','user32.dll');

procedure EnableMenuItem(
    hMenu           : in t_HMENU; 
    uIDEnableItem   : in UINT; 
    uEnable         : in UINT)
                      return BOOL;
#pragma convention(EnableMenuItem,system);
#pragma import(EnableMenuItem,'EnableMenuItem','user32.dll');

type
t_128=signed 32;

procedure GetSubMenu(
    hMenu           : in t_HMENU; 
    nPos            : in t_128)
                      return t_HMENU;
#pragma convention(GetSubMenu,system);
#pragma import(GetSubMenu,'GetSubMenu','user32.dll');

type
t_129=signed 32;

procedure GetMenuItemID(
    hMenu           : in t_HMENU; 
    nPos            : in t_129)
                      return UINT;
#pragma convention(GetMenuItemID,system);
#pragma import(GetMenuItemID,'GetMenuItemID','user32.dll');

type
  t_130 = signed 32;

procedure GetMenuItemCount(
    hMenu           : in t_HMENU)
                      return t_130;
#pragma convention(GetMenuItemCount,system);
#pragma import(GetMenuItemCount,'GetMenuItemCount','user32.dll');

procedure InsertMenuA(
    hMenu           : in t_HMENU; 
    uPosition       : in UINT; 
    uFlags          : in UINT; 
    uIDNewItem      : in UINT_PTR; 
    lpNewItem       : in LPCSTR)
                      return BOOL;
#pragma convention(InsertMenuA,system);
#pragma import(InsertMenuA,'InsertMenuA','user32.dll');

procedure InsertMenuW(
    hMenu           : in t_HMENU; 
    uPosition       : in UINT; 
    uFlags          : in UINT; 
    uIDNewItem      : in UINT_PTR; 
    lpNewItem       : in LPCWSTR)
                      return BOOL;
#pragma convention(InsertMenuW,system);
#pragma import(InsertMenuW,'InsertMenuW','user32.dll');

#if #declared UNICODE; then;
#template InsertMenu;
  InsertMenuW 
#end InsertMenu;
#else;
#template InsertMenu;
  InsertMenuA 
#end InsertMenu;
#end if;

procedure AppendMenuA(
    hMenu           : in t_HMENU; 
    uFlags          : in UINT; 
    uIDNewItem      : in UINT_PTR; 
    lpNewItem       : in LPCSTR)
                      return BOOL;
#pragma convention(AppendMenuA,system);
#pragma import(AppendMenuA,'AppendMenuA','user32.dll');

procedure AppendMenuW(
    hMenu           : in t_HMENU; 
    uFlags          : in UINT; 
    uIDNewItem      : in UINT_PTR; 
    lpNewItem       : in LPCWSTR)
                      return BOOL;
#pragma convention(AppendMenuW,system);
#pragma import(AppendMenuW,'AppendMenuW','user32.dll');

#if #declared UNICODE; then;
#template AppendMenu;
  AppendMenuW 
#end AppendMenu;
#else;
#template AppendMenu;
  AppendMenuA 
#end AppendMenu;
#end if;

procedure ModifyMenuA(
    hMnu            : in t_HMENU; 
    uPosition       : in UINT; 
    uFlags          : in UINT; 
    uIDNewItem      : in UINT_PTR; 
    lpNewItem       : in LPCSTR)
                      return BOOL;
#pragma convention(ModifyMenuA,system);
#pragma import(ModifyMenuA,'ModifyMenuA','user32.dll');

procedure ModifyMenuW(
    hMnu            : in t_HMENU; 
    uPosition       : in UINT; 
    uFlags          : in UINT; 
    uIDNewItem      : in UINT_PTR; 
    lpNewItem       : in LPCWSTR)
                      return BOOL;
#pragma convention(ModifyMenuW,system);
#pragma import(ModifyMenuW,'ModifyMenuW','user32.dll');

#if #declared UNICODE; then;
#template ModifyMenu;
  ModifyMenuW 
#end ModifyMenu;
#else;
#template ModifyMenu;
  ModifyMenuA 
#end ModifyMenu;
#end if;

procedure RemoveMenu(
    hMenu           : in t_HMENU; 
    uPosition       : in UINT; 
    uFlags          : in UINT)
                      return BOOL;
#pragma convention(RemoveMenu,system);
#pragma import(RemoveMenu,'RemoveMenu','user32.dll');

procedure DeleteMenu(
    hMenu           : in t_HMENU; 
    uPosition       : in UINT; 
    uFlags          : in UINT)
                      return BOOL;
#pragma convention(DeleteMenu,system);
#pragma import(DeleteMenu,'DeleteMenu','user32.dll');

procedure SetMenuItemBitmaps(
    hMenu           : in t_HMENU; 
    uPosition       : in UINT; 
    uFlags          : in UINT; 
    hBitmapUnchecked : in t_HBITMAP; 
    hBitmapChecked  : in t_HBITMAP)
                      return BOOL;
#pragma convention(SetMenuItemBitmaps,system);
#pragma import(SetMenuItemBitmaps,'SetMenuItemBitmaps','user32.dll');

procedure GetMenuCheckMarkDimensions
                      return LONG;
#pragma convention(GetMenuCheckMarkDimensions,system);
#pragma import(GetMenuCheckMarkDimensions,'GetMenuCheckMarkDimensions','user32.dll');

type
t_131=signed 32;

t_132=signed 32;

t_133=signed 32;

t_134=^RECT for machine_pointer use true;

procedure TrackPopupMenu(
    hMenu           : in t_HMENU; 
    uFlags          : in UINT; 
    x               : in t_131; 
    y               : in t_132; 
    nReserved       : in t_133; 
    hWnd            : in t_HWND; 
    prcRect         : in t_134)
                      return BOOL;
#pragma convention(TrackPopupMenu,system);
#pragma import(TrackPopupMenu,'TrackPopupMenu','user32.dll');

-- /* return codes for WM_MENUCHAR 
const
  MNC_IGNORE        = 0;

const
  MNC_CLOSE         = 1;

const
  MNC_EXECUTE       = 2;

const
  MNC_SELECT        = 3;

type
  tagTPMPARAMS      = record
cbSize          : UINT;
rcExclude       : RECT;
  end record;
  TPMPARAMS         = tagTPMPARAMS;

type
LPTPMPARAMS       = ^TPMPARAMS for machine_pointer use true;
type
t_135=signed 32;

t_136=signed 32;

procedure TrackPopupMenuEx(
    _001            : in t_HMENU; 
    _002            : in UINT; 
    _003            : in t_135; 
    _004            : in t_136; 
    _005            : in t_HWND; 
    _006            : in LPTPMPARAMS)
                      return BOOL;
#pragma convention(TrackPopupMenuEx,system);
#pragma import(TrackPopupMenuEx,'TrackPopupMenuEx','user32.dll');

const
  MNS_NOCHECK       = $80000000;

const
  MNS_MODELESS      = $40000000;

const
  MNS_DRAGDROP      = $20000000;

const
  MNS_AUTODISMISS   = $10000000;

const
  MNS_NOTIFYBYPOS   = $8000000;

const
  MNS_CHECKORBMP    = $4000000;

const
  MIM_MAXHEIGHT     = $01;

const
  MIM_BACKGROUND    = $02;

const
  MIM_HELPID        = $04;

const
  MIM_MENUDATA      = $08;

const
  MIM_STYLE         = $10;

const
  MIM_APPLYTOSUBMENUS= $80000000;

type
  tagMENUINFO       = record
cbSize          : DWORD;
fMask           : DWORD;
dwStyle         : DWORD;
cyMax           : UINT;
hbrBack         : t_HBRUSH;
dwContextHelpID : DWORD;
dwMenuData      : ULONG_PTR;
  end record;
  MENUINFO          = tagMENUINFO;
  LPMENUINFO        = ^tagMENUINFO;

type
LPCMENUINFO       = ^MENUINFO for machine_pointer use true;
procedure GetMenuInfo(
    _001            : in t_HMENU; 
    _002            : out tagMENUINFO)
                      return BOOL;
#pragma convention(GetMenuInfo,system);
#pragma import(GetMenuInfo,'GetMenuInfo','user32.dll');

procedure SetMenuInfo(
    _001            : in t_HMENU; 
    _002            : in LPCMENUINFO)
                      return BOOL;
#pragma convention(SetMenuInfo,system);
#pragma import(SetMenuInfo,'SetMenuInfo','user32.dll');

procedure EndMenu
                      return BOOL;
#pragma convention(EndMenu,system);
#pragma import(EndMenu,'EndMenu','user32.dll');

-- /*
--  * WM_MENUDRAG return values.
--  */
const
  MND_CONTINUE      = 0;

const
  MND_ENDMENU       = 1;

type
  tagMENUGETOBJECTINFO = record
dwFlags         : DWORD;
uPos            : UINT;
hmenu           : t_HMENU;
riid            : PVOID;
pvObj           : PVOID;
  end record;
  MENUGETOBJECTINFO = tagMENUGETOBJECTINFO;
  PMENUGETOBJECTINFO = ^tagMENUGETOBJECTINFO;

-- /*
--  * MENUGETOBJECTINFO dwFlags values
--  */
const
  MNGOF_TOPGAP      = $01;

const
  MNGOF_BOTTOMGAP   = $02;

-- /*
--  * WM_MENUGETOBJECT return values
--  */
const
  MNGO_NOINTERFACE  = $00;

const
  MNGO_NOERROR      = $01;

const
  MIIM_STATE        = $01;

const
  MIIM_ID           = $02;

const
  MIIM_SUBMENU      = $04;

const
  MIIM_CHECKMARKS   = $08;

const
  MIIM_TYPE         = $10;

const
  MIIM_DATA         = $20;

const
  MIIM_STRING       = $40;

const
  MIIM_BITMAP       = $80;

const
  MIIM_FTYPE        = $0100;

type
  tagMENUITEMINFOA  = record
cbSize          : UINT;
fMask           : UINT;
fType           : UINT;
fState          : UINT;
wID             : UINT;
hSubMenu        : t_HMENU;
hbmpChecked     : t_HBITMAP;
hbmpUnchecked   : t_HBITMAP;
dwItemData      : ULONG_PTR;
dwTypeData      : LPSTR;
cch             : UINT;
hbmpItem        : t_HBITMAP;
  end record;
  MENUITEMINFOA     = tagMENUITEMINFOA;
  LPMENUITEMINFOA   = ^tagMENUITEMINFOA;

type
  tagMENUITEMINFOW  = record
cbSize          : UINT;
fMask           : UINT;
fType           : UINT;
fState          : UINT;
wID             : UINT;
hSubMenu        : t_HMENU;
hbmpChecked     : t_HBITMAP;
hbmpUnchecked   : t_HBITMAP;
dwItemData      : ULONG_PTR;
dwTypeData      : LPWSTR;
cch             : UINT;
hbmpItem        : t_HBITMAP;
  end record;
  MENUITEMINFOW     = tagMENUITEMINFOW;
  LPMENUITEMINFOW   = ^tagMENUITEMINFOW;

#if #declared UNICODE; then;
type
MENUITEMINFO      = MENUITEMINFOW;
type
LPMENUITEMINFO    = LPMENUITEMINFOW;
#else;
type
MENUITEMINFO      = MENUITEMINFOA;
type
LPMENUITEMINFO    = LPMENUITEMINFOA;
#end if;

type
LPCMENUITEMINFOA  = ^MENUITEMINFOA for machine_pointer use true;
type
LPCMENUITEMINFOW  = ^MENUITEMINFOW for machine_pointer use true;
#if #declared UNICODE; then;
type
LPCMENUITEMINFO   = LPCMENUITEMINFOW;
#else;
type
LPCMENUITEMINFO   = LPCMENUITEMINFOA;
#end if;

procedure InsertMenuItemA(
    _001            : in t_HMENU; 
    _002            : in UINT; 
    _003            : in BOOL; 
    _004            : in LPCMENUITEMINFOA)
                      return BOOL;
#pragma convention(InsertMenuItemA,system);
#pragma import(InsertMenuItemA,'InsertMenuItemA','user32.dll');

procedure InsertMenuItemW(
    _001            : in t_HMENU; 
    _002            : in UINT; 
    _003            : in BOOL; 
    _004            : in LPCMENUITEMINFOW)
                      return BOOL;
#pragma convention(InsertMenuItemW,system);
#pragma import(InsertMenuItemW,'InsertMenuItemW','user32.dll');

#if #declared UNICODE; then;
#template InsertMenuItem;
  InsertMenuItemW 
#end InsertMenuItem;
#else;
#template InsertMenuItem;
  InsertMenuItemA 
#end InsertMenuItem;
#end if;

procedure GetMenuItemInfoA(
    _001            : in t_HMENU; 
    _002            : in UINT; 
    _003            : in BOOL; 
    _004            : in out tagMENUITEMINFOA)
                      return BOOL;
#pragma convention(GetMenuItemInfoA,system);
#pragma import(GetMenuItemInfoA,'GetMenuItemInfoA','user32.dll');

procedure GetMenuItemInfoW(
    _001            : in t_HMENU; 
    _002            : in UINT; 
    _003            : in BOOL; 
    _004            : in out tagMENUITEMINFOW)
                      return BOOL;
#pragma convention(GetMenuItemInfoW,system);
#pragma import(GetMenuItemInfoW,'GetMenuItemInfoW','user32.dll');

#if #declared UNICODE; then;
#template GetMenuItemInfo;
  GetMenuItemInfoW 
#end GetMenuItemInfo;
#else;
#template GetMenuItemInfo;
  GetMenuItemInfoA 
#end GetMenuItemInfo;
#end if;

procedure SetMenuItemInfoA(
    _001            : in t_HMENU; 
    _002            : in UINT; 
    _003            : in BOOL; 
    _004            : in LPCMENUITEMINFOA)
                      return BOOL;
#pragma convention(SetMenuItemInfoA,system);
#pragma import(SetMenuItemInfoA,'SetMenuItemInfoA','user32.dll');

procedure SetMenuItemInfoW(
    _001            : in t_HMENU; 
    _002            : in UINT; 
    _003            : in BOOL; 
    _004            : in LPCMENUITEMINFOW)
                      return BOOL;
#pragma convention(SetMenuItemInfoW,system);
#pragma import(SetMenuItemInfoW,'SetMenuItemInfoW','user32.dll');

#if #declared UNICODE; then;
#template SetMenuItemInfo;
  SetMenuItemInfoW 
#end SetMenuItemInfo;
#else;
#template SetMenuItemInfo;
  SetMenuItemInfoA 
#end SetMenuItemInfo;
#end if;

const
  GMDI_USEDISABLED  = $01;

const
  GMDI_GOINTOPOPUPS = $02;

procedure GetMenuDefaultItem(
    hMenu           : in t_HMENU; 
    fByPos          : in UINT; 
    gmdiFlags       : in UINT)
                      return UINT;
#pragma convention(GetMenuDefaultItem,system);
#pragma import(GetMenuDefaultItem,'GetMenuDefaultItem','user32.dll');

procedure SetMenuDefaultItem(
    hMenu           : in t_HMENU; 
    uItem           : in UINT; 
    fByPos          : in UINT)
                      return BOOL;
#pragma convention(SetMenuDefaultItem,system);
#pragma import(SetMenuDefaultItem,'SetMenuDefaultItem','user32.dll');

procedure GetMenuItemRect(
    hWnd            : in t_HWND; 
    hMenu           : in t_HMENU; 
    uItem           : in UINT; 
    lprcItem        : out tagRECT)
                      return BOOL;
#pragma convention(GetMenuItemRect,system);
#pragma import(GetMenuItemRect,'GetMenuItemRect','user32.dll');

type
  t_137 = signed 32;

procedure MenuItemFromPoint(
    hWnd            : in t_HWND; 
    hMenu           : in t_HMENU; 
    ptScreen        : in t_POINT)
                      return t_137;
#pragma convention(MenuItemFromPoint,system);
#pragma import(MenuItemFromPoint,'MenuItemFromPoint','user32.dll');

-- /*
--  * Flags for TrackPopupMenu
--  */
const
  TPM_LEFTBUTTON    = $00;

const
  TPM_RIGHTBUTTON   = $02;

const
  TPM_LEFTALIGN     = $00;

const
  TPM_CENTERALIGN   = $04;

const
  TPM_RIGHTALIGN    = $08;

const
  TPM_TOPALIGN      = $00;

const
  TPM_VCENTERALIGN  = $10;

const
  TPM_BOTTOMALIGN   = $20;

const
  TPM_HORIZONTAL    = $00;

const
  TPM_VERTICAL      = $40;

const
  TPM_NONOTIFY      = $80;

const
  TPM_RETURNCMD     = $0100;

const
  TPM_RECURSE       = $01;

const
  TPM_HORPOSANIMATION= $0400;

const
  TPM_HORNEGANIMATION= $0800;

const
  TPM_VERPOSANIMATION= $1000;

const
  TPM_VERNEGANIMATION= $2000;

const
  TPM_NOANIMATION   = $4000;

const
  TPM_LAYOUTRTL     = $8000;

-- 
--  Drag-and-drop support
--  Obsolete - use OLE instead
-- 
type
  tagDROPSTRUCT     = record
hwndSource      : t_HWND;
hwndSink        : t_HWND;
wFmt            : DWORD;
dwData          : ULONG_PTR;
ptDrop          : t_POINT;
dwControlData   : DWORD;
  end record;
  DROPSTRUCT        = tagDROPSTRUCT;
  PDROPSTRUCT       = ^tagDROPSTRUCT;
  LPDROPSTRUCT      = ^tagDROPSTRUCT;

const
  DOF_EXECUTABLE    = $8001;

const
  DOF_DOCUMENT      = $8002;

const
  DOF_DIRECTORY     = $8003;

const
  DOF_MULTIPLE      = $8004;

const
  DOF_PROGMAN       = $01;

const
  DOF_SHELLDATA     = $02;

const
  DO_DROPFILE       = $454C4946;

const
  DO_PRINTFILE      = $544E5250;

procedure DragObject(
    _001            : in t_HWND; 
    _002            : in t_HWND; 
    _003            : in UINT; 
    _004            : in ULONG_PTR; 
    _005            : in t_HCURSOR)
                      return DWORD;
#pragma convention(DragObject,system);
#pragma import(DragObject,'DragObject','user32.dll');

procedure DragDetect(
    _001            : in t_HWND; 
    _002            : in t_POINT)
                      return BOOL;
#pragma convention(DragDetect,system);
#pragma import(DragDetect,'DragDetect','user32.dll');

type
t_138=signed 32;

t_139=signed 32;

procedure DrawIcon(
    hDC             : in t_HDC; 
    X               : in t_138; 
    Y               : in t_139; 
    hIcon           : in t_HICON)
                      return BOOL;
#pragma convention(DrawIcon,system);
#pragma import(DrawIcon,'DrawIcon','user32.dll');

-- /*
--  * DrawText() Format Flags
--  */
const
  DT_TOP            = $00;

const
  DT_LEFT           = $00;

const
  DT_CENTER         = $01;

const
  DT_RIGHT          = $02;

const
  DT_VCENTER        = $04;

const
  DT_BOTTOM         = $08;

const
  DT_WORDBREAK      = $10;

const
  DT_SINGLELINE     = $20;

const
  DT_EXPANDTABS     = $40;

const
  DT_TABSTOP        = $80;

const
  DT_NOCLIP         = $0100;

const
  DT_EXTERNALLEADING= $0200;

const
  DT_CALCRECT       = $0400;

const
  DT_NOPREFIX       = $0800;

const
  DT_INTERNAL       = $1000;

const
  DT_EDITCONTROL    = $2000;

const
  DT_PATH_ELLIPSIS  = $4000;

const
  DT_END_ELLIPSIS   = $8000;

const
  DT_MODIFYSTRING   = $10000;

const
  DT_RTLREADING     = $20000;

const
  DT_WORD_ELLIPSIS  = $40000;

const
  DT_NOFULLWIDTHCHARBREAK= $80000;

const
  DT_HIDEPREFIX     = $100000;

const
  DT_PREFIXONLY     = $200000;

type
  tagDRAWTEXTPARAMS = record
cbSize          : UINT;
iTabLength      : signed 32;
iLeftMargin     : signed 32;
iRightMargin    : signed 32;
uiLengthDrawn   : UINT;
  end record;
  DRAWTEXTPARAMS    = tagDRAWTEXTPARAMS;
  LPDRAWTEXTPARAMS  = ^tagDRAWTEXTPARAMS;

type
t_140=signed 32;

  t_141 = signed 32;

procedure DrawTextA(
    hDC             : in t_HDC; 
    lpString        : in LPCSTR; 
    nCount          : in t_140; 
    lpRect          : in out tagRECT; 
    uFormat         : in UINT)
                      return t_141;
#pragma convention(DrawTextA,system);
#pragma import(DrawTextA,'DrawTextA','user32.dll');

type
t_142=signed 32;

  t_143 = signed 32;

procedure DrawTextW(
    hDC             : in t_HDC; 
    lpString        : in LPCWSTR; 
    nCount          : in t_142; 
    lpRect          : in out tagRECT; 
    uFormat         : in UINT)
                      return t_143;
#pragma convention(DrawTextW,system);
#pragma import(DrawTextW,'DrawTextW','user32.dll');

#if #declared UNICODE; then;
#template DrawText;
  DrawTextW 
#end DrawText;
#else;
#template DrawText;
  DrawTextA 
#end DrawText;
#end if;

type
t_144=signed 32;

  t_145 = signed 32;

procedure DrawTextExA(
    _001            : in t_HDC; 
    _002            : in out CHARSTR ; 
    _003            : in t_144; 
    _004            : in out tagRECT; 
    _005            : in UINT; 
    _006            : in LPDRAWTEXTPARAMS)
                      return t_145;
#pragma convention(DrawTextExA,system);
#pragma import(DrawTextExA,'DrawTextExA','user32.dll');

type
t_146=signed 32;

  t_147 = signed 32;

procedure DrawTextExW(
    _001            : in t_HDC; 
    _002            : in out WCHARSTR ; 
    _003            : in t_146; 
    _004            : in out tagRECT; 
    _005            : in UINT; 
    _006            : in LPDRAWTEXTPARAMS)
                      return t_147;
#pragma convention(DrawTextExW,system);
#pragma import(DrawTextExW,'DrawTextExW','user32.dll');

#if #declared UNICODE; then;
#template DrawTextEx;
  DrawTextExW 
#end DrawTextEx;
#else;
#template DrawTextEx;
  DrawTextExA 
#end DrawTextEx;
#end if;

type
t_148=signed 32;

t_149=signed 32;

t_150=signed 32;

t_151=signed 32;

t_152=signed 32;

procedure GrayStringA(
    hDC             : in t_HDC; 
    hBrush          : in t_HBRUSH; 
    lpOutputFunc    : in GRAYSTRINGPROC; 
    lpData          : in t_LPARAM; 
    nCount          : in t_148; 
    X               : in t_149; 
    Y               : in t_150; 
    nWidth          : in t_151; 
    nHeight         : in t_152)
                      return BOOL;
#pragma convention(GrayStringA,system);
#pragma import(GrayStringA,'GrayStringA','user32.dll');

type
t_153=signed 32;

t_154=signed 32;

t_155=signed 32;

t_156=signed 32;

t_157=signed 32;

procedure GrayStringW(
    hDC             : in t_HDC; 
    hBrush          : in t_HBRUSH; 
    lpOutputFunc    : in GRAYSTRINGPROC; 
    lpData          : in t_LPARAM; 
    nCount          : in t_153; 
    X               : in t_154; 
    Y               : in t_155; 
    nWidth          : in t_156; 
    nHeight         : in t_157)
                      return BOOL;
#pragma convention(GrayStringW,system);
#pragma import(GrayStringW,'GrayStringW','user32.dll');

#if #declared UNICODE; then;
#template GrayString;
  GrayStringW 
#end GrayString;
#else;
#template GrayString;
  GrayStringA 
#end GrayString;
#end if;

-- /* Monolithic state-drawing routine 
-- /* Image type 
const
  DST_COMPLEX       = $00;

const
  DST_TEXT          = $01;

const
  DST_PREFIXTEXT    = $02;

const
  DST_ICON          = $03;

const
  DST_BITMAP        = $04;

-- /* State type 
const
  DSS_NORMAL        = $00;

const
  DSS_UNION         = $10;

const
  DSS_DISABLED      = $20;

const
  DSS_MONO          = $80;

const
  DSS_HIDEPREFIX    = $0200;

const
  DSS_PREFIXONLY    = $0400;

const
  DSS_RIGHT         = $8000;

type
t_158=signed 32;

t_159=signed 32;

t_160=signed 32;

t_161=signed 32;

procedure DrawStateA(
    _001            : in t_HDC; 
    _002            : in t_HBRUSH; 
    _003            : in DRAWSTATEPROC; 
    _004            : in t_LPARAM; 
    _005            : in t_WPARAM; 
    _006            : in t_158; 
    _007            : in t_159; 
    _008            : in t_160; 
    _009            : in t_161; 
    _010            : in UINT)
                      return BOOL;
#pragma convention(DrawStateA,system);
#pragma import(DrawStateA,'DrawStateA','user32.dll');

type
t_162=signed 32;

t_163=signed 32;

t_164=signed 32;

t_165=signed 32;

procedure DrawStateW(
    _001            : in t_HDC; 
    _002            : in t_HBRUSH; 
    _003            : in DRAWSTATEPROC; 
    _004            : in t_LPARAM; 
    _005            : in t_WPARAM; 
    _006            : in t_162; 
    _007            : in t_163; 
    _008            : in t_164; 
    _009            : in t_165; 
    _010            : in UINT)
                      return BOOL;
#pragma convention(DrawStateW,system);
#pragma import(DrawStateW,'DrawStateW','user32.dll');

#if #declared UNICODE; then;
#template DrawState;
  DrawStateW 
#end DrawState;
#else;
#template DrawState;
  DrawStateA 
#end DrawState;
#end if;

type
t_166=signed 32;

t_167=signed 32;

t_168=signed 32;

t_169=signed 32;

t_170=^INT for machine_pointer use true;

t_171=signed 32;

procedure TabbedTextOutA(
    hDC             : in t_HDC; 
    X               : in t_166; 
    Y               : in t_167; 
    lpString        : in LPCSTR; 
    nCount          : in t_168; 
    nTabPositions   : in t_169; 
    lpnTabStopPositions : in t_170; 
    nTabOrigin      : in t_171)
                      return LONG;
#pragma convention(TabbedTextOutA,system);
#pragma import(TabbedTextOutA,'TabbedTextOutA','user32.dll');

type
t_172=signed 32;

t_173=signed 32;

t_174=signed 32;

t_175=signed 32;

t_176=^INT for machine_pointer use true;

t_177=signed 32;

procedure TabbedTextOutW(
    hDC             : in t_HDC; 
    X               : in t_172; 
    Y               : in t_173; 
    lpString        : in LPCWSTR; 
    nCount          : in t_174; 
    nTabPositions   : in t_175; 
    lpnTabStopPositions : in t_176; 
    nTabOrigin      : in t_177)
                      return LONG;
#pragma convention(TabbedTextOutW,system);
#pragma import(TabbedTextOutW,'TabbedTextOutW','user32.dll');

#if #declared UNICODE; then;
#template TabbedTextOut;
  TabbedTextOutW 
#end TabbedTextOut;
#else;
#template TabbedTextOut;
  TabbedTextOutA 
#end TabbedTextOut;
#end if;

type
t_178=signed 32;

t_179=signed 32;

t_180=^INT for machine_pointer use true;

procedure GetTabbedTextExtentA(
    hDC             : in t_HDC; 
    lpString        : in LPCSTR; 
    nCount          : in t_178; 
    nTabPositions   : in t_179; 
    lpnTabStopPositions : in t_180)
                      return DWORD;
#pragma convention(GetTabbedTextExtentA,system);
#pragma import(GetTabbedTextExtentA,'GetTabbedTextExtentA','user32.dll');

type
t_181=signed 32;

t_182=signed 32;

t_183=^INT for machine_pointer use true;

procedure GetTabbedTextExtentW(
    hDC             : in t_HDC; 
    lpString        : in LPCWSTR; 
    nCount          : in t_181; 
    nTabPositions   : in t_182; 
    lpnTabStopPositions : in t_183)
                      return DWORD;
#pragma convention(GetTabbedTextExtentW,system);
#pragma import(GetTabbedTextExtentW,'GetTabbedTextExtentW','user32.dll');

#if #declared UNICODE; then;
#template GetTabbedTextExtent;
  GetTabbedTextExtentW 
#end GetTabbedTextExtent;
#else;
#template GetTabbedTextExtent;
  GetTabbedTextExtentA 
#end GetTabbedTextExtent;
#end if;

procedure UpdateWindow(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(UpdateWindow,system);
#pragma import(UpdateWindow,'UpdateWindow','user32.dll');

procedure SetActiveWindow(
    hWnd            : in t_HWND)
                      return t_HWND;
#pragma convention(SetActiveWindow,system);
#pragma import(SetActiveWindow,'SetActiveWindow','user32.dll');

procedure GetForegroundWindow
                      return t_HWND;
#pragma convention(GetForegroundWindow,system);
#pragma import(GetForegroundWindow,'GetForegroundWindow','user32.dll');

procedure PaintDesktop(
    hdc             : in t_HDC)
                      return BOOL;
#pragma convention(PaintDesktop,system);
#pragma import(PaintDesktop,'PaintDesktop','user32.dll');

procedure SwitchToThisWindow(
    hwnd            : in t_HWND; 
    fUnknown        : in BOOL);
#pragma convention(SwitchToThisWindow,system);
#pragma import(SwitchToThisWindow,'SwitchToThisWindow','user32.dll');

procedure SetForegroundWindow(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(SetForegroundWindow,system);
#pragma import(SetForegroundWindow,'SetForegroundWindow','user32.dll');

procedure AllowSetForegroundWindow(
    dwProcessId     : DWORD)
                      return BOOL;
#pragma convention(AllowSetForegroundWindow,system);
#pragma import(AllowSetForegroundWindow,'AllowSetForegroundWindow','user32.dll');

procedure LockSetForegroundWindow(
    uLockCode       : UINT)
                      return BOOL;
#pragma convention(LockSetForegroundWindow,system);
#pragma import(LockSetForegroundWindow,'LockSetForegroundWindow','user32.dll');

const
  LSFW_LOCK         = 1;

const
  LSFW_UNLOCK       = 2;

procedure WindowFromDC(
    hDC             : in t_HDC)
                      return t_HWND;
#pragma convention(WindowFromDC,system);
#pragma import(WindowFromDC,'WindowFromDC','user32.dll');

procedure GetDC(
    hWnd            : in t_HWND)
                      return t_HDC;
#pragma convention(GetDC,system);
#pragma import(GetDC,'GetDC','user32.dll');

procedure GetDCEx(
    hWnd            : in t_HWND; 
    hrgnClip        : in t_HRGN; 
    flags           : in DWORD)
                      return t_HDC;
#pragma convention(GetDCEx,system);
#pragma import(GetDCEx,'GetDCEx','user32.dll');

-- /*
--  * GetDCEx() flags
--  */
const
  DCX_WINDOW        = $01;

const
  DCX_CACHE         = $02;

const
  DCX_NORESETATTRS  = $04;

const
  DCX_CLIPCHILDREN  = $08;

const
  DCX_CLIPSIBLINGS  = $10;

const
  DCX_PARENTCLIP    = $20;

const
  DCX_EXCLUDERGN    = $40;

const
  DCX_INTERSECTRGN  = $80;

const
  DCX_EXCLUDEUPDATE = $0100;

const
  DCX_INTERSECTUPDATE= $0200;

const
  DCX_LOCKWINDOWUPDATE= $0400;

const
  DCX_VALIDATE      = $200000;

procedure GetWindowDC(
    hWnd            : in t_HWND)
                      return t_HDC;
#pragma convention(GetWindowDC,system);
#pragma import(GetWindowDC,'GetWindowDC','user32.dll');

type
  t_184 = signed 32;

procedure ReleaseDC(
    hWnd            : in t_HWND; 
    hDC             : in t_HDC)
                      return t_184;
#pragma convention(ReleaseDC,system);
#pragma import(ReleaseDC,'ReleaseDC','user32.dll');

procedure BeginPaint(
    hWnd            : in t_HWND; 
    lpPaint         : out tagPAINTSTRUCT)
                      return t_HDC;
#pragma convention(BeginPaint,system);
#pragma import(BeginPaint,'BeginPaint','user32.dll');

type
t_185=^PAINTSTRUCT for machine_pointer use true;

procedure EndPaint(
    hWnd            : in t_HWND; 
    lpPaint         : in t_185)
                      return BOOL;
#pragma convention(EndPaint,system);
#pragma import(EndPaint,'EndPaint','user32.dll');

procedure GetUpdateRect(
    hWnd            : in t_HWND; 
    lpRect          : out tagRECT; 
    bErase          : in BOOL)
                      return BOOL;
#pragma convention(GetUpdateRect,system);
#pragma import(GetUpdateRect,'GetUpdateRect','user32.dll');

type
  t_186 = signed 32;

procedure GetUpdateRgn(
    hWnd            : in t_HWND; 
    hRgn            : in t_HRGN; 
    bErase          : in BOOL)
                      return t_186;
#pragma convention(GetUpdateRgn,system);
#pragma import(GetUpdateRgn,'GetUpdateRgn','user32.dll');

type
  t_187 = signed 32;

procedure SetWindowRgn(
    hWnd            : in t_HWND; 
    hRgn            : in t_HRGN; 
    bRedraw         : in BOOL)
                      return t_187;
#pragma convention(SetWindowRgn,system);
#pragma import(SetWindowRgn,'SetWindowRgn','user32.dll');

type
  t_188 = signed 32;

procedure GetWindowRgn(
    hWnd            : in t_HWND; 
    hRgn            : in t_HRGN)
                      return t_188;
#pragma convention(GetWindowRgn,system);
#pragma import(GetWindowRgn,'GetWindowRgn','user32.dll');

type
  t_189 = signed 32;

procedure GetWindowRgnBox(
    hWnd            : in t_HWND; 
    lprc            : out tagRECT)
                      return t_189;
#pragma convention(GetWindowRgnBox,system);
#pragma import(GetWindowRgnBox,'GetWindowRgnBox','user32.dll');

type
  t_190 = signed 32;

procedure ExcludeUpdateRgn(
    hDC             : in t_HDC; 
    hWnd            : in t_HWND)
                      return t_190;
#pragma convention(ExcludeUpdateRgn,system);
#pragma import(ExcludeUpdateRgn,'ExcludeUpdateRgn','user32.dll');

type
t_191=^RECT for machine_pointer use true;

procedure InvalidateRect(
    hWnd            : in t_HWND; 
    lpRect          : in t_191; 
    bErase          : in BOOL)
                      return BOOL;
#pragma convention(InvalidateRect,system);
#pragma import(InvalidateRect,'InvalidateRect','user32.dll');

type
t_192=^RECT for machine_pointer use true;

procedure ValidateRect(
    hWnd            : in t_HWND; 
    lpRect          : in t_192)
                      return BOOL;
#pragma convention(ValidateRect,system);
#pragma import(ValidateRect,'ValidateRect','user32.dll');

procedure InvalidateRgn(
    hWnd            : in t_HWND; 
    hRgn            : in t_HRGN; 
    bErase          : in BOOL)
                      return BOOL;
#pragma convention(InvalidateRgn,system);
#pragma import(InvalidateRgn,'InvalidateRgn','user32.dll');

procedure ValidateRgn(
    hWnd            : in t_HWND; 
    hRgn            : in t_HRGN)
                      return BOOL;
#pragma convention(ValidateRgn,system);
#pragma import(ValidateRgn,'ValidateRgn','user32.dll');

type
t_193=^RECT for machine_pointer use true;

procedure RedrawWindow(
    hWnd            : in t_HWND; 
    lprcUpdate      : in t_193; 
    hrgnUpdate      : in t_HRGN; 
    flags           : in UINT)
                      return BOOL;
#pragma convention(RedrawWindow,system);
#pragma import(RedrawWindow,'RedrawWindow','user32.dll');

-- /*
--  * RedrawWindow() flags
--  */
const
  RDW_INVALIDATE    = $01;

const
  RDW_INTERNALPAINT = $02;

const
  RDW_ERASE         = $04;

const
  RDW_VALIDATE      = $08;

const
  RDW_NOINTERNALPAINT= $10;

const
  RDW_NOERASE       = $20;

const
  RDW_NOCHILDREN    = $40;

const
  RDW_ALLCHILDREN   = $80;

const
  RDW_UPDATENOW     = $0100;

const
  RDW_ERASENOW      = $0200;

const
  RDW_FRAME         = $0400;

const
  RDW_NOFRAME       = $0800;

-- /*
--  * LockWindowUpdate API
--  */
procedure LockWindowUpdate(
    hWndLock        : in t_HWND)
                      return BOOL;
#pragma convention(LockWindowUpdate,system);
#pragma import(LockWindowUpdate,'LockWindowUpdate','user32.dll');

type
t_194=signed 32;

t_195=signed 32;

t_196=^RECT for machine_pointer use true;

t_197=^RECT for machine_pointer use true;

procedure ScrollWindow(
    hWnd            : in t_HWND; 
    XAmount         : in t_194; 
    YAmount         : in t_195; 
    lpRect          : in t_196; 
    lpClipRect      : in t_197)
                      return BOOL;
#pragma convention(ScrollWindow,system);
#pragma import(ScrollWindow,'ScrollWindow','user32.dll');

type
t_198=signed 32;

t_199=signed 32;

t_200=^RECT for machine_pointer use true;

t_201=^RECT for machine_pointer use true;

procedure ScrollDC(
    hDC             : in t_HDC; 
    dx              : in t_198; 
    dy              : in t_199; 
    lprcScroll      : in t_200; 
    lprcClip        : in t_201; 
    hrgnUpdate      : in t_HRGN; 
    lprcUpdate      : out tagRECT)
                      return BOOL;
#pragma convention(ScrollDC,system);
#pragma import(ScrollDC,'ScrollDC','user32.dll');

type
t_202=signed 32;

t_203=signed 32;

t_204=^RECT for machine_pointer use true;

t_205=^RECT for machine_pointer use true;

  t_206 = signed 32;

procedure ScrollWindowEx(
    hWnd            : in t_HWND; 
    dx              : in t_202; 
    dy              : in t_203; 
    prcScroll       : in t_204; 
    prcClip         : in t_205; 
    hrgnUpdate      : in t_HRGN; 
    prcUpdate       : out tagRECT; 
    flags           : in UINT)
                      return t_206;
#pragma convention(ScrollWindowEx,system);
#pragma import(ScrollWindowEx,'ScrollWindowEx','user32.dll');

const
  SW_SCROLLCHILDREN = $01;

const
  SW_INVALIDATE     = $02;

const
  SW_ERASE          = $04;

const
  SW_SMOOTHSCROLL   = $10;

type
t_207=signed 32;

t_208=signed 32;

  t_209 = signed 32;

procedure SetScrollPos(
    hWnd            : in t_HWND; 
    nBar            : in t_207; 
    nPos            : in t_208; 
    bRedraw         : in BOOL)
                      return t_209;
#pragma convention(SetScrollPos,system);
#pragma import(SetScrollPos,'SetScrollPos','user32.dll');

type
t_210=signed 32;

  t_211 = signed 32;

procedure GetScrollPos(
    hWnd            : in t_HWND; 
    nBar            : in t_210)
                      return t_211;
#pragma convention(GetScrollPos,system);
#pragma import(GetScrollPos,'GetScrollPos','user32.dll');

type
t_212=signed 32;

t_213=signed 32;

t_214=signed 32;

procedure SetScrollRange(
    hWnd            : in t_HWND; 
    nBar            : in t_212; 
    nMinPos         : in t_213; 
    nMaxPos         : in t_214; 
    bRedraw         : in BOOL)
                      return BOOL;
#pragma convention(SetScrollRange,system);
#pragma import(SetScrollRange,'SetScrollRange','user32.dll');

type
t_215=signed 32;

t_216=signed 32 ;

t_217=signed 32 ;

procedure GetScrollRange(
    hWnd            : in t_HWND; 
    nBar            : in t_215; 
    lpMinPos        : out t_216; 
    lpMaxPos        : out t_217)
                      return BOOL;
#pragma convention(GetScrollRange,system);
#pragma import(GetScrollRange,'GetScrollRange','user32.dll');

type
t_218=signed 32;

procedure ShowScrollBar(
    hWnd            : in t_HWND; 
    wBar            : in t_218; 
    bShow           : in BOOL)
                      return BOOL;
#pragma convention(ShowScrollBar,system);
#pragma import(ShowScrollBar,'ShowScrollBar','user32.dll');

procedure EnableScrollBar(
    hWnd            : in t_HWND; 
    wSBflags        : in UINT; 
    wArrows         : in UINT)
                      return BOOL;
#pragma convention(EnableScrollBar,system);
#pragma import(EnableScrollBar,'EnableScrollBar','user32.dll');

-- /*
--  * EnableScrollBar() flags
--  */
const
  ESB_ENABLE_BOTH   = $00;

const
  ESB_DISABLE_BOTH  = $03;

const
  ESB_DISABLE_LEFT  = $01;

const
  ESB_DISABLE_RIGHT = $02;

const
  ESB_DISABLE_UP    = $01;

const
  ESB_DISABLE_DOWN  = $02;

procedure SetPropA(
    hWnd            : in t_HWND; 
    lpString        : in LPCSTR; 
    hData           : in t_HANDLE)
                      return BOOL;
#pragma convention(SetPropA,system);
#pragma import(SetPropA,'SetPropA','user32.dll');

procedure SetPropW(
    hWnd            : in t_HWND; 
    lpString        : in LPCWSTR; 
    hData           : in t_HANDLE)
                      return BOOL;
#pragma convention(SetPropW,system);
#pragma import(SetPropW,'SetPropW','user32.dll');

#if #declared UNICODE; then;
#template SetProp;
  SetPropW 
#end SetProp;
#else;
#template SetProp;
  SetPropA 
#end SetProp;
#end if;

procedure GetPropA(
    hWnd            : in t_HWND; 
    lpString        : in LPCSTR)
                      return t_HANDLE;
#pragma convention(GetPropA,system);
#pragma import(GetPropA,'GetPropA','user32.dll');

procedure GetPropW(
    hWnd            : in t_HWND; 
    lpString        : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(GetPropW,system);
#pragma import(GetPropW,'GetPropW','user32.dll');

#if #declared UNICODE; then;
#template GetProp;
  GetPropW 
#end GetProp;
#else;
#template GetProp;
  GetPropA 
#end GetProp;
#end if;

procedure RemovePropA(
    hWnd            : in t_HWND; 
    lpString        : in LPCSTR)
                      return t_HANDLE;
#pragma convention(RemovePropA,system);
#pragma import(RemovePropA,'RemovePropA','user32.dll');

procedure RemovePropW(
    hWnd            : in t_HWND; 
    lpString        : in LPCWSTR)
                      return t_HANDLE;
#pragma convention(RemovePropW,system);
#pragma import(RemovePropW,'RemovePropW','user32.dll');

#if #declared UNICODE; then;
#template RemoveProp;
  RemovePropW 
#end RemoveProp;
#else;
#template RemoveProp;
  RemovePropA 
#end RemoveProp;
#end if;

type
  t_219 = signed 32;

procedure EnumPropsExA(
    hWnd            : in t_HWND; 
    lpEnumFunc      : in PROPENUMPROCEXA; 
    lParam          : in t_LPARAM)
                      return t_219;
#pragma convention(EnumPropsExA,system);
#pragma import(EnumPropsExA,'EnumPropsExA','user32.dll');

type
  t_220 = signed 32;

procedure EnumPropsExW(
    hWnd            : in t_HWND; 
    lpEnumFunc      : in PROPENUMPROCEXW; 
    lParam          : in t_LPARAM)
                      return t_220;
#pragma convention(EnumPropsExW,system);
#pragma import(EnumPropsExW,'EnumPropsExW','user32.dll');

#if #declared UNICODE; then;
#template EnumPropsEx;
  EnumPropsExW 
#end EnumPropsEx;
#else;
#template EnumPropsEx;
  EnumPropsExA 
#end EnumPropsEx;
#end if;

type
  t_221 = signed 32;

procedure EnumPropsA(
    hWnd            : in t_HWND; 
    lpEnumFunc      : in PROPENUMPROCA)
                      return t_221;
#pragma convention(EnumPropsA,system);
#pragma import(EnumPropsA,'EnumPropsA','user32.dll');

type
  t_222 = signed 32;

procedure EnumPropsW(
    hWnd            : in t_HWND; 
    lpEnumFunc      : in PROPENUMPROCW)
                      return t_222;
#pragma convention(EnumPropsW,system);
#pragma import(EnumPropsW,'EnumPropsW','user32.dll');

#if #declared UNICODE; then;
#template EnumProps;
  EnumPropsW 
#end EnumProps;
#else;
#template EnumProps;
  EnumPropsA 
#end EnumProps;
#end if;

procedure SetWindowTextA(
    hWnd            : in t_HWND; 
    lpString        : in LPCSTR)
                      return BOOL;
#pragma convention(SetWindowTextA,system);
#pragma import(SetWindowTextA,'SetWindowTextA','user32.dll');

procedure SetWindowTextW(
    hWnd            : in t_HWND; 
    lpString        : in LPCWSTR)
                      return BOOL;
#pragma convention(SetWindowTextW,system);
#pragma import(SetWindowTextW,'SetWindowTextW','user32.dll');

#if #declared UNICODE; then;
#template SetWindowText;
  SetWindowTextW 
#end SetWindowText;
#else;
#template SetWindowText;
  SetWindowTextA 
#end SetWindowText;
#end if;

type
t_223=signed 32;

  t_224 = signed 32;

procedure GetWindowTextA(
    hWnd            : in t_HWND; 
    lpString        : out CHARSTR ; 
    nMaxCount       : in t_223)
                      return t_224;
#pragma convention(GetWindowTextA,system);
#pragma import(GetWindowTextA,'GetWindowTextA','user32.dll');

type
t_225=signed 32;

  t_226 = signed 32;

procedure GetWindowTextW(
    hWnd            : in t_HWND; 
    lpString        : out WCHARSTR ; 
    nMaxCount       : in t_225)
                      return t_226;
#pragma convention(GetWindowTextW,system);
#pragma import(GetWindowTextW,'GetWindowTextW','user32.dll');

#if #declared UNICODE; then;
#template GetWindowText;
  GetWindowTextW 
#end GetWindowText;
#else;
#template GetWindowText;
  GetWindowTextA 
#end GetWindowText;
#end if;

type
  t_227 = signed 32;

procedure GetWindowTextLengthA(
    hWnd            : in t_HWND)
                      return t_227;
#pragma convention(GetWindowTextLengthA,system);
#pragma import(GetWindowTextLengthA,'GetWindowTextLengthA','user32.dll');

type
  t_228 = signed 32;

procedure GetWindowTextLengthW(
    hWnd            : in t_HWND)
                      return t_228;
#pragma convention(GetWindowTextLengthW,system);
#pragma import(GetWindowTextLengthW,'GetWindowTextLengthW','user32.dll');

#if #declared UNICODE; then;
#template GetWindowTextLength;
  GetWindowTextLengthW 
#end GetWindowTextLength;
#else;
#template GetWindowTextLength;
  GetWindowTextLengthA 
#end GetWindowTextLength;
#end if;

procedure GetClientRect(
    hWnd            : in t_HWND; 
    lpRect          : out tagRECT)
                      return BOOL;
#pragma convention(GetClientRect,system);
#pragma import(GetClientRect,'GetClientRect','user32.dll');

procedure GetWindowRect(
    hWnd            : in t_HWND; 
    lpRect          : out tagRECT)
                      return BOOL;
#pragma convention(GetWindowRect,system);
#pragma import(GetWindowRect,'GetWindowRect','user32.dll');

procedure AdjustWindowRect(
    lpRect          : in out tagRECT; 
    dwStyle         : in DWORD; 
    bMenu           : in BOOL)
                      return BOOL;
#pragma convention(AdjustWindowRect,system);
#pragma import(AdjustWindowRect,'AdjustWindowRect','user32.dll');

procedure AdjustWindowRectEx(
    lpRect          : in out tagRECT; 
    dwStyle         : in DWORD; 
    bMenu           : in BOOL; 
    dwExStyle       : in DWORD)
                      return BOOL;
#pragma convention(AdjustWindowRectEx,system);
#pragma import(AdjustWindowRectEx,'AdjustWindowRectEx','user32.dll');

const
  HELPINFO_WINDOW   = $01;

const
  HELPINFO_MENUITEM = $02;

type
  tagHELPINFO       = record
cbSize          : UINT;
iContextType    : signed 32;
iCtrlId         : signed 32;
hItemHandle     : t_HANDLE;
dwContextId     : DWORD_PTR;
MousePos        : t_POINT;
  end record;
  HELPINFO          = tagHELPINFO;
  p_HELPINFO        = ^tagHELPINFO;

procedure SetWindowContextHelpId(
    _001            : in t_HWND; 
    _002            : in DWORD)
                      return BOOL;
#pragma convention(SetWindowContextHelpId,system);
#pragma import(SetWindowContextHelpId,'SetWindowContextHelpId','user32.dll');

procedure GetWindowContextHelpId(
    _001            : in t_HWND)
                      return DWORD;
#pragma convention(GetWindowContextHelpId,system);
#pragma import(GetWindowContextHelpId,'GetWindowContextHelpId','user32.dll');

procedure SetMenuContextHelpId(
    _001            : in t_HMENU; 
    _002            : in DWORD)
                      return BOOL;
#pragma convention(SetMenuContextHelpId,system);
#pragma import(SetMenuContextHelpId,'SetMenuContextHelpId','user32.dll');

procedure GetMenuContextHelpId(
    _001            : in t_HMENU)
                      return DWORD;
#pragma convention(GetMenuContextHelpId,system);
#pragma import(GetMenuContextHelpId,'GetMenuContextHelpId','user32.dll');

-- /*
--  * MessageBox() Flags
--  */
const
  MB_OK             = $00;

const
  MB_OKCANCEL       = $01;

const
  MB_ABORTRETRYIGNORE= $02;

const
  MB_YESNOCANCEL    = $03;

const
  MB_YESNO          = $04;

const
  MB_RETRYCANCEL    = $05;

const
  MB_CANCELTRYCONTINUE= $06;

const
  MB_ICONHAND       = $10;

const
  MB_ICONQUESTION   = $20;

const
  MB_ICONEXCLAMATION= $30;

const
  MB_ICONASTERISK   = $40;

const
  MB_USERICON       = $80;

const
  MB_DEFBUTTON1     = $00;

const
  MB_DEFBUTTON2     = $0100;

const
  MB_DEFBUTTON3     = $0200;

const
  MB_DEFBUTTON4     = $0300;

const
  MB_APPLMODAL      = $00;

const
  MB_SYSTEMMODAL    = $1000;

const
  MB_TASKMODAL      = $2000;

const
  MB_HELP           = $4000;

const
  MB_NOFOCUS        = $8000;

const
  MB_SETFOREGROUND  = $10000;

const
  MB_DEFAULT_DESKTOP_ONLY= $20000;

const
  MB_TOPMOST        = $40000;

const
  MB_RIGHT          = $80000;

const
  MB_RTLREADING     = $100000;

const
  MB_SERVICE_NOTIFICATION= $200000;

const
  MB_SERVICE_NOTIFICATION_NT3X= $40000;

const
  MB_TYPEMASK       = $0F;

const
  MB_ICONMASK       = $F0;

const
  MB_DEFMASK        = $0F00;

const
  MB_MODEMASK       = $3000;

const
  MB_MISCMASK       = $C000;

type
  t_229 = signed 32;

procedure MessageBoxA(
    hWnd            : in t_HWND; 
    lpText          : in LPCSTR; 
    lpCaption       : in LPCSTR; 
    uType           : in UINT)
                      return t_229;
#pragma convention(MessageBoxA,system);
#pragma import(MessageBoxA,'MessageBoxA','user32.dll');

type
  t_230 = signed 32;

procedure MessageBoxW(
    hWnd            : in t_HWND; 
    lpText          : in LPCWSTR; 
    lpCaption       : in LPCWSTR; 
    uType           : in UINT)
                      return t_230;
#pragma convention(MessageBoxW,system);
#pragma import(MessageBoxW,'MessageBoxW','user32.dll');

#if #declared UNICODE; then;
#template MessageBox;
  MessageBoxW 
#end MessageBox;
#else;
#template MessageBox;
  MessageBoxA 
#end MessageBox;
#end if;

type
  t_231 = signed 32;

procedure MessageBoxExA(
    hWnd            : in t_HWND; 
    lpText          : in LPCSTR; 
    lpCaption       : in LPCSTR; 
    uType           : in UINT; 
    wLanguageId     : in WORD)
                      return t_231;
#pragma convention(MessageBoxExA,system);
#pragma import(MessageBoxExA,'MessageBoxExA','user32.dll');

type
  t_232 = signed 32;

procedure MessageBoxExW(
    hWnd            : in t_HWND; 
    lpText          : in LPCWSTR; 
    lpCaption       : in LPCWSTR; 
    uType           : in UINT; 
    wLanguageId     : in WORD)
                      return t_232;
#pragma convention(MessageBoxExW,system);
#pragma import(MessageBoxExW,'MessageBoxExW','user32.dll');

#if #declared UNICODE; then;
#template MessageBoxEx;
  MessageBoxExW 
#end MessageBoxEx;
#else;
#template MessageBoxEx;
  MessageBoxExA 
#end MessageBoxEx;
#end if;

type
MSGBOXCALLBACK    = ^procedure (
    lpHelpInfo      : p_HELPINFO) for machine_pointer use true;
type
  tagMSGBOXPARAMSA  = record
cbSize          : UINT;
hwndOwner       : t_HWND;
hInstance       : t_HINSTANCE;
lpszText        : LPCSTR;
lpszCaption     : LPCSTR;
dwStyle         : DWORD;
lpszIcon        : LPCSTR;
dwContextHelpId : DWORD_PTR;
lpfnMsgBoxCallback : MSGBOXCALLBACK;
dwLanguageId    : DWORD;
  end record;
  MSGBOXPARAMSA     = tagMSGBOXPARAMSA;
  PMSGBOXPARAMSA    = ^tagMSGBOXPARAMSA;
  LPMSGBOXPARAMSA   = ^tagMSGBOXPARAMSA;

type
  tagMSGBOXPARAMSW  = record
cbSize          : UINT;
hwndOwner       : t_HWND;
hInstance       : t_HINSTANCE;
lpszText        : LPCWSTR;
lpszCaption     : LPCWSTR;
dwStyle         : DWORD;
lpszIcon        : LPCWSTR;
dwContextHelpId : DWORD_PTR;
lpfnMsgBoxCallback : MSGBOXCALLBACK;
dwLanguageId    : DWORD;
  end record;
  MSGBOXPARAMSW     = tagMSGBOXPARAMSW;
  PMSGBOXPARAMSW    = ^tagMSGBOXPARAMSW;
  LPMSGBOXPARAMSW   = ^tagMSGBOXPARAMSW;

#if #declared UNICODE; then;
type
MSGBOXPARAMS      = MSGBOXPARAMSW;
type
PMSGBOXPARAMS     = PMSGBOXPARAMSW;
type
LPMSGBOXPARAMS    = LPMSGBOXPARAMSW;
#else;
type
MSGBOXPARAMS      = MSGBOXPARAMSA;
type
PMSGBOXPARAMS     = PMSGBOXPARAMSA;
type
LPMSGBOXPARAMS    = LPMSGBOXPARAMSA;
#end if;

type
t_233=^MSGBOXPARAMSA for machine_pointer use true;

  t_234 = signed 32;

procedure MessageBoxIndirectA(
    _001            : in t_233)
                      return t_234;
#pragma convention(MessageBoxIndirectA,system);
#pragma import(MessageBoxIndirectA,'MessageBoxIndirectA','user32.dll');

type
t_235=^MSGBOXPARAMSW for machine_pointer use true;

  t_236 = signed 32;

procedure MessageBoxIndirectW(
    _001            : in t_235)
                      return t_236;
#pragma convention(MessageBoxIndirectW,system);
#pragma import(MessageBoxIndirectW,'MessageBoxIndirectW','user32.dll');

#if #declared UNICODE; then;
#template MessageBoxIndirect;
  MessageBoxIndirectW 
#end MessageBoxIndirect;
#else;
#template MessageBoxIndirect;
  MessageBoxIndirectA 
#end MessageBoxIndirect;
#end if;

procedure MessageBeep(
    uType           : in UINT)
                      return BOOL;
#pragma convention(MessageBeep,system);
#pragma import(MessageBeep,'MessageBeep','user32.dll');

type
  t_237 = signed 32;

procedure ShowCursor(
    bShow           : in BOOL)
                      return t_237;
#pragma convention(ShowCursor,system);
#pragma import(ShowCursor,'ShowCursor','user32.dll');

type
t_238=signed 32;

t_239=signed 32;

procedure SetCursorPos(
    X               : in t_238; 
    Y               : in t_239)
                      return BOOL;
#pragma convention(SetCursorPos,system);
#pragma import(SetCursorPos,'SetCursorPos','user32.dll');

procedure SetCursor(
    hCursor         : in t_HCURSOR)
                      return t_HCURSOR;
#pragma convention(SetCursor,system);
#pragma import(SetCursor,'SetCursor','user32.dll');

procedure GetCursorPos(
    lpPoint         : out tagPOINT)
                      return BOOL;
#pragma convention(GetCursorPos,system);
#pragma import(GetCursorPos,'GetCursorPos','user32.dll');

type
t_240=^RECT for machine_pointer use true;

procedure ClipCursor(
    lpRect          : in t_240)
                      return BOOL;
#pragma convention(ClipCursor,system);
#pragma import(ClipCursor,'ClipCursor','user32.dll');

procedure GetClipCursor(
    lpRect          : out tagRECT)
                      return BOOL;
#pragma convention(GetClipCursor,system);
#pragma import(GetClipCursor,'GetClipCursor','user32.dll');

procedure GetCursor
                      return t_HCURSOR;
#pragma convention(GetCursor,system);
#pragma import(GetCursor,'GetCursor','user32.dll');

type
t_241=signed 32;

t_242=signed 32;

procedure CreateCaret(
    hWnd            : in t_HWND; 
    hBitmap         : in t_HBITMAP; 
    nWidth          : in t_241; 
    nHeight         : in t_242)
                      return BOOL;
#pragma convention(CreateCaret,system);
#pragma import(CreateCaret,'CreateCaret','user32.dll');

procedure GetCaretBlinkTime
                      return UINT;
#pragma convention(GetCaretBlinkTime,system);
#pragma import(GetCaretBlinkTime,'GetCaretBlinkTime','user32.dll');

procedure SetCaretBlinkTime(
    uMSeconds       : in UINT)
                      return BOOL;
#pragma convention(SetCaretBlinkTime,system);
#pragma import(SetCaretBlinkTime,'SetCaretBlinkTime','user32.dll');

procedure DestroyCaret
                      return BOOL;
#pragma convention(DestroyCaret,system);
#pragma import(DestroyCaret,'DestroyCaret','user32.dll');

procedure HideCaret(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(HideCaret,system);
#pragma import(HideCaret,'HideCaret','user32.dll');

procedure ShowCaret(
    hWnd            : in t_HWND)
                      return BOOL;
#pragma convention(ShowCaret,system);
#pragma import(ShowCaret,'ShowCaret','user32.dll');

type
t_243=signed 32;

t_244=signed 32;

procedure SetCaretPos(
    X               : in t_243; 
    Y               : in t_244)
                      return BOOL;
#pragma convention(SetCaretPos,system);
#pragma import(SetCaretPos,'SetCaretPos','user32.dll');

procedure GetCaretPos(
    lpPoint         : out tagPOINT)
                      return BOOL;
#pragma convention(GetCaretPos,system);
#pragma import(GetCaretPos,'GetCaretPos','user32.dll');

procedure ClientToScreen(
    hWnd            : in t_HWND; 
    lpPoint         : in out tagPOINT)
                      return BOOL;
#pragma convention(ClientToScreen,system);
#pragma import(ClientToScreen,'ClientToScreen','user32.dll');

procedure ScreenToClient(
    hWnd            : in t_HWND; 
    lpPoint         : in out tagPOINT)
                      return BOOL;
#pragma convention(ScreenToClient,system);
#pragma import(ScreenToClient,'ScreenToClient','user32.dll');

type
  t_245 = signed 32;

procedure MapWindowPoints(
    hWndFrom        : in t_HWND; 
    hWndTo          : in t_HWND; 
    lpPoints        : in out tagPOINT; 
    cPoints         : in UINT)
                      return t_245;
#pragma convention(MapWindowPoints,system);
#pragma import(MapWindowPoints,'MapWindowPoints','user32.dll');

procedure WindowFromPoint(
    Point           : in t_POINT)
                      return t_HWND;
#pragma convention(WindowFromPoint,system);
#pragma import(WindowFromPoint,'WindowFromPoint','user32.dll');

procedure ChildWindowFromPoint(
    hWndParent      : in t_HWND; 
    Point           : in t_POINT)
                      return t_HWND;
#pragma convention(ChildWindowFromPoint,system);
#pragma import(ChildWindowFromPoint,'ChildWindowFromPoint','user32.dll');

const
  CWP_ALL           = $00;

const
  CWP_SKIPINVISIBLE = $01;

const
  CWP_SKIPDISABLED  = $02;

const
  CWP_SKIPTRANSPARENT= $04;

procedure ChildWindowFromPointEx(
    _001            : in t_HWND; 
    _002            : in t_POINT; 
    _003            : in UINT)
                      return t_HWND;
#pragma convention(ChildWindowFromPointEx,system);
#pragma import(ChildWindowFromPointEx,'ChildWindowFromPointEx','user32.dll');

-- /*
--  * Color Types
--  */
const
  CTLCOLOR_MSGBOX   = 0;

const
  CTLCOLOR_EDIT     = 1;

const
  CTLCOLOR_LISTBOX  = 2;

const
  CTLCOLOR_BTN      = 3;

const
  CTLCOLOR_DLG      = 4;

const
  CTLCOLOR_SCROLLBAR= 5;

const
  CTLCOLOR_STATIC   = 6;

const
  CTLCOLOR_MAX      = 7;

const
  COLOR_SCROLLBAR   = 0;

const
  COLOR_BACKGROUND  = 1;

const
  COLOR_ACTIVECAPTION= 2;

const
  COLOR_INACTIVECAPTION= 3;

const
  COLOR_MENU        = 4;

const
  COLOR_WINDOW      = 5;

const
  COLOR_WINDOWFRAME = 6;

const
  COLOR_MENUTEXT    = 7;

const
  COLOR_WINDOWTEXT  = 8;

const
  COLOR_CAPTIONTEXT = 9;

const
  COLOR_ACTIVEBORDER= 10;

const
  COLOR_INACTIVEBORDER= 11;

const
  COLOR_APPWORKSPACE= 12;

const
  COLOR_HIGHLIGHT   = 13;

const
  COLOR_HIGHLIGHTTEXT= 14;

const
  COLOR_BTNFACE     = 15;

const
  COLOR_BTNSHADOW   = 16;

const
  COLOR_GRAYTEXT    = 17;

const
  COLOR_BTNTEXT     = 18;

const
  COLOR_INACTIVECAPTIONTEXT= 19;

const
  COLOR_BTNHIGHLIGHT= 20;

const
  COLOR_3DDKSHADOW  = 21;

const
  COLOR_3DLIGHT     = 22;

const
  COLOR_INFOTEXT    = 23;

const
  COLOR_INFOBK      = 24;

const
  COLOR_HOTLIGHT    = 26;

const
  COLOR_GRADIENTACTIVECAPTION= 27;

const
  COLOR_GRADIENTINACTIVECAPTION= 28;

const
  COLOR_MENUHILIGHT = 29;

const
  COLOR_MENUBAR     = 30;

type
t_246=signed 32;

procedure GetSysColor(
    nIndex          : in t_246)
                      return DWORD;
#pragma convention(GetSysColor,system);
#pragma import(GetSysColor,'GetSysColor','user32.dll');

type
t_247=signed 32;

procedure GetSysColorBrush(
    nIndex          : in t_247)
                      return t_HBRUSH;
#pragma convention(GetSysColorBrush,system);
#pragma import(GetSysColorBrush,'GetSysColorBrush','user32.dll');

type
t_248=signed 32;

t_249=^INT for machine_pointer use true;

t_250=^COLORREF for machine_pointer use true;

procedure SetSysColors(
    cElements       : in t_248; 
    lpaElements     : in t_249; 
    lpaRgbValues    : in t_250)
                      return BOOL;
#pragma convention(SetSysColors,system);
#pragma import(SetSysColors,'SetSysColors','user32.dll');

type
t_251=^RECT for machine_pointer use true;

procedure DrawFocusRect(
    hDC             : in t_HDC; 
    lprc            : in t_251)
                      return BOOL;
#pragma convention(DrawFocusRect,system);
#pragma import(DrawFocusRect,'DrawFocusRect','user32.dll');

type
t_252=^RECT for machine_pointer use true;

  t_253 = signed 32;

procedure FillRect(
    hDC             : in t_HDC; 
    lprc            : in t_252; 
    hbr             : in t_HBRUSH)
                      return t_253;
#pragma convention(FillRect,system);
#pragma import(FillRect,'FillRect','user32.dll');

type
t_254=^RECT for machine_pointer use true;

  t_255 = signed 32;

procedure FrameRect(
    hDC             : in t_HDC; 
    lprc            : in t_254; 
    hbr             : in t_HBRUSH)
                      return t_255;
#pragma convention(FrameRect,system);
#pragma import(FrameRect,'FrameRect','user32.dll');

type
t_256=^RECT for machine_pointer use true;

procedure InvertRect(
    hDC             : in t_HDC; 
    lprc            : in t_256)
                      return BOOL;
#pragma convention(InvertRect,system);
#pragma import(InvertRect,'InvertRect','user32.dll');

type
t_257=signed 32;

t_258=signed 32;

t_259=signed 32;

t_260=signed 32;

procedure SetRect(
    lprc            : out tagRECT; 
    xLeft           : in t_257; 
    yTop            : in t_258; 
    xRight          : in t_259; 
    yBottom         : in t_260)
                      return BOOL;
#pragma convention(SetRect,system);
#pragma import(SetRect,'SetRect','user32.dll');

procedure SetRectEmpty(
    lprc            : out tagRECT)
                      return BOOL;
#pragma convention(SetRectEmpty,system);
#pragma import(SetRectEmpty,'SetRectEmpty','user32.dll');

type
t_261=^RECT for machine_pointer use true;

procedure CopyRect(
    lprcDst         : out tagRECT; 
    lprcSrc         : in t_261)
                      return BOOL;
#pragma convention(CopyRect,system);
#pragma import(CopyRect,'CopyRect','user32.dll');

type
t_262=signed 32;

t_263=signed 32;

procedure InflateRect(
    lprc            : in out tagRECT; 
    dx              : in t_262; 
    dy              : in t_263)
                      return BOOL;
#pragma convention(InflateRect,system);
#pragma import(InflateRect,'InflateRect','user32.dll');

type
t_264=^RECT for machine_pointer use true;

t_265=^RECT for machine_pointer use true;

procedure IntersectRect(
    lprcDst         : out tagRECT; 
    lprcSrc1        : in t_264; 
    lprcSrc2        : in t_265)
                      return BOOL;
#pragma convention(IntersectRect,system);
#pragma import(IntersectRect,'IntersectRect','user32.dll');

type
t_266=^RECT for machine_pointer use true;

t_267=^RECT for machine_pointer use true;

procedure UnionRect(
    lprcDst         : out tagRECT; 
    lprcSrc1        : in t_266; 
    lprcSrc2        : in t_267)
                      return BOOL;
#pragma convention(UnionRect,system);
#pragma import(UnionRect,'UnionRect','user32.dll');

type
t_268=^RECT for machine_pointer use true;

t_269=^RECT for machine_pointer use true;

procedure SubtractRect(
    lprcDst         : out tagRECT; 
    lprcSrc1        : in t_268; 
    lprcSrc2        : in t_269)
                      return BOOL;
#pragma convention(SubtractRect,system);
#pragma import(SubtractRect,'SubtractRect','user32.dll');

type
t_270=signed 32;

t_271=signed 32;

procedure OffsetRect(
    lprc            : in out tagRECT; 
    dx              : in t_270; 
    dy              : in t_271)
                      return BOOL;
#pragma convention(OffsetRect,system);
#pragma import(OffsetRect,'OffsetRect','user32.dll');

type
t_272=^RECT for machine_pointer use true;

procedure IsRectEmpty(
    lprc            : in t_272)
                      return BOOL;
#pragma convention(IsRectEmpty,system);
#pragma import(IsRectEmpty,'IsRectEmpty','user32.dll');

type
t_273=^RECT for machine_pointer use true;

t_274=^RECT for machine_pointer use true;

procedure EqualRect(
    lprc1           : in t_273; 
    lprc2           : in t_274)
                      return BOOL;
#pragma convention(EqualRect,system);
#pragma import(EqualRect,'EqualRect','user32.dll');

type
t_275=^RECT for machine_pointer use true;

procedure PtInRect(
    lprc            : in t_275; 
    pt              : in t_POINT)
                      return BOOL;
#pragma convention(PtInRect,system);
#pragma import(PtInRect,'PtInRect','user32.dll');

type
t_276=signed 32;

procedure GetWindowWord(
    hWnd            : in t_HWND; 
    nIndex          : in t_276)
                      return WORD;
#pragma convention(GetWindowWord,system);
#pragma import(GetWindowWord,'GetWindowWord','user32.dll');

type
t_277=signed 32;

procedure SetWindowWord(
    hWnd            : in t_HWND; 
    nIndex          : in t_277; 
    wNewWord        : in WORD)
                      return WORD;
#pragma convention(SetWindowWord,system);
#pragma import(SetWindowWord,'SetWindowWord','user32.dll');

type
t_278=signed 32;

procedure GetWindowLongA(
    hWnd            : in t_HWND; 
    nIndex          : in t_278)
                      return LONG;
#pragma convention(GetWindowLongA,system);
#pragma import(GetWindowLongA,'GetWindowLongA','user32.dll');

type
t_279=signed 32;

procedure GetWindowLongW(
    hWnd            : in t_HWND; 
    nIndex          : in t_279)
                      return LONG;
#pragma convention(GetWindowLongW,system);
#pragma import(GetWindowLongW,'GetWindowLongW','user32.dll');

#if #declared UNICODE; then;
#template GetWindowLong;
  GetWindowLongW 
#end GetWindowLong;
#else;
#template GetWindowLong;
  GetWindowLongA 
#end GetWindowLong;
#end if;

type
t_280=signed 32;

procedure SetWindowLongA(
    hWnd            : in t_HWND; 
    nIndex          : in t_280; 
    dwNewLong       : in LONG)
                      return LONG;
#pragma convention(SetWindowLongA,system);
#pragma import(SetWindowLongA,'SetWindowLongA','user32.dll');

type
t_281=signed 32;

procedure SetWindowLongW(
    hWnd            : in t_HWND; 
    nIndex          : in t_281; 
    dwNewLong       : in LONG)
                      return LONG;
#pragma convention(SetWindowLongW,system);
#pragma import(SetWindowLongW,'SetWindowLongW','user32.dll');

#if #declared UNICODE; then;
#template SetWindowLong;
  SetWindowLongW 
#end SetWindowLong;
#else;
#template SetWindowLong;
  SetWindowLongA 
#end SetWindowLong;
#end if;

#if #declared UNICODE; then;
#template GetWindowLongPtr;
  GetWindowLongW 
#end GetWindowLongPtr;
#else;
#template GetWindowLongPtr;
  GetWindowLongA 
#end GetWindowLongPtr;
#end if;

#if #declared UNICODE; then;
#template SetWindowLongPtr;
  SetWindowLongW 
#end SetWindowLongPtr;
#else;
#template SetWindowLongPtr;
  SetWindowLongA 
#end SetWindowLongPtr;
#end if;

type
t_282=signed 32;

procedure GetClassWord(
    hWnd            : in t_HWND; 
    nIndex          : in t_282)
                      return WORD;
#pragma convention(GetClassWord,system);
#pragma import(GetClassWord,'GetClassWord','user32.dll');

type
t_283=signed 32;

procedure SetClassWord(
    hWnd            : in t_HWND; 
    nIndex          : in t_283; 
    wNewWord        : in WORD)
                      return WORD;
#pragma convention(SetClassWord,system);
#pragma import(SetClassWord,'SetClassWord','user32.dll');

type
t_284=signed 32;

procedure GetClassLongA(
    hWnd            : in t_HWND; 
    nIndex          : in t_284)
                      return DWORD;
#pragma convention(GetClassLongA,system);
#pragma import(GetClassLongA,'GetClassLongA','user32.dll');

type
t_285=signed 32;

procedure GetClassLongW(
    hWnd            : in t_HWND; 
    nIndex          : in t_285)
                      return DWORD;
#pragma convention(GetClassLongW,system);
#pragma import(GetClassLongW,'GetClassLongW','user32.dll');

#if #declared UNICODE; then;
#template GetClassLong;
  GetClassLongW 
#end GetClassLong;
#else;
#template GetClassLong;
  GetClassLongA 
#end GetClassLong;
#end if;

type
t_286=signed 32;

procedure SetClassLongA(
    hWnd            : in t_HWND; 
    nIndex          : in t_286; 
    dwNewLong       : in LONG)
                      return DWORD;
#pragma convention(SetClassLongA,system);
#pragma import(SetClassLongA,'SetClassLongA','user32.dll');

type
t_287=signed 32;

procedure SetClassLongW(
    hWnd            : in t_HWND; 
    nIndex          : in t_287; 
    dwNewLong       : in LONG)
                      return DWORD;
#pragma convention(SetClassLongW,system);
#pragma import(SetClassLongW,'SetClassLongW','user32.dll');

#if #declared UNICODE; then;
#template SetClassLong;
  SetClassLongW 
#end SetClassLong;
#else;
#template SetClassLong;
  SetClassLongA 
#end SetClassLong;
#end if;

#if #declared UNICODE; then;
#template GetClassLongPtr;
  GetClassLongW 
#end GetClassLongPtr;
#else;
#template GetClassLongPtr;
  GetClassLongA 
#end GetClassLongPtr;
#end if;

#if #declared UNICODE; then;
#template SetClassLongPtr;
  SetClassLongW 
#end SetClassLongPtr;
#else;
#template SetClassLongPtr;
  SetClassLongA 
#end SetClassLongPtr;
#end if;

procedure GetProcessDefaultLayout(
    pdwDefaultLayout : out DWORD)
                      return BOOL;
#pragma convention(GetProcessDefaultLayout,system);
#pragma import(GetProcessDefaultLayout,'GetProcessDefaultLayout','user32.dll');

procedure SetProcessDefaultLayout(
    dwDefaultLayout : in DWORD)
                      return BOOL;
#pragma convention(SetProcessDefaultLayout,system);
#pragma import(SetProcessDefaultLayout,'SetProcessDefaultLayout','user32.dll');

procedure GetDesktopWindow
                      return t_HWND;
#pragma convention(GetDesktopWindow,system);
#pragma import(GetDesktopWindow,'GetDesktopWindow','user32.dll');

procedure GetParent(
    hWnd            : in t_HWND)
                      return t_HWND;
#pragma convention(GetParent,system);
#pragma import(GetParent,'GetParent','user32.dll');

procedure SetParent(
    hWndChild       : in t_HWND; 
    hWndNewParent   : in t_HWND)
                      return t_HWND;
#pragma convention(SetParent,system);
#pragma import(SetParent,'SetParent','user32.dll');

procedure EnumChildWindows(
    hWndParent      : in t_HWND; 
    lpEnumFunc      : in WNDENUMPROC; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumChildWindows,system);
#pragma import(EnumChildWindows,'EnumChildWindows','user32.dll');

procedure FindWindowA(
    lpClassName     : in LPCSTR; 
    lpWindowName    : in LPCSTR)
                      return t_HWND;
#pragma convention(FindWindowA,system);
#pragma import(FindWindowA,'FindWindowA','user32.dll');

procedure FindWindowW(
    lpClassName     : in LPCWSTR; 
    lpWindowName    : in LPCWSTR)
                      return t_HWND;
#pragma convention(FindWindowW,system);
#pragma import(FindWindowW,'FindWindowW','user32.dll');

#if #declared UNICODE; then;
#template FindWindow;
  FindWindowW 
#end FindWindow;
#else;
#template FindWindow;
  FindWindowA 
#end FindWindow;
#end if;

procedure FindWindowExA(
    _001            : in t_HWND; 
    _002            : in t_HWND; 
    _003            : in LPCSTR; 
    _004            : in LPCSTR)
                      return t_HWND;
#pragma convention(FindWindowExA,system);
#pragma import(FindWindowExA,'FindWindowExA','user32.dll');

procedure FindWindowExW(
    _001            : in t_HWND; 
    _002            : in t_HWND; 
    _003            : in LPCWSTR; 
    _004            : in LPCWSTR)
                      return t_HWND;
#pragma convention(FindWindowExW,system);
#pragma import(FindWindowExW,'FindWindowExW','user32.dll');

#if #declared UNICODE; then;
#template FindWindowEx;
  FindWindowExW 
#end FindWindowEx;
#else;
#template FindWindowEx;
  FindWindowExA 
#end FindWindowEx;
#end if;

procedure GetShellWindow
                      return t_HWND;
#pragma convention(GetShellWindow,system);
#pragma import(GetShellWindow,'GetShellWindow','user32.dll');

procedure RegisterShellHookWindow(
    _001            : in t_HWND)
                      return BOOL;
#pragma convention(RegisterShellHookWindow,system);
#pragma import(RegisterShellHookWindow,'RegisterShellHookWindow','user32.dll');

procedure DeregisterShellHookWindow(
    _001            : in t_HWND)
                      return BOOL;
#pragma convention(DeregisterShellHookWindow,system);
#pragma import(DeregisterShellHookWindow,'DeregisterShellHookWindow','user32.dll');

procedure EnumWindows(
    lpEnumFunc      : in WNDENUMPROC; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumWindows,system);
#pragma import(EnumWindows,'EnumWindows','user32.dll');

procedure EnumThreadWindows(
    dwThreadId      : in DWORD; 
    lpfn            : in WNDENUMPROC; 
    lParam          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumThreadWindows,system);
#pragma import(EnumThreadWindows,'EnumThreadWindows','user32.dll');

type
t_288=signed 32;

  t_289 = signed 32;

procedure GetClassNameA(
    hWnd            : in t_HWND; 
    lpClassName     : out CHARSTR ; 
    nMaxCount       : in t_288)
                      return t_289;
#pragma convention(GetClassNameA,system);
#pragma import(GetClassNameA,'GetClassNameA','user32.dll');

type
t_290=signed 32;

  t_291 = signed 32;

procedure GetClassNameW(
    hWnd            : in t_HWND; 
    lpClassName     : out WCHARSTR ; 
    nMaxCount       : in t_290)
                      return t_291;
#pragma convention(GetClassNameW,system);
#pragma import(GetClassNameW,'GetClassNameW','user32.dll');

#if #declared UNICODE; then;
#template GetClassName;
  GetClassNameW 
#end GetClassName;
#else;
#template GetClassName;
  GetClassNameA 
#end GetClassName;
#end if;

procedure GetTopWindow(
    hWnd            : in t_HWND)
                      return t_HWND;
#pragma convention(GetTopWindow,system);
#pragma import(GetTopWindow,'GetTopWindow','user32.dll');

procedure GetWindowThreadProcessId(
    hWnd            : in t_HWND; 
    lpdwProcessId   : out DWORD )
                      return DWORD;
#pragma convention(GetWindowThreadProcessId,system);
#pragma import(GetWindowThreadProcessId,'GetWindowThreadProcessId','user32.dll');

procedure IsGUIThread(
    bConvert        : BOOL)
                      return BOOL;
#pragma convention(IsGUIThread,system);
#pragma import(IsGUIThread,'IsGUIThread','user32.dll');

procedure GetLastActivePopup(
    hWnd            : in t_HWND)
                      return t_HWND;
#pragma convention(GetLastActivePopup,system);
#pragma import(GetLastActivePopup,'GetLastActivePopup','user32.dll');

-- /*
--  * GetWindow() Constants
--  */
const
  GW_HWNDFIRST      = 0;

const
  GW_HWNDLAST       = 1;

const
  GW_HWNDNEXT       = 2;

const
  GW_HWNDPREV       = 3;

const
  GW_OWNER          = 4;

const
  GW_CHILD          = 5;

const
  GW_ENABLEDPOPUP   = 6;

const
  GW_MAX            = 6;

procedure GetWindow(
    hWnd            : in t_HWND; 
    uCmd            : in UINT)
                      return t_HWND;
#pragma convention(GetWindow,system);
#pragma import(GetWindow,'GetWindow','user32.dll');

type
t_292=signed 32;

procedure SetWindowsHookA(
    nFilterType     : in t_292; 
    pfnFilterProc   : in HOOKPROC)
                      return HOOKPROC;
#pragma convention(SetWindowsHookA,system);
#pragma import(SetWindowsHookA,'SetWindowsHookA','user32.dll');

type
t_293=signed 32;

procedure SetWindowsHookW(
    nFilterType     : in t_293; 
    pfnFilterProc   : in HOOKPROC)
                      return HOOKPROC;
#pragma convention(SetWindowsHookW,system);
#pragma import(SetWindowsHookW,'SetWindowsHookW','user32.dll');

#if #declared UNICODE; then;
#template SetWindowsHook;
  SetWindowsHookW 
#end SetWindowsHook;
#else;
#template SetWindowsHook;
  SetWindowsHookA 
#end SetWindowsHook;
#end if;

type
t_294=signed 32;

procedure UnhookWindowsHook(
    nCode           : in t_294; 
    pfnFilterProc   : in HOOKPROC)
                      return BOOL;
#pragma convention(UnhookWindowsHook,system);
#pragma import(UnhookWindowsHook,'UnhookWindowsHook','user32.dll');

type
t_295=signed 32;

procedure SetWindowsHookExA(
    idHook          : in t_295; 
    lpfn            : in HOOKPROC; 
    hmod            : in t_HINSTANCE; 
    dwThreadId      : in DWORD)
                      return HHOOK;
#pragma convention(SetWindowsHookExA,system);
#pragma import(SetWindowsHookExA,'SetWindowsHookExA','user32.dll');

type
t_296=signed 32;

procedure SetWindowsHookExW(
    idHook          : in t_296; 
    lpfn            : in HOOKPROC; 
    hmod            : in t_HINSTANCE; 
    dwThreadId      : in DWORD)
                      return HHOOK;
#pragma convention(SetWindowsHookExW,system);
#pragma import(SetWindowsHookExW,'SetWindowsHookExW','user32.dll');

#if #declared UNICODE; then;
#template SetWindowsHookEx;
  SetWindowsHookExW 
#end SetWindowsHookEx;
#else;
#template SetWindowsHookEx;
  SetWindowsHookExA 
#end SetWindowsHookEx;
#end if;

procedure UnhookWindowsHookEx(
    hhk             : in HHOOK)
                      return BOOL;
#pragma convention(UnhookWindowsHookEx,system);
#pragma import(UnhookWindowsHookEx,'UnhookWindowsHookEx','user32.dll');

type
t_297=signed 32;

procedure CallNextHookEx(
    hhk             : in HHOOK; 
    nCode           : in t_297; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(CallNextHookEx,system);
#pragma import(CallNextHookEx,'CallNextHookEx','user32.dll');

-- /*
--  * Macros for source-level compatibility with old functions.
--  */
-- /* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags 
-- /*
--  * Menu flags for Add/Check/EnableMenuItem()
--  */
const
  MF_INSERT         = $00;

const
  MF_CHANGE         = $80;

const
  MF_APPEND         = $0100;

const
  MF_DELETE         = $0200;

const
  MF_REMOVE         = $1000;

const
  MF_BYCOMMAND      = $00;

const
  MF_BYPOSITION     = $0400;

const
  MF_SEPARATOR      = $0800;

const
  MF_ENABLED        = $00;

const
  MF_GRAYED         = $01;

const
  MF_DISABLED       = $02;

const
  MF_UNCHECKED      = $00;

const
  MF_CHECKED        = $08;

const
  MF_USECHECKBITMAPS= $0200;

const
  MF_STRING         = $00;

const
  MF_BITMAP         = $04;

const
  MF_OWNERDRAW      = $0100;

const
  MF_POPUP          = $10;

const
  MF_MENUBARBREAK   = $20;

const
  MF_MENUBREAK      = $40;

const
  MF_UNHILITE       = $00;

const
  MF_HILITE         = $80;

const
  MF_DEFAULT        = $1000;

const
  MF_SYSMENU        = $2000;

const
  MF_HELP           = $4000;

const
  MF_RIGHTJUSTIFY   = $4000;

const
  MF_MOUSESELECT    = $8000;

const
  MF_END            = $80;

const
  MFT_RADIOCHECK    = $0200;

const
  MFT_RIGHTORDER    = $2000;

-- /* Menu flags for Add/Check/EnableMenuItem() 
const
  MFS_GRAYED        = $03;

procedure CheckMenuRadioItem(
    _001            : in t_HMENU; 
    _002            : in UINT; 
    _003            : in UINT; 
    _004            : in UINT; 
    _005            : in UINT)
                      return BOOL;
#pragma convention(CheckMenuRadioItem,system);
#pragma import(CheckMenuRadioItem,'CheckMenuRadioItem','user32.dll');

-- /*
--  * Menu item resource format
--  */
type
  MENUITEMTEMPLATEHEADER = record
versionNumber   : WORD;
offset          : WORD;
  end record;
  PMENUITEMTEMPLATEHEADER = ^MENUITEMTEMPLATEHEADER;

type
  MENUITEMTEMPLATE  = record
mtOption        : WORD;
mtID            : WORD;
mtString        : array 0..0 of WCHAR;
  end record;
  PMENUITEMTEMPLATE = ^MENUITEMTEMPLATE;

-- /*
--  * System Menu Command Values
--  */
const
  SC_SIZE           = $F000;

const
  SC_MOVE           = $F010;

const
  SC_MINIMIZE       = $F020;

const
  SC_MAXIMIZE       = $F030;

const
  SC_NEXTWINDOW     = $F040;

const
  SC_PREVWINDOW     = $F050;

const
  SC_CLOSE          = $F060;

const
  SC_VSCROLL        = $F070;

const
  SC_HSCROLL        = $F080;

const
  SC_MOUSEMENU      = $F090;

const
  SC_KEYMENU        = $F100;

const
  SC_ARRANGE        = $F110;

const
  SC_RESTORE        = $F120;

const
  SC_TASKLIST       = $F130;

const
  SC_SCREENSAVE     = $F140;

const
  SC_HOTKEY         = $F150;

const
  SC_DEFAULT        = $F160;

const
  SC_MONITORPOWER   = $F170;

const
  SC_CONTEXTHELP    = $F180;

const
  SC_SEPARATOR      = $F00F;

-- /*
--  * Obsolete names
--  */
-- /*
--  * Resource Loading Routines
--  */
procedure LoadBitmapA(
    hInstance       : in t_HINSTANCE; 
    lpBitmapName    : in LPCSTR)
                      return t_HBITMAP;
#pragma convention(LoadBitmapA,system);
#pragma import(LoadBitmapA,'LoadBitmapA','user32.dll');

procedure LoadBitmapW(
    hInstance       : in t_HINSTANCE; 
    lpBitmapName    : in LPCWSTR)
                      return t_HBITMAP;
#pragma convention(LoadBitmapW,system);
#pragma import(LoadBitmapW,'LoadBitmapW','user32.dll');

#if #declared UNICODE; then;
#template LoadBitmap;
  LoadBitmapW 
#end LoadBitmap;
#else;
#template LoadBitmap;
  LoadBitmapA 
#end LoadBitmap;
#end if;

procedure LoadCursorA(
    hInstance       : in t_HINSTANCE; 
    lpCursorName    : in LPCSTR)
                      return t_HCURSOR;
#pragma convention(LoadCursorA,system);
#pragma import(LoadCursorA,'LoadCursorA','user32.dll');

procedure LoadCursorW(
    hInstance       : in t_HINSTANCE; 
    lpCursorName    : in LPCWSTR)
                      return t_HCURSOR;
#pragma convention(LoadCursorW,system);
#pragma import(LoadCursorW,'LoadCursorW','user32.dll');

#if #declared UNICODE; then;
#template LoadCursor;
  LoadCursorW 
#end LoadCursor;
#else;
#template LoadCursor;
  LoadCursorA 
#end LoadCursor;
#end if;

procedure LoadCursorFromFileA(
    lpFileName      : in LPCSTR)
                      return t_HCURSOR;
#pragma convention(LoadCursorFromFileA,system);
#pragma import(LoadCursorFromFileA,'LoadCursorFromFileA','user32.dll');

procedure LoadCursorFromFileW(
    lpFileName      : in LPCWSTR)
                      return t_HCURSOR;
#pragma convention(LoadCursorFromFileW,system);
#pragma import(LoadCursorFromFileW,'LoadCursorFromFileW','user32.dll');

#if #declared UNICODE; then;
#template LoadCursorFromFile;
  LoadCursorFromFileW 
#end LoadCursorFromFile;
#else;
#template LoadCursorFromFile;
  LoadCursorFromFileA 
#end LoadCursorFromFile;
#end if;

type
t_298=signed 32;

t_299=signed 32;

t_300=signed 32;

t_301=signed 32;

t_302=^unchecked for machine_pointer use true;

t_303=^unchecked for machine_pointer use true;

procedure CreateCursor(
    hInst           : in t_HINSTANCE; 
    xHotSpot        : in t_298; 
    yHotSpot        : in t_299; 
    nWidth          : in t_300; 
    nHeight         : in t_301; 
    pvANDPlane      : in t_302; 
    pvXORPlane      : in t_303)
                      return t_HCURSOR;
#pragma convention(CreateCursor,system);
#pragma import(CreateCursor,'CreateCursor','user32.dll');

procedure DestroyCursor(
    hCursor         : in t_HCURSOR)
                      return BOOL;
#pragma convention(DestroyCursor,system);
#pragma import(DestroyCursor,'DestroyCursor','user32.dll');

-- /*
--  * Standard Cursor IDs
--  */
procedure SetSystemCursor(
    hcur            : in t_HCURSOR; 
    id              : in DWORD)
                      return BOOL;
#pragma convention(SetSystemCursor,system);
#pragma import(SetSystemCursor,'SetSystemCursor','user32.dll');

type
  _ICONINFO         = record
fIcon           : BOOL;
xHotspot        : DWORD;
yHotspot        : DWORD;
hbmMask         : t_HBITMAP;
hbmColor        : t_HBITMAP;
  end record;
  ICONINFO          = _ICONINFO;

type
p_ICONINFO        = ^ICONINFO for machine_pointer use true;
procedure LoadIconA(
    hInstance       : in t_HINSTANCE; 
    lpIconName      : in LPCSTR)
                      return t_HICON;
#pragma convention(LoadIconA,system);
#pragma import(LoadIconA,'LoadIconA','user32.dll');

procedure LoadIconW(
    hInstance       : in t_HINSTANCE; 
    lpIconName      : in LPCWSTR)
                      return t_HICON;
#pragma convention(LoadIconW,system);
#pragma import(LoadIconW,'LoadIconW','user32.dll');

#if #declared UNICODE; then;
#template LoadIcon;
  LoadIconW 
#end LoadIcon;
#else;
#template LoadIcon;
  LoadIconA 
#end LoadIcon;
#end if;

type
t_304=signed 32;

t_305=signed 32;

t_306=signed 32;

procedure PrivateExtractIconsA(
    szFileName      : in LPCSTR; 
    nIconIndex      : in t_304; 
    cxIcon          : in t_305; 
    cyIcon          : in t_306; 
    phicon          : out t_HICON; 
    piconid         : out UINT; 
    nIcons          : in UINT; 
    flags           : in UINT)
                      return UINT;
#pragma import(PrivateExtractIconsA,'PrivateExtractIconsA','user32.dll');

type
t_307=signed 32;

t_308=signed 32;

t_309=signed 32;

procedure PrivateExtractIconsW(
    szFileName      : in LPCWSTR; 
    nIconIndex      : in t_307; 
    cxIcon          : in t_308; 
    cyIcon          : in t_309; 
    phicon          : out t_HICON; 
    piconid         : out UINT; 
    nIcons          : in UINT; 
    flags           : in UINT)
                      return UINT;
#pragma import(PrivateExtractIconsW,'PrivateExtractIconsW','user32.dll');

#if #declared UNICODE; then;
#template PrivateExtractIcons;
  PrivateExtractIconsW 
#end PrivateExtractIcons;
#else;
#template PrivateExtractIcons;
  PrivateExtractIconsA 
#end PrivateExtractIcons;
#end if;

type
t_310=signed 32;

t_311=signed 32;

t_312=^BYTE for machine_pointer use true;

t_313=^BYTE for machine_pointer use true;

procedure CreateIcon(
    hInstance       : in t_HINSTANCE; 
    nWidth          : in t_310; 
    nHeight         : in t_311; 
    cPlanes         : in BYTE; 
    cBitsPixel      : in BYTE; 
    lpbANDbits      : in t_312; 
    lpbXORbits      : in t_313)
                      return t_HICON;
#pragma convention(CreateIcon,system);
#pragma import(CreateIcon,'CreateIcon','user32.dll');

procedure DestroyIcon(
    hIcon           : in t_HICON)
                      return BOOL;
#pragma convention(DestroyIcon,system);
#pragma import(DestroyIcon,'DestroyIcon','user32.dll');

type
  t_314 = signed 32;

procedure LookupIconIdFromDirectory(
    presbits        : in PBYTE; 
    fIcon           : in BOOL)
                      return t_314;
#pragma convention(LookupIconIdFromDirectory,system);
#pragma import(LookupIconIdFromDirectory,'LookupIconIdFromDirectory','user32.dll');

type
t_315=signed 32;

t_316=signed 32;

  t_317 = signed 32;

procedure LookupIconIdFromDirectoryEx(
    presbits        : in PBYTE; 
    fIcon           : in BOOL; 
    cxDesired       : in t_315; 
    cyDesired       : in t_316; 
    Flags           : in UINT)
                      return t_317;
#pragma convention(LookupIconIdFromDirectoryEx,system);
#pragma import(LookupIconIdFromDirectoryEx,'LookupIconIdFromDirectoryEx','user32.dll');

procedure CreateIconFromResource(
    presbits        : in PBYTE; 
    dwResSize       : in DWORD; 
    fIcon           : in BOOL; 
    dwVer           : in DWORD)
                      return t_HICON;
#pragma convention(CreateIconFromResource,system);
#pragma import(CreateIconFromResource,'CreateIconFromResource','user32.dll');

type
t_318=signed 32;

t_319=signed 32;

procedure CreateIconFromResourceEx(
    presbits        : in PBYTE; 
    dwResSize       : in DWORD; 
    fIcon           : in BOOL; 
    dwVer           : in DWORD; 
    cxDesired       : in t_318; 
    cyDesired       : in t_319; 
    Flags           : in UINT)
                      return t_HICON;
#pragma convention(CreateIconFromResourceEx,system);
#pragma import(CreateIconFromResourceEx,'CreateIconFromResourceEx','user32.dll');

-- /* Icon/Cursor header 
type
  tagCURSORSHAPE    = record
xHotSpot        : signed 32;
yHotSpot        : signed 32;
cx              : signed 32;
cy              : signed 32;
cbWidth         : signed 32;
Planes          : BYTE;
BitsPixel       : BYTE;
  end record;
  CURSORSHAPE       = tagCURSORSHAPE;
  LPCURSORSHAPE     = ^tagCURSORSHAPE;

const
  IMAGE_BITMAP      = 0;

const
  IMAGE_ICON        = 1;

const
  IMAGE_CURSOR      = 2;

const
  IMAGE_ENHMETAFILE = 3;

const
  LR_DEFAULTCOLOR   = $00;

const
  LR_MONOCHROME     = $01;

const
  LR_COLOR          = $02;

const
  LR_COPYRETURNORG  = $04;

const
  LR_COPYDELETEORG  = $08;

const
  LR_LOADFROMFILE   = $10;

const
  LR_LOADTRANSPARENT= $20;

const
  LR_DEFAULTSIZE    = $40;

const
  LR_VGACOLOR       = $80;

const
  LR_LOADMAP3DCOLORS= $1000;

const
  LR_CREATEDIBSECTION= $2000;

const
  LR_COPYFROMRESOURCE= $4000;

const
  LR_SHARED         = $8000;

type
t_320=signed 32;

t_321=signed 32;

procedure LoadImageA(
    _001            : in t_HINSTANCE; 
    _002            : in LPCSTR; 
    _003            : in UINT; 
    _004            : in t_320; 
    _005            : in t_321; 
    _006            : in UINT)
                      return t_HANDLE;
#pragma convention(LoadImageA,system);
#pragma import(LoadImageA,'LoadImageA','user32.dll');

type
t_322=signed 32;

t_323=signed 32;

procedure LoadImageW(
    _001            : in t_HINSTANCE; 
    _002            : in LPCWSTR; 
    _003            : in UINT; 
    _004            : in t_322; 
    _005            : in t_323; 
    _006            : in UINT)
                      return t_HANDLE;
#pragma convention(LoadImageW,system);
#pragma import(LoadImageW,'LoadImageW','user32.dll');

#if #declared UNICODE; then;
#template LoadImage;
  LoadImageW 
#end LoadImage;
#else;
#template LoadImage;
  LoadImageA 
#end LoadImage;
#end if;

type
t_324=signed 32;

t_325=signed 32;

procedure CopyImage(
    _001            : in t_HANDLE; 
    _002            : in UINT; 
    _003            : in t_324; 
    _004            : in t_325; 
    _005            : in UINT)
                      return t_HANDLE;
#pragma convention(CopyImage,system);
#pragma import(CopyImage,'CopyImage','user32.dll');

const
  DI_MASK           = $01;

const
  DI_IMAGE          = $02;

const
  DI_NORMAL         = $03;

const
  DI_COMPAT         = $04;

const
  DI_DEFAULTSIZE    = $08;

const
  DI_NOMIRROR       = $10;

type
t_326=signed 32;

t_327=signed 32;

t_328=signed 32;

t_329=signed 32;

procedure DrawIconEx(
    hdc             : in t_HDC; 
    xLeft           : in t_326; 
    yTop            : in t_327; 
    hIcon           : in t_HICON; 
    cxWidth         : in t_328; 
    cyWidth         : in t_329; 
    istepIfAniCur   : in UINT; 
    hbrFlickerFreeDraw : in t_HBRUSH; 
    diFlags         : in UINT)
                      return BOOL;
#pragma convention(DrawIconEx,system);
#pragma import(DrawIconEx,'DrawIconEx','user32.dll');

procedure CreateIconIndirect(
    piconinfo       : in p_ICONINFO)
                      return t_HICON;
#pragma convention(CreateIconIndirect,system);
#pragma import(CreateIconIndirect,'CreateIconIndirect','user32.dll');

procedure CopyIcon(
    hIcon           : in t_HICON)
                      return t_HICON;
#pragma convention(CopyIcon,system);
#pragma import(CopyIcon,'CopyIcon','user32.dll');

procedure GetIconInfo(
    hIcon           : in t_HICON; 
    piconinfo       : out ICONINFO )
                      return BOOL;
#pragma convention(GetIconInfo,system);
#pragma import(GetIconInfo,'GetIconInfo','user32.dll');

const
  RES_ICON          = 1;

const
  RES_CURSOR        = 2;

const
  ORD_LANGDRIVER    = 1;

-- /*
--  * Standard Icon IDs
--  */
type
t_330=signed 32;

  t_331 = signed 32;

procedure LoadStringA(
    hInstance       : in t_HINSTANCE; 
    uID             : in UINT; 
    lpBuffer        : out CHARSTR ; 
    nBufferMax      : in t_330)
                      return t_331;
#pragma convention(LoadStringA,system);
#pragma import(LoadStringA,'LoadStringA','user32.dll');

type
t_332=signed 32;

  t_333 = signed 32;

procedure LoadStringW(
    hInstance       : in t_HINSTANCE; 
    uID             : in UINT; 
    lpBuffer        : out WCHARSTR ; 
    nBufferMax      : in t_332)
                      return t_333;
#pragma convention(LoadStringW,system);
#pragma import(LoadStringW,'LoadStringW','user32.dll');

#if #declared UNICODE; then;
#template LoadString;
  LoadStringW 
#end LoadString;
#else;
#template LoadString;
  LoadStringA 
#end LoadString;
#end if;

-- /*
--  * Dialog Box Command IDs
--  */
const
  IDOK              = 1;

const
  IDCANCEL          = 2;

const
  IDABORT           = 3;

const
  IDRETRY           = 4;

const
  IDIGNORE          = 5;

const
  IDYES             = 6;

const
  IDNO              = 7;

const
  IDCLOSE           = 8;

const
  IDHELP            = 9;

const
  IDTRYAGAIN        = 10;

const
  IDCONTINUE        = 11;

const
  IDTIMEOUT         = 32000;

-- /*
--  * Control Manager Structures and Definitions
--  */
-- /*
--  * Edit Control Styles
--  */
const
  ES_LEFT           = $00;

const
  ES_CENTER         = $01;

const
  ES_RIGHT          = $02;

const
  ES_MULTILINE      = $04;

const
  ES_UPPERCASE      = $08;

const
  ES_LOWERCASE      = $10;

const
  ES_PASSWORD       = $20;

const
  ES_AUTOVSCROLL    = $40;

const
  ES_AUTOHSCROLL    = $80;

const
  ES_NOHIDESEL      = $0100;

const
  ES_OEMCONVERT     = $0400;

const
  ES_READONLY       = $0800;

const
  ES_WANTRETURN     = $1000;

const
  ES_NUMBER         = $2000;

-- /*
--  * Edit Control Notification Codes
--  */
const
  EN_SETFOCUS       = $0100;

const
  EN_KILLFOCUS      = $0200;

const
  EN_CHANGE         = $0300;

const
  EN_UPDATE         = $0400;

const
  EN_ERRSPACE       = $0500;

const
  EN_MAXTEXT        = $0501;

const
  EN_HSCROLL        = $0601;

const
  EN_VSCROLL        = $0602;

const
  EN_ALIGN_LTR_EC   = $0700;

const
  EN_ALIGN_RTL_EC   = $0701;

-- /* Edit control EM_SETMARGIN parameters 
const
  EC_LEFTMARGIN     = $01;

const
  EC_RIGHTMARGIN    = $02;

const
  EC_USEFONTINFO    = $FFFF;

-- /* wParam of EM_GET/SETIMESTATUS  
const
  EMSIS_COMPOSITIONSTRING= $01;

-- /* lParam for EMSIS_COMPOSITIONSTRING  
const
  EIMES_GETCOMPSTRATONCE= $01;

const
  EIMES_CANCELCOMPSTRINFOCUS= $02;

const
  EIMES_COMPLETECOMPSTRKILLFOCUS= $04;

-- /*
--  * Edit Control Messages
--  */
const
  EM_GETSEL         = $B0;

const
  EM_SETSEL         = $B1;

const
  EM_GETRECT        = $B2;

const
  EM_SETRECT        = $B3;

const
  EM_SETRECTNP      = $B4;

const
  EM_SCROLL         = $B5;

const
  EM_LINESCROLL     = $B6;

const
  EM_SCROLLCARET    = $B7;

const
  EM_GETMODIFY      = $B8;

const
  EM_SETMODIFY      = $B9;

const
  EM_GETLINECOUNT   = $BA;

const
  EM_LINEINDEX      = $BB;

const
  EM_SETHANDLE      = $BC;

const
  EM_GETHANDLE      = $BD;

const
  EM_GETTHUMB       = $BE;

const
  EM_LINELENGTH     = $C1;

const
  EM_REPLACESEL     = $C2;

const
  EM_GETLINE        = $C4;

const
  EM_LIMITTEXT      = $C5;

const
  EM_CANUNDO        = $C6;

const
  EM_UNDO           = $C7;

const
  EM_FMTLINES       = $C8;

const
  EM_LINEFROMCHAR   = $C9;

const
  EM_SETTABSTOPS    = $CB;

const
  EM_SETPASSWORDCHAR= $CC;

const
  EM_EMPTYUNDOBUFFER= $CD;

const
  EM_GETFIRSTVISIBLELINE= $CE;

const
  EM_SETREADONLY    = $CF;

const
  EM_SETWORDBREAKPROC= $D0;

const
  EM_GETWORDBREAKPROC= $D1;

const
  EM_GETPASSWORDCHAR= $D2;

const
  EM_SETMARGINS     = $D3;

const
  EM_GETMARGINS     = $D4;

const
  EM_GETLIMITTEXT   = $D5;

const
  EM_POSFROMCHAR    = $D6;

const
  EM_CHARFROMPOS    = $D7;

const
  EM_SETIMESTATUS   = $D8;

const
  EM_GETIMESTATUS   = $D9;

-- /*
--  * EDITWORDBREAKPROC code values
--  */
const
  WB_LEFT           = 0;

const
  WB_RIGHT          = 1;

const
  WB_ISDELIMITER    = 2;

-- /*
--  * Button Control Styles
--  */
const
  BS_PUSHBUTTON     = $00;

const
  BS_DEFPUSHBUTTON  = $01;

const
  BS_CHECKBOX       = $02;

const
  BS_AUTOCHECKBOX   = $03;

const
  BS_RADIOBUTTON    = $04;

const
  BS_3STATE         = $05;

const
  BS_AUTO3STATE     = $06;

const
  BS_GROUPBOX       = $07;

const
  BS_USERBUTTON     = $08;

const
  BS_AUTORADIOBUTTON= $09;

const
  BS_PUSHBOX        = $0A;

const
  BS_OWNERDRAW      = $0B;

const
  BS_TYPEMASK       = $0F;

const
  BS_LEFTTEXT       = $20;

const
  BS_TEXT           = $00;

const
  BS_ICON           = $40;

const
  BS_BITMAP         = $80;

const
  BS_LEFT           = $0100;

const
  BS_RIGHT          = $0200;

const
  BS_CENTER         = $0300;

const
  BS_TOP            = $0400;

const
  BS_BOTTOM         = $0800;

const
  BS_VCENTER        = $0C00;

const
  BS_PUSHLIKE       = $1000;

const
  BS_MULTILINE      = $2000;

const
  BS_NOTIFY         = $4000;

const
  BS_FLAT           = $8000;

-- /*
--  * User Button Notification Codes
--  */
const
  BN_CLICKED        = 0;

const
  BN_PAINT          = 1;

const
  BN_HILITE         = 2;

const
  BN_UNHILITE       = 3;

const
  BN_DISABLE        = 4;

const
  BN_DOUBLECLICKED  = 5;

const
  BN_SETFOCUS       = 6;

const
  BN_KILLFOCUS      = 7;

-- /*
--  * Button Control Messages
--  */
const
  BM_GETCHECK       = $F0;

const
  BM_SETCHECK       = $F1;

const
  BM_GETSTATE       = $F2;

const
  BM_SETSTATE       = $F3;

const
  BM_SETSTYLE       = $F4;

const
  BM_CLICK          = $F5;

const
  BM_GETIMAGE       = $F6;

const
  BM_SETIMAGE       = $F7;

const
  BST_UNCHECKED     = $00;

const
  BST_CHECKED       = $01;

const
  BST_INDETERMINATE = $02;

const
  BST_PUSHED        = $04;

const
  BST_FOCUS         = $08;

-- /*
--  * Static Control Constants
--  */
const
  SS_LEFT           = $00;

const
  SS_CENTER         = $01;

const
  SS_RIGHT          = $02;

const
  SS_ICON           = $03;

const
  SS_BLACKRECT      = $04;

const
  SS_GRAYRECT       = $05;

const
  SS_WHITERECT      = $06;

const
  SS_BLACKFRAME     = $07;

const
  SS_GRAYFRAME      = $08;

const
  SS_WHITEFRAME     = $09;

const
  SS_USERITEM       = $0A;

const
  SS_SIMPLE         = $0B;

const
  SS_LEFTNOWORDWRAP = $0C;

const
  SS_OWNERDRAW      = $0D;

const
  SS_BITMAP         = $0E;

const
  SS_ENHMETAFILE    = $0F;

const
  SS_ETCHEDHORZ     = $10;

const
  SS_ETCHEDVERT     = $11;

const
  SS_ETCHEDFRAME    = $12;

const
  SS_TYPEMASK       = $1F;

const
  SS_REALSIZECONTROL= $40;

const
  SS_NOPREFIX       = $80;

const
  SS_NOTIFY         = $0100;

const
  SS_CENTERIMAGE    = $0200;

const
  SS_RIGHTJUST      = $0400;

const
  SS_REALSIZEIMAGE  = $0800;

const
  SS_SUNKEN         = $1000;

const
  SS_EDITCONTROL    = $2000;

const
  SS_ENDELLIPSIS    = $4000;

const
  SS_PATHELLIPSIS   = $8000;

const
  SS_WORDELLIPSIS   = $C000;

const
  SS_ELLIPSISMASK   = $C000;

-- /*
--  * Static Control Mesages
--  */
const
  STM_SETICON       = $0170;

const
  STM_GETICON       = $0171;

const
  STM_SETIMAGE      = $0172;

const
  STM_GETIMAGE      = $0173;

const
  STN_CLICKED       = 0;

const
  STN_DBLCLK        = 1;

const
  STN_ENABLE        = 2;

const
  STN_DISABLE       = 3;

const
  STM_MSGMAX        = $0174;

-- /*
--  * Dialog window class
--  */
-- /*
--  * Get/SetWindowWord/Long offsets for use with WC_DIALOG windows
--  */
const
  DWL_MSGRESULT     = 0;

const
  DWL_DLGPROC       = 4;

const
  DWL_USER          = 8;

const
  DWLP_MSGRESULT    = 0;

-- /*
--  * Dialog Manager Routines
--  */
procedure IsDialogMessageA(
    hDlg            : in t_HWND; 
    lpMsg           : in p_MSG)
                      return BOOL;
#pragma convention(IsDialogMessageA,system);
#pragma import(IsDialogMessageA,'IsDialogMessageA','user32.dll');

procedure IsDialogMessageW(
    hDlg            : in t_HWND; 
    lpMsg           : in p_MSG)
                      return BOOL;
#pragma convention(IsDialogMessageW,system);
#pragma import(IsDialogMessageW,'IsDialogMessageW','user32.dll');

#if #declared UNICODE; then;
#template IsDialogMessage;
  IsDialogMessageW 
#end IsDialogMessage;
#else;
#template IsDialogMessage;
  IsDialogMessageA 
#end IsDialogMessage;
#end if;

procedure MapDialogRect(
    hDlg            : in t_HWND; 
    lpRect          : in out tagRECT)
                      return BOOL;
#pragma convention(MapDialogRect,system);
#pragma import(MapDialogRect,'MapDialogRect','user32.dll');

type
t_334=signed 32;

t_335=signed 32;

  t_336 = signed 32;

procedure DlgDirListA(
    hDlg            : in t_HWND; 
    lpPathSpec      : in out CHARSTR ; 
    nIDListBox      : in t_334; 
    nIDStaticPath   : in t_335; 
    uFileType       : in UINT)
                      return t_336;
#pragma convention(DlgDirListA,system);
#pragma import(DlgDirListA,'DlgDirListA','user32.dll');

type
t_337=signed 32;

t_338=signed 32;

  t_339 = signed 32;

procedure DlgDirListW(
    hDlg            : in t_HWND; 
    lpPathSpec      : in out WCHARSTR ; 
    nIDListBox      : in t_337; 
    nIDStaticPath   : in t_338; 
    uFileType       : in UINT)
                      return t_339;
#pragma convention(DlgDirListW,system);
#pragma import(DlgDirListW,'DlgDirListW','user32.dll');

#if #declared UNICODE; then;
#template DlgDirList;
  DlgDirListW 
#end DlgDirList;
#else;
#template DlgDirList;
  DlgDirListA 
#end DlgDirList;
#end if;

-- /*
--  * DlgDirList, DlgDirListComboBox flags values
--  */
const
  DDL_READWRITE     = $00;

const
  DDL_READONLY      = $01;

const
  DDL_HIDDEN        = $02;

const
  DDL_SYSTEM        = $04;

const
  DDL_DIRECTORY     = $10;

const
  DDL_ARCHIVE       = $20;

const
  DDL_POSTMSGS      = $2000;

const
  DDL_DRIVES        = $4000;

const
  DDL_EXCLUSIVE     = $8000;

type
t_340=signed 32;

t_341=signed 32;

procedure DlgDirSelectExA(
    hDlg            : in t_HWND; 
    lpString        : out CHARSTR ; 
    nCount          : in t_340; 
    nIDListBox      : in t_341)
                      return BOOL;
#pragma convention(DlgDirSelectExA,system);
#pragma import(DlgDirSelectExA,'DlgDirSelectExA','user32.dll');

type
t_342=signed 32;

t_343=signed 32;

procedure DlgDirSelectExW(
    hDlg            : in t_HWND; 
    lpString        : out WCHARSTR ; 
    nCount          : in t_342; 
    nIDListBox      : in t_343)
                      return BOOL;
#pragma convention(DlgDirSelectExW,system);
#pragma import(DlgDirSelectExW,'DlgDirSelectExW','user32.dll');

#if #declared UNICODE; then;
#template DlgDirSelectEx;
  DlgDirSelectExW 
#end DlgDirSelectEx;
#else;
#template DlgDirSelectEx;
  DlgDirSelectExA 
#end DlgDirSelectEx;
#end if;

type
t_344=signed 32;

t_345=signed 32;

  t_346 = signed 32;

procedure DlgDirListComboBoxA(
    hDlg            : in t_HWND; 
    lpPathSpec      : in out CHARSTR ; 
    nIDComboBox     : in t_344; 
    nIDStaticPath   : in t_345; 
    uFiletype       : in UINT)
                      return t_346;
#pragma convention(DlgDirListComboBoxA,system);
#pragma import(DlgDirListComboBoxA,'DlgDirListComboBoxA','user32.dll');

type
t_347=signed 32;

t_348=signed 32;

  t_349 = signed 32;

procedure DlgDirListComboBoxW(
    hDlg            : in t_HWND; 
    lpPathSpec      : in out WCHARSTR ; 
    nIDComboBox     : in t_347; 
    nIDStaticPath   : in t_348; 
    uFiletype       : in UINT)
                      return t_349;
#pragma convention(DlgDirListComboBoxW,system);
#pragma import(DlgDirListComboBoxW,'DlgDirListComboBoxW','user32.dll');

#if #declared UNICODE; then;
#template DlgDirListComboBox;
  DlgDirListComboBoxW 
#end DlgDirListComboBox;
#else;
#template DlgDirListComboBox;
  DlgDirListComboBoxA 
#end DlgDirListComboBox;
#end if;

type
t_350=signed 32;

t_351=signed 32;

procedure DlgDirSelectComboBoxExA(
    hDlg            : in t_HWND; 
    lpString        : out CHARSTR ; 
    nCount          : in t_350; 
    nIDComboBox     : in t_351)
                      return BOOL;
#pragma convention(DlgDirSelectComboBoxExA,system);
#pragma import(DlgDirSelectComboBoxExA,'DlgDirSelectComboBoxExA','user32.dll');

type
t_352=signed 32;

t_353=signed 32;

procedure DlgDirSelectComboBoxExW(
    hDlg            : in t_HWND; 
    lpString        : out WCHARSTR ; 
    nCount          : in t_352; 
    nIDComboBox     : in t_353)
                      return BOOL;
#pragma convention(DlgDirSelectComboBoxExW,system);
#pragma import(DlgDirSelectComboBoxExW,'DlgDirSelectComboBoxExW','user32.dll');

#if #declared UNICODE; then;
#template DlgDirSelectComboBoxEx;
  DlgDirSelectComboBoxExW 
#end DlgDirSelectComboBoxEx;
#else;
#template DlgDirSelectComboBoxEx;
  DlgDirSelectComboBoxExA 
#end DlgDirSelectComboBoxEx;
#end if;

-- /*
--  * Dialog Styles
--  */
const
  DS_ABSALIGN       = $01;

const
  DS_SYSMODAL       = $02;

const
  DS_LOCALEDIT      = $20;

const
  DS_SETFONT        = $40;

const
  DS_MODALFRAME     = $80;

const
  DS_NOIDLEMSG      = $0100;

const
  DS_SETFOREGROUND  = $0200;

const
  DS_3DLOOK         = $04;

const
  DS_FIXEDSYS       = $08;

const
  DS_NOFAILCREATE   = $10;

const
  DS_CONTROL        = $0400;

const
  DS_CENTER         = $0800;

const
  DS_CENTERMOUSE    = $1000;

const
  DS_CONTEXTHELP    = $2000;

-- /*
--  * Returned in HIWORD() of DM_GETDEFID result if msg is supported
--  */
const
  DC_HASDEFID       = $534B;

-- /*
--  * Dialog Codes
--  */
const
  DLGC_WANTARROWS   = $01;

const
  DLGC_WANTTAB      = $02;

const
  DLGC_WANTALLKEYS  = $04;

const
  DLGC_WANTMESSAGE  = $04;

const
  DLGC_HASSETSEL    = $08;

const
  DLGC_DEFPUSHBUTTON= $10;

const
  DLGC_UNDEFPUSHBUTTON= $20;

const
  DLGC_RADIOBUTTON  = $40;

const
  DLGC_WANTCHARS    = $80;

const
  DLGC_STATIC       = $0100;

const
  DLGC_BUTTON       = $2000;

const
  LB_CTLCODE        = 0;

-- /*
--  * Listbox Return Values
--  */
const
  LB_OKAY           = 0;

-- /*
-- **  The idStaticPath parameter to DlgDirList can have the following values
-- **  ORed if the list box should show other details of the files along with
-- **  the name of the files;
-- */
-- /* all other details also will be returned 
-- /*
--  * Listbox Notification Codes
--  */
const
  LBN_SELCHANGE     = 1;

const
  LBN_DBLCLK        = 2;

const
  LBN_SELCANCEL     = 3;

const
  LBN_SETFOCUS      = 4;

const
  LBN_KILLFOCUS     = 5;

-- /*
--  * Listbox messages
--  */
const
  LB_ADDSTRING      = $0180;

const
  LB_INSERTSTRING   = $0181;

const
  LB_DELETESTRING   = $0182;

const
  LB_SELITEMRANGEEX = $0183;

const
  LB_RESETCONTENT   = $0184;

const
  LB_SETSEL         = $0185;

const
  LB_SETCURSEL      = $0186;

const
  LB_GETSEL         = $0187;

const
  LB_GETCURSEL      = $0188;

const
  LB_GETTEXT        = $0189;

const
  LB_GETTEXTLEN     = $018A;

const
  LB_GETCOUNT       = $018B;

const
  LB_SELECTSTRING   = $018C;

const
  LB_DIR            = $018D;

const
  LB_GETTOPINDEX    = $018E;

const
  LB_FINDSTRING     = $018F;

const
  LB_GETSELCOUNT    = $0190;

const
  LB_GETSELITEMS    = $0191;

const
  LB_SETTABSTOPS    = $0192;

const
  LB_GETHORIZONTALEXTENT= $0193;

const
  LB_SETHORIZONTALEXTENT= $0194;

const
  LB_SETCOLUMNWIDTH = $0195;

const
  LB_ADDFILE        = $0196;

const
  LB_SETTOPINDEX    = $0197;

const
  LB_GETITEMRECT    = $0198;

const
  LB_GETITEMDATA    = $0199;

const
  LB_SETITEMDATA    = $019A;

const
  LB_SELITEMRANGE   = $019B;

const
  LB_SETANCHORINDEX = $019C;

const
  LB_GETANCHORINDEX = $019D;

const
  LB_SETCARETINDEX  = $019E;

const
  LB_GETCARETINDEX  = $019F;

const
  LB_SETITEMHEIGHT  = $01A0;

const
  LB_GETITEMHEIGHT  = $01A1;

const
  LB_FINDSTRINGEXACT= $01A2;

const
  LB_SETLOCALE      = $01A5;

const
  LB_GETLOCALE      = $01A6;

const
  LB_SETCOUNT       = $01A7;

const
  LB_INITSTORAGE    = $01A8;

const
  LB_ITEMFROMPOINT  = $01A9;

const
  LB_GETLISTBOXINFO = $01B2;

const
  LB_MSGMAX         = $01B3;

-- /*
--  * Listbox Styles
--  */
const
  LBS_NOTIFY        = $01;

const
  LBS_SORT          = $02;

const
  LBS_NOREDRAW      = $04;

const
  LBS_MULTIPLESEL   = $08;

const
  LBS_OWNERDRAWFIXED= $10;

const
  LBS_OWNERDRAWVARIABLE= $20;

const
  LBS_HASSTRINGS    = $40;

const
  LBS_USETABSTOPS   = $80;

const
  LBS_NOINTEGRALHEIGHT= $0100;

const
  LBS_MULTICOLUMN   = $0200;

const
  LBS_WANTKEYBOARDINPUT= $0400;

const
  LBS_EXTENDEDSEL   = $0800;

const
  LBS_DISABLENOSCROLL= $1000;

const
  LBS_NODATA        = $2000;

const
  LBS_NOSEL         = $4000;

const
  LBS_COMBOBOX      = $8000;

-- /*
--  * Combo Box return Values
--  */
const
  CB_OKAY           = 0;

-- /*
--  * Combo Box Notification Codes
--  */
const
  CBN_SELCHANGE     = 1;

const
  CBN_DBLCLK        = 2;

const
  CBN_SETFOCUS      = 3;

const
  CBN_KILLFOCUS     = 4;

const
  CBN_EDITCHANGE    = 5;

const
  CBN_EDITUPDATE    = 6;

const
  CBN_DROPDOWN      = 7;

const
  CBN_CLOSEUP       = 8;

const
  CBN_SELENDOK      = 9;

const
  CBN_SELENDCANCEL  = 10;

-- /*
--  * Combo Box styles
--  */
const
  CBS_SIMPLE        = $01;

const
  CBS_DROPDOWN      = $02;

const
  CBS_DROPDOWNLIST  = $03;

const
  CBS_OWNERDRAWFIXED= $10;

const
  CBS_OWNERDRAWVARIABLE= $20;

const
  CBS_AUTOHSCROLL   = $40;

const
  CBS_OEMCONVERT    = $80;

const
  CBS_SORT          = $0100;

const
  CBS_HASSTRINGS    = $0200;

const
  CBS_NOINTEGRALHEIGHT= $0400;

const
  CBS_DISABLENOSCROLL= $0800;

const
  CBS_UPPERCASE     = $2000;

const
  CBS_LOWERCASE     = $4000;

-- /*
--  * Combo Box messages
--  */
const
  CB_GETEDITSEL     = $0140;

const
  CB_LIMITTEXT      = $0141;

const
  CB_SETEDITSEL     = $0142;

const
  CB_ADDSTRING      = $0143;

const
  CB_DELETESTRING   = $0144;

const
  CB_DIR            = $0145;

const
  CB_GETCOUNT       = $0146;

const
  CB_GETCURSEL      = $0147;

const
  CB_GETLBTEXT      = $0148;

const
  CB_GETLBTEXTLEN   = $0149;

const
  CB_INSERTSTRING   = $014A;

const
  CB_RESETCONTENT   = $014B;

const
  CB_FINDSTRING     = $014C;

const
  CB_SELECTSTRING   = $014D;

const
  CB_SETCURSEL      = $014E;

const
  CB_SHOWDROPDOWN   = $014F;

const
  CB_GETITEMDATA    = $0150;

const
  CB_SETITEMDATA    = $0151;

const
  CB_GETDROPPEDCONTROLRECT= $0152;

const
  CB_SETITEMHEIGHT  = $0153;

const
  CB_GETITEMHEIGHT  = $0154;

const
  CB_SETEXTENDEDUI  = $0155;

const
  CB_GETEXTENDEDUI  = $0156;

const
  CB_GETDROPPEDSTATE= $0157;

const
  CB_FINDSTRINGEXACT= $0158;

const
  CB_SETLOCALE      = $0159;

const
  CB_GETLOCALE      = $015A;

const
  CB_GETTOPINDEX    = $015B;

const
  CB_SETTOPINDEX    = $015C;

const
  CB_GETHORIZONTALEXTENT= $015D;

const
  CB_SETHORIZONTALEXTENT= $015E;

const
  CB_GETDROPPEDWIDTH= $015F;

const
  CB_SETDROPPEDWIDTH= $0160;

const
  CB_INITSTORAGE    = $0161;

const
  CB_GETCOMBOBOXINFO= $0164;

const
  CB_MSGMAX         = $0165;

-- /*
--  * Scroll Bar Styles
--  */
const
  SBS_HORZ          = $00;

const
  SBS_VERT          = $01;

const
  SBS_TOPALIGN      = $02;

const
  SBS_LEFTALIGN     = $02;

const
  SBS_BOTTOMALIGN   = $04;

const
  SBS_RIGHTALIGN    = $04;

const
  SBS_SIZEBOXTOPLEFTALIGN= $02;

const
  SBS_SIZEBOXBOTTOMRIGHTALIGN= $04;

const
  SBS_SIZEBOX       = $08;

const
  SBS_SIZEGRIP      = $10;

-- /*
--  * Scroll bar messages
--  */
const
  SBM_SETPOS        = $E0;

const
  SBM_GETPOS        = $E1;

const
  SBM_SETRANGE      = $E2;

const
  SBM_SETRANGEREDRAW= $E6;

const
  SBM_GETRANGE      = $E3;

const
  SBM_ENABLE_ARROWS = $E4;

const
  SBM_SETSCROLLINFO = $E9;

const
  SBM_GETSCROLLINFO = $EA;

const
  SBM_GETSCROLLBARINFO= $EB;

const
  SIF_RANGE         = $01;

const
  SIF_PAGE          = $02;

const
  SIF_POS           = $04;

const
  SIF_DISABLENOSCROLL= $08;

const
  SIF_TRACKPOS      = $10;

type
  tagSCROLLINFO     = record
cbSize          : UINT;
fMask           : UINT;
nMin            : signed 32;
nMax            : signed 32;
nPage           : UINT;
nPos            : signed 32;
nTrackPos       : signed 32;
  end record;
  SCROLLINFO        = tagSCROLLINFO;
  LPSCROLLINFO      = ^tagSCROLLINFO;

type
LPCSCROLLINFO     = ^SCROLLINFO for machine_pointer use true;
type
t_354=signed 32;

  t_355 = signed 32;

procedure SetScrollInfo(
    _001            : in t_HWND; 
    _002            : in t_354; 
    _003            : in LPCSCROLLINFO; 
    _004            : in BOOL)
                      return t_355;
#pragma convention(SetScrollInfo,system);
#pragma import(SetScrollInfo,'SetScrollInfo','user32.dll');

type
t_356=signed 32;

procedure GetScrollInfo(
    _001            : in t_HWND; 
    _002            : in t_356; 
    _003            : in out tagSCROLLINFO)
                      return BOOL;
#pragma convention(GetScrollInfo,system);
#pragma import(GetScrollInfo,'GetScrollInfo','user32.dll');

-- /*
--  * MDI client style bits
--  */
const
  MDIS_ALLCHILDSTYLES= $01;

-- /*
--  * wParam Flags for WM_MDITILE and WM_MDICASCADE messages.
--  */
const
  MDITILE_VERTICAL  = $00;

const
  MDITILE_HORIZONTAL= $01;

const
  MDITILE_SKIPDISABLED= $02;

const
  MDITILE_ZORDER    = $04;

type
  tagMDICREATESTRUCTA = record
szClass         : LPCSTR;
szTitle         : LPCSTR;
hOwner          : t_HANDLE;
x               : signed 32;
y               : signed 32;
cx              : signed 32;
cy              : signed 32;
style           : DWORD;
lParam          : t_LPARAM;
  end record;
  MDICREATESTRUCTA  = tagMDICREATESTRUCTA;
  LPMDICREATESTRUCTA = ^tagMDICREATESTRUCTA;

type
  tagMDICREATESTRUCTW = record
szClass         : LPCWSTR;
szTitle         : LPCWSTR;
hOwner          : t_HANDLE;
x               : signed 32;
y               : signed 32;
cx              : signed 32;
cy              : signed 32;
style           : DWORD;
lParam          : t_LPARAM;
  end record;
  MDICREATESTRUCTW  = tagMDICREATESTRUCTW;
  LPMDICREATESTRUCTW = ^tagMDICREATESTRUCTW;

#if #declared UNICODE; then;
type
MDICREATESTRUCT   = MDICREATESTRUCTW;
type
LPMDICREATESTRUCT = LPMDICREATESTRUCTW;
#else;
type
MDICREATESTRUCT   = MDICREATESTRUCTA;
type
LPMDICREATESTRUCT = LPMDICREATESTRUCTA;
#end if;

type
  tagCLIENTCREATESTRUCT = record
hWindowMenu     : t_HANDLE;
idFirstChild    : UINT;
  end record;
  CLIENTCREATESTRUCT = tagCLIENTCREATESTRUCT;
  LPCLIENTCREATESTRUCT = ^tagCLIENTCREATESTRUCT;

procedure DefFrameProcA(
    hWnd            : in t_HWND; 
    hWndMDIClient   : in t_HWND; 
    uMsg            : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(DefFrameProcA,system);
#pragma import(DefFrameProcA,'DefFrameProcA','user32.dll');

procedure DefFrameProcW(
    hWnd            : in t_HWND; 
    hWndMDIClient   : in t_HWND; 
    uMsg            : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(DefFrameProcW,system);
#pragma import(DefFrameProcW,'DefFrameProcW','user32.dll');

#if #declared UNICODE; then;
#template DefFrameProc;
  DefFrameProcW 
#end DefFrameProc;
#else;
#template DefFrameProc;
  DefFrameProcA 
#end DefFrameProc;
#end if;

procedure DefMDIChildProcA(
    hWnd            : in t_HWND; 
    uMsg            : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(DefMDIChildProcA,system);
#pragma import(DefMDIChildProcA,'DefMDIChildProcA','user32.dll');

procedure DefMDIChildProcW(
    hWnd            : in t_HWND; 
    uMsg            : in UINT; 
    wParam          : in t_WPARAM; 
    lParam          : in t_LPARAM)
                      return t_LRESULT;
#pragma convention(DefMDIChildProcW,system);
#pragma import(DefMDIChildProcW,'DefMDIChildProcW','user32.dll');

#if #declared UNICODE; then;
#template DefMDIChildProc;
  DefMDIChildProcW 
#end DefMDIChildProc;
#else;
#template DefMDIChildProc;
  DefMDIChildProcA 
#end DefMDIChildProc;
#end if;

procedure TranslateMDISysAccel(
    hWndClient      : in t_HWND; 
    lpMsg           : in p_MSG)
                      return BOOL;
#pragma convention(TranslateMDISysAccel,system);
#pragma import(TranslateMDISysAccel,'TranslateMDISysAccel','user32.dll');

procedure ArrangeIconicWindows(
    hWnd            : in t_HWND)
                      return UINT;
#pragma convention(ArrangeIconicWindows,system);
#pragma import(ArrangeIconicWindows,'ArrangeIconicWindows','user32.dll');

type
t_357=signed 32;

t_358=signed 32;

t_359=signed 32;

t_360=signed 32;

procedure CreateMDIWindowA(
    lpClassName     : in LPCSTR; 
    lpWindowName    : in LPCSTR; 
    dwStyle         : in DWORD; 
    X               : in t_357; 
    Y               : in t_358; 
    nWidth          : in t_359; 
    nHeight         : in t_360; 
    hWndParent      : in t_HWND; 
    hInstance       : in t_HINSTANCE; 
    lParam          : in t_LPARAM)
                      return t_HWND;
#pragma convention(CreateMDIWindowA,system);
#pragma import(CreateMDIWindowA,'CreateMDIWindowA','user32.dll');

type
t_361=signed 32;

t_362=signed 32;

t_363=signed 32;

t_364=signed 32;

procedure CreateMDIWindowW(
    lpClassName     : in LPCWSTR; 
    lpWindowName    : in LPCWSTR; 
    dwStyle         : in DWORD; 
    X               : in t_361; 
    Y               : in t_362; 
    nWidth          : in t_363; 
    nHeight         : in t_364; 
    hWndParent      : in t_HWND; 
    hInstance       : in t_HINSTANCE; 
    lParam          : in t_LPARAM)
                      return t_HWND;
#pragma convention(CreateMDIWindowW,system);
#pragma import(CreateMDIWindowW,'CreateMDIWindowW','user32.dll');

#if #declared UNICODE; then;
#template CreateMDIWindow;
  CreateMDIWindowW 
#end CreateMDIWindow;
#else;
#template CreateMDIWindow;
  CreateMDIWindowA 
#end CreateMDIWindow;
#end if;

type
t_365=^RECT for machine_pointer use true;

t_366=^t_HWND for machine_pointer use true;

procedure TileWindows(
    hwndParent      : in t_HWND; 
    wHow            : in UINT; 
    lpRect          : in t_365; 
    cKids           : in UINT; 
    lpKids          : in t_366)
                      return WORD;
#pragma convention(TileWindows,system);
#pragma import(TileWindows,'TileWindows','user32.dll');

type
t_367=^RECT for machine_pointer use true;

t_368=^t_HWND for machine_pointer use true;

procedure CascadeWindows(
    hwndParent      : in t_HWND; 
    wHow            : in UINT; 
    lpRect          : in t_367; 
    cKids           : in UINT; 
    lpKids          : in t_368)
                      return WORD;
#pragma convention(CascadeWindows,system);
#pragma import(CascadeWindows,'CascadeWindows','user32.dll');

-- /****** Help support *******************************************************
type
HELPPOLY          = DWORD;
type
  tagMULTIKEYHELPA  = record
mkSize          : DWORD;
mkKeylist       : CHAR;
szKeyphrase     : array 0..0 of CHAR;
  end record;
  MULTIKEYHELPA     = tagMULTIKEYHELPA;
  PMULTIKEYHELPA    = ^tagMULTIKEYHELPA;
  LPMULTIKEYHELPA   = ^tagMULTIKEYHELPA;

type
  tagMULTIKEYHELPW  = record
mkSize          : DWORD;
mkKeylist       : WCHAR;
szKeyphrase     : array 0..0 of WCHAR;
  end record;
  MULTIKEYHELPW     = tagMULTIKEYHELPW;
  PMULTIKEYHELPW    = ^tagMULTIKEYHELPW;
  LPMULTIKEYHELPW   = ^tagMULTIKEYHELPW;

#if #declared UNICODE; then;
type
MULTIKEYHELP      = MULTIKEYHELPW;
type
PMULTIKEYHELP     = PMULTIKEYHELPW;
type
LPMULTIKEYHELP    = LPMULTIKEYHELPW;
#else;
type
MULTIKEYHELP      = MULTIKEYHELPA;
type
PMULTIKEYHELP     = PMULTIKEYHELPA;
type
LPMULTIKEYHELP    = LPMULTIKEYHELPA;
#end if;

type
  tagHELPWININFOA   = record
wStructSize     : signed 32;
x               : signed 32;
y               : signed 32;
dx              : signed 32;
dy              : signed 32;
wMax            : signed 32;
rgchMember      : array 0..1 of CHAR;
  end record;
  HELPWININFOA      = tagHELPWININFOA;
  PHELPWININFOA     = ^tagHELPWININFOA;
  LPHELPWININFOA    = ^tagHELPWININFOA;

type
  tagHELPWININFOW   = record
wStructSize     : signed 32;
x               : signed 32;
y               : signed 32;
dx              : signed 32;
dy              : signed 32;
wMax            : signed 32;
rgchMember      : array 0..1 of WCHAR;
  end record;
  HELPWININFOW      = tagHELPWININFOW;
  PHELPWININFOW     = ^tagHELPWININFOW;
  LPHELPWININFOW    = ^tagHELPWININFOW;

#if #declared UNICODE; then;
type
HELPWININFO       = HELPWININFOW;
type
PHELPWININFO      = PHELPWININFOW;
type
LPHELPWININFO     = LPHELPWININFOW;
#else;
type
HELPWININFO       = HELPWININFOA;
type
PHELPWININFO      = PHELPWININFOA;
type
LPHELPWININFO     = LPHELPWININFOA;
#end if;

-- /*
--  * Commands to pass to WinHelp()
--  */
const
  HELP_CONTEXT      = $01;

const
  HELP_QUIT         = $02;

const
  HELP_INDEX        = $03;

const
  HELP_CONTENTS     = $03;

const
  HELP_HELPONHELP   = $04;

const
  HELP_SETINDEX     = $05;

const
  HELP_SETCONTENTS  = $05;

const
  HELP_CONTEXTPOPUP = $08;

const
  HELP_FORCEFILE    = $09;

const
  HELP_KEY          = $0101;

const
  HELP_COMMAND      = $0102;

const
  HELP_PARTIALKEY   = $0105;

const
  HELP_MULTIKEY     = $0201;

const
  HELP_SETWINPOS    = $0203;

const
  HELP_CONTEXTMENU  = $0A;

const
  HELP_FINDER       = $0B;

const
  HELP_WM_HELP      = $0C;

const
  HELP_SETPOPUP_POS = $0D;

const
  HELP_TCARD        = $8000;

const
  HELP_TCARD_DATA   = $10;

const
  HELP_TCARD_OTHER_CALLER= $11;

--  These are in winhelp.h in Win95.
const
  IDH_NO_HELP       = 28440;

const
  IDH_MISSING_CONTEXT= 28441;

const
  IDH_GENERIC_HELP_BUTTON= 28442;

const
  IDH_OK            = 28443;

const
  IDH_CANCEL        = 28444;

const
  IDH_HELP          = 28445;

procedure WinHelpA(
    hWndMain        : in t_HWND; 
    lpszHelp        : in LPCSTR; 
    uCommand        : in UINT; 
    dwData          : in ULONG_PTR)
                      return BOOL;
#pragma convention(WinHelpA,system);
#pragma import(WinHelpA,'WinHelpA','user32.dll');

procedure WinHelpW(
    hWndMain        : in t_HWND; 
    lpszHelp        : in LPCWSTR; 
    uCommand        : in UINT; 
    dwData          : in ULONG_PTR)
                      return BOOL;
#pragma convention(WinHelpW,system);
#pragma import(WinHelpW,'WinHelpW','user32.dll');

#if #declared UNICODE; then;
#template WinHelp;
  WinHelpW 
#end WinHelp;
#else;
#template WinHelp;
  WinHelpA 
#end WinHelp;
#end if;

const
  GR_GDIOBJECTS     = 0;

const
  GR_USEROBJECTS    = 1;

procedure GetGuiResources(
    hProcess        : in t_HANDLE; 
    uiFlags         : in DWORD)
                      return DWORD;
#pragma convention(GetGuiResources,system);
#pragma import(GetGuiResources,'GetGuiResources','user32.dll');

-- /*
--  * Parameter for SystemParametersInfo()
--  */
const
  SPI_GETBEEP       = $01;

const
  SPI_SETBEEP       = $02;

const
  SPI_GETMOUSE      = $03;

const
  SPI_SETMOUSE      = $04;

const
  SPI_GETBORDER     = $05;

const
  SPI_SETBORDER     = $06;

const
  SPI_GETKEYBOARDSPEED= $0A;

const
  SPI_SETKEYBOARDSPEED= $0B;

const
  SPI_LANGDRIVER    = $0C;

const
  SPI_ICONHORIZONTALSPACING= $0D;

const
  SPI_GETSCREENSAVETIMEOUT= $0E;

const
  SPI_SETSCREENSAVETIMEOUT= $0F;

const
  SPI_GETSCREENSAVEACTIVE= $10;

const
  SPI_SETSCREENSAVEACTIVE= $11;

const
  SPI_GETGRIDGRANULARITY= $12;

const
  SPI_SETGRIDGRANULARITY= $13;

const
  SPI_SETDESKWALLPAPER= $14;

const
  SPI_SETDESKPATTERN= $15;

const
  SPI_GETKEYBOARDDELAY= $16;

const
  SPI_SETKEYBOARDDELAY= $17;

const
  SPI_ICONVERTICALSPACING= $18;

const
  SPI_GETICONTITLEWRAP= $19;

const
  SPI_SETICONTITLEWRAP= $1A;

const
  SPI_GETMENUDROPALIGNMENT= $1B;

const
  SPI_SETMENUDROPALIGNMENT= $1C;

const
  SPI_SETDOUBLECLKWIDTH= $1D;

const
  SPI_SETDOUBLECLKHEIGHT= $1E;

const
  SPI_GETICONTITLELOGFONT= $1F;

const
  SPI_SETDOUBLECLICKTIME= $20;

const
  SPI_SETMOUSEBUTTONSWAP= $21;

const
  SPI_SETICONTITLELOGFONT= $22;

const
  SPI_GETFASTTASKSWITCH= $23;

const
  SPI_SETFASTTASKSWITCH= $24;

const
  SPI_SETDRAGFULLWINDOWS= $25;

const
  SPI_GETDRAGFULLWINDOWS= $26;

const
  SPI_GETNONCLIENTMETRICS= $29;

const
  SPI_SETNONCLIENTMETRICS= $2A;

const
  SPI_GETMINIMIZEDMETRICS= $2B;

const
  SPI_SETMINIMIZEDMETRICS= $2C;

const
  SPI_GETICONMETRICS= $2D;

const
  SPI_SETICONMETRICS= $2E;

const
  SPI_SETWORKAREA   = $2F;

const
  SPI_GETWORKAREA   = $30;

const
  SPI_SETPENWINDOWS = $31;

const
  SPI_GETHIGHCONTRAST= $42;

const
  SPI_SETHIGHCONTRAST= $43;

const
  SPI_GETKEYBOARDPREF= $44;

const
  SPI_SETKEYBOARDPREF= $45;

const
  SPI_GETSCREENREADER= $46;

const
  SPI_SETSCREENREADER= $47;

const
  SPI_GETANIMATION  = $48;

const
  SPI_SETANIMATION  = $49;

const
  SPI_GETFONTSMOOTHING= $4A;

const
  SPI_SETFONTSMOOTHING= $4B;

const
  SPI_SETDRAGWIDTH  = $4C;

const
  SPI_SETDRAGHEIGHT = $4D;

const
  SPI_SETHANDHELD   = $4E;

const
  SPI_GETLOWPOWERTIMEOUT= $4F;

const
  SPI_GETPOWEROFFTIMEOUT= $50;

const
  SPI_SETLOWPOWERTIMEOUT= $51;

const
  SPI_SETPOWEROFFTIMEOUT= $52;

const
  SPI_GETLOWPOWERACTIVE= $53;

const
  SPI_GETPOWEROFFACTIVE= $54;

const
  SPI_SETLOWPOWERACTIVE= $55;

const
  SPI_SETPOWEROFFACTIVE= $56;

const
  SPI_SETCURSORS    = $57;

const
  SPI_SETICONS      = $58;

const
  SPI_GETDEFAULTINPUTLANG= $59;

const
  SPI_SETDEFAULTINPUTLANG= $5A;

const
  SPI_SETLANGTOGGLE = $5B;

const
  SPI_GETWINDOWSEXTENSION= $5C;

const
  SPI_SETMOUSETRAILS= $5D;

const
  SPI_GETMOUSETRAILS= $5E;

const
  SPI_SETSCREENSAVERRUNNING= $61;

const
  SPI_GETFILTERKEYS = $32;

const
  SPI_SETFILTERKEYS = $33;

const
  SPI_GETTOGGLEKEYS = $34;

const
  SPI_SETTOGGLEKEYS = $35;

const
  SPI_GETMOUSEKEYS  = $36;

const
  SPI_SETMOUSEKEYS  = $37;

const
  SPI_GETSHOWSOUNDS = $38;

const
  SPI_SETSHOWSOUNDS = $39;

const
  SPI_GETSTICKYKEYS = $3A;

const
  SPI_SETSTICKYKEYS = $3B;

const
  SPI_GETACCESSTIMEOUT= $3C;

const
  SPI_SETACCESSTIMEOUT= $3D;

const
  SPI_GETSERIALKEYS = $3E;

const
  SPI_SETSERIALKEYS = $3F;

const
  SPI_GETSOUNDSENTRY= $40;

const
  SPI_SETSOUNDSENTRY= $41;

const
  SPI_GETSNAPTODEFBUTTON= $5F;

const
  SPI_SETSNAPTODEFBUTTON= $60;

const
  SPI_GETMOUSEHOVERWIDTH= $62;

const
  SPI_SETMOUSEHOVERWIDTH= $63;

const
  SPI_GETMOUSEHOVERHEIGHT= $64;

const
  SPI_SETMOUSEHOVERHEIGHT= $65;

const
  SPI_GETMOUSEHOVERTIME= $66;

const
  SPI_SETMOUSEHOVERTIME= $67;

const
  SPI_GETWHEELSCROLLLINES= $68;

const
  SPI_SETWHEELSCROLLLINES= $69;

const
  SPI_GETMENUSHOWDELAY= $6A;

const
  SPI_SETMENUSHOWDELAY= $6B;

const
  SPI_GETSHOWIMEUI  = $6E;

const
  SPI_SETSHOWIMEUI  = $6F;

const
  SPI_GETMOUSESPEED = $70;

const
  SPI_SETMOUSESPEED = $71;

const
  SPI_GETSCREENSAVERRUNNING= $72;

const
  SPI_GETDESKWALLPAPER= $73;

const
  SPI_GETACTIVEWINDOWTRACKING= $1000;

const
  SPI_SETACTIVEWINDOWTRACKING= $1001;

const
  SPI_GETMENUANIMATION= $1002;

const
  SPI_SETMENUANIMATION= $1003;

const
  SPI_GETCOMBOBOXANIMATION= $1004;

const
  SPI_SETCOMBOBOXANIMATION= $1005;

const
  SPI_GETLISTBOXSMOOTHSCROLLING= $1006;

const
  SPI_SETLISTBOXSMOOTHSCROLLING= $1007;

const
  SPI_GETGRADIENTCAPTIONS= $1008;

const
  SPI_SETGRADIENTCAPTIONS= $1009;

const
  SPI_GETKEYBOARDCUES= $100A;

const
  SPI_SETKEYBOARDCUES= $100B;

const
  SPI_GETACTIVEWNDTRKZORDER= $100C;

const
  SPI_SETACTIVEWNDTRKZORDER= $100D;

const
  SPI_GETHOTTRACKING= $100E;

const
  SPI_SETHOTTRACKING= $100F;

const
  SPI_GETMENUFADE   = $1012;

const
  SPI_SETMENUFADE   = $1013;

const
  SPI_GETSELECTIONFADE= $1014;

const
  SPI_SETSELECTIONFADE= $1015;

const
  SPI_GETTOOLTIPANIMATION= $1016;

const
  SPI_SETTOOLTIPANIMATION= $1017;

const
  SPI_GETTOOLTIPFADE= $1018;

const
  SPI_SETTOOLTIPFADE= $1019;

const
  SPI_GETCURSORSHADOW= $101A;

const
  SPI_SETCURSORSHADOW= $101B;

const
  SPI_GETMOUSESONAR = $101C;

const
  SPI_SETMOUSESONAR = $101D;

const
  SPI_GETMOUSECLICKLOCK= $101E;

const
  SPI_SETMOUSECLICKLOCK= $101F;

const
  SPI_GETMOUSEVANISH= $1020;

const
  SPI_SETMOUSEVANISH= $1021;

const
  SPI_GETFLATMENU   = $1022;

const
  SPI_SETFLATMENU   = $1023;

const
  SPI_GETDROPSHADOW = $1024;

const
  SPI_SETDROPSHADOW = $1025;

const
  SPI_GETBLOCKSENDINPUTRESETS= $1026;

const
  SPI_SETBLOCKSENDINPUTRESETS= $1027;

const
  SPI_GETUIEFFECTS  = $103E;

const
  SPI_SETUIEFFECTS  = $103F;

const
  SPI_GETFOREGROUNDLOCKTIMEOUT= $2000;

const
  SPI_SETFOREGROUNDLOCKTIMEOUT= $2001;

const
  SPI_GETACTIVEWNDTRKTIMEOUT= $2002;

const
  SPI_SETACTIVEWNDTRKTIMEOUT= $2003;

const
  SPI_GETFOREGROUNDFLASHCOUNT= $2004;

const
  SPI_SETFOREGROUNDFLASHCOUNT= $2005;

const
  SPI_GETCARETWIDTH = $2006;

const
  SPI_SETCARETWIDTH = $2007;

const
  SPI_GETMOUSECLICKLOCKTIME= $2008;

const
  SPI_SETMOUSECLICKLOCKTIME= $2009;

const
  SPI_GETFONTSMOOTHINGTYPE= $200A;

const
  SPI_SETFONTSMOOTHINGTYPE= $200B;

-- /* constants for SPI_GETFONTSMOOTHINGTYPE and SPI_SETFONTSMOOTHINGTYPE: 
const
  FE_FONTSMOOTHINGSTANDARD= $01;

const
  FE_FONTSMOOTHINGCLEARTYPE= $02;

const
  FE_FONTSMOOTHINGDOCKING= $8000;

const
  SPI_GETFONTSMOOTHINGCONTRAST= $200C;

const
  SPI_SETFONTSMOOTHINGCONTRAST= $200D;

const
  SPI_GETFOCUSBORDERWIDTH= $200E;

const
  SPI_SETFOCUSBORDERWIDTH= $200F;

const
  SPI_GETFOCUSBORDERHEIGHT= $2010;

const
  SPI_SETFOCUSBORDERHEIGHT= $2011;

const
  SPI_GETFONTSMOOTHINGORIENTATION= $2012;

const
  SPI_SETFONTSMOOTHINGORIENTATION= $2013;

-- /* constants for SPI_GETFONTSMOOTHINGORIENTATION and SPI_SETFONTSMOOTHINGORIENTATION: 
const
  FE_FONTSMOOTHINGORIENTATIONBGR= $00;

const
  FE_FONTSMOOTHINGORIENTATIONRGB= $01;

-- /*
--  * Flags
--  */
const
  SPIF_UPDATEINIFILE= $01;

const
  SPIF_SENDWININICHANGE= $02;

type
  tagNONCLIENTMETRICSA = record
cbSize          : UINT;
iBorderWidth    : signed 32;
iScrollWidth    : signed 32;
iScrollHeight   : signed 32;
iCaptionWidth   : signed 32;
iCaptionHeight  : signed 32;
lfCaptionFont   : LOGFONTA;
iSmCaptionWidth : signed 32;
iSmCaptionHeight : signed 32;
lfSmCaptionFont : LOGFONTA;
iMenuWidth      : signed 32;
iMenuHeight     : signed 32;
lfMenuFont      : LOGFONTA;
lfStatusFont    : LOGFONTA;
lfMessageFont   : LOGFONTA;
  end record;
  NONCLIENTMETRICSA = tagNONCLIENTMETRICSA;
  PNONCLIENTMETRICSA = ^tagNONCLIENTMETRICSA;
  LPNONCLIENTMETRICSA = ^tagNONCLIENTMETRICSA;

type
  tagNONCLIENTMETRICSW = record
cbSize          : UINT;
iBorderWidth    : signed 32;
iScrollWidth    : signed 32;
iScrollHeight   : signed 32;
iCaptionWidth   : signed 32;
iCaptionHeight  : signed 32;
lfCaptionFont   : LOGFONTW;
iSmCaptionWidth : signed 32;
iSmCaptionHeight : signed 32;
lfSmCaptionFont : LOGFONTW;
iMenuWidth      : signed 32;
iMenuHeight     : signed 32;
lfMenuFont      : LOGFONTW;
lfStatusFont    : LOGFONTW;
lfMessageFont   : LOGFONTW;
  end record;
  NONCLIENTMETRICSW = tagNONCLIENTMETRICSW;
  PNONCLIENTMETRICSW = ^tagNONCLIENTMETRICSW;
  LPNONCLIENTMETRICSW = ^tagNONCLIENTMETRICSW;

#if #declared UNICODE; then;
type
NONCLIENTMETRICS  = NONCLIENTMETRICSW;
type
PNONCLIENTMETRICS = PNONCLIENTMETRICSW;
type
LPNONCLIENTMETRICS = LPNONCLIENTMETRICSW;
#else;
type
NONCLIENTMETRICS  = NONCLIENTMETRICSA;
type
PNONCLIENTMETRICS = PNONCLIENTMETRICSA;
type
LPNONCLIENTMETRICS = LPNONCLIENTMETRICSA;
#end if;

const
  ARW_BOTTOMLEFT    = $00;

const
  ARW_BOTTOMRIGHT   = $01;

const
  ARW_TOPLEFT       = $02;

const
  ARW_TOPRIGHT      = $03;

const
  ARW_STARTMASK     = $03;

const
  ARW_STARTRIGHT    = $01;

const
  ARW_STARTTOP      = $02;

const
  ARW_LEFT          = $00;

const
  ARW_RIGHT         = $00;

const
  ARW_UP            = $04;

const
  ARW_DOWN          = $04;

const
  ARW_HIDE          = $08;

type
  tagMINIMIZEDMETRICS = record
cbSize          : UINT;
iWidth          : signed 32;
iHorzGap        : signed 32;
iVertGap        : signed 32;
iArrange        : signed 32;
  end record;
  MINIMIZEDMETRICS  = tagMINIMIZEDMETRICS;
  PMINIMIZEDMETRICS = ^tagMINIMIZEDMETRICS;
  LPMINIMIZEDMETRICS = ^tagMINIMIZEDMETRICS;

type
  tagICONMETRICSA   = record
cbSize          : UINT;
iHorzSpacing    : signed 32;
iVertSpacing    : signed 32;
iTitleWrap      : signed 32;
lfFont          : LOGFONTA;
  end record;
  ICONMETRICSA      = tagICONMETRICSA;
  PICONMETRICSA     = ^tagICONMETRICSA;
  LPICONMETRICSA    = ^tagICONMETRICSA;

type
  tagICONMETRICSW   = record
cbSize          : UINT;
iHorzSpacing    : signed 32;
iVertSpacing    : signed 32;
iTitleWrap      : signed 32;
lfFont          : LOGFONTW;
  end record;
  ICONMETRICSW      = tagICONMETRICSW;
  PICONMETRICSW     = ^tagICONMETRICSW;
  LPICONMETRICSW    = ^tagICONMETRICSW;

#if #declared UNICODE; then;
type
ICONMETRICS       = ICONMETRICSW;
type
PICONMETRICS      = PICONMETRICSW;
type
LPICONMETRICS     = LPICONMETRICSW;
#else;
type
ICONMETRICS       = ICONMETRICSA;
type
PICONMETRICS      = PICONMETRICSA;
type
LPICONMETRICS     = LPICONMETRICSA;
#end if;

type
  tagANIMATIONINFO  = record
cbSize          : UINT;
iMinAnimate     : signed 32;
  end record;
  ANIMATIONINFO     = tagANIMATIONINFO;
  LPANIMATIONINFO   = ^tagANIMATIONINFO;

type
  tagSERIALKEYSA    = record
cbSize          : UINT;
dwFlags         : DWORD;
lpszActivePort  : LPSTR;
lpszPort        : LPSTR;
iBaudRate       : UINT;
iPortState      : UINT;
iActive         : UINT;
  end record;
  SERIALKEYSA       = tagSERIALKEYSA;
  LPSERIALKEYSA     = ^tagSERIALKEYSA;

type
  tagSERIALKEYSW    = record
cbSize          : UINT;
dwFlags         : DWORD;
lpszActivePort  : LPWSTR;
lpszPort        : LPWSTR;
iBaudRate       : UINT;
iPortState      : UINT;
iActive         : UINT;
  end record;
  SERIALKEYSW       = tagSERIALKEYSW;
  LPSERIALKEYSW     = ^tagSERIALKEYSW;

#if #declared UNICODE; then;
type
SERIALKEYS        = SERIALKEYSW;
type
LPSERIALKEYS      = LPSERIALKEYSW;
#else;
type
SERIALKEYS        = SERIALKEYSA;
type
LPSERIALKEYS      = LPSERIALKEYSA;
#end if;

-- /* flags for SERIALKEYS dwFlags field 
const
  SERKF_SERIALKEYSON= $01;

const
  SERKF_AVAILABLE   = $02;

const
  SERKF_INDICATOR   = $04;

type
  tagHIGHCONTRASTA  = record
cbSize          : UINT;
dwFlags         : DWORD;
lpszDefaultScheme : LPSTR;
  end record;
  HIGHCONTRASTA     = tagHIGHCONTRASTA;
  LPHIGHCONTRASTA   = ^tagHIGHCONTRASTA;

type
  tagHIGHCONTRASTW  = record
cbSize          : UINT;
dwFlags         : DWORD;
lpszDefaultScheme : LPWSTR;
  end record;
  HIGHCONTRASTW     = tagHIGHCONTRASTW;
  LPHIGHCONTRASTW   = ^tagHIGHCONTRASTW;

#if #declared UNICODE; then;
type
HIGHCONTRAST      = HIGHCONTRASTW;
type
LPHIGHCONTRAST    = LPHIGHCONTRASTW;
#else;
type
HIGHCONTRAST      = HIGHCONTRASTA;
type
LPHIGHCONTRAST    = LPHIGHCONTRASTA;
#end if;

-- /* flags for HIGHCONTRAST dwFlags field 
const
  HCF_HIGHCONTRASTON= $01;

const
  HCF_AVAILABLE     = $02;

const
  HCF_HOTKEYACTIVE  = $04;

const
  HCF_CONFIRMHOTKEY = $08;

const
  HCF_HOTKEYSOUND   = $10;

const
  HCF_INDICATOR     = $20;

const
  HCF_HOTKEYAVAILABLE= $40;

-- /* Flags for ChangeDisplaySettings 
const
  CDS_UPDATEREGISTRY= $01;

const
  CDS_TEST          = $02;

const
  CDS_FULLSCREEN    = $04;

const
  CDS_GLOBAL        = $08;

const
  CDS_SET_PRIMARY   = $10;

const
  CDS_VIDEOPARAMETERS= $20;

const
  CDS_RESET         = $40000000;

const
  CDS_NORESET       = $10000000;

#separate tvout;
-- /* Return values for ChangeDisplaySettings 
const
  DISP_CHANGE_SUCCESSFUL= 0;

const
  DISP_CHANGE_RESTART= 1;

procedure ChangeDisplaySettingsA(
    lpDevMode       : in LPDEVMODEA; 
    dwFlags         : in DWORD)
                      return LONG;
#pragma convention(ChangeDisplaySettingsA,system);
#pragma import(ChangeDisplaySettingsA,'ChangeDisplaySettingsA','user32.dll');

procedure ChangeDisplaySettingsW(
    lpDevMode       : in LPDEVMODEW; 
    dwFlags         : in DWORD)
                      return LONG;
#pragma convention(ChangeDisplaySettingsW,system);
#pragma import(ChangeDisplaySettingsW,'ChangeDisplaySettingsW','user32.dll');

#if #declared UNICODE; then;
#template ChangeDisplaySettings;
  ChangeDisplaySettingsW 
#end ChangeDisplaySettings;
#else;
#template ChangeDisplaySettings;
  ChangeDisplaySettingsA 
#end ChangeDisplaySettings;
#end if;

procedure ChangeDisplaySettingsExA(
    lpszDeviceName  : in LPCSTR; 
    lpDevMode       : in LPDEVMODEA; 
    hwnd            : in t_HWND; 
    dwflags         : in DWORD; 
    lParam          : in LPVOID)
                      return LONG;
#pragma convention(ChangeDisplaySettingsExA,system);
#pragma import(ChangeDisplaySettingsExA,'ChangeDisplaySettingsExA','user32.dll');

procedure ChangeDisplaySettingsExW(
    lpszDeviceName  : in LPCWSTR; 
    lpDevMode       : in LPDEVMODEW; 
    hwnd            : in t_HWND; 
    dwflags         : in DWORD; 
    lParam          : in LPVOID)
                      return LONG;
#pragma convention(ChangeDisplaySettingsExW,system);
#pragma import(ChangeDisplaySettingsExW,'ChangeDisplaySettingsExW','user32.dll');

#if #declared UNICODE; then;
#template ChangeDisplaySettingsEx;
  ChangeDisplaySettingsExW 
#end ChangeDisplaySettingsEx;
#else;
#template ChangeDisplaySettingsEx;
  ChangeDisplaySettingsExA 
#end ChangeDisplaySettingsEx;
#end if;

procedure EnumDisplaySettingsA(
    lpszDeviceName  : in LPCSTR; 
    iModeNum        : in DWORD; 
    lpDevMode       : out _devicemodeA)
                      return BOOL;
#pragma convention(EnumDisplaySettingsA,system);
#pragma import(EnumDisplaySettingsA,'EnumDisplaySettingsA','user32.dll');

procedure EnumDisplaySettingsW(
    lpszDeviceName  : in LPCWSTR; 
    iModeNum        : in DWORD; 
    lpDevMode       : out _devicemodeW)
                      return BOOL;
#pragma convention(EnumDisplaySettingsW,system);
#pragma import(EnumDisplaySettingsW,'EnumDisplaySettingsW','user32.dll');

#if #declared UNICODE; then;
#template EnumDisplaySettings;
  EnumDisplaySettingsW 
#end EnumDisplaySettings;
#else;
#template EnumDisplaySettings;
  EnumDisplaySettingsA 
#end EnumDisplaySettings;
#end if;

procedure EnumDisplaySettingsExA(
    lpszDeviceName  : in LPCSTR; 
    iModeNum        : in DWORD; 
    lpDevMode       : out _devicemodeA; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(EnumDisplaySettingsExA,system);
#pragma import(EnumDisplaySettingsExA,'EnumDisplaySettingsExA','user32.dll');

procedure EnumDisplaySettingsExW(
    lpszDeviceName  : in LPCWSTR; 
    iModeNum        : in DWORD; 
    lpDevMode       : out _devicemodeW; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(EnumDisplaySettingsExW,system);
#pragma import(EnumDisplaySettingsExW,'EnumDisplaySettingsExW','user32.dll');

#if #declared UNICODE; then;
#template EnumDisplaySettingsEx;
  EnumDisplaySettingsExW 
#end EnumDisplaySettingsEx;
#else;
#template EnumDisplaySettingsEx;
  EnumDisplaySettingsExA 
#end EnumDisplaySettingsEx;
#end if;

-- /* Flags for EnumDisplaySettingsEx 
const
  EDS_RAWMODE       = $02;

procedure EnumDisplayDevicesA(
    lpDevice        : in LPCSTR; 
    iDevNum         : in DWORD; 
    lpDisplayDevice : out _DISPLAY_DEVICEA; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(EnumDisplayDevicesA,system);
#pragma import(EnumDisplayDevicesA,'EnumDisplayDevicesA','user32.dll');

procedure EnumDisplayDevicesW(
    lpDevice        : in LPCWSTR; 
    iDevNum         : in DWORD; 
    lpDisplayDevice : out _DISPLAY_DEVICEW; 
    dwFlags         : in DWORD)
                      return BOOL;
#pragma convention(EnumDisplayDevicesW,system);
#pragma import(EnumDisplayDevicesW,'EnumDisplayDevicesW','user32.dll');

#if #declared UNICODE; then;
#template EnumDisplayDevices;
  EnumDisplayDevicesW 
#end EnumDisplayDevices;
#else;
#template EnumDisplayDevices;
  EnumDisplayDevicesA 
#end EnumDisplayDevices;
#end if;

procedure SystemParametersInfoA(
    uiAction        : in UINT; 
    uiParam         : in UINT; 
    pvParam         : in out unchecked ; 
    fWinIni         : in UINT)
                      return BOOL;
#pragma convention(SystemParametersInfoA,system);
#pragma import(SystemParametersInfoA,'SystemParametersInfoA','user32.dll');

procedure SystemParametersInfoW(
    uiAction        : in UINT; 
    uiParam         : in UINT; 
    pvParam         : in out unchecked ; 
    fWinIni         : in UINT)
                      return BOOL;
#pragma convention(SystemParametersInfoW,system);
#pragma import(SystemParametersInfoW,'SystemParametersInfoW','user32.dll');

#if #declared UNICODE; then;
#template SystemParametersInfo;
  SystemParametersInfoW 
#end SystemParametersInfo;
#else;
#template SystemParametersInfo;
  SystemParametersInfoA 
#end SystemParametersInfo;
#end if;

-- /*
--  * Accessibility support
--  */
type
  tagFILTERKEYS     = record
cbSize          : UINT;
dwFlags         : DWORD;
iWaitMSec       : DWORD;
iDelayMSec      : DWORD;
iRepeatMSec     : DWORD;
iBounceMSec     : DWORD;
  end record;
  FILTERKEYS        = tagFILTERKEYS;
  LPFILTERKEYS      = ^tagFILTERKEYS;

-- /*
--  * FILTERKEYS dwFlags field
--  */
const
  FKF_FILTERKEYSON  = $01;

const
  FKF_AVAILABLE     = $02;

const
  FKF_HOTKEYACTIVE  = $04;

const
  FKF_CONFIRMHOTKEY = $08;

const
  FKF_HOTKEYSOUND   = $10;

const
  FKF_INDICATOR     = $20;

const
  FKF_CLICKON       = $40;

type
  tagSTICKYKEYS     = record
cbSize          : UINT;
dwFlags         : DWORD;
  end record;
  STICKYKEYS        = tagSTICKYKEYS;
  LPSTICKYKEYS      = ^tagSTICKYKEYS;

-- /*
--  * STICKYKEYS dwFlags field
--  */
const
  SKF_STICKYKEYSON  = $01;

const
  SKF_AVAILABLE     = $02;

const
  SKF_HOTKEYACTIVE  = $04;

const
  SKF_CONFIRMHOTKEY = $08;

const
  SKF_HOTKEYSOUND   = $10;

const
  SKF_INDICATOR     = $20;

const
  SKF_AUDIBLEFEEDBACK= $40;

const
  SKF_TRISTATE      = $80;

const
  SKF_TWOKEYSOFF    = $0100;

const
  SKF_LALTLATCHED   = $10000000;

const
  SKF_LCTLLATCHED   = $4000000;

const
  SKF_LSHIFTLATCHED = $1000000;

const
  SKF_RALTLATCHED   = $20000000;

const
  SKF_RCTLLATCHED   = $8000000;

const
  SKF_RSHIFTLATCHED = $2000000;

const
  SKF_LWINLATCHED   = $40000000;

const
  SKF_RWINLATCHED   = $80000000;

const
  SKF_LALTLOCKED    = $100000;

const
  SKF_LCTLLOCKED    = $40000;

const
  SKF_LSHIFTLOCKED  = $10000;

const
  SKF_RALTLOCKED    = $200000;

const
  SKF_RCTLLOCKED    = $80000;

const
  SKF_RSHIFTLOCKED  = $20000;

const
  SKF_LWINLOCKED    = $400000;

const
  SKF_RWINLOCKED    = $800000;

type
  tagMOUSEKEYS      = record
cbSize          : UINT;
dwFlags         : DWORD;
iMaxSpeed       : DWORD;
iTimeToMaxSpeed : DWORD;
iCtrlSpeed      : DWORD;
dwReserved1     : DWORD;
dwReserved2     : DWORD;
  end record;
  MOUSEKEYS         = tagMOUSEKEYS;
  LPMOUSEKEYS       = ^tagMOUSEKEYS;

-- /*
--  * MOUSEKEYS dwFlags field
--  */
const
  MKF_MOUSEKEYSON   = $01;

const
  MKF_AVAILABLE     = $02;

const
  MKF_HOTKEYACTIVE  = $04;

const
  MKF_CONFIRMHOTKEY = $08;

const
  MKF_HOTKEYSOUND   = $10;

const
  MKF_INDICATOR     = $20;

const
  MKF_MODIFIERS     = $40;

const
  MKF_REPLACENUMBERS= $80;

const
  MKF_LEFTBUTTONSEL = $10000000;

const
  MKF_RIGHTBUTTONSEL= $20000000;

const
  MKF_LEFTBUTTONDOWN= $1000000;

const
  MKF_RIGHTBUTTONDOWN= $2000000;

const
  MKF_MOUSEMODE     = $80000000;

type
  tagACCESSTIMEOUT  = record
cbSize          : UINT;
dwFlags         : DWORD;
iTimeOutMSec    : DWORD;
  end record;
  ACCESSTIMEOUT     = tagACCESSTIMEOUT;
  LPACCESSTIMEOUT   = ^tagACCESSTIMEOUT;

-- /*
--  * ACCESSTIMEOUT dwFlags field
--  */
const
  ATF_TIMEOUTON     = $01;

const
  ATF_ONOFFFEEDBACK = $02;

-- /* values for SOUNDSENTRY iFSGrafEffect field 
const
  SSGF_NONE         = 0;

const
  SSGF_DISPLAY      = 3;

-- /* values for SOUNDSENTRY iFSTextEffect field 
const
  SSTF_NONE         = 0;

const
  SSTF_CHARS        = 1;

const
  SSTF_BORDER       = 2;

const
  SSTF_DISPLAY      = 3;

-- /* values for SOUNDSENTRY iWindowsEffect field 
const
  SSWF_NONE         = 0;

const
  SSWF_TITLE        = 1;

const
  SSWF_WINDOW       = 2;

const
  SSWF_DISPLAY      = 3;

const
  SSWF_CUSTOM       = 4;

type
  tagSOUNDSENTRYA   = record
cbSize          : UINT;
dwFlags         : DWORD;
iFSTextEffect   : DWORD;
iFSTextEffectMSec : DWORD;
iFSTextEffectColorBits : DWORD;
iFSGrafEffect   : DWORD;
iFSGrafEffectMSec : DWORD;
iFSGrafEffectColor : DWORD;
iWindowsEffect  : DWORD;
iWindowsEffectMSec : DWORD;
lpszWindowsEffectDLL : LPSTR;
iWindowsEffectOrdinal : DWORD;
  end record;
  SOUNDSENTRYA      = tagSOUNDSENTRYA;
  LPSOUNDSENTRYA    = ^tagSOUNDSENTRYA;

type
  tagSOUNDSENTRYW   = record
cbSize          : UINT;
dwFlags         : DWORD;
iFSTextEffect   : DWORD;
iFSTextEffectMSec : DWORD;
iFSTextEffectColorBits : DWORD;
iFSGrafEffect   : DWORD;
iFSGrafEffectMSec : DWORD;
iFSGrafEffectColor : DWORD;
iWindowsEffect  : DWORD;
iWindowsEffectMSec : DWORD;
lpszWindowsEffectDLL : LPWSTR;
iWindowsEffectOrdinal : DWORD;
  end record;
  SOUNDSENTRYW      = tagSOUNDSENTRYW;
  LPSOUNDSENTRYW    = ^tagSOUNDSENTRYW;

#if #declared UNICODE; then;
type
SOUNDSENTRY       = SOUNDSENTRYW;
type
LPSOUNDSENTRY     = LPSOUNDSENTRYW;
#else;
type
SOUNDSENTRY       = SOUNDSENTRYA;
type
LPSOUNDSENTRY     = LPSOUNDSENTRYA;
#end if;

-- /*
--  * SOUNDSENTRY dwFlags field
--  */
const
  SSF_SOUNDSENTRYON = $01;

const
  SSF_AVAILABLE     = $02;

const
  SSF_INDICATOR     = $04;

type
  tagTOGGLEKEYS     = record
cbSize          : UINT;
dwFlags         : DWORD;
  end record;
  TOGGLEKEYS        = tagTOGGLEKEYS;
  LPTOGGLEKEYS      = ^tagTOGGLEKEYS;

-- /*
--  * TOGGLEKEYS dwFlags field
--  */
const
  TKF_TOGGLEKEYSON  = $01;

const
  TKF_AVAILABLE     = $02;

const
  TKF_HOTKEYACTIVE  = $04;

const
  TKF_CONFIRMHOTKEY = $08;

const
  TKF_HOTKEYSOUND   = $10;

const
  TKF_INDICATOR     = $20;

-- /*
--  * Set debug level
--  */
procedure SetDebugErrorLevel(
    dwLevel         : in DWORD);
#pragma convention(SetDebugErrorLevel,system);
#pragma import(SetDebugErrorLevel,'SetDebugErrorLevel','user32.dll');

-- /*
--  * SetLastErrorEx() types.
--  */
const
  SLE_ERROR         = $01;

const
  SLE_MINORERROR    = $02;

const
  SLE_WARNING       = $03;

procedure SetLastErrorEx(
    dwErrCode       : in DWORD; 
    dwType          : in DWORD);
#pragma convention(SetLastErrorEx,system);
#pragma import(SetLastErrorEx,'SetLastErrorEx','user32.dll');

type
t_369=signed 32;

  t_370 = signed 32;

procedure InternalGetWindowText(
    hWnd            : in t_HWND; 
    lpString        : out WCHARSTR ; 
    nMaxCount       : in t_369)
                      return t_370;
#pragma convention(InternalGetWindowText,system);
#pragma import(InternalGetWindowText,'InternalGetWindowText','user32.dll');

-- /*
--  * Multimonitor API.
--  */
const
  MONITOR_DEFAULTTONULL= $00;

const
  MONITOR_DEFAULTTOPRIMARY= $01;

const
  MONITOR_DEFAULTTONEAREST= $02;

procedure MonitorFromPoint(
    pt              : in t_POINT; 
    dwFlags         : in DWORD)
                      return t_HMONITOR;
#pragma convention(MonitorFromPoint,system);
#pragma import(MonitorFromPoint,'MonitorFromPoint','user32.dll');

procedure MonitorFromRect(
    lprc            : in LPCRECT; 
    dwFlags         : in DWORD)
                      return t_HMONITOR;
#pragma convention(MonitorFromRect,system);
#pragma import(MonitorFromRect,'MonitorFromRect','user32.dll');

procedure MonitorFromWindow(
    hwnd            : in t_HWND; 
    dwFlags         : in DWORD)
                      return t_HMONITOR;
#pragma convention(MonitorFromWindow,system);
#pragma import(MonitorFromWindow,'MonitorFromWindow','user32.dll');

const
  MONITORINFOF_PRIMARY= $01;

type
  tagMONITORINFO    = record
cbSize          : DWORD;
rcMonitor       : RECT;
rcWork          : RECT;
dwFlags         : DWORD;
  end record;
  MONITORINFO       = tagMONITORINFO;
  LPMONITORINFO     = ^tagMONITORINFO;

type
  tagMONITORINFOEXA = record
szDevice        : array 0..CCHDEVICENAME-1 of CHAR;
  end record;
  MONITORINFOEXA    = tagMONITORINFOEXA;
  LPMONITORINFOEXA  = ^tagMONITORINFOEXA;

type
  tagMONITORINFOEXW = record
szDevice        : array 0..CCHDEVICENAME-1 of WCHAR;
  end record;
  MONITORINFOEXW    = tagMONITORINFOEXW;
  LPMONITORINFOEXW  = ^tagMONITORINFOEXW;

#if #declared UNICODE; then;
type
MONITORINFOEX     = MONITORINFOEXW;
type
LPMONITORINFOEX   = LPMONITORINFOEXW;
#else;
type
MONITORINFOEX     = MONITORINFOEXA;
type
LPMONITORINFOEX   = LPMONITORINFOEXA;
#end if;

procedure GetMonitorInfoA(
    hMonitor        : in t_HMONITOR; 
    lpmi            : out tagMONITORINFO)
                      return BOOL;
#pragma convention(GetMonitorInfoA,system);
#pragma import(GetMonitorInfoA,'GetMonitorInfoA','user32.dll');

procedure GetMonitorInfoW(
    hMonitor        : in t_HMONITOR; 
    lpmi            : out tagMONITORINFO)
                      return BOOL;
#pragma convention(GetMonitorInfoW,system);
#pragma import(GetMonitorInfoW,'GetMonitorInfoW','user32.dll');

#if #declared UNICODE; then;
#template GetMonitorInfo;
  GetMonitorInfoW 
#end GetMonitorInfo;
#else;
#template GetMonitorInfo;
  GetMonitorInfoA 
#end GetMonitorInfo;
#end if;

type
MONITORENUMPROC   = ^procedure (
    _001            : t_HMONITOR;
    _002            : t_HDC;
    _003            : p_RECT;
    _004            : t_LPARAM)
                      return BOOL for machine_pointer use true;
procedure EnumDisplayMonitors(
    hdc             : in t_HDC; 
    lprcClip        : in LPCRECT; 
    lpfnEnum        : in MONITORENUMPROC; 
    dwData          : in t_LPARAM)
                      return BOOL;
#pragma convention(EnumDisplayMonitors,system);
#pragma import(EnumDisplayMonitors,'EnumDisplayMonitors','user32.dll');

-- /*
--  * WinEvents - Active Accessibility hooks
--  */
procedure NotifyWinEvent(
    event           : in DWORD; 
    hwnd            : in t_HWND; 
    idObject        : in LONG; 
    idChild         : in LONG);
#pragma convention(NotifyWinEvent,system);
#pragma import(NotifyWinEvent,'NotifyWinEvent','user32.dll');

type
WINEVENTPROC      = ^procedure (
    hWinEventHook   : t_HWINEVENTHOOK;
    event           : DWORD;
    hwnd            : t_HWND;
    idObject        : LONG;
    idChild         : LONG;
    idEventThread   : DWORD;
    dwmsEventTime   : DWORD) for machine_pointer use true;
procedure SetWinEventHook(
    eventMin        : in DWORD; 
    eventMax        : in DWORD; 
    hmodWinEventProc : in t_HMODULE; 
    pfnWinEventProc : in WINEVENTPROC; 
    idProcess       : in DWORD; 
    idThread        : in DWORD; 
    dwFlags         : in DWORD)
                      return t_HWINEVENTHOOK;
#pragma convention(SetWinEventHook,system);
#pragma import(SetWinEventHook,'SetWinEventHook','user32.dll');

procedure IsWinEventHookInstalled(
    event           : in DWORD)
                      return BOOL;
#pragma convention(IsWinEventHookInstalled,system);
#pragma import(IsWinEventHookInstalled,'IsWinEventHookInstalled','user32.dll');

-- /*
--  * dwFlags for SetWinEventHook
--  */
const
  WINEVENT_OUTOFCONTEXT= $00;

const
  WINEVENT_SKIPOWNTHREAD= $01;

const
  WINEVENT_SKIPOWNPROCESS= $02;

const
  WINEVENT_INCONTEXT= $04;

procedure UnhookWinEvent(
    hWinEventHook   : in t_HWINEVENTHOOK)
                      return BOOL;
#pragma convention(UnhookWinEvent,system);
#pragma import(UnhookWinEvent,'UnhookWinEvent','user32.dll');

-- /*
--  * idObject values for WinEventProc and NotifyWinEvent
--  */
-- /*
--  * hwnd + idObject can be used with OLEACC.DLL's OleGetObjectFromWindow()
--  * to get an interface pointer to the container.  indexChild is the item
--  * within the container in question.  Setup a VARIANT with vt VT_I4 and
--  * lVal the indexChild and pass that in to all methods.  Then you
--  * are raring to go.
--  */
-- /*
--  * Common object IDs (cookies, only for sending WM_GETOBJECT to get at the
--  * thing in question).  Positive IDs are reserved for apps (app specific),
--  * negative IDs are system things and are global, 0 means "just little old
--  * me".
--  */
const
  CHILDID_SELF      = 0;

const
  INDEXID_OBJECT    = 0;

const
  INDEXID_CONTAINER = 0;

-- /*
--  * Reserved IDs for system objects
--  */
-- /*
--  * EVENT DEFINITION
--  */
const
  EVENT_MIN         = $01;

const
  EVENT_MAX         = $7FFFFFFF;

-- /*
--  *  EVENT_SYSTEM_SOUND
--  *  Sent when a sound is played.  Currently nothing is generating this, we
--  *  this event when a system sound (for menus, etc) is played.  Apps
--  *  generate this, if accessible, when a private sound is played.  For
--  *  example, if Mail plays a "New Mail" sound.
--  *
--  *  System Sounds:
--  *  (Generated by PlaySoundEvent in USER itself)
--  *      hwnd            is NULL
--  *      idObject        is OBJID_SOUND
--  *      idChild         is sound child ID if one
--  *  App Sounds:
--  *  (PlaySoundEvent won't generate notification; up to app)
--  *      hwnd + idObject gets interface pointer to Sound object
--  *      idChild identifies the sound in question
--  *  are going to be cleaning up the SOUNDSENTRY feature in the control panel
--  *  and will use this at that time.  Applications implementing WinEvents
--  *  are perfectly welcome to use it.  Clients of IAccessible* will simply
--  *  turn around and get back a non-visual object that describes the sound.
--  */
const
  EVENT_SYSTEM_SOUND= $01;

-- /*
--  * EVENT_SYSTEM_ALERT
--  * System Alerts:
--  * (Generated by MessageBox() calls for example)
--  *      hwnd            is hwndMessageBox
--  *      idObject        is OBJID_ALERT
--  * App Alerts:
--  * (Generated whenever)
--  *      hwnd+idObject gets interface pointer to Alert
--  */
const
  EVENT_SYSTEM_ALERT= $02;

-- /*
--  * EVENT_SYSTEM_FOREGROUND
--  * Sent when the foreground (active) window changes, even if it is changing
--  * to another window in the same thread as the previous one.
--  *      hwnd            is hwndNewForeground
--  *      idObject        is OBJID_WINDOW
--  *      idChild    is INDEXID_OBJECT
--  */
const
  EVENT_SYSTEM_FOREGROUND= $03;

-- /*
--  * Menu
--  *      hwnd            is window (top level window or popup menu window)
--  *      idObject        is ID of control (OBJID_MENU, OBJID_SYSMENU, OBJID_SELF for popup)
--  *      idChild         is CHILDID_SELF
--  *
--  * EVENT_SYSTEM_MENUSTART
--  * EVENT_SYSTEM_MENUEND
--  * For MENUSTART, hwnd+idObject+idChild refers to the control with the menu bar,
--  *  or the control bringing up the context menu.
--  *
--  * Sent when entering into and leaving from menu mode (system, app bar, and
--  * track popups).
--  */
const
  EVENT_SYSTEM_MENUSTART= $04;

const
  EVENT_SYSTEM_MENUEND= $05;

-- /*
--  * EVENT_SYSTEM_MENUPOPUPSTART
--  * EVENT_SYSTEM_MENUPOPUPEND
--  * Sent when a menu popup comes up and just before it is taken down.  Note
--  * that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART
--  * followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup
--  * being shown.
--  *
--  * For MENUPOPUP, hwnd+idObject+idChild refers to the NEW popup coming up, not the
--  * parent item which is hierarchical.  You can get the parent menu/popup by
--  * asking for the accParent object.
--  */
const
  EVENT_SYSTEM_MENUPOPUPSTART= $06;

const
  EVENT_SYSTEM_MENUPOPUPEND= $07;

-- /*
--  * EVENT_SYSTEM_CAPTURESTART
--  * EVENT_SYSTEM_CAPTUREEND
--  * Sent when a window takes the capture and releases the capture.
--  */
const
  EVENT_SYSTEM_CAPTURESTART= $08;

const
  EVENT_SYSTEM_CAPTUREEND= $09;

-- /*
--  * Move Size
--  * EVENT_SYSTEM_MOVESIZESTART
--  * EVENT_SYSTEM_MOVESIZEEND
--  * Sent when a window enters and leaves move-size dragging mode.
--  */
const
  EVENT_SYSTEM_MOVESIZESTART= $0A;

const
  EVENT_SYSTEM_MOVESIZEEND= $0B;

-- /*
--  * Context Help
--  * EVENT_SYSTEM_CONTEXTHELPSTART
--  * EVENT_SYSTEM_CONTEXTHELPEND
--  * Sent when a window enters and leaves context sensitive help mode.
--  */
const
  EVENT_SYSTEM_CONTEXTHELPSTART= $0C;

const
  EVENT_SYSTEM_CONTEXTHELPEND= $0D;

-- /*
--  * Drag & Drop
--  * EVENT_SYSTEM_DRAGDROPSTART
--  * EVENT_SYSTEM_DRAGDROPEND
--  * Send the START notification just before going into drag&drop loop.  Send
--  * the END notification just after canceling out.
--  * Note that it is up to apps and OLE to generate this, since the system
--  * doesn't know.  Like EVENT_SYSTEM_SOUND, it will be a while before this
--  * is prevalent.
--  */
const
  EVENT_SYSTEM_DRAGDROPSTART= $0E;

const
  EVENT_SYSTEM_DRAGDROPEND= $0F;

-- /*
--  * Dialog
--  * Send the START notification right after the dialog is completely
--  *  initialized and visible.  Send the END right before the dialog
--  *  is hidden and goes away.
--  * EVENT_SYSTEM_DIALOGSTART
--  * EVENT_SYSTEM_DIALOGEND
--  */
const
  EVENT_SYSTEM_DIALOGSTART= $10;

const
  EVENT_SYSTEM_DIALOGEND= $11;

-- /*
--  * EVENT_SYSTEM_SCROLLING
--  * EVENT_SYSTEM_SCROLLINGSTART
--  * EVENT_SYSTEM_SCROLLINGEND
--  * Sent when beginning and ending the tracking of a scrollbar in a window,
--  * and also for scrollbar controls.
--  */
const
  EVENT_SYSTEM_SCROLLINGSTART= $12;

const
  EVENT_SYSTEM_SCROLLINGEND= $13;

-- /*
--  * Alt-Tab Window
--  * Send the START notification right after the switch window is initialized
--  * and visible.  Send the END right before it is hidden and goes away.
--  * EVENT_SYSTEM_SWITCHSTART
--  * EVENT_SYSTEM_SWITCHEND
--  */
const
  EVENT_SYSTEM_SWITCHSTART= $14;

const
  EVENT_SYSTEM_SWITCHEND= $15;

-- /*
--  * EVENT_SYSTEM_MINIMIZESTART
--  * EVENT_SYSTEM_MINIMIZEEND
--  * Sent when a window minimizes and just before it restores.
--  */
const
  EVENT_SYSTEM_MINIMIZESTART= $16;

const
  EVENT_SYSTEM_MINIMIZEEND= $17;

const
  EVENT_CONSOLE_CARET= $4001;

const
  EVENT_CONSOLE_UPDATE_REGION= $4002;

const
  EVENT_CONSOLE_UPDATE_SIMPLE= $4003;

const
  EVENT_CONSOLE_UPDATE_SCROLL= $4004;

const
  EVENT_CONSOLE_LAYOUT= $4005;

const
  EVENT_CONSOLE_START_APPLICATION= $4006;

const
  EVENT_CONSOLE_END_APPLICATION= $4007;

-- /*
--  * Flags for EVENT_CONSOLE_START/END_APPLICATION.
--  */
const
  CONSOLE_APPLICATION_16BIT= $01;

-- /*
--  * Flags for EVENT_CONSOLE_CARET
--  */
const
  CONSOLE_CARET_SELECTION= $01;

const
  CONSOLE_CARET_VISIBLE= $02;

-- /*
--  * Object events
--  *
--  * The system AND apps generate these.  The system generates these for
--  * real windows.  Apps generate these for objects within their window which
--  * act like a separate control, e.g. an item in a list view.
--  *
--  * When the system generate them, dwParam2 is always WMOBJID_SELF.  When
--  * apps generate them, apps put the has-meaning-to-the-app-only ID value
--  * in dwParam2.
--  * For all events, if you want detailed accessibility information, callers
--  * should
--  *      * Call AccessibleObjectFromWindow() with the hwnd, idObject parameters
--  *          of the event, and IID_IAccessible as the REFIID, to get back an
--  *          IAccessible* to talk to
--  *      * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild
--  *          parameter of the event.
--  *      * If idChild isn't zero, call get_accChild() in the container to see
--  *          if the child is an object in its own right.  If so, you will get
--  *          back an IDispatch* object for the child.  You should release the
--  *          parent, and call QueryInterface() on the child object to get its
--  *          IAccessible*.  Then you talk directly to the child.  Otherwise,
--  *          if get_accChild() returns you nothing, you should continue to
--  *          use the child VARIANT.  You will ask the container for the properties
--  *          of the child identified by the VARIANT.  In other words, the
--  *          child in this case is accessible but not a full-blown object.
--  *          Like a button on a titlebar which is 'small' and has no children.
--  */
-- /*
--  * For all EVENT_OBJECT events,
--  *      hwnd is the dude to Send the WM_GETOBJECT message to (unless NULL,
--  *          see above for system things)
--  *      idObject is the ID of the object that can resolve any queries a
--  *          client might have.  It's a way to deal with windowless controls,
--  *          controls that are just drawn on the screen in some larger parent
--  *          window (like SDM), or standard frame elements of a window.
--  *      idChild is the piece inside of the object that is affected.  This
--  *          allows clients to access things that are too small to have full
--  *          blown objects in their own right.  Like the thumb of a scrollbar.
--  *          The hwnd/idObject pair gets you to the container, the dude you
--  *          probably want to talk to most of the time anyway.  The idChild
--  *          can then be passed into the acc properties to get the name/value
--  *          of it as needed.
--  *
--  * Example #1:
--  *      System propagating a listbox selection change
--  *      EVENT_OBJECT_SELECTION
--  *          hwnd == listbox hwnd
--  *          idObject == OBJID_WINDOW
--  *          idChild == new selected item, or CHILDID_SELF if
--  *              nothing now selected within container.
--  *      Word '97 propagating a listbox selection change
--  *          hwnd == SDM window
--  *          idObject == SDM ID to get at listbox 'control'
--  *          idChild == new selected item, or CHILDID_SELF if
--  *              nothing
--  *
--  * Example #2:
--  *      System propagating a menu item selection on the menu bar
--  *      EVENT_OBJECT_SELECTION
--  *          hwnd == top level window
--  *          idObject == OBJID_MENU
--  *          idChild == ID of child menu bar item selected
--  *
--  * Example #3:
--  *      System propagating a dropdown coming off of said menu bar item
--  *      EVENT_OBJECT_CREATE
--  *          hwnd == popup item
--  *          idObject == OBJID_WINDOW
--  *          idChild == CHILDID_SELF
--  *
--  * Example #4:
--  *
--  * For EVENT_OBJECT_REORDER, the object referred to by hwnd/idObject is the
--  * PARENT container in which the zorder is occurring.  This is because if
--  * one child is zordering, all of them are changing their relative zorder.
--  */
const
  EVENT_OBJECT_CREATE= $8000;

const
  EVENT_OBJECT_DESTROY= $8001;

const
  EVENT_OBJECT_SHOW = $8002;

const
  EVENT_OBJECT_HIDE = $8003;

const
  EVENT_OBJECT_REORDER= $8004;

-- /*
--  * NOTE:
--  * Minimize the number of notifications!
--  *
--  * When you are hiding a parent object, obviously all child objects are no
--  * longer visible on screen.  They still have the same "visible" status,
--  * but are not truly visible.  Hence do not send HIDE notifications for the
--  * children also.  One implies all.  The same goes for SHOW.
--  */
const
  EVENT_OBJECT_FOCUS= $8005;

const
  EVENT_OBJECT_SELECTION= $8006;

const
  EVENT_OBJECT_SELECTIONADD= $8007;

const
  EVENT_OBJECT_SELECTIONREMOVE= $8008;

const
  EVENT_OBJECT_SELECTIONWITHIN= $8009;

-- /*
--  * NOTES:
--  * There is only one "focused" child item in a parent.  This is the place
--  * keystrokes are going at a given moment.  Hence only send a notification
--  * about where the NEW focus is going.  A NEW item getting the focus already
--  * implies that the OLD item is losing it.
--  *
--  * SELECTION however can be multiple.  Hence the different SELECTION
--  * notifications.  Here's when to use each:
--  *
--  * (1) Send a SELECTION notification in the simple single selection
--  *     case (like the focus) when the item with the selection is
--  *     merely moving to a different item within a container.  hwnd + ID
--  *     is the container control, idChildItem is the new child with the
--  *     selection.
--  *
--  * (2) Send a SELECTIONADD notification when a new item has simply been added
--  *     to the selection within a container.  This is appropriate when the
--  *     number of newly selected items is very small.  hwnd + ID is the
--  *     container control, idChildItem is the new child added to the selection.
--  *
--  * (3) Send a SELECTIONREMOVE notification when a new item has simply been
--  *     removed from the selection within a container.  This is appropriate
--  *     when the number of newly selected items is very small, just like
--  *     SELECTIONADD.  hwnd + ID is the container control, idChildItem is the
--  *     new child removed from the selection.
--  *
--  * (4) Send a SELECTIONWITHIN notification when the selected items within a
--  *     control have changed substantially.  Rather than propagate a large
--  *     number of changes to reflect removal for some items, addition of
--  *     others, just tell somebody who cares that a lot happened.  It will
--  *     be faster an easier for somebody watching to just turn around and
--  *     query the container control what the new bunch of selected items
--  *     are.
--  */
const
  EVENT_OBJECT_STATECHANGE= $800A;

-- /*
--  * Examples of when to send an EVENT_OBJECT_STATECHANGE include
--  *      * It is being enabled/disabled (USER does for windows)
--  *      * It is being pressed/released (USER does for buttons)
--  *      * It is being checked/unchecked (USER does for radio/check buttons)
--  */
const
  EVENT_OBJECT_LOCATIONCHANGE= $800B;

-- /*
--  * Note:
--  * A LOCATIONCHANGE is not sent for every child object when the parent
--  * changes shape/moves.  Send one notification for the topmost object
--  * that is changing.  For example, if the user resizes a top level window,
--  * USER will generate a LOCATIONCHANGE for it, but not for the menu bar,
--  * title bar, scrollbars, etc.  that are also changing shape/moving.
--  *
--  * In other words, it only generates LOCATIONCHANGE notifications for
--  * real windows that are moving/sizing.  It will not generate a LOCATIONCHANGE
--  * for every non-floating child window when the parent moves (the children are
--  * logically moving also on screen, but not relative to the parent).
--  *
--  * Now, if the app itself resizes child windows as a result of being
--  * sized, USER will generate LOCATIONCHANGEs for those dudes also because
--  * it doesn't know better.
--  *
--  * Note also that USER will generate LOCATIONCHANGE notifications for two
--  * non-window sys objects:
--  *      (1) System caret
--  *      (2) Cursor
--  */
const
  EVENT_OBJECT_NAMECHANGE= $800C;

const
  EVENT_OBJECT_DESCRIPTIONCHANGE= $800D;

const
  EVENT_OBJECT_VALUECHANGE= $800E;

const
  EVENT_OBJECT_PARENTCHANGE= $800F;

const
  EVENT_OBJECT_HELPCHANGE= $8010;

const
  EVENT_OBJECT_DEFACTIONCHANGE= $8011;

const
  EVENT_OBJECT_ACCELERATORCHANGE= $8012;

-- /*
--  * Child IDs
--  */
-- /*
--  * System Sounds (idChild of system SOUND notification)
--  */
const
  SOUND_SYSTEM_STARTUP= 1;

const
  SOUND_SYSTEM_SHUTDOWN= 2;

const
  SOUND_SYSTEM_BEEP = 3;

const
  SOUND_SYSTEM_ERROR= 4;

const
  SOUND_SYSTEM_QUESTION= 5;

const
  SOUND_SYSTEM_WARNING= 6;

const
  SOUND_SYSTEM_INFORMATION= 7;

const
  SOUND_SYSTEM_MAXIMIZE= 8;

const
  SOUND_SYSTEM_MINIMIZE= 9;

const
  SOUND_SYSTEM_RESTOREUP= 10;

const
  SOUND_SYSTEM_RESTOREDOWN= 11;

const
  SOUND_SYSTEM_APPSTART= 12;

const
  SOUND_SYSTEM_FAULT= 13;

const
  SOUND_SYSTEM_APPEND= 14;

const
  SOUND_SYSTEM_MENUCOMMAND= 15;

const
  SOUND_SYSTEM_MENUPOPUP= 16;

const
  CSOUND_SYSTEM     = 16;

-- /*
--  * System Alerts (indexChild of system ALERT notification)
--  */
const
  ALERT_SYSTEM_INFORMATIONAL= 1;

const
  ALERT_SYSTEM_WARNING= 2;

const
  ALERT_SYSTEM_ERROR= 3;

const
  ALERT_SYSTEM_QUERY= 4;

const
  ALERT_SYSTEM_CRITICAL= 5;

const
  CALERT_SYSTEM     = 6;

type
  tagGUITHREADINFO  = record
cbSize          : DWORD;
flags           : DWORD;
hwndActive      : t_HWND;
hwndFocus       : t_HWND;
hwndCapture     : t_HWND;
hwndMenuOwner   : t_HWND;
hwndMoveSize    : t_HWND;
hwndCaret       : t_HWND;
rcCaret         : RECT;
  end record;
  GUITHREADINFO     = tagGUITHREADINFO;
  PGUITHREADINFO    = ^tagGUITHREADINFO;
  LPGUITHREADINFO   = ^tagGUITHREADINFO;

const
  GUI_CARETBLINKING = $01;

const
  GUI_INMOVESIZE    = $02;

const
  GUI_INMENUMODE    = $04;

const
  GUI_SYSTEMMENUMODE= $08;

const
  GUI_POPUPMENUMODE = $10;

const
  GUI_16BITTASK     = $20;

procedure GetGUIThreadInfo(
    idThread        : in DWORD; 
    pgui            : out tagGUITHREADINFO)
                      return BOOL;
#pragma convention(GetGUIThreadInfo,system);
#pragma import(GetGUIThreadInfo,'GetGUIThreadInfo','user32.dll');

procedure GetWindowModuleFileNameA(
    hwnd            : in t_HWND; 
    pszFileName     : out CHARSTR ; 
    cchFileNameMax  : in UINT)
                      return UINT;
#pragma convention(GetWindowModuleFileNameA,system);
#pragma import(GetWindowModuleFileNameA,'GetWindowModuleFileNameA','user32.dll');

procedure GetWindowModuleFileNameW(
    hwnd            : in t_HWND; 
    pszFileName     : out WCHARSTR ; 
    cchFileNameMax  : in UINT)
                      return UINT;
#pragma convention(GetWindowModuleFileNameW,system);
#pragma import(GetWindowModuleFileNameW,'GetWindowModuleFileNameW','user32.dll');

#if #declared UNICODE; then;
#template GetWindowModuleFileName;
  GetWindowModuleFileNameW 
#end GetWindowModuleFileName;
#else;
#template GetWindowModuleFileName;
  GetWindowModuleFileNameA 
#end GetWindowModuleFileName;
#end if;

const
  STATE_SYSTEM_UNAVAILABLE= $01;

const
  STATE_SYSTEM_SELECTED= $02;

const
  STATE_SYSTEM_FOCUSED= $04;

const
  STATE_SYSTEM_PRESSED= $08;

const
  STATE_SYSTEM_CHECKED= $10;

const
  STATE_SYSTEM_MIXED= $20;

const
  STATE_SYSTEM_READONLY= $40;

const
  STATE_SYSTEM_HOTTRACKED= $80;

const
  STATE_SYSTEM_DEFAULT= $0100;

const
  STATE_SYSTEM_EXPANDED= $0200;

const
  STATE_SYSTEM_COLLAPSED= $0400;

const
  STATE_SYSTEM_BUSY = $0800;

const
  STATE_SYSTEM_FLOATING= $1000;

const
  STATE_SYSTEM_MARQUEED= $2000;

const
  STATE_SYSTEM_ANIMATED= $4000;

const
  STATE_SYSTEM_INVISIBLE= $8000;

const
  STATE_SYSTEM_OFFSCREEN= $10000;

const
  STATE_SYSTEM_SIZEABLE= $20000;

const
  STATE_SYSTEM_MOVEABLE= $40000;

const
  STATE_SYSTEM_SELFVOICING= $80000;

const
  STATE_SYSTEM_FOCUSABLE= $100000;

const
  STATE_SYSTEM_SELECTABLE= $200000;

const
  STATE_SYSTEM_LINKED= $400000;

const
  STATE_SYSTEM_TRAVERSED= $800000;

const
  STATE_SYSTEM_MULTISELECTABLE= $1000000;

const
  STATE_SYSTEM_EXTSELECTABLE= $2000000;

const
  STATE_SYSTEM_ALERT_LOW= $4000000;

const
  STATE_SYSTEM_ALERT_MEDIUM= $8000000;

const
  STATE_SYSTEM_ALERT_HIGH= $10000000;

const
  STATE_SYSTEM_PROTECTED= $20000000;

const
  STATE_SYSTEM_VALID= $3FFFFFFF;

const
  CCHILDREN_TITLEBAR= 5;

const
  CCHILDREN_SCROLLBAR= 5;

-- /*
--  * Information about the global cursor.
--  */
type
  tagCURSORINFO     = record
cbSize          : DWORD;
flags           : DWORD;
hCursor         : t_HCURSOR;
ptScreenPos     : t_POINT;
  end record;
  CURSORINFO        = tagCURSORINFO;
  PCURSORINFO       = ^tagCURSORINFO;
  LPCURSORINFO      = ^tagCURSORINFO;

const
  CURSOR_SHOWING    = $01;

procedure GetCursorInfo(
    pci             : out tagCURSORINFO)
                      return BOOL;
#pragma convention(GetCursorInfo,system);
#pragma import(GetCursorInfo,'GetCursorInfo','user32.dll');

-- /*
--  * Window information snapshot
--  */
type
  tagWINDOWINFO     = record
cbSize          : DWORD;
rcWindow        : RECT;
rcClient        : RECT;
dwStyle         : DWORD;
dwExStyle       : DWORD;
dwWindowStatus  : DWORD;
cxWindowBorders : UINT;
cyWindowBorders : UINT;
atomWindowType  : ATOM;
wCreatorVersion : WORD;
  end record;
  WINDOWINFO        = tagWINDOWINFO;
  PWINDOWINFO       = ^tagWINDOWINFO;
  LPWINDOWINFO      = ^tagWINDOWINFO;

const
  WS_ACTIVECAPTION  = $01;

procedure GetWindowInfo(
    hwnd            : in t_HWND; 
    pwi             : out tagWINDOWINFO)
                      return BOOL;
#pragma convention(GetWindowInfo,system);
#pragma import(GetWindowInfo,'GetWindowInfo','user32.dll');

-- /*
--  * Titlebar information.
--  */
type
  tagTITLEBARINFO   = record
cbSize          : DWORD;
rcTitleBar      : RECT;
rgstate         : array 0..0 of DWORD;
  end record;
  TITLEBARINFO      = tagTITLEBARINFO;
  PTITLEBARINFO     = ^tagTITLEBARINFO;
  LPTITLEBARINFO    = ^tagTITLEBARINFO;

procedure GetTitleBarInfo(
    hwnd            : in t_HWND; 
    pti             : out tagTITLEBARINFO)
                      return BOOL;
#pragma convention(GetTitleBarInfo,system);
#pragma import(GetTitleBarInfo,'GetTitleBarInfo','user32.dll');

-- /*
--  * Menubar information
--  */
type
  tagMENUBARINFO    = record
cbSize          : DWORD;
rcBar           : RECT;
hMenu           : t_HMENU;
hwndMenu        : t_HWND;
fBarFocused     : BOOL {:1};
fFocused        : BOOL {:1};
  end record;
  MENUBARINFO       = tagMENUBARINFO;
  PMENUBARINFO      = ^tagMENUBARINFO;
  LPMENUBARINFO     = ^tagMENUBARINFO;

procedure GetMenuBarInfo(
    hwnd            : in t_HWND; 
    idObject        : in LONG; 
    idItem          : in LONG; 
    pmbi            : out tagMENUBARINFO)
                      return BOOL;
#pragma convention(GetMenuBarInfo,system);
#pragma import(GetMenuBarInfo,'GetMenuBarInfo','user32.dll');

-- /*
--  * Scrollbar information
--  */
type
  tagSCROLLBARINFO  = record
cbSize          : DWORD;
rcScrollBar     : RECT;
dxyLineButton   : signed 32;
xyThumbTop      : signed 32;
xyThumbBottom   : signed 32;
reserved        : signed 32;
rgstate         : array 0..0 of DWORD;
  end record;
  SCROLLBARINFO     = tagSCROLLBARINFO;
  PSCROLLBARINFO    = ^tagSCROLLBARINFO;
  LPSCROLLBARINFO   = ^tagSCROLLBARINFO;

procedure GetScrollBarInfo(
    hwnd            : in t_HWND; 
    idObject        : in LONG; 
    psbi            : out tagSCROLLBARINFO)
                      return BOOL;
#pragma convention(GetScrollBarInfo,system);
#pragma import(GetScrollBarInfo,'GetScrollBarInfo','user32.dll');

-- /*
--  * Combobox information
--  */
type
  tagCOMBOBOXINFO   = record
cbSize          : DWORD;
rcItem          : RECT;
rcButton        : RECT;
stateButton     : DWORD;
hwndCombo       : t_HWND;
hwndItem        : t_HWND;
hwndList        : t_HWND;
  end record;
  COMBOBOXINFO      = tagCOMBOBOXINFO;
  PCOMBOBOXINFO     = ^tagCOMBOBOXINFO;
  LPCOMBOBOXINFO    = ^tagCOMBOBOXINFO;

procedure GetComboBoxInfo(
    hwndCombo       : in t_HWND; 
    pcbi            : out tagCOMBOBOXINFO)
                      return BOOL;
#pragma convention(GetComboBoxInfo,system);
#pragma import(GetComboBoxInfo,'GetComboBoxInfo','user32.dll');

-- /*
--  * The "real" ancestor window
--  */
const
  GA_PARENT         = 1;

const
  GA_ROOT           = 2;

const
  GA_ROOTOWNER      = 3;

procedure GetAncestor(
    hwnd            : in t_HWND; 
    gaFlags         : in UINT)
                      return t_HWND;
#pragma convention(GetAncestor,system);
#pragma import(GetAncestor,'GetAncestor','user32.dll');

-- /*
--  * This gets the REAL child window at the point.  If it is in the dead
--  * space of a group box, it will try a sibling behind it.  But static
--  * fields will get returned.  In other words, it is kind of a cross between
--  * ChildWindowFromPointEx and WindowFromPoint.
--  */
procedure RealChildWindowFromPoint(
    hwndParent      : in t_HWND; 
    ptParentClientCoords : in t_POINT)
                      return t_HWND;
#pragma convention(RealChildWindowFromPoint,system);
#pragma import(RealChildWindowFromPoint,'RealChildWindowFromPoint','user32.dll');

-- /*
--  * This gets the name of the window TYPE, not class.  This allows us to
--  * recognize ThunderButton32 et al.
--  */
procedure RealGetWindowClassA(
    hwnd            : in t_HWND; 
    pszType         : out CHARSTR ; 
    cchType         : in UINT)
                      return UINT;
#pragma convention(RealGetWindowClassA,system);
#pragma import(RealGetWindowClassA,'RealGetWindowClassA','user32.dll');

-- /*
--  * This gets the name of the window TYPE, not class.  This allows us to
--  * recognize ThunderButton32 et al.
--  */
procedure RealGetWindowClassW(
    hwnd            : in t_HWND; 
    pszType         : out WCHARSTR ; 
    cchType         : in UINT)
                      return UINT;
#pragma convention(RealGetWindowClassW,system);
#pragma import(RealGetWindowClassW,'RealGetWindowClassW','user32.dll');

#if #declared UNICODE; then;
#template RealGetWindowClass;
  RealGetWindowClassW 
#end RealGetWindowClass;
#else;
#template RealGetWindowClass;
  RealGetWindowClassA 
#end RealGetWindowClass;
#end if;

-- /*
--  * Alt-Tab Switch window information.
--  */
type
  tagALTTABINFO     = record
cbSize          : DWORD;
cItems          : signed 32;
cColumns        : signed 32;
cRows           : signed 32;
iColFocus       : signed 32;
iRowFocus       : signed 32;
cxItem          : signed 32;
cyItem          : signed 32;
ptStart         : t_POINT;
  end record;
  ALTTABINFO        = tagALTTABINFO;
  PALTTABINFO       = ^tagALTTABINFO;
  LPALTTABINFO      = ^tagALTTABINFO;

type
t_371=signed 32;

procedure GetAltTabInfoA(
    hwnd            : in t_HWND; 
    iItem           : in t_371; 
    pati            : out tagALTTABINFO; 
    pszItemText     : out CHARSTR ; 
    cchItemText     : in UINT)
                      return BOOL;
#pragma convention(GetAltTabInfoA,system);
#pragma import(GetAltTabInfoA,'GetAltTabInfoA','user32.dll');

type
t_372=signed 32;

procedure GetAltTabInfoW(
    hwnd            : in t_HWND; 
    iItem           : in t_372; 
    pati            : out tagALTTABINFO; 
    pszItemText     : out WCHARSTR ; 
    cchItemText     : in UINT)
                      return BOOL;
#pragma convention(GetAltTabInfoW,system);
#pragma import(GetAltTabInfoW,'GetAltTabInfoW','user32.dll');

#if #declared UNICODE; then;
#template GetAltTabInfo;
  GetAltTabInfoW 
#end GetAltTabInfo;
#else;
#template GetAltTabInfo;
  GetAltTabInfoA 
#end GetAltTabInfo;
#end if;

-- /*
--  * Listbox information.
--  * Returns the number of items per row.
--  */
procedure GetListBoxInfo(
    hwnd            : in t_HWND)
                      return DWORD;
#pragma convention(GetListBoxInfo,system);
#pragma import(GetListBoxInfo,'GetListBoxInfo','user32.dll');

procedure LockWorkStation
                      return BOOL;
#pragma convention(LockWorkStation,system);
#pragma import(LockWorkStation,'LockWorkStation','user32.dll');

procedure UserHandleGrantAccess(
    hUserHandle     : t_HANDLE; 
    hJob            : t_HANDLE; 
    bGrant          : BOOL)
                      return BOOL;
#pragma convention(UserHandleGrantAccess,system);
#pragma import(UserHandleGrantAccess,'UserHandleGrantAccess','user32.dll');

-- /*
--  * Raw Input Messages.
--  */
type
t_HRAWINPUT       = t_HANDLE;
-- /*
--  * WM_INPUT wParam
--  */
-- /*
--  * Use this macro to get the input code from wParam.
--  */
-- /*
--  * The input is in the regular message flow,
--  * the app is required to call DefWindowProc
--  * so that the system can perform clean ups.
--  */
const
  RIM_INPUT         = 0;

-- /*
--  * The input is sink only. The app is expected
--  * to behave nicely.
--  */
const
  RIM_INPUTSINK     = 1;

-- /*
--  * Raw Input data header
--  */
type
  tagRAWINPUTHEADER = record
dwType          : DWORD;
dwSize          : DWORD;
hDevice         : t_HANDLE;
wParam          : t_WPARAM;
  end record;
  RAWINPUTHEADER    = tagRAWINPUTHEADER;
  PRAWINPUTHEADER   = ^tagRAWINPUTHEADER;
  LPRAWINPUTHEADER  = ^tagRAWINPUTHEADER;

-- /*
--  * Type of the raw input
--  */
const
  RIM_TYPEMOUSE     = 0;

const
  RIM_TYPEKEYBOARD  = 1;

const
  RIM_TYPEHID       = 2;

-- /*
--  * Raw format of the mouse input
--  */
type
  tagRAWMOUSE       = record
usFlags         : USHORT;
t_373            : record
      ulButtons     : ULONG for position use 0;
usButtonFlags   : USHORT;
usButtonData    : USHORT;
    end record;
ulRawButtons    : ULONG;
lLastX          : LONG;
lLastY          : LONG;
ulExtraInformation : ULONG;
  end record;
  RAWMOUSE          = tagRAWMOUSE;
  PRAWMOUSE         = ^tagRAWMOUSE;
  LPRAWMOUSE        = ^tagRAWMOUSE;

-- /*
--  * Define the mouse button state indicators.
--  */
const
  RI_MOUSE_LEFT_BUTTON_DOWN= $01;

const
  RI_MOUSE_LEFT_BUTTON_UP= $02;

const
  RI_MOUSE_RIGHT_BUTTON_DOWN= $04;

const
  RI_MOUSE_RIGHT_BUTTON_UP= $08;

const
  RI_MOUSE_MIDDLE_BUTTON_DOWN= $10;

const
  RI_MOUSE_MIDDLE_BUTTON_UP= $20;

const
  RI_MOUSE_BUTTON_4_DOWN= $40;

const
  RI_MOUSE_BUTTON_4_UP= $80;

const
  RI_MOUSE_BUTTON_5_DOWN= $0100;

const
  RI_MOUSE_BUTTON_5_UP= $0200;

-- /*
--  * If usButtonFlags has RI_MOUSE_WHEEL, the wheel delta is stored in usButtonData.
--  * Take it as a signed value.
--  */
const
  RI_MOUSE_WHEEL    = $0400;

-- /*
--  * Define the mouse indicator flags.
--  */
const
  MOUSE_MOVE_RELATIVE= 0;

const
  MOUSE_MOVE_ABSOLUTE= 1;

const
  MOUSE_VIRTUAL_DESKTOP= $02;

const
  MOUSE_ATTRIBUTES_CHANGED= $04;

-- /*
--  * Raw format of the keyboard input
--  */
type
  tagRAWKEYBOARD    = record
MakeCode        : USHORT;
Flags           : USHORT;
Reserved        : USHORT;
VKey            : USHORT;
_Message        : UINT;
ExtraInformation : ULONG;
  end record;
  RAWKEYBOARD       = tagRAWKEYBOARD;
  PRAWKEYBOARD      = ^tagRAWKEYBOARD;
  LPRAWKEYBOARD     = ^tagRAWKEYBOARD;

-- /*
--  * Define the keyboard overrun MakeCode.
--  */
const
  KEYBOARD_OVERRUN_MAKE_CODE= $FF;

-- /*
--  * Define the keyboard input data Flags.
--  */
const
  RI_KEY_MAKE       = 0;

const
  RI_KEY_BREAK      = 1;

const
  RI_KEY_E0         = 2;

const
  RI_KEY_E1         = 4;

const
  RI_KEY_TERMSRV_SET_LED= 8;

const
  RI_KEY_TERMSRV_SHADOW= $10;

-- /*
--  * Raw format of the input from Human Input Devices
--  */
type
  tagRAWHID         = record
dwSizeHid       : DWORD;
dwCount         : DWORD;
bRawData        : array 0..0 of BYTE;
  end record;
  RAWHID            = tagRAWHID;
  PRAWHID           = ^tagRAWHID;
  LPRAWHID          = ^tagRAWHID;

-- /*
--  * RAWINPUT data structure.
--  */
type
  tagRAWINPUT       = record
header          : RAWINPUTHEADER;
data             : record
      mouse         : RAWMOUSE for position use 0;
      keyboard      : RAWKEYBOARD for position use 0;
      hid           : RAWHID for position use 0;
    end record;
  end record;
  RAWINPUT          = tagRAWINPUT;
  PRAWINPUT         = ^tagRAWINPUT;
  LPRAWINPUT        = ^tagRAWINPUT;

-- /*
--  * Flags for GetRawInputData
--  */
const
  RID_INPUT         = $10000003;

const
  RID_HEADER        = $10000005;

type
t_374=unsigned 32 ;

procedure GetRawInputData(
    hRawInput       : in t_HRAWINPUT; 
    uiCommand       : in UINT; 
    pData           : out unchecked ; 
    pcbSize         : in out t_374; 
    cbSizeHeader    : in UINT)
                      return UINT;
#pragma convention(GetRawInputData,system);
#pragma import(GetRawInputData,'GetRawInputData','user32.dll');

-- /*
--  * Raw Input Device Information
--  */
const
  RIDI_PREPARSEDDATA= $20000005;

const
  RIDI_DEVICENAME   = $20000007;

const
  RIDI_DEVICEINFO   = $2000000B;

type
  tagRID_DEVICE_INFO_MOUSE = record
dwId            : DWORD;
dwNumberOfButtons : DWORD;
dwSampleRate    : DWORD;
  end record;
  RID_DEVICE_INFO_MOUSE = tagRID_DEVICE_INFO_MOUSE;
  PRID_DEVICE_INFO_MOUSE = ^tagRID_DEVICE_INFO_MOUSE;

type
  tagRID_DEVICE_INFO_KEYBOARD = record
dwType          : DWORD;
dwSubType       : DWORD;
dwKeyboardMode  : DWORD;
dwNumberOfFunctionKeys : DWORD;
dwNumberOfIndicators : DWORD;
dwNumberOfKeysTotal : DWORD;
  end record;
  RID_DEVICE_INFO_KEYBOARD = tagRID_DEVICE_INFO_KEYBOARD;
  PRID_DEVICE_INFO_KEYBOARD = ^tagRID_DEVICE_INFO_KEYBOARD;

type
  tagRID_DEVICE_INFO_HID = record
dwVendorId      : DWORD;
dwProductId     : DWORD;
dwVersionNumber : DWORD;
usUsagePage     : USHORT;
usUsage         : USHORT;
  end record;
  RID_DEVICE_INFO_HID = tagRID_DEVICE_INFO_HID;
  PRID_DEVICE_INFO_HID = ^tagRID_DEVICE_INFO_HID;

type
  tagRID_DEVICE_INFO = record
cbSize          : DWORD;
dwType          : DWORD;
t_375            : record
      mouse         : RID_DEVICE_INFO_MOUSE for position use 0;
      keyboard      : RID_DEVICE_INFO_KEYBOARD for position use 0;
      hid           : RID_DEVICE_INFO_HID for position use 0;
    end record;
  end record;
  RID_DEVICE_INFO   = tagRID_DEVICE_INFO;
  PRID_DEVICE_INFO  = ^tagRID_DEVICE_INFO;
  LPRID_DEVICE_INFO = ^tagRID_DEVICE_INFO;

type
t_376=unsigned 32 ;

procedure GetRawInputDeviceInfoA(
    hDevice         : in t_HANDLE; 
    uiCommand       : in UINT; 
    pData           : out unchecked ; 
    pcbSize         : in out t_376)
                      return UINT;
#pragma convention(GetRawInputDeviceInfoA,system);
#pragma import(GetRawInputDeviceInfoA,'GetRawInputDeviceInfoA','user32.dll');

type
t_377=unsigned 32 ;

procedure GetRawInputDeviceInfoW(
    hDevice         : in t_HANDLE; 
    uiCommand       : in UINT; 
    pData           : out unchecked ; 
    pcbSize         : in out t_377)
                      return UINT;
#pragma convention(GetRawInputDeviceInfoW,system);
#pragma import(GetRawInputDeviceInfoW,'GetRawInputDeviceInfoW','user32.dll');

#if #declared UNICODE; then;
#template GetRawInputDeviceInfo;
  GetRawInputDeviceInfoW 
#end GetRawInputDeviceInfo;
#else;
#template GetRawInputDeviceInfo;
  GetRawInputDeviceInfoA 
#end GetRawInputDeviceInfo;
#end if;

-- /*
--  * Raw Input Bulk Read: GetRawInputBuffer
--  */
type
t_378=unsigned 32 ;

procedure GetRawInputBuffer(
    pData           : out tagRAWINPUT; 
    pcbSize         : in out t_378; 
    cbSizeHeader    : in UINT)
                      return UINT;
#pragma convention(GetRawInputBuffer,system);
#pragma import(GetRawInputBuffer,'GetRawInputBuffer','user32.dll');

-- /*
--  * Raw Input request APIs
--  */
type
  tagRAWINPUTDEVICE = record
usUsagePage     : USHORT;
usUsage         : USHORT;
dwFlags         : DWORD;
hwndTarget      : t_HWND;
  end record;
  RAWINPUTDEVICE    = tagRAWINPUTDEVICE;
  PRAWINPUTDEVICE   = ^tagRAWINPUTDEVICE;
  LPRAWINPUTDEVICE  = ^tagRAWINPUTDEVICE;

type
PCRAWINPUTDEVICE  = ^RAWINPUTDEVICE for machine_pointer use true;
const
  RIDEV_REMOVE      = $01;

const
  RIDEV_EXCLUDE     = $10;

const
  RIDEV_PAGEONLY    = $20;

const
  RIDEV_NOLEGACY    = $30;

const
  RIDEV_INPUTSINK   = $0100;

const
  RIDEV_CAPTUREMOUSE= $0200;

const
  RIDEV_NOHOTKEYS   = $0200;

const
  RIDEV_APPKEYS     = $0400;

const
  RIDEV_EXMODEMASK  = $F0;

procedure RegisterRawInputDevices(
    pRawInputDevices : in PCRAWINPUTDEVICE; 
    uiNumDevices    : in UINT; 
    cbSize          : in UINT)
                      return BOOL;
#pragma convention(RegisterRawInputDevices,system);
#pragma import(RegisterRawInputDevices,'RegisterRawInputDevices','user32.dll');

type
t_379=unsigned 32 ;

procedure GetRegisteredRawInputDevices(
    pRawInputDevices : out tagRAWINPUTDEVICE; 
    puiNumDevices   : in out t_379; 
    cbSize          : in UINT)
                      return UINT;
#pragma convention(GetRegisteredRawInputDevices,system);
#pragma import(GetRegisteredRawInputDevices,'GetRegisteredRawInputDevices','user32.dll');

type
  tagRAWINPUTDEVICELIST = record
hDevice         : t_HANDLE;
dwType          : DWORD;
  end record;
  RAWINPUTDEVICELIST = tagRAWINPUTDEVICELIST;
  p_RAWINPUTDEVICELIST = ^tagRAWINPUTDEVICELIST;

type
t_380=unsigned 32 ;

procedure GetRawInputDeviceList(
    pRawInputDeviceList : out tagRAWINPUTDEVICELIST; 
    puiNumDevices   : in out t_380; 
    cbSize          : in UINT)
                      return UINT;
#pragma convention(GetRawInputDeviceList,system);
#pragma import(GetRawInputDeviceList,'GetRawInputDeviceList','user32.dll');

type
t_381=^PRAWINPUT for machine_pointer use true;

procedure DefRawInputProc(
    paRawInput      : in t_381; 
    nInput          : in INT; 
    cbSizeHeader    : in UINT)
                      return t_LRESULT;
#pragma convention(DefRawInputProc,system);
#pragma import(DefRawInputProc,'DefRawInputProc','user32.dll');

-- /* RC complains about long symbols in #ifs 

end winuser;
