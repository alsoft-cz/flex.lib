----------------------------------------------------------------------------------------------------
module private names =
-- Object names.
-- Flex Standard Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
-- To do:
--   -- add suport for quotes in file names
--   -- change the silly implementation of [c_name.join] into clone & join of the [components] lists
----------------------------------------------------------------------------------------------------

with
  standard.strings;

----- Generic mechanisms for manipulation with names in a context of a namespace -------------------

----------------------------------------------------------------------------------------------------
class private abstract c_namespace =
-- Zaklad pro odvozeni konkretniho namespace.
----------------------------------------------------------------------------------------------------

    end c_namespace;



----------------------------------------------------------------------------------------------------
class private abstract c_name_component =
-- A single component of a name.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    virtual decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of subcomponents [subcomponents]
    ------------------------------------------------------------------------------------------------
    var
      base_name    : p_name_subcomponent_base_name; -- base name of a component

    begin
      -- by defalult, the name is composed of one component only - a base name
      new base_name;
      base_name^.set_name(text_name);
      subcomponents.insert(base_name);
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    virtual compose_name =
    -- Composes a plain-text name [text_name] from a list of subcomponents of this component. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    var
      base_name    : p_name_subcomponent_base_name; -- base name of a component

    begin
      -- by default, return the base name
      subcomponents.set_first(p_list_item(base_name));
      new text_name range base_name^.name^:length;
      text_name^:=base_name^.name^;
      end compose_name;

-->>>
    ------------------------------------------------------------------------------------------------
    static join_subcomponent =
    -- P©ipoj¡ zleva kopii subkomponenty [prefix] a zprava [suffix], pokud je kˆkter  z nich nil, nen¡ p©ipojena
    ------------------------------------------------------------------------------------------------
    begin
      -- p©id n¡ [prefix] na za‡ tek seznamu
      if prefix<>nil then
        subcomponents.insert_first(prefix^.clone);
        end if;

      -- p©id n¡ [suffix] na konec seznamu
      if suffix<>nil then
        subcomponents.insert_last(suffix^.clone);
        end if;
      end join_subcomponent;



    ------------------------------------------------------------------------------------------------
    static find_item =
    -- Vr t¡ subkomponentu s po©adov m ‡¡slem [index] v seznamu [components]
    ------------------------------------------------------------------------------------------------
    var
      i            : t_signed32;                 -- index

    begin
      -- inicializace
      i:=index;

--      *** tohle mi p©ijde nˆjak˜ divn˜. Hlavnˆ ta pot©eba pracovat se spojov˜m seznamem p©es index
      -- index kladn˜ => vr t¡ se [i]-t˜ prvek od za‡ tku
      if i>0 then
        result:=subcomponents.get_first();
        while i>1 and result<>nil loop
          result:=subcomponents.get_next(result);
          pred i;
          end loop;
        end if;

      -- index z porn˜ => vr t¡ se -[i]-t˜ prvek od konce
      if i<0 then
        result:=subcomponents.get_last();
        while i<-1 and result<>nil loop
          result:=subcomponents.get_prev(result);
          succ i;
          end loop;
        end if;
      end find_item;



    ------------------------------------------------------------------------------------------------
    static assign_subcomponents =
    -- P©i©ad¡ do [subcomponents] komponenty z source, dˆl  hlubok‚ kopie
    ------------------------------------------------------------------------------------------------
    var
      c            : p_name_subcomponent;        -- promˆnn  pro projit¡ seznamu [source]

    begin
      -- vymazat seznam [subcomponents]
      subcomponents.delete_all;

      -- proj¡t seznam [source]
      c:=source.get_first;
      while c<>nil loop
        -- do seznamu [components] p©idat hlubokou kopii prvku seznamu [source]
        subcomponents.insert_last(c^.clone);
        c:=source.get_next(c);
        end loop;
      end assign_subcomponents;
--<<<

    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalization
    ------------------------------------------------------------------------------------------------
    begin
      subcomponents.delete_all;
      end exit;

    end c_name_component;



----------------------------------------------------------------------------------------------------
class private abstract c_name_subcomponent =
-- A single subcomponent of a name's component.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static set_name =
    -- Assigns a plain-text name of this subcomponent.
    ------------------------------------------------------------------------------------------------
    begin
      -- discard the existing name, if any
      discard name;

      -- set a new name
      new name range text_name:length;
      name^:=text_name;
      end set_name;


-->>>
    ------------------------------------------------------------------------------------------------
    static assign_to =
    -- Zkop¡ruje do tohoto objektu data z [source].
    ------------------------------------------------------------------------------------------------
    begin
      -- zkop¡ruje jedin‚ pole - name
      set_name(source^.name^);
      end assign_to;
--<<<


    ------------------------------------------------------------------------------------------------
    exit =
    ------------------------------------------------------------------------------------------------
    begin
      discard name;
      end exit;

    end c_name_subcomponent;



----------------------------------------------------------------------------------------------------
class private c_name =
-- A name split into a list of components.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of components [components]
    ------------------------------------------------------------------------------------------------
    var
      valid        : t_logical;                  -- [true] if the name is a valid name in the given 
                                                 -- namespace
    begin
    { %%TODO(LIB)
      -- try to figure-out the right namespace

    }
      -- decompose the name
      declare var
        system_ns  : ^c_namespace_system;
      begin
        new system_ns;
        system_ns^.check_name(text_name,name_type,valid);
        if valid
          then system_ns^.decompose_name(text_name,name_type,this.name_type,components,ns_data);
          else raise name_error;
          end if;
      leave
        discard system_ns;
        end declare;
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    static compose_name =
    -- Composes a plain-text name [text_name] from a list of components [components]. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    begin
    { %%TODO(LIB)
      -- compose the name in context of the same namespace as used for decomposition
    }
      --compose the name
      declare var
        system_ns  : ^c_namespace_system;
      begin
        new system_ns;
        system_ns^.compose_name(components,ns_data,text_name);
      leave
        discard system_ns;
        end declare;
      end compose_name;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Joins a prefix and a suffix into this name. 
    ------------------------------------------------------------------------------------------------
    var
      prefix_name  : p_text_name;
      suffix_name  : p_text_name;
      full_name    : p_text_name;

    begin
      prefix.compose_name(prefix_name);
      suffix.compose_name(suffix_name);
      new full_name range prefix_name^:length+suffix_name^:length+1;
      full_name^:=prefix_name^;
      if full_name^<>'' and then full_name^[full_name^:length]<>"\" then
        full_name^ & "\";
        end if;
      full_name^ & suffix_name^;    
      decompose_name(full_name^,tnt_unspecified);
    leave
      discard prefix_name;
      discard suffix_name;
      discard full_name;
      end join;


-->>>
{
    ------------------------------------------------------------------------------------------------
    static join =
    -- Joins a prefix and a suffix into this name. 
    ------------------------------------------------------------------------------------------------
    begin
      -- vlo‘it [prefix] na za‡ tek seznamu
      join_before(prefix);

      -- vlo‘it [suffix] na konec seznamu
      join_after(suffix);
      end join;
}


    ------------------------------------------------------------------------------------------------
    static join_before =
    -- Prepends a prefix before this name. This name must be a relative name.
    ------------------------------------------------------------------------------------------------
    var
      component    : p_name_component;           -- promˆnn  pro projet¡ seznamu

    begin 
      -- proj¡t seznam prefix.components
      component:=prefix.components.get_last();
      while component<>nil loop
        -- vlo‘it na za‡ tek seznamu kopii [component]
        components.insert_first(component^.clone);
        component:=prefix.components.get_prev(component);
        end loop;
      end join_before;

                         

    ------------------------------------------------------------------------------------------------
    static join_after =
    -- Appends a suffix to this name. The [suffix] must be a relative name.
    ------------------------------------------------------------------------------------------------
    var
      component    : p_name_component;           -- promˆnn  pro projet¡ seznamu

    begin 
      -- proj¡t seznam suffix.components
      component:=suffix.components.get_first();
      while component<>nil loop
        -- vlo‘it na konec seznamu kopii [component]
        components.insert_last(component^.clone);
        component:=suffix.components.get_next(component);
        end loop;
      end join_after;



    ------------------------------------------------------------------------------------------------
    static join_string =
    -- Joins a prefix and a suffix into this name. 
    ------------------------------------------------------------------------------------------------
    var
      tmp          : p_name;                     -- temporary name

    begin
      -- inicializace [tmp]
      new tmp;

      -- if prefix is not empty, join prefix
      if prefix<>'' then
        tmp^.assign_to_string(prefix);
        join_before(tmp^);
        end if;

      -- if suffix is not empty, join suffix
      if suffix<>'' then
        tmp^.assign_to_string(suffix);
        join_after(tmp^);
        end if;

      leave
        discard tmp;
      end join_string;



    ------------------------------------------------------------------------------------------------
    static find_component_from =
    -- Najde prvn¡ komponentu typu [atype] nebo potomka [atype]
    ------------------------------------------------------------------------------------------------
    var
      p            : p_name_component;           -- promˆnn  pro proch zen¡ seznamu components

    begin
      -- %% TODO(TAG)
      {
      -- proj¡t seznam
      p:=components.get_first();
      while p<>nil loop
        -- [p] je p©ijateln‚ho typu
        if p:tag>=atype then
          result:=p;
          return;
          end if;

        -- p©ej¡t na dal¨¡ prvek seznamu
        p:=components.get_next(p);
        end loop;
      }
      end find_component_from;



    ------------------------------------------------------------------------------------------------
    static find_last_component =
    -- Najde posledn¡ komponentu typu [atype] nebo potomka [atype]
    ------------------------------------------------------------------------------------------------
    var
      p            : p_name_component;           -- promˆnn  pro proch zen¡ seznamu components

    begin
      -- %% TODO(TAG)
      {
      -- proj¡t seznam
      p:=components.get_last();
      while p<>nil loop
        -- [p] je p©ijateln‚ho typu
        if p:tag>=atype then
          result:=p;
          return;
          end if;

        -- p©ej¡t na p©edchoz¡ prvek seznamu
        p:=components.get_prev(p);
        end loop;
      }
      end find_last_component;



    ------------------------------------------------------------------------------------------------
    static remove_last_component =
    -- Removes last component, if it exists    
    ------------------------------------------------------------------------------------------------
    begin
      components.delete_last;
      end remove_last_component;



    ------------------------------------------------------------------------------------------------
    static remove_first_component =
    -- Removes last component, if it exists    
    ------------------------------------------------------------------------------------------------
    begin
      components.delete_first;
      end remove_first_component;

                  

    ------------------------------------------------------------------------------------------------
    static find_subitem =
    -- Vr t¡ subkomponentu s po©adovov˜m ‡¡slem [main_index] v seznamu [components], 
    -- v r mci nˆho pak subkomponentu s po©adov˜m ‡¡slem [sub_index]
    -- Indexy jsou ‡¡slovan‚ od jedni‡ky, pokud jsou z porn‚, znamen  to, ‘e seznam je proch zen odzadu,
    -- tzn. ‘e pro [sub_index]=-2 to vr t¡ druhou subkomponentu odzadu
    ------------------------------------------------------------------------------------------------
    var
      c            : p_name_component;           -- komponenta ze seznamu [components]
    begin
      -- zjistit [main-index]- tou komponentu
      c:=find_item(main_index);

      -- vr tit [sub_index]- tou subkomponentu
      if c<>nil then
        result:=c^.find_item(sub_index);
      else
        result:=nil;
        end if;
      end find_subitem;



    ------------------------------------------------------------------------------------------------
    static find_item =
    -- Vr t¡ komponentu s po©adovov˜m ‡¡slem [index] v seznamu [components]
    ------------------------------------------------------------------------------------------------
    var
      i            : t_signed32;                 -- index
    begin
      -- inicializace
      i:=index;

      -- index kladn˜ => vr tit [i]-t˜ prvek od za‡ tku
      if i>0 then
        result:=components.get_first();
        while i>1 and result<>nil loop
          result:=components.get_next(result);
          pred i;
          end loop;
        end if;

      -- index z porn˜ => vr tit -[i]-t˜ prvek od konce
      if i<0 then
        result:=components.get_last();
        while i<-1 and result<>nil loop
          result:=components.get_prev(result);
          succ i;
          end loop;
        end if;
      end find_item;



    ------------------------------------------------------------------------------------------------
    static equal_to =
    -- Vr t¡, zda je [name] je stejn‚ jako [this]
    ------------------------------------------------------------------------------------------------
    begin
      --*** no fuj, co je tohle za pras rnu? ’ dn˜ koment ©, vno©en˜ blok, kter˜ prakticky nepot©ebuje¨
      -- %%TODO(MEETING) zjistit prav‚ namespace m¡sto [c_namespace_system]
      declare var
        system_ns  : ^c_namespace_system;
      begin
        new system_ns;

        -- zjistit rovnost, rovnost se zji¨Ÿuje vol n¡m namespace
        result:=system_ns^.equal_names(components,ns_data,name.components,name.ns_data);
      leave
        discard system_ns;
        end declare;
      end equal_to;



    ------------------------------------------------------------------------------------------------
    static assign_to =
    -- Makes deep copy of source
    ------------------------------------------------------------------------------------------------
    begin
      -- zkop¡rov t komponenty
      assign_components(source.components);
      name_type:=source.name_type;

      -- zkop¡rovat pole ns - mus¡ udˆlat p©¡slu¨n˜ c_namespace
      -- %%TODO(MEETING) zjistit prav‚ namespace m¡sto [c_namespace_system]
      declare var
        system_ns  : ^c_namespace_system;
      begin
        new system_ns;
        ns_data:=system_ns^.clone_specific(source.ns_data);
      leave
        discard system_ns;
        end declare;
      end assign_to;


    ------------------------------------------------------------------------------------------------
    static assign_to_string =
    -- Assigns string value
    ------------------------------------------------------------------------------------------------
    begin
      -- dekomponovat [source] do seznamu [components]
      decompose_name(source,tnt_unspecified);
      end assign_to_string;



    ------------------------------------------------------------------------------------------------
    static join_component =
    -- P©ipoj¡ zleva kopii komponenty prefix a zprava suffix, pokud je nˆkter  z nich nil, nen¡ p©ipojena
    ------------------------------------------------------------------------------------------------
    begin
      -- p©idat prefix ma za‡ tek seznamu
      if prefix<>nil then
        components.insert_first(prefix^.clone);
        end if;

      -- p©idat suffix ma konec seznamu
      if suffix<>nil then
        components.insert_first(suffix^.clone);
        end if;
      end join_component;


    ------------------------------------------------------------------------------------------------
    static clone =
    -- Vr t¡ hlubokou kopii tohoto objektu
    ------------------------------------------------------------------------------------------------
    begin
      -- vytvo©it novou instanci a zkop¡rovat pole
      new result;
      result^.assign_to(this);
      end clone;


    ------------------------------------------------------------------------------------------------
    static assign_components =
    -- P©i©ad¡ do [subcomponents] komponenty z source
    ------------------------------------------------------------------------------------------------
    var
      c            : p_name_component;
    begin
      -- vymazat seznam components
      components.delete_all;

      -- proj¡t seznam source
      c:=source.get_first;
      while c<>nil loop
        -- do seznamu [components] p©idat hlubokou kopii prvku seznamu [source]
        components.insert_last(c^.clone);
        c:=source.get_next(c);
        end loop;
      end assign_components;
--<<<


    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalization
    ------------------------------------------------------------------------------------------------
    begin
      components.delete_all;
      discard ns_data;
      end exit;

    end c_name;



----------------------------------------------------------------------------------------------------
class private c_names =
-- A collection of names.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    entry =
    -- Initialization
    ------------------------------------------------------------------------------------------------
    begin
      init(c_name:tag,false,false);
      end entry;

    end c_names;



----------------------------------------------------------------------------------------------------
procedure register_namespace =
-- Registers a new namespace.
--
-- Remarks:
--   The system namespace ([c_namespace_system]) is registered by default.
----------------------------------------------------------------------------------------------------
begin
  -- %%TODO(LIB)
{
  -- check if it is an ancestor of c_namespace
  if not (namspace>c_namespace:tag) then
    ...
    end if;

  -- add to the list of registered namespaces
  namespaces.insert(...);
}
  end register_namespace;



----- Implementation of a system native namespace --------------------------------------------------

----------------------------------------------------------------------------------------------------
class private c_namespace_system =
-- This platform's native namespace.
----------------------------------------------------------------------------------------------------

    type
      -- internal differentiation between types of names
      t_system_name_type = enum
          tsnt_empty;                            -- an empty name
          tsnt_absolute_unc;                     -- an UNC name in the form "\\server\share\path"
          tsnt_absolute_local;                   -- a local absolute name in the form "c:\path"
          tsnt_root_relative;                    -- a root-relative name in the form "\path"
          tsnt_relative;                         -- a relative name in the form "path"
          end enum;

      -- system-namespace specific data
      t_namespace_specific_system = t_namespace_specific with record
          name_type: t_system_name_type;
          end record;
      p_namespace_specific_system = ^class t_namespace_specific_system;

    ------------------------------------------------------------------------------------------------
    override check_name =
    -- Check if the given plain-text name [text_name] is a valid name in this namespace. When the
    -- name is a valid name, [valid] is set to [true], otherwise it is set to [false].
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure check_for_valid_characters (
            from   : in t_unsigned)              -- starting index into [text_name] from which to check
            return t_logical =
        -- Checks if the name contains only valid characters
        --------------------------------------------------------------------------------------------
        begin
          for i in from..text_name:length loop
            -- the invalid characters within a name are >, <, :, " and |
            -- more precisely, \ and / are also invalid characters, but in this stage, we do not
            -- distinguish between a full path and a file name
            if {%%TODO(SET)text_name[i] in [">","<",":",""","|"]} text_name[i]=">" or text_name[i]="<" or text_name[i]=":" or text_name[i]=""" or text_name[i]="|" then
              result:=false;
              end if;
            end loop;
          result:=true;
          end check_for_valid_characters;

    begin
      -- empty name always matches
      if text_name='' then
        valid:=true;
        return;
        end if;

      -- possibly a UNC name
      if name_type in t_name_type_set:[tnt_absolute,tnt_unspecified] and then {%%TODO(SLICE)text_name[1..2]='\\'} text_name:length>=4 and then (text_name[1]="\" and text_name[2]="\") then
      {%%TODO(SLICE) %%TODO(LIB)
        -- it could be a "long" UNC name
        if text_name[1..8]='\\?\UNC\' then
          ...
          end if;
      }
        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        valid:=check_for_valid_characters(3);

      -- possibly a "c:\file.ext" name
      elsif name_type in t_name_type_set:[tnt_absolute,tnt_unspecified] and then text_name:length>=2 
      and then (((text_name[1]>="a" and text_name[1]<="z") or (text_name[1]>="A" and text_name[1]<="Z")) {%%TODO(SET)text_name[1] in ["a".."z","A".."Z"]} and text_name[2]=":") then
        -- the third character shall be a backslash
        if text_name:length>=3 and then text_name[3]<>"\" then  
          valid:=false;
          return;
          end if;

        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        valid:=check_for_valid_characters(4);

      -- possibly a relative name 
      elsif name_type in t_name_type_set:[tnt_relative,tnt_unspecified] then
        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        valid:=check_for_valid_characters(1);

      -- definitely an invalid name
      else
        valid:=false;
        end if;
      end check_name;



    ------------------------------------------------------------------------------------------------
    override decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of components [components]
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure separate_component_name (
            start  : in out t_unsigned;          -- actual position in [text_name]
            name   : out p_text_name;            -- separated subcomponent name
            is_folder : out t_logical;           -- [true] if the subcomponent represents a folder 
                                                 -- for sure
            can_have_quotes : in t_logical:=false) = -- p©¡znak, zda jm‚no m–‘e b˜t v uvozovk ch
        -- Separates the name of a subcomponent starting at position [start] from the [text_name].
        --------------------------------------------------------------------------------------------

            ----------------------------------------------------------------------------------------
            procedure allocate_result (
                start : in t_unsigned;           -- start position of result name
                stop  : in t_unsigned;           -- stop position of result name
                name  : out p_text_name) =       -- result name
            -- allocates result
            ----------------------------------------------------------------------------------------
            begin
              -- copy it
              new name range 1+stop-start;{%%TODO(STRING)}
              for i in start..stop loop
                name^ & text_name[i];
                end loop;
              end allocate_result;

        var
          stop     : t_unsigned;

        begin
          -- is it quoted component?
          if can_have_quotes and then start<=text_name:length and then text_name[start]=""" then
            stop:=start+1;

            -- find the end of the name
            while stop<=text_name:length and then text_name[stop]<>""" loop
              succ stop;
              end loop;

            -- end " expected
            if stop>text_name:length then
              raise name_error;
              end if;

             -- skip stop over """
            succ stop;
            if stop>text_name:length then
              is_folder:=false;
            else
              -- if no backslash detected, raise error
              if text_name[stop]<>"/" and text_name[stop]<>"\" then
                raise name_error;
                end if;
              is_folder:=true;
              end if;

            -- allocates result
            allocate_result(start+1,stop-2,name);

            -- update the [start] position
            start:=stop+1;
          else
            -- find the end of the name
            stop:=start;
            while stop<=text_name:length and then {%%TODO(SLICE)text_name[stop] not in ["\","/"]} (text_name[stop]<>"\" and text_name[stop]<>"/") loop
              succ stop;
              end loop;

            -- allocates result
            allocate_result(start,stop-1,name);

            -- decide if it is a folder name for sure
            is_folder:=stop<=text_name:length or name^='.' or name^='..';

            -- update the [start] position
            start:=stop+1;
            end if;
          end separate_component_name;



        --------------------------------------------------------------------------------------------
        procedure parse_rest_of_name (
            initial : in t_unsigned) =           -- initial position for parsing
        -- Parses the rest of the name starting with position [initial].
        --------------------------------------------------------------------------------------------
        var
          folder   : p_name_component_folder;    -- folder component
          file_or_folder : p_name_component_file_or_folder; -- file or folder component
          name     : p_text_name;                -- name of a single component
          start    : t_unsigned;                 -- actual position in [text_name]
          is_folder: t_logical;                  -- [true] if the subcomponent represents a folder 
                                                 -- for sure
        begin
          start:=initial;
          while start<=text_name:length loop
            begin
              -- separate the name of a folder or file
              separate_component_name(start,name,is_folder,true);

              -- create a component
              if is_folder

                -- it is a folder for sure
                then
                  new folder;
                  folder^.decompose_name(name^);
                  components.insert(folder);

                -- it can be either a folder or a file
                else
                  new file_or_folder;
                  file_or_folder^.decompose_name(name^);
                  components.insert(file_or_folder);
                  end if;
            leave
              -- free the plain-text name
              discard name;
              end;
            end loop;
          end parse_rest_of_name;

    var
      server       : p_name_component_server;    -- server component
      drive        : p_name_component_drive;     -- drive component
      name         : p_text_name;                -- name of a single component
      start        : t_unsigned;                 -- actual position in [text_name]
      is_folder    : t_logical;                  -- [true] if the subcomponent represents a folder 
                                                 -- for sure

    begin
      -- prepare namespace specific data
      new p_namespace_specific_system(ns_data);

      -- empty name - no decomposition possible
      if text_name='' then
        return;
        end if;

      -- possibly a UNC name
      if proposed_nt in t_name_type_set:[tnt_absolute,tnt_unspecified] and then {%%TODO(SLICE)text_name[1..2]='\\'} text_name:length>=4 and then (text_name[1]="\" and text_name[2]="\") then
      {%%TODO(SLICE) %%TODO(LIB)
        -- it could be a "long" UNC name
        if text_name[1..8]='\\?\UNC\' then
          ...
          end if;
      }                                                        
        {%%TODO(DECLARE) server, drive, start, name, is_folder }

        -- remember the type of the name
        p_namespace_specific_system(ns_data)^.name_type:=tsnt_absolute_unc;
        
        -- set the detected name type to an absolute name
        detected_nt:=tnt_absolute;

        -- the first component of a name is a server
        start:=3;
        separate_component_name(start,name,is_folder);
        new server;
        server^.decompose_name(name^);
        components.insert(server);
        discard name;

        -- the second component of a name is a share
        separate_component_name(start,name,is_folder);
        new server;
        server^.decompose_name(name^);
        components.insert(server);
        discard name;

        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        parse_rest_of_name(start);

      -- possibly a "c:\file.ext" name
      elsif proposed_nt in t_name_type_set:[tnt_absolute,tnt_unspecified] and then text_name:length>=2 
      and then (((text_name[1]>="a" and text_name[1]<="z") or (text_name[1]>="A" and text_name[1]<="Z")) {%%TODO(SET)text_name[1] in ["a".."z","A".."Z"]} and text_name[2]=":") then
        -- the third character shall be a backslash
        if text_name:length>=3 and then text_name[3]<>"\" then  
          -- %%FLEX signal an error !
          return;
          end if;

        -- remember the type of the name
        p_namespace_specific_system(ns_data)^.name_type:=tsnt_absolute_local;
        
        -- set the detected name type to an absolute name
        detected_nt:=tnt_absolute;

        -- the first component of a name is a drive
        {%%TODO(DECLARE) drive, name }
        new name range 1;
        name^ & text_name[1];
        new drive;
        drive^.decompose_name(name^);
        components.insert(drive);
        discard name;

        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        parse_rest_of_name(4);
        
      -- possibly a relative name 
      elsif proposed_nt in t_name_type_set:[tnt_relative,tnt_unspecified] then
        -- remember the type of the name
        if {%%TODO(SET) text_name[1] in ["\","/"]} text_name[1]="\" or text_name[1]="/"
          then p_namespace_specific_system(ns_data)^.name_type:=tsnt_root_relative;
          else p_namespace_specific_system(ns_data)^.name_type:=tsnt_relative;
          end if;
        
        -- set the detected name type to a relative name
        detected_nt:=tnt_relative;

        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes       
        parse_rest_of_name(1);

      -- definitely an invalid name
      else
        -- %%FLEX signal an error !
        return;
        end if;

    leave
      -- discard any unfreed memory
      discard name;
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    override compose_name =
    -- Composes a plain-text name [text_name] from a list of components [components]. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure append_name_component (
            component : in t_text_name) =
        -- Appends the name of a component to the full plain-text name.
        --------------------------------------------------------------------------------------------
        var
          _text_name : p_text_name;

        begin
          -- reallocate memory
          if text_name=nil
            then new text_name range component:length
            else
              -- %%TODO(ADJUST) adjust text_name range text_name^:length+component:length;
              new _text_name range text_name^:length+component:length;
              _text_name^:=text_name^;
              discard text_name;
              text_name:=_text_name;
              end if;

          -- append the component's name
          text_name^ & component;
          end append_name_component; 



        --------------------------------------------------------------------------------------------
        procedure append_rest_of_path (
            first_file_or_folder : in p_name_component_file_or_folder) =
        -- Appends the rest of the path beginning with [file_or_folder].
        --------------------------------------------------------------------------------------------
        var
          text_name : p_text_name;               -- a plain-text name of a component
          file_or_folder : p_name_component_file_or_folder; -- the file or folder actually being processed

        begin
          file_or_folder:=first_file_or_folder;
          while file_or_folder<>nil loop
            -- append the name of this file or folder
            begin
              file_or_folder^.compose_name(text_name);
              append_name_component(text_name^);
            leave
              discard text_name;
              end;

            -- get next entry
            components.set_next(p_list_item(file_or_folder));

            -- don't forget the separating backslash
            if file_or_folder<>nil then
              append_name_component('\');
              end if;
            end loop;
          end append_rest_of_path;

    var
      server       : p_name_component_server;    -- the server component
      share        : p_name_component_drive;     -- the share component
      drive        : p_name_component_drive;     -- the drive component
      component_name : p_text_name;              -- a plain-text name of a component

    begin
      case p_namespace_specific_system(ns_data)^.name_type
        -- an empty name
        when tsnt_empty do new text_name range {%%FLEX 0 => Constant out of range}1;

        -- an UNC name in the form "\\server\share\path"
        when tsnt_absolute_unc do
            -- append the server name
            begin
              server:=components.get_first;
              server^.compose_name(component_name);
              append_name_component('\\');
              append_name_component(component_name^);
            leave
              discard component_name;
              end;

            -- append the share name
            begin
              share:=components.get_next(server);
              share^.compose_name(component_name);
              append_name_component('\');
              append_name_component(component_name^);
            leave
              discard component_name;
              end;

            -- append the rest of the path
            append_name_component('\');
            append_rest_of_path(components.get_next(share));

        -- a local absolute name in the form "c:\path"
        when tsnt_absolute_local do
            -- append the drive name
            begin
              drive:=components.get_first;
              drive^.compose_name(component_name);
              append_name_component(component_name^);
              append_name_component(':\');
            leave
              discard component_name;
              end;

            -- append the rest of the path
            append_rest_of_path(components.get_next(drive));

        -- a root-relative name in the form "\path"
        when tsnt_root_relative do
            -- append the rest of the path
            append_name_component('\');
            append_rest_of_path(components.get_first);

        -- a relative name in the form "path"
        when tsnt_relative do
            -- append the rest of the path
            append_rest_of_path(components.get_first);
        end case;
      
      -- prepare iterator
      --iterator.init(this,
      end compose_name;


-->>>
    ------------------------------------------------------------------------------------------------
    override equal_names =
    -- Compares two names by their components and returns, whether they are equal
    ------------------------------------------------------------------------------------------------
    var
      left_name    : p_text_name;                -- ukazatel na dynamick˜ ©etˆzec lev‚ho jm‚na
      right_name   : p_text_name;                -- ukazatel na dynamick˜ ©etˆzec prav‚ho jm‚na
      
    begin
      -- compose names
      compose_name(left,left_specific,left_name);
      compose_name(right,right_specific,right_name);

      -- v˜sledn  hodnota je true, pokud jsou oba ©etˆzce stejn‚ a‘ na velikost p¡smen
      result:=str_compare_case_insensitive(left_name^,right_name^);

    leave
      -- uvolnit pamˆt
      discard left_name;
      discard right_name;
      end equal_names;



    ------------------------------------------------------------------------------------------------
    override clone_specific =
    -- makes copy of ns
    ------------------------------------------------------------------------------------------------
    begin
      -- zkop¡rovat namespace-specific data, pokud vstupn¡ argument nen¡ nil
      if ns<>nil then
        new p_namespace_specific_system(result);
        p_namespace_specific_system(result)^:=p_namespace_specific_system(ns)^;
        end if;
      end clone_specific;
--<<<

    end c_namespace_system;



----------------------------------------------------------------------------------------------------
class private c_name_component_server =
-- Name of a server.
----------------------------------------------------------------------------------------------------
-->>>
    ------------------------------------------------------------------------------------------------
    override clone =
    -- Vr t¡ hlubokou kopii tohoto objektu
    ------------------------------------------------------------------------------------------------
    begin
      -- vytvo©it novou instanci
      new p_name_component_server(result);

      -- zkop¡rovat data do nov‚ instance
      result^.assign_subcomponents(subcomponents);
      end clone;
--<<<
    end c_name_component_server;



----------------------------------------------------------------------------------------------------
class private c_name_component_drive =
-- Name of a drive (or a "share" or a "volume" in some naming conventions) within a server.
----------------------------------------------------------------------------------------------------
-->>>
    ------------------------------------------------------------------------------------------------
    override clone =
    -- Vr t¡ hlubokou kopii tohoto objektu
    ------------------------------------------------------------------------------------------------
    begin
      -- vytvo©it novou instanci
      new p_name_component_drive(result);

      -- zkop¡rovat data do nov‚ instance
      result^.assign_subcomponents(subcomponents);
      end clone;
--<<<
    end c_name_component_drive;



----------------------------------------------------------------------------------------------------
class private c_name_component_file_or_folder =
-- Name of a folder or a file.
----------------------------------------------------------------------------------------------------
    
    ------------------------------------------------------------------------------------------------
    static get_base_name =
    -- Retrieves the base name of a file or folder name.
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    var
      base_name_subcomponent : p_name_subcomponent_base_name;

    begin
      subcomponents.set_first(p_list_item(base_name_subcomponent));

      -- allocate result
      new base_name range base_name_subcomponent^.name^:length;
      base_name^:=base_name_subcomponent^.name^;
      end get_base_name;



    ------------------------------------------------------------------------------------------------
    static check_base_name =
    -- Retrieves the base name of a file or folder name.
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    var
      base         : p_name_subcomponent_base_name;

    begin
      subcomponents.set_first(p_list_item(base));

      result:=str_compare_case_insensitive(base^.name^,base_name);
      end check_base_name;



    ------------------------------------------------------------------------------------------------
    static check_last_extension =
    -- Checks if the last extension of the name is equal to the given extension.
    ------------------------------------------------------------------------------------------------
    var
      ext          : p_name_subcomponent_extension; -- extension

    begin
      -- if there are any extensions in the name...
      if subcomponents.count>1 then
        -- retrieve the last
        ext:=subcomponents.get_last;

        -- and compare with the given extension
        result:=str_compare_case_insensitive(ext^.name^,extension);
        end if;
      end check_last_extension;



    ------------------------------------------------------------------------------------------------
    static replace_last_extension =
    -- Replaces the last extension of the name with the given extension.
    ------------------------------------------------------------------------------------------------
    var
      ext          : p_name_subcomponent_extension; -- extension

    begin
      -- if there are any extensions in the name...
      if subcomponents.count>1 then
        -- retrieve the last
        ext:=subcomponents.get_last;

        -- replace it with the value
        ext^.set_name(extension);
        end if;
      end replace_last_extension;



    ------------------------------------------------------------------------------------------------
    static append_extension =
    -- Appends the given extension to the name.
    ------------------------------------------------------------------------------------------------
    var
      ext          : p_name_subcomponent_extension; -- extension

    begin
      -- create a subcomponent
      new ext;
      ext^.set_name(extension);
      subcomponents.insert(ext);
      end append_extension;



    ------------------------------------------------------------------------------------------------
    override decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of subcomponents [subcomponents]
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure separate_subcomponent_name (
            start  : in out t_unsigned;          -- actual position in [text_name]
            name   : out p_text_name) =          -- separated subcomponent name
        -- Separates the name of a subcomponent starting at position [start] from the [text_name].
        --------------------------------------------------------------------------------------------
        var
          stop     : t_unsigned;

        begin
          -- find the end of the name
          stop:=start;
          while stop<=text_name:length and then text_name[stop]<>"." loop
            succ stop;
            end loop;

          -- copy it
          if stop-start<1 then
            new name range 1;
          else
            new name range stop-start;
            end if;

          for i in start..stop-1 loop
            name^ & text_name[i];
            end loop;

          -- update the [start] position
          start:=stop+1;
          end separate_subcomponent_name;

    var
      base_name    : p_name_subcomponent_base_name; -- base name
      extension    : p_name_subcomponent_extension; -- extension
      name         : p_text_name;                -- plain-text name of a single subcomponent
      start        : t_unsigned;                 -- actual position in [text_name]

    begin
      -- there are two special cases of folder names: '.' and '..' => handle them separately
      if text_name='.' or text_name='..' then
        new base_name;
        base_name^.set_name(text_name);
        subcomponents.insert(base_name);
        return;
        end if;

      -- start from the beginning of the name
      start:=1;

      -- separate the base name
      separate_subcomponent_name(start,name);

      -- create a subcomponent
      new base_name;
      base_name^.set_name(name^);
      subcomponents.insert(base_name);

      -- free the plain-text name
      discard name;

      -- separate all extensions
      while start<=text_name:length loop
        -- separate one extension
        separate_subcomponent_name(start,name);

        -- create a subcomponent
        new extension;
        extension^.set_name(name^);
        subcomponents.insert(extension);

        -- free the plain-text name
        discard name;
        end loop;
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    override compose_name =
    -- Composes a plain-text name [text_name] from a list of subcomponents of this component. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure append_name_subcomponent (
            subcomponent : in t_text_name) =
        -- Appends s name of a subcomponent to the full plain-text name of the component.
        --------------------------------------------------------------------------------------------
        var
          _text_name : p_text_name;

        begin
          -- reallocate memory
          if text_name=nil
            then new text_name range subcomponent:length
            else
              -- %%TODO(ADJUST) adjust text_name range text_name^:length+subcomponent:length;
              new _text_name range text_name^:length+subcomponent:length;
              _text_name^:=text_name^;
              discard text_name;
              text_name:=_text_name;
              end if;

          -- append the subcomponent's name
          text_name^ & subcomponent;
          end append_name_subcomponent; 

    var
      base_name    : p_name_subcomponent_base_name; -- base name of a component
      extension    : p_name_subcomponent_extension; -- extension

    begin
      -- retrieve the base name
      subcomponents.set_first(p_list_item(base_name));
      append_name_subcomponent(base_name^.name^);

      -- append all extensions
      extension:=subcomponents.get_next(base_name);
      while extension<>nil loop
        -- append the extension to the full plain-text name
        append_name_subcomponent('.');
        append_name_subcomponent(extension^.name^);
        
        -- retrieve next extension
        subcomponents.set_next(p_list_item(extension));
        end loop;
      end compose_name;


    ------------------------------------------------------------------------------------------------
    static get_last_extension =
    -- Retrieves the last extension of a file or folder name.
    -- The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    begin

      end get_last_extension;


-->>>
    ------------------------------------------------------------------------------------------------
    static remove_last_extension =
    -- Removes the last extension of the name.
    ------------------------------------------------------------------------------------------------
    begin
      --%%TODO(TAG) 
      {
      if components.get_last()^:tag>=c_name_subcomponent_extension:tag
        subcomponents.delete_last;
        end if;
      }
      end remove_last_extension;



    ------------------------------------------------------------------------------------------------
    override clone =
    -- Vr t¡ hlubokou kopii tohoto objektu.
    ------------------------------------------------------------------------------------------------
    begin
      -- vytvo©it novou instanci
      new p_name_component_file_or_folder(result);

      -- zkop¡rovat data do nov‚ instance
      result^.assign_subcomponents(subcomponents);
      end clone;
--<<<

    end c_name_component_file_or_folder;



----------------------------------------------------------------------------------------------------
class private c_name_component_file =
-- Name of a file.
----------------------------------------------------------------------------------------------------
-->>>
    ------------------------------------------------------------------------------------------------
    override clone =
    -- Vr t¡ hlubokou kopii tohoto objektu
    ------------------------------------------------------------------------------------------------
    begin
      -- vytvo©it novou instanci
      new p_name_component_file(result);

      -- zkop¡rovat data do nov‚ instance
      result^.assign_subcomponents(subcomponents);
      end clone;
--<<<
    end c_name_component_file;



----------------------------------------------------------------------------------------------------
class private c_name_component_folder =
-- Name of a folder.
----------------------------------------------------------------------------------------------------
-->>>
    ------------------------------------------------------------------------------------------------
    override clone =
    -- Vr t¡ hlubokou kopii tohoto objektu
    ------------------------------------------------------------------------------------------------
    begin
      -- vytvo©it novou instanci
      new p_name_component_folder(result);

      -- zkop¡rovat data do nov‚ instance
      result^.assign_subcomponents(subcomponents);
      end clone;
--<<<
    end c_name_component_folder;



----------------------------------------------------------------------------------------------------
class private c_name_subcomponent_base_name =
-- Base part of a name.
----------------------------------------------------------------------------------------------------
-->>>
    ------------------------------------------------------------------------------------------------
    override clone =
    -- Vr t¡ hlubokou kopii tohoto objektu
    ------------------------------------------------------------------------------------------------
    begin
      -- vytvo©it novou instanci
      new p_name_subcomponent_base_name(result);

      -- zkop¡rovat data do nov‚ instance
      result^.assign_to(^this);
      end clone;
--<<<      
    end c_name_subcomponent_base_name;



----------------------------------------------------------------------------------------------------
class private c_name_subcomponent_extension =
-- Extension of a name.
----------------------------------------------------------------------------------------------------
-->>>    
    ------------------------------------------------------------------------------------------------
    override clone =
    -- Vr t¡ hlubokou kopii tohoto objektu
    ------------------------------------------------------------------------------------------------
    begin
      -- vytvo©it novou instanci a zkop¡rovat do n¡ data z tohoto objektu
      new p_name_subcomponent_extension(result);
      result^.assign_to(^this);
      end clone;



    ------------------------------------------------------------------------------------------------
    static find_in_list =
    -- vr t¡ index p©¡pony v ©etˆzci exts ‡¡slovan˜ od 0, -1, pokud tam p©¡pona nen¡
    ------------------------------------------------------------------------------------------------
    var
      i            : t_unsigned32;               -- index do [name]^
      waseq        : t_logical;                  -- p©¡znak, zda pr vˆ testovan  p©¡pona je zat¡m rovna name
      index        : t_signed32;                 -- kolik t  p©¡pona je zpracov v na

    begin
      -- inicializace
      i:=1;
      waseq:=true;
      index:=0;

      -- zpracovat vstupn¡ ©etˆzec
      for j in exts:range loop
        -- aktu ln¡ znak je ';' - oddˆlova‡ znak–
        if exts[j]=";" then
          -- p©¡pona je shodn  s £sekem ©etezce [exts] - vr tit index p©¡pony v seznamu [exts]
          if waseq and i=name^:length+1 then
            result:=index;
            return;
            end if;

          -- ©etˆzec [name] se bude testovat zase od za‡ tku
          waseq:=true;
          i:=1;
          succ index;

        -- aktu ln¡ znak nen¡ st©edn¡k
        else
          -- aktu ln¡ znak [name] se li¨¡ od aktu ln¡ho znaku [exts]
          if i>name^:length or else exts[j]<>name^[i] then
            waseq:=false;
            end if;

          -- p©ej¡t na dal¨¡ znak ©etˆzce [name]
          succ i;
          end if;
        end loop;

      -- byla nalezena p©¡pona?
      if waseq and i=name^:length+1
        -- ano => vr tit index p©¡pony
        then
          result:=index;

        -- ne => vr tit p©¡znak
        else
          result:=-1;
          end if;
      end find_in_list;
--<<<
    end c_name_subcomponent_extension;


-->>>
----------------------------------------------------------------------------------------------------
procedure operator_c_name_concat_on_n =
-- Joins names name and j_name
----------------------------------------------------------------------------------------------------
begin
  name.join_after(joined_name);
  end operator_c_name_concat_on_n;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_concat_on_s =
-- Joins names name and joined_name
----------------------------------------------------------------------------------------------------
var 
  name_tmp         : c_name;                     -- pomocn‚ jm‚no
begin 
  -- rozparsov n¡ a p©id n¡ na konec
  name_tmp.assign_to_string(joined_name);
  name.join_after(name_tmp);
  end operator_c_name_concat_on_s;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_concat_on_c =
-- name & joined_name
----------------------------------------------------------------------------------------------------
begin
  name.join_component(nil,joined_name);
  end operator_c_name_concat_on_c;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_concat_on_u =
-- Joins names name and joined_name, joined_name is added to last component
----------------------------------------------------------------------------------------------------
var
  last             : p_name_component;           -- pomocn‚ jm‚no
begin 
  -- zjistit posledn¡ komponentu
  last:=name.find_item(-1);

  -- pokud existuje = seznam [name.components] nen¡ pr zdn˜, p©idat [joined_name]
  if last<>nil then
    last^.join_subcomponent(nil,joined_name);
    end if;

  end operator_c_name_concat_on_u;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_concat_n_n_n =
-- Joins names left and right and returns left & right
----------------------------------------------------------------------------------------------------
begin
  -- p©idat na za‡ tek [left] a na konec [right]
  result.join(left,right);
  end operator_c_name_concat_n_n_n;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_concat_n_s_n =
-- Joins names left and right and returns left & right
----------------------------------------------------------------------------------------------------
begin
  -- inicializovat
  result:=left;

  -- na konec seznamu p©idat [right] 
  result.join_string('',right);
  end operator_c_name_concat_n_s_n;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_concat_s_n_n =
-- Joins names left and right and returns left & right
----------------------------------------------------------------------------------------------------
begin
  -- inicializovat
  result:=right;

  -- na konec za‡ tek p©idat [left] 
  result.join_string(left,'');
  end operator_c_name_concat_s_n_n;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_pred =
-- Removes last component.
----------------------------------------------------------------------------------------------------
begin
  -- odebrat posledn¡ komponentu
  n.remove_last_component;
  end operator_c_name_pred;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_equal =
-- left=right
----------------------------------------------------------------------------------------------------
begin
  -- zjistit, zda [left] a [right] jsou stejn‚
  result:=left.equal_to(right);
  end operator_c_name_equal;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_not_equal =
-- left<>right
----------------------------------------------------------------------------------------------------
begin
  -- zjistit, zda [left] a [right] nejsou stejn‚
  result:=not left.equal_to(right);
  end operator_c_name_not_equal;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_assign_n_n =
-- name:=value, makes deep copy
----------------------------------------------------------------------------------------------------
begin
  -- hlubok  kopie [value] do [name]
  name.assign_to(value);
  end operator_c_name_assign_n_n;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_assign_n_s =
-- name:=value, makes decomposion into components
----------------------------------------------------------------------------------------------------
begin
  -- dekomponovat [value]
  name.assign_to_string(value);
  end operator_c_name_assign_n_s;



----------------------------------------------------------------------------------------------------
procedure operator_c_name_assign_s_n =
-- value:=name, makes decomposion into components
----------------------------------------------------------------------------------------------------
var 
  tmp               : p_text_name;               -- pomocn  promˆnn 

begin
  -- konverze z [c_name] na ©etˆzec
  tmp:=name;
  value:=tmp^;

leave
  discard tmp;
  end operator_c_name_assign_s_n;


----------------------------------------------------------------------------------------------------
procedure operator_c_name_assign_ps_n =
-- name:=value, makes composion from components
----------------------------------------------------------------------------------------------------
begin
  -- konverze z ©etˆzce na [c_name]
  name.compose_name(value);
  end operator_c_name_assign_ps_n;
--<<<


----------------------------------------------------------------------------------------------------
procedure get_parent_path =
-- Vr t¡ rodi‡ovsk˜ adres © zadan‚ cesty.
----------------------------------------------------------------------------------------------------
var
  c                : p_name_component;           -- posledn¡ komponenta
  p                : p_name_component;           -- p©edposledn¡ komponenta
begin
  -- %%TODO(TAG)

{
  -- zkop¡rovat objekt do v˜sledn‚ hodnoty
  result:=name.clone;
  c:=result^.components.get_last();

  -- seznam [components] m  posledn¡ prvek
  if c<>nil then
    -- je posledn¡ komponenta jm‚no souboru?
    if c:tag>=c_name_component_file_or_folder:tag then
      -- zjistit p©edposledn¡ komponentu
      p:=result^.get_prev(c);

      -- existuje p©edposledn¡ komponenta?
      if p<>nil then
        -- pokud je p©edposledn¡ komponenta jm‚no slo‘ky, vymazat posledn¡ komponentu v˜sledku
        if p:tag>=c_name_component_file_or_folder:tag then
          pred result^;
          end if;
        end if;
      end if;
    end if;
}
  end get_parent_path;

----------------------------------------------------------------------------------------------------
entry =
-- Initialization.
----------------------------------------------------------------------------------------------------
begin
  -- register the system namespace
  register_namespace(c_namespace_system:tag);
  end entry;



end names;