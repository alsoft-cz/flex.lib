----------------------------------------------------------------------------------------------------
module private files =
-- Files.
-- Flex Standard Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------

with
  classes.lists;

use 
  system.windows,
  system.windows.windef,
  system.windows.windef.winnt,
  system.windows.winbase,
  system.windows.winbase.winerror;



----------------------------------------------------------------------------------------------------
procedure file_ptr_to_system (
    _pos           : in t_file_pointer)
    return system.windows.windef.winnt.large_integer = 
-- Convert flex t_file_pointer to lower part of system accepted varible taken as a file position
----------------------------------------------------------------------------------------------------
begin
  --%%TODO(64) assign to quadpart as soon as t_file_pointer will be unsigned 64
  result.lowpart:=system.windows.windef.dword(t_mod_dword{%%TODO(64)}(_pos) and $FFFF_FFFF);
  result.highpart:=system.windows.windef.winnt.long(t_mod_dword{%%TODO(64)}(_pos) shr 32);
  end file_ptr_to_system;



----------------------------------------------------------------------------------------------------
procedure file_ptr_to_high_part (
    _pos           : in t_file_pointer)    
    return system.windows.windef.winnt.plong =
-- Convert flex t_file_pointer to a pointer to high part of system accepted varible taken as 
-- a file position
----------------------------------------------------------------------------------------------------
begin
  --%%TODO as soon as t_file_pointer will be unsigned 64
  result:=nil;
  end file_ptr_to_high_part;



----------------------------------------------------------------------------------------------------
class private c_filesystem_object =
-- Filesystem class.
----------------------------------------------------------------------------------------------------
-- This class is used as a general ancestor for all filesystem objects, such as c_drive, c_folder
-- and c_file.
-- As such contains general attributes common to all of those filesystem objects and provides
-- methods to operate with these attributes and other virtual methods that have to be overriden.
----------------------------------------------------------------------------------------------------

    var 
      sys_error    : protected windows.windef.dword;  -- system error code
      disable_exceptions : t_logical;

    

    ------------------------------------------------------------------------------------------------
    virtual set_exception_mode =
    ------------------------------------------------------------------------------------------------
    begin
      disable_exceptions:=disable;
      end set_exception_mode;
    

    
    ------------------------------------------------------------------------------------------------
    virtual set_ok =
    -- Clears [this.res] error flag.
    ------------------------------------------------------------------------------------------------
    begin
      res:=tfe_ok;
      sys_error:=0;  
      end set_ok;



    ------------------------------------------------------------------------------------------------
    virtual set_error =
    -- Sets [this.res] to [res], retrieves the error code from the operating system  and executes 
    -- the [event_error] trigger.
    ------------------------------------------------------------------------------------------------
    begin
      -- set result
      this.res:=res;
      
      -- get error code from the operating system
      sys_error:=windows.winbase.getlasterror;

      -- trigger the error event
      execute(event_error);
      if not disable_exceptions then
        raise file_error;
        end if;
      end set_error;



    ------------------------------------------------------------------------------------------------
    virtual get_datetime =
    -- Returns requested date and time information. When the subprogram fails, [res] is set to 
    -- [tfe_get_info].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end get_datetime;



    ------------------------------------------------------------------------------------------------
    virtual set_datetime =
    -- Sets all date and time informations of the file contained in [kind] to [datim]. When the 
    -- method fails, [res] is set to [tfe_set_info].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end set_datetime;



    ------------------------------------------------------------------------------------------------
    virtual get_attribute =                        
    -- Returns the state of the given file attribute [attr]. When the subprogram fails, [res] is set 
    -- to [tfe_get_info] and the return value is undefined.
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        #template check_attribute (sys_attribute);
        --------------------------------------------------------------------------------------------
          (t_mod_dword(win32_attrs) and system.windows.windef.winnt.sys_attribute)<>0
          #end check_attribute;

    var
      win32_attrs   : windows.windef.dword;
      sys_name      : windows.windef.winnt.pwstr; -- system name
      
    begin
      -- composes system file name
      declare var
        text_name  : p_text_name;                -- plain-text name of a file
      begin
        name.compose_name(text_name);
        to_system_string(text_name^,sys_name);
      leave
        discard text_name;
        end declare;

      -- read file attributes
      win32_attrs:=windows.winbase.GetFileAttributesW(sys_name);
      if win32_attrs=system.windows.winbase.INVALID_FILE_ATTRIBUTES then
        set_error(tfe_get_info);
        return;
        end if;

      -- remap win32 attributes to ours
      case attr
        when tfattr_readonly    do result:=check_attribute(FILE_ATTRIBUTE_READONLY);
        when tfattr_temporary   do result:=check_attribute(FILE_ATTRIBUTE_TEMPORARY);
        when tfattr_compressed  do result:=check_attribute(FILE_ATTRIBUTE_COMPRESSED);
        when tfattr_encrypted   do result:=check_attribute(FILE_ATTRIBUTE_ENCRYPTED);
        when tfattr_sparse      do result:=check_attribute(FILE_ATTRIBUTE_SPARSE_FILE);
        when tfattr_hidden      do result:=check_attribute(FILE_ATTRIBUTE_HIDDEN);
        when others             do set_error(tfe_get_info); return;
        end case;

    leave
      discard sys_name;
      end get_attribute;



    ------------------------------------------------------------------------------------------------
    virtual set_attribute =
    -- Sets the state of the given file attribute [attr]. When the subprogram fails, [res] is set to 
    -- [tfe_set_info].
    ------------------------------------------------------------------------------------------------
    var
      win32_attrs   : windows.windef.dword;
      attr_mask     : t_mod_dword;
      sys_name      : windows.windef.winnt.pwstr; -- system name

    begin
      -- composes system file name
      declare var
        text_name  : p_text_name;                -- plain-text name of a file
      begin
        name.compose_name(text_name);
        to_system_string(text_name^,sys_name);
      leave
        discard text_name;
        end declare;

      -- read original file attributes
      win32_attrs:=windows.winbase.GetFileAttributesW(sys_name);
      if win32_attrs = system.windows.winbase.INVALID_FILE_ATTRIBUTES then
        set_error(tfe_set_info);
        return;
        end if;

      -- prepare attribute mask  = which bit will be set/reset
      case attr
        when tfattr_readonly    do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_READONLY;
        when tfattr_temporary   do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_TEMPORARY;
--      when tfattr_compressed  do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_COMPRESSED;   {by other system calls than SetFileAttributes}
--      when tfattr_encrypted   do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_ENCRYPTED;
--      when tfattr_sparse      do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_SPARSE_FILE;
        when tfattr_hidden      do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_HIDDEN;
        when others             do set_error(tfe_set_info); return;
        end case;

      -- change bit as required
      if status 
        then t_mod_dword(win32_attrs) or attr_mask
        else t_mod_dword(win32_attrs) and not attr_mask
        end if;

      -- store modified flags
      if not windows.winbase.SetFileAttributesW(sys_name,win32_attrs) then 
        set_error(tfe_set_info);
        end if;

    leave
      discard sys_name;
      end set_attribute;

    end c_filesystem_object;



---- Working with files ----------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private c_file = 
-- File access class.
----------------------------------------------------------------------------------------------------

    var
      handle       : windows.windef.winnt.t_handle  -- OS file handle
                   := windows.winbase.invalid_handle_value;
      sys_error    : windows.windef.dword;  -- system error code



    ------------------------------------------------------------------------------------------------
    static init_decomposed_name =
    -- Initializes the instance of the file access class.
    ------------------------------------------------------------------------------------------------
    var
      text_name    : p_text_name;

    begin
      -- %%TODO(ADJUST) remember the file name
      -- this.name:=name;
      name.compose_name(text_name);
      this.name.decompose_name(text_name^,tnt_unspecified);
    leave
      discard text_name;
      end init_decomposed_name;



    ------------------------------------------------------------------------------------------------
    static init_text_name =
    -- Initializes the instance of the file access class.
    ------------------------------------------------------------------------------------------------
    begin
      -- remember the file name
      this.name.decompose_name(name,tnt_unspecified);
      end init_text_name;


  {
    ------------------------------------------------------------------------------------------------
    procedure set_global_error_policy =
    -- Sets the global error reporting policy. 
    ------------------------------------------------------------------------------------------------
    begin
      global_error_policy:=error_policy;
      end set_global_error_policy;



    ------------------------------------------------------------------------------------------------
    static set_local_error_policy =
    -- Sets the local error reporting policy. 
    ------------------------------------------------------------------------------------------------
    begin
      local_error_policy:=error_policy;
      end set_local_error_policy;
  }


    ------------------------------------------------------------------------------------------------
    static open_or_create (
        mode       : in t_fs_object_mode_set;    -- requested open mode
        access     : in t_file_access;           -- requested access mode
        sharing    : in t_file_sharing_set;      -- requested sharing mode
        oflag      : in windows.windef.dword) =  -- opening mode
    -- Opens or creates a file.
    ------------------------------------------------------------------------------------------------
    var
      sys_rights   : t_mod_dword;                -- system access rights
      sys_sharing  : t_mod_dword;                -- system sharing mode
      sys_flags    : t_mod_dword;                -- system flags
      sys_name     : windows.windef.winnt.pwstr; -- system name
      text_name    : p_text_name;                -- plain-text name of file

    begin
      -- remember file open parameters
      this.mode:=mode;
      this.access:=access;
      this.sharing:=sharing;

      -- prepare system access rights
      if tfm_read  in mode then sys_rights or windows.windef.winnt.generic_read  end if;
      if tfm_write in mode then sys_rights or windows.windef.winnt.generic_write end if;

      -- prepare system sharing mode
      if tfs_read  in sharing then sys_sharing or windows.windef.winnt.file_share_read  end if;
      if tfs_write in sharing then sys_sharing or windows.windef.winnt.file_share_write end if;

      -- set system caching policy
      case access
        when tfa_random        do sys_flags or windows.winbase.file_flag_random_access;
        when tfa_sequential    do sys_flags or windows.winbase.file_flag_sequential_scan;
        when tfa_write_through do sys_flags or windows.winbase.file_flag_write_through;
        when tfa_no_cache      do sys_flags or windows.winbase.file_flag_no_buffering;
        end case;

      { %%TODO(DECLARE) declare sys_name : ... }
      begin
        -- prepare UNICODE ASCIIZ file name
        -- %%FLEX return of t_char32ustr
        begin
          name.compose_name(text_name);
          to_system_string(text_name^,sys_name);
        leave
          discard text_name;
          end;
   
        -- open file
        handle:=windows.winbase.createfilew(
          sys_name{^},
          windows.windef.dword(sys_rights),
          windows.windef.dword(sys_sharing),
          nil,
          oflag{windows.winbase.open_existing},
          windows.windef.dword(sys_flags),
          {windows.winbase.}null_handle);

      leave
        -- free temporary name
        discard sys_name;
        end;

      -- check result
      if handle=windows.winbase.invalid_handle_value

        -- error
        then set_error(tfe_open);

        -- ok
        else set_ok;
        end if;
      end open_or_create;



    ------------------------------------------------------------------------------------------------
    virtual open =
    -- Opens existing file.
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      -- open the file
      if always
        then open_or_create(mode,access,sharing,windows.winbase.open_always);
        else open_or_create(mode,access,sharing,windows.winbase.open_existing);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end open;



    ------------------------------------------------------------------------------------------------
    virtual create =  
    -- Creates a new file.
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      -- create the file
      if always
        then open_or_create(mode,access,sharing,windows.winbase.create_always);
        else open_or_create(mode,access,sharing,windows.winbase.create_new);
        end if;

      -- if error change error attribute to tfe_create
      if res=tfe_open then res:=tfe_create end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end create;



    ------------------------------------------------------------------------------------------------
    static close =
    -- Closes the file.
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      -- close a file a we have a valid handle
      if handle=windows.winbase.invalid_handle_value or else windows.winbase.closehandle(handle)

        -- ok
        then set_ok

        -- error
        else set_error(tfe_close);
        end if;

      -- get rid of the handle
      handle:=windows.winbase.invalid_handle_value;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end close;



    type
      -- from where to seek in a file
      t_seek_from  = enum
          seek_from_begin;                       -- from the beginning of the file
          seek_from_end;                         -- from the end of the file
          end enum;

    ------------------------------------------------------------------------------------------------
    static seek (
        pos        : in t_file_pointer;          -- position within the file from its beginning
        res        : in t_fs_object_error;       -- error code to set when method fails
        seek_from  : in t_seek_from) =           -- from where to seek in the file
    -- Sets file pointer to the given position from the beginnig of the.
    ------------------------------------------------------------------------------------------------
    const
      -- conversion table from our flag to system's flag
      seek_from_to_system : array t_seek_from of windows.windef.dword = [
          for seek_from_begin use windows.winbase.file_begin,
          for seek_from_end   use windows.winbase.file_end];

    var
      system_file_ptr : windows.windef.winnt.large_integer; -- system representation of file position

    begin
      -- convert file position to system parametrs
      system_file_ptr:=file_ptr_to_system(pos);

      -- perform the actual seek
      if windows.winbase.setfilepointer(handle,
             windows.windef.winnt.long(system_file_ptr.lowpart:unchecked),
            ^windows.windef.winnt.long(system_file_ptr.highpart:unchecked),
             seek_from_to_system[seek_from])
             =$FFFF_FFFF
      and then windows.winbase.getlasterror<>windows.winbase.winerror.no_error
        then set_error(res);
        else set_ok;
        end if;
{ %%X Doesn't word, don't know why.
      -- perform the actual seek
      if not windows.winbase.setfilepointerex(handle,system_file_ptr,nil,windows.winbase.file_begin)
                                        --=windows.winbase.invalid_set_file_pointer
        then set_error(res);
        else set_ok;
        end if;
}
      end seek;



    ------------------------------------------------------------------------------------------------
    static read =
    -- Reads LEN bytes at position POS from the file and stores them to the BUFFER.
    -- File must be open with the read (read/write) access.
    ------------------------------------------------------------------------------------------------
    var
      read         : windows.windef.dword;       -- number of bytes actualy read

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- set file pointer
      seek(pos,tfe_read,seek_from_begin);
      if res<>tfe_ok then 
        return 
        end if;

      -- read data
      if windows.winbase.readfile(handle,buffer,len,read,nil)

        -- read operation succeeded
        then
          -- not enough data read ?
          if read<len

            -- yes => error
            then set_error(tfe_read);

            -- no => ok
            else set_ok;
            end if;

        -- error
        else set_error(tfe_read);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end read;



    ------------------------------------------------------------------------------------------------
    static write =
    -- Writes [len] bytes of data from [buffer] to the file to position 
    -- [pos].
    -- File must be opened for write (or read/write) access.
    ------------------------------------------------------------------------------------------------
    var
      written      : windows.windef.dword;       -- number of bytes actually written

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- set file pointer
      seek(pos,tfe_write,seek_from_begin);
      if res<>tfe_ok then 
        return 
        end if;

      -- write data
      if windows.winbase.writefile(handle,^buffer,len,written,nil)

        -- write operation succeeded
        then
          -- not all data written ?
          if written<len

            -- yes => error
            then set_error(tfe_write);

            -- no => ok
            else set_ok;
            end if;

        -- error
        else set_error(tfe_write);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end write;



    ------------------------------------------------------------------------------------------------
    static append =
    -- Writes [len] bytes of data from [buffer] to the end of file.
    --   File must be opened for write (or read/write) access, otherwise the write operation fails.
    -- When the write operation fails due to any kind of error, [res] is set to 
    -- [tfe_write].
    ------------------------------------------------------------------------------------------------
    var
      written      : windows.windef.dword;       -- number of bytes actually written

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- set file pointer
      seek(0,tfe_write,seek_from_end);
      if res<>tfe_ok then 
        return 
        end if;

      -- write data
      if windows.winbase.writefile(handle,^buffer,len,written,nil)

        -- write operation succeeded
        then
          -- not all data written ?
          if written<len

            -- yes => error
            then set_error(tfe_write);

            -- no => ok
            else set_ok;
            end if;

        -- error
        else set_error(tfe_write);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end append;




    ------------------------------------------------------------------------------------------------
    static flush =
    ------------------------------------------------------------------------------------------------
    begin
      if not windows.winbase.flushfilebuffers(handle) then
        set_error(tfe_write);
        end if;
      end flush;



    ------------------------------------------------------------------------------------------------
    static get_size =
    -- Current size of the file.
    ------------------------------------------------------------------------------------------------
    var
      sys_size     : windows.windef.dword;  -- file size (low order 32 bits)

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- get the size of the file
      sys_size:=windows.winbase.getfilesize(handle,nil);
      if sys_size=sys_size:last{-1}

        -- error
        then
          result:=0;
          set_error(tfe_get_info);

        -- ok
        else
          result:=t_file_pointer(sys_size);
          set_ok;
          end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end get_size;



    ------------------------------------------------------------------------------------------------
    static set_size =
    -- Sets file's size to [size].
    -- When [size] is shorter than the actual file size, the file is truncated. When
    -- [size] is longer than the actual file size, it is enlarged and the new space is 
    -- filled with binary zeroes when [zero] is [true], otherwise it is left
    -- uninitialized.
    ------------------------------------------------------------------------------------------------
    begin 
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end set_size;



    ------------------------------------------------------------------------------------------------
    static get_output_stream =
    -- Temporary, to be removed once interfaces (abstract classes) will work.
    ------------------------------------------------------------------------------------------------
    var
      os           : p_file_output_stream;

    begin
      new os;
      os^.init(^this);
      result:=os;
      end get_output_stream;



  { 
    ------------------------------------------------------------------------------------------------
    entry =
    -- Initialization.
    ------------------------------------------------------------------------------------------------
    begin
      -- initialize local error reporting policy
      local_error_policy:=global_error_policy;
      end entry;
  }


    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalization.
    ------------------------------------------------------------------------------------------------
    begin
      -- close a potentially unclosed file
      if handle<>windows.winbase.invalid_handle_value then
        close;
        end if;
      end exit;
 
    end c_file;



---- Working with folders --------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class c_folder_content_trigger = extend c_trigger;
----------------------------------------------------------------------------------------------------

    type
      -- the desired content of the collection
      t_collection_content = enum
           content_files;                        -- the collection shall contain names of files
           content_folders;                      -- the collection shall contain names of folders
           end enum;

    ------------------------------------------------------------------------------------------------
    static init (
        parent     : in p_folder;                -- parent folder
        collection : in p_names;                 -- related collection of names
        content    : in t_collection_content);   -- the desired content of the collection
    -- Initializes the content trigger.
    ------------------------------------------------------------------------------------------------

  private

    var
      parent       : p_folder;                   -- parent folder
      collection   : p_names;                    -- related collection of names
      content      : t_collection_content;       -- the desired content of the collection
      initialized  : t_logical;                  -- [true] if the collection has already been initialized

    ------------------------------------------------------------------------------------------------
    static init =
    -- Initializes the content trigger.
    ------------------------------------------------------------------------------------------------
    begin
      this.parent:=parent;
      this.collection:=collection;
      this.content:=content;
      end init;



    ------------------------------------------------------------------------------------------------
    override execute =
    -- Trigger of the "before" action on an uninitialized collection.
    ------------------------------------------------------------------------------------------------
    var
      _search_mask : p_text_name;
      search_mask  : p_text_name;                -- search mask
      sys_search_mask : windows.windef.winnt.pwstr; -- system search mask
      find_data    : windows.winbase._win32_find_dataw; -- data returned by the system
      search_op    : windows.winbase.findex_search_ops;     -- system search operation type
      search_handle: windows.windef.winnt.t_handle := windows.winbase.invalid_handle_value; -- handle of the search
      name         : p_name;                     -- decomposed name being inserted into the collection
      text_name    : p_text_name;                -- found plain-text name

    begin
      -- intercept only before-calls to uninitialized collection
      if {%%TODO(TAG) event<>event_before or else} initialized then
        return;
        end if;

      -- the collection is now initialized
      -- %%TODO(TAG) After specializing the event to event_before_retrieve, move this statement
      -- back to the end of this procedure. Actually here it serves on as an unwanted recursion 
      -- barrier.
      initialized:=true;

      -- compose name of the parent folder with search mask
      -- %%TODO(ADJUST) parent^.name.compose_name(search_mask);
      --                adjust search_mask range search_mask^:length+2;
      parent^.name.compose_name(_search_mask);
      new search_mask range _search_mask^:length+2;
      search_mask^:=_search_mask^;
      if search_mask^[search_mask^:length]<>"\"
        then search_mask^ & '\*';
        else search_mask^ & "*";
        end if;

      -- convert to a system string
      to_system_string(search_mask^,sys_search_mask);

      begin
        -- setup the search
        case content
          when content_files   do search_op:=windows.winbase.FindExSearchNameMatch;
          when content_folders do search_op:=windows.winbase.FindExSearchLimitToDirectories;
          end case;
        search_handle:=windows.winbase.findfirstfileexw(sys_search_mask,windows.winbase.FindExInfoStandard,find_data,search_op,nil,0);

        -- process all found entries
        if search_handle<>windows.winbase.invalid_handle_value then
          loop
            -- insert matching entry into the names collection
            if (content=content_files   and (t_mod_dword(find_data.dwfileattributes) and windows.windef.winnt.file_attribute_directory)=0)
            or (content=content_folders and (t_mod_dword(find_data.dwfileattributes) and windows.windef.winnt.file_attribute_directory)<>0) then
              -- %%TODO(DECLARE) declare name, text_name
              begin
                -- prepare a plain-text name
                from_system_string(windows.windef.winnt.pwstr(^find_data.cFileName),p_char32ustr(text_name));

                -- ignore special directories '.' and '..' 
                if content<>content_folders or else (text_name^<>'.' and text_name^<>'..') then
                  -- decompose into a [c_name]
                  new name;
                  name^.decompose_name(text_name^,tnt_relative);

                  -- insert into the collection
                  collection^.insert(p_list_item(name));
                  end if;

              leave
                discard text_name;
                end;
              end if;

            -- search for the next entry
            until not windows.winbase.findnextfilew(search_handle,find_data);
          end if;

      leave
        -- close the search
        if not windows.winbase.findclose(search_handle) then
          -- and what? %%FLEX
          end if;
        end;

    leave
      discard _search_mask;
      discard search_mask;
      discard sys_search_mask;
      end execute;

    end c_folder_content_trigger;



----------------------------------------------------------------------------------------------------
class private c_folder = 
----------------------------------------------------------------------------------------------------

    var 
      handle       : windows.windef.winnt.t_handle;    -- OS file handle

      -- triggers of the "before" action on uninitialized names collections
      files_trigger   : aliased c_folder_content_trigger;
      folders_trigger : aliased c_folder_content_trigger;

    ------------------------------------------------------------------------------------------------
    static init_decomposed_name =
    -- Initializes the instance of the folder access class with the given folder name. 
    --
    -- Result:
    --   This subprogram always succeeds.
    --
    -- Remarks:
    --   -- This subprogram is not triggerable.
    ------------------------------------------------------------------------------------------------
    var
      text_name    : p_text_name;

    begin
      -- %%TODO(ADJUST) remember the file name
      -- this.name:=name;
      name.compose_name(text_name);
      this.name.decompose_name(text_name^,tnt_unspecified);
    leave
      discard text_name;
      end init_decomposed_name;



    ------------------------------------------------------------------------------------------------
    static init_text_name =
    -- Initializes the instance of the folder access class with the given folder name. 
    --
    -- Result:
    --   This subprogram always succeeds.
    --
    -- Remarks:
    --   -- This subprogram is not triggerable.
    ------------------------------------------------------------------------------------------------
    begin
      this.name.decompose_name(name,tnt_unspecified);
      end init_text_name;
    
    
{    
    ------------------------------------------------------------------------------------------------
    static open =
    -- Opens an existing folder.
    --
    -- Result:
    --   When folder does not exist opening failes, [res] is set to [tfe_open].
    --   When user program has no rigths to open the folder, opening fails,
    --      [res] is set to [tfe_open].
    ------------------------------------------------------------------------------------------------
    var
      sys_rights   : windows.windef.tsys_dword;  -- system access rights
      sys_sharing  : windows.windef.tsys_dword;  -- system sharing mode
      sys_flags    : windows.windef.tsys_dword;  -- system flags
      sys_name     : windows.windef.winnt.psys_wstr; -- system name
      text_name    : p_text_name;                -- plain-text name of a file

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- remember file open parameters
      this.mode:=mode;

      -- prepare system access rights
      if tfm_read  in mode then sys_rights or windows.windef.winnt.generic_read  end if;
      if tfm_write in mode then sys_rights or windows.windef.winnt.generic_write end if;

{      -- prepare system sharing mode
      if tfs_read  in sharing then sys_sharing or windows.windef.winnt.file_share_read  end if;
      if tfs_write in sharing then sys_sharing or windows.windef.winnt.file_share_write end if;}

      -- set system caching policy
{      case access
        when tfa_random        do sys_flags or windows.winbase.file_flag_random_access;
        when tfa_sequential    do sys_flags or windows.winbase.file_flag_sequential_scan;
        when tfa_write_through do sys_flags or windows.winbase.file_flag_write_through;
        when tfa_no_cache      do sys_flags or windows.winbase.file_flag_no_buffering;
        end case;}

      -- set directory flag
      sys_flags or windows.winbase.file_flag_backup_semantics;

      {%%FLEX declare sys_name : ... }
      begin
        -- prepare UNICODE ASCIIZ file name
        -- %%FLEX return of t_char32ustr
        begin
          name.compose_name(text_name);
          to_system_string(text_name^,sys_name);
        leave
          discard text_name;
          end;
   
        -- open file
        handle:=windows.winbase.createfilew(
          sys_name^,sys_rights,sys_sharing,nil,windows.winbase.open_existing,
          sys_flags,windows.winbase.null_handle)

      leave
        -- free temporary name
        discard sys_name;
        end;

      -- check result
      if handle=windows.winbase.invalid_handle_value

        -- error
        then set_error(tfe_open);

        -- ok
        else set_ok;
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end open;
}    
    
    
    ------------------------------------------------------------------------------------------------
    static create =
    -- Creates a new folder.
    --
    -- Result:
    --   When folder exists then it will be opened.
    --   When folder does not exist, new one is created.
    --   When user program has no rigths to create the folder, creation fails,
    --      [res] is set to [tfe_create].
    ------------------------------------------------------------------------------------------------
    var 
      sys_res      : windows.windef.bool;        -- result of system call
      sys_name     : windows.windef.winnt.pwstr; -- system name
      sys_template_name : windows.windef.winnt.pwstr; -- system name of template folder
      text_name    : p_text_name;                -- plain-text name of a file

    begin
      -- trigger the 'before' event
      execute(event_before);

      begin 
        -- convert folder name
        begin
          name.compose_name(text_name);
          to_system_string(text_name^,sys_name);
        leave
          discard text_name;
          end;

        if template=nil 

          -- creation of a new directory 
          then
            sys_res:=windows.winbase.createdirectoryw(sys_name,nil{%%TODO security attributes});

          -- creation of given the template directory
          else
            begin
              template^.name.compose_name(text_name);
              to_system_string(text_name^,sys_template_name);
            leave
              discard text_name;
              end;
            sys_res:=windows.winbase.createdirectoryexw(sys_template_name,sys_name,nil{%%TODO security attributes});
            end if;

      leave   
        discard sys_name;
        discard sys_template_name;
        end;

      -- check result 
      if sys_res 
        -- ok
        then
          set_ok;

        --error
        else
          set_error(tfe_create);
          end if;
    {
      -- %%TODO mon by open nemusel bt soust create, ale to by zase neodpovdalo koncepci soubor
      -- open the created directory
      if res<>tfe_ok then open(mode); end if;
    }
    leave
      -- trigger the 'after' event
      execute(event_after);
      end create;
    
    
{    
    ------------------------------------------------------------------------------------------------
    static close =
    -- Closes the file.
    -- The file needs not to be opened (nothing happens in this case).
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      if windows.winbase.closehandle(handle)
        -- ok
        then set_ok

        -- error
        else set_error(tfe_close);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end close;
}


    ------------------------------------------------------------------------------------------------
    static get_sub_folder =
    -- 
    ------------------------------------------------------------------------------------------------
    begin
      result.init_decomposed_name(this.name);
      result.name.join_after(sub_folder);
      end get_sub_folder;



    ------------------------------------------------------------------------------------------------
    entry =
    -- Initialization.
    ------------------------------------------------------------------------------------------------
    begin
      -- setup the triggers for files and folders names collections
      files_trigger.init(^this,^files,files_trigger.content_files);
      folders_trigger.init(^this,^folders,folders_trigger.content_folders);
      files.register_trigger(^files_trigger);
      folders.register_trigger(^folders_trigger);
      end entry;

    end c_folder;



---- Working with drives ---------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private c_drive = 
----------------------------------------------------------------------------------------------------
    
--    var 
--      mount_point  : protected c_name;
--      mounted      : protected boolean;
--      root_folder  : protected c_folder;

    ------------------------------------------------------------------------------------------------
    static set_mount_point =
    -- Sets [mount_point] of the drive to [new_mount_point].
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end set_mount_point;
    

    
    ------------------------------------------------------------------------------------------------
    static get_mount_point =
    -- Returns mount point of the logical drive.
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end get_mount_point;
    

    
    ------------------------------------------------------------------------------------------------
    static mount =
    -- Mounts drive to the specified [mount_point].
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end mount;
    

    
    ------------------------------------------------------------------------------------------------
    static unmount = 
    -- Unmounts the drive. On system which does not support unmounting it simulates the unmount and 
    -- then the drive will behave as unmounted for our application.
    -- %%TODO to je ale njak divn
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end unmount; 

    end c_drive;



----------------------------------------------------------------------------------------------------
class private c_drives =
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static update =
    -- Updates the list of available drives.
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end update;


    end c_drives;



----------------------------------------------------------------------------------------------------
class private c_file_manager =
----------------------------------------------------------------------------------------------------
    
    ------------------------------------------------------------------------------------------------
    static copy_file =
    -- Copies file of name [srcname] to a file at destination of [destname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_copy].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end copy_file;



    ------------------------------------------------------------------------------------------------
    static move_file =
    -- Moves file of name [srcname] to a file at destination of [destname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_move].
    ------------------------------------------------------------------------------------------------
    var
      ssys_name     : windows.windef.winnt.pwstr; -- system name
      stext_name    : p_text_name;                -- plain-text name of a file
      dsys_name     : windows.windef.winnt.pwstr; -- system name
      dtext_name    : p_text_name;                -- plain-text name of a file

    begin
      begin
        srcname.compose_name(stext_name);
        to_system_string(stext_name^,ssys_name);
        destname.compose_name(dtext_name);
        to_system_string(dtext_name^,dsys_name);
      leave
        discard stext_name;
        discard dtext_name;
        end;
      
      if not windows.winbase.MoveFileW(ssys_name,dsys_name) then
        raise file_error;
        end if;
      leave   
        discard dsys_name;
        discard ssys_name;
      end move_file;



    ------------------------------------------------------------------------------------------------
    static delete_file =
    -- Deletes file of name [filename].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_delete].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end delete_file;



    ------------------------------------------------------------------------------------------------
    static copy_folder =
    -- Copies folder of name [srcname] to a folder at destination of [destname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_copy].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end copy_folder;



    ------------------------------------------------------------------------------------------------
    static move_folder =
    -- Moves file of name [srcname] to a file at destination of [destname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_move].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end move_folder;



    ------------------------------------------------------------------------------------------------
    static remove_folder =
    -- Removes folder of name [pathname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If parametr [always] is false the folder must be empty otherwise this operation fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_delete].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end remove_folder;



    ------------------------------------------------------------------------------------------------
    virtual progress = 
    -- Returns progress information about the operation being processed.
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end progress;


    end c_file_manager;

----------------------------------------------------------------------------------------------------
#separate private streams;
----------------------------------------------------------------------------------------------------

end files;