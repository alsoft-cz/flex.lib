----------------------------------------------------------------------------------------------------
module private conversions =
-- Miscellaneous conversion routines.
-- Flex Standard Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------



const
  -- konstanty pro p°evod 
  fp_p_0       : t_extended = [$00,$00,$00,$00,$00,$00,$00,$00,$00,$00]; --  0
  fp_p_1       : t_extended = [$00,$00,$00,$00,$00,$00,$00,$80,$FF,$3F]; --  1
  fp_p_01      : t_extended = [$CD,$CC,$CC,$CC,$CC,$CC,$CC,$CC,$FB,$3F]; --  0.1
  fp_p_10      : t_extended = [$00,$00,$00,$00,$00,$00,$00,$A0,$02,$40]; -- 10
  fp_p_1e17    : t_extended = [$00,$00,$00,$C5,$2E,$BC,$A2,$B1,$37,$40]; --  1e17

type
  -- mocninn² rozvoj p°evßd∞nΘho Φφsla
  t_expansion      = array 0..12 of record
    exp            : t_signed;                   -- exponent 2^i
    pos            : t_extended;                 -- koeficient 10^(2^i)
    neg            : t_extended;                 -- koeficient 10^-(2^i)
    end record;

var
  -- Mantisa je sprßvn∞ zaokrouhlenß, v komentß°i je uvedena p∙vodnφ hodnota
  -- p°ed zaokrouhlenφm + jeden dalÜφ byte mantisy.
  -- Pozor, n∞kterΘ hodnoty NEG vypoΦtenΘ p°φmo procesorem se o 1 bit liÜφ
  -- (nejsou zaokrouhlenΘ, jen od°φznutΘ).
  expansion   : const t_expansion := [
    [ 0001, [{$00,}$00{00},$00,$00,$00,$00,$00,$00,$A0,$02,$40], [{$CC,}$CD{CC},$CC,$CC,$CC,$CC,$CC,$CC,$CC,$FB,$3F]],
    [ 0002, [{$00,}$00{00},$00,$00,$00,$00,$00,$00,$C8,$05,$40], [{$3D,}$0A{0A},$D7,$A3,$70,$3D,$0A,$D7,$A3,$F8,$3F]],
    [ 0004, [{$00,}$00{00},$00,$00,$00,$00,$00,$40,$9C,$0C,$40], [{$D3,}$2C{2B},$65,$19,$E2,$58,$17,$B7,$D1,$F1,$3F]],
    [ 0008, [{$00,}$00{00},$00,$00,$00,$00,$20,$BC,$BE,$19,$40], [{$FD,}$FD{FC},$CE,$61,$84,$11,$77,$CC,$AB,$E4,$3F]],
    [ 0016, [{$00,}$00{00},$00,$00,$04,$BF,$C9,$1B,$8E,$34,$40], [{$4C,}$5B{5B},$E1,$4D,$C4,$BE,$94,$95,$E6,$C9,$3F]],
    [ 0032, [{$F0,}$9E{9D},$B5,$70,$2B,$A8,$AD,$C5,$9D,$69,$40], [{$67,}$BA{BA},$94,$39,$45,$AD,$1E,$B1,$CF,$94,$3F]],
    [ 0064, [{$3C,}$D5{D5},$A6,$CF,$FF,$49,$1F,$78,$C2,$D3,$40], [{$3F,}$A5{A5},$E9,$39,$A5,$27,$EA,$7F,$A8,$2A,$3F]],
    [ 0128, [{$C6,}$E0{DF},$8C,$E9,$80,$C9,$47,$BA,$93,$A8,$41], [{$AC,}$A1{A0},$E4,$BC,$64,$7C,$46,$D0,$DD,$55,$3E]],
    [ 0256, [{$DD,}$8E{8D},$DE,$F9,$9D,$FB,$EB,$7E,$AA,$51,$43], [{$FA,}$3A{39},$19,$7A,$63,$25,$43,$31,$C0,$AC,$3C]],
    [ 0512, [{$CC,}$C7{C6},$91,$0E,$A6,$AE,$A0,$19,$E3,$A3,$46], [{$71,}$1D{1C},$D2,$23,$DB,$32,$EE,$49,$90,$5A,$39]],
    [ 1024, [{$65,}$17{17},$0C,$75,$81,$86,$75,$76,$C9,$48,$4D], [{$87,}$BE{BD},$C0,$57,$DA,$A5,$82,$A6,$A2,$B5,$32]],
    [ 2048, [{$A7,}$E5{E4},$5D,$3D,$C5,$5D,$3B,$8B,$9E,$92,$5A], [{$49,}$E4{E4},$2D,$36,$34,$4F,$53,$AE,$CE,$6B,$25]],
    [ 4096, [{$C9,}$9B{9A},$97,$20,$8A,$02,$52,$60,$C4,$25,$75], [{$2D,}$DE{DE},$9F,$CE,$D2,$C8,$04,$DD,$A6,$D8,$0A]]];


type
  t_BCDmantissa    = array 0..17 of t_char32;




----------------------------------------------------------------------------------------------------
procedure addx (
    bin            : in out unchecked;           -- binary number
    lbin           : in t_unsigned;              -- length of the number in bytes
    n              : in t_unsigned;              -- constant (0-255)
    overflow       : out t_logical) =
-- Addition of a small coefficient within the range 0-255 to a long unsigned integer
-- Coefficient's range is not tested.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm; 
        mov     ecx,lbin       -- dΘlka binßrnφho Φφsla
        jecxz   @0             -- nulovß, nic neprovßd∞t
        mov     al,<1>n        -- p°iΦφtanß konstanta
        mov     edi,bin        -- index pole nastavit na zaΦßtek
        clc                    -- Řßdn² p°enos z minulΘho kroku
        add     [edi],al       -- p°iΦφst jeden byte
        mov     al,0           -- za chvφli tam budu pot°ebovat nulu
        jmp     @2             
@1:     adc     [edi],al       -- p°iΦφst p°enos
@2:     jnc     @0             -- nenastal p°enos, konΦφme s p°iΦφtßnφm
        inc     edi            -- index pole nastavit na dalÜφ byte
        loop    @1
        mov     edi,overflow   -- adresa prom∞nnΘ pro p°eteΦenφ
        mov     <1>[edi],1     -- nastal p°enos, vrßtit chybu (jen 1 byte, p°edpoklßdßm, Ře je prom∞nnß vynulovanß)
@0:     
  #end asm;  
  end addx;





----------------------------------------------------------------------------------------------------
procedure mulx (
    bin            : in out unchecked;           -- binary number
    lbin           : in t_unsigned;              -- length of the number in bytes
    n              : in t_unsigned;              -- constant (0-255)
    overflow       : out t_logical) =
-- Multiplication of a long unsigned integer by a small coefficient within the range 0-255.
-- Coefficient's range is not tested.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm; 
        mov     ecx,lbin       -- dΘlka binßrnφho Φφsla
        jecxz   @0             -- nulovß, nic neprovßd∞t
        mov     dl,<1>n        -- koeficient
        mov     edi,bin        -- index pole nastavit na zaΦßtek
        mov     bx,0           -- p°enos z minulΘho kroku je pro zaΦßtek nulov²
@1:     mov     al,[edi]       -- Φinitel
        mul     dl             -- vynßsobit koeficientem
        add     ax,bx          -- p°enos z minulΘho kroku
        mov     [edi],al
        mov     bl,ah
        inc     edi            -- index pole nastavit na dalÜφ byte
        loop    @1
        cmp     bl,0           -- poslednφ p°enos je nulov², je to OK
        jz      @0
        mov     edi,overflow   -- adresa prom∞nnΘ pro p°eteΦenφ
        mov     <1>[edi],1     -- nastal p°enos, vrßtit chybu (jen 1 byte, p°edpoklßdßm, Ře je prom∞nnß vynulovanß)
@0:     
  #end asm;  
  end mulx;




----------------------------------------------------------------------------------------------------
procedure divx (
    bin            : in out unchecked;           -- binary number
    lbin           : in t_unsigned;              -- length of the number in bytes
    n              : in t_unsigned;              -- constant (0-255)
    remainder      : out t_unsigned) =
-- Division long unsigned integer by a small coefficient within the range 0-255.
-- Coefficient's range is not tested.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm; 
        mov     ebx,0          -- p°enos z minulΘho kroku je pro zaΦßtek nulov²
        mov     ecx,lbin       -- dΘlka binßrnφho Φφsla
        jecxz   @0             -- nulovß, nic neprovßd∞t
        mov     dl,<1>n        -- d∞litel
        mov     edi,bin        -- index pole... 
        add     edi,ecx        -- ...nastavit t∞sn∞ za konec
        dec     edi            -- ...a te∩ p°esn∞ na konec
@1:     mov     al,[edi]       -- d∞lenec
        mov     ah,0           -- vyÜÜφ slabika je nulovß
        add     ax,bx          -- p°enos z minulΘho kroku
        div     dl             -- vyd∞lit
        mov     [edi],al       -- v²sledek uloŘit
        mov     bh,ah          -- poznamenat si p°enost
        dec     edi            -- index pole nastavit na p°edchozφ byte
        loop    @1
@0:     mov     edi,remainder  -- adresa zbytku
        mov     [edi],bh       -- p°edat zbytek (jen 1 byte, p°edpoklßdßm, Ře je prom∞nnß vynulovanß)
  #end asm;  
  end divx;


  

----------------------------------------------------------------------------------------------------
procedure is_zero (
    bin            : in out unchecked;           -- binary number
    lbin           : in t_unsigned)              -- length of the number in bytes
    return t_logical =
-- Test if a long unsigned integer is zero.
-- Works for t_unsigned:bits >= 8
----------------------------------------------------------------------------------------------------
begin
  #syntax asm; 
        mov     ecx,lbin       -- dΘlka binßrnφho Φφsla
        jecxz   @0             -- nulovß, nic neprovßd∞t
@1:     cmp     <1>[edi],0     -- je to nula ?        
        jnz     @2             -- nenφ!
        loop    @1
        jmp     @0             -- vÜechno bylo nulovΘ, konΦφme
@2:     mov     result,1       -- je to nula
@0:     
  #end asm;  
  end is_zero;




----------------------------------------------------------------------------------------------------
procedure is_negative (
    bin            : in out unchecked;           -- binary number
    lbin           : in t_unsigned)              -- length of the number in bytes
    return t_logical =
-- Test if a long signed integer is < 0.
-- Works for t_unsigned:bits >= 8
----------------------------------------------------------------------------------------------------
begin
  #syntax asm; 
        mov     edi,bin
        add     edi,lbin
        dec     edi
        mov     al,[edi]
        shr     al,7
        mov     <1>result,al
  #end asm;  
  end is_negative;




----------------------------------------------------------------------------------------------------
procedure negx (
    bin            : in out unchecked;           -- binary number
    lbin           : in t_unsigned;              -- length of the number in bytes
    overflow       : out t_logical) =
-- Change sign
----------------------------------------------------------------------------------------------------
begin
  #syntax asm; 
        mov     edi,bin
        mov     ecx,lbin
        clc
        cld
@1:     mov     al,0
        sbb     al,[edi]
        stosb
        loop    @1
        jno     @0
        mov     edi,overflow
        mov     <1>[edi],1
@0:
  #end asm;  
  end negx;




----------------------------------------------------------------------------------------------------
procedure unsigned_to_string_primitive =
--  num            : in t_unsigned;              -- number to convert
--  radix          : in t_radix;                 -- radix of the number system
--  s              : out t_char32str;            -- it's string representation
--  code           : out t_conversion_result) =  -- conversion result
-- Converts a signed integer to its string representation. 
----------------------------------------------------------------------------------------------------
var
  bin              : t_unsigned;
  digit            : t_unsigned;                 -- 1 digit
  c                : s:base;                     -- 1 digit in character representation

begin
  code:=tcres_ok;
  s:='';
  bin:=num;
  loop
    divx(bin,bin:size,radix,digit);
    if digit<=9
      then c:=c:type("0":ord+digit)
      else c:=c:type("A":ord+digit-10);
      end if;
    s:=c & s;
  until bin=0;
  end unsigned_to_string_primitive;




----------------------------------------------------------------------------------------------------
procedure signed_to_string_primitive =
--  num            : in t_signed;                -- number to convert
--  radix          : in t_radix;                 -- radix of the number system
--  s              : out t_char32str;            -- it's string representation
--  sign           : out t_logical;              -- True = negative
--  code           : out t_conversion_result) =  -- conversion result
-- Converts a signed integer to its string representation. 
----------------------------------------------------------------------------------------------------
begin
  if num>=0
    then
      sign:=false;
      unsigned_to_string_primitive(t_unsigned(num),radix,s,code);
    else 
      sign:=true;
      unsigned_to_string_primitive(t_unsigned(-num),radix,s,code);
    end if;
  end signed_to_string_primitive;




----------------------------------------------------------------------------------------------------
procedure string_to_unsigned_primitive =
--  s              : in t_char32ustr;            -- string represetation of a value
--  radix          : in t_radix;                 -- radix of the number system
--  num            : out unchecked;              -- corresponding binary representation
--  code           : out t_conversion_result) =  -- conversion result
-- Converts a string representation of an unsigned integer to the corresponding binary 
-- representation. 
----------------------------------------------------------------------------------------------------
var
  i                : s:range:type;               -- index to the string
  digit            : t_unsigned;                 -- 1 digit
  c                : s:base;                     -- processed character
  overflow         : t_logical;

begin
  -- convert
  i:=1;
  while i<=s:length loop
    -- shift left (multiply by radix)
    mulx(num,num:size,radix,overflow);
    if overflow then
      code:=tcres_out_of_range;
      return;
      end if;

    -- get one character
    c:=s[i];

    -- convert the character to its corresponding value
    if    {%%TODO(SET) c in digits}  c>="0" and c<="9" then digit:=c:ord-"0":ord
    elsif {%%TODO(SET) c in letterL} c>="a" and c<="z" then digit:=c:ord-"a":ord+10
    elsif {%%TODO(SET) c in letterU} c>="A" and c<="Z" then digit:=c:ord-"A":ord+10
    else
      code:=tcres_not_a_number;
      return;
      end if ;

    -- does the digit fit to the expected radix ?
    if digit>=radix then
      code:=tcres_not_a_number;
      return;
      end if;

    -- add digit
    addx(num,num:size,digit,overflow);
    if overflow then
      code:=tcres_out_of_range;
      return;
      end if;

    -- next character
    succ i;
    end loop;

  end string_to_unsigned_primitive; 




----------------------------------------------------------------------------------------------------
procedure string_to_signed_primitive =
--  s              : in t_char32ustr;            -- string represetation of a value
--  radix          : in t_radix;                 -- radix of the number system
--  sign           : in t_logical;               -- True = negative
--  num            : out unchecked;              -- corresponding binary representation
--  code           : out t_conversion_result) =  -- conversion result
-- Converts a string representation of an unsigned integer to the corresponding binary 
-- representation. 
----------------------------------------------------------------------------------------------------
var
  overflow         : t_logical;

begin
  string_to_unsigned_primitive(s,radix,num,code);
  if code<>tcres_ok then return end if;
  if sign then
    negx(num,num:size,overflow);
    if overflow then
      code:=tcres_out_of_range;
      return;
      end if;
    end if;
  end string_to_signed_primitive; 




----------------------------------------------------------------------------------------------------
procedure fp_evaluate_exception =
-- Vyhodnotφ stavov² registr floating-point a vyvolß v²jimku
----------------------------------------------------------------------------------------------------
var
  fp_sw            : mod unsigned 16;
  
begin
  #syntax asm; 
    wait 
    fstsw   fp_sw
    fnclex       
  #end asm;  

  if (fp_sw and fp_sw_invalid) > 0 then raise fp_invalid_operand; end if;
  if (fp_sw and fp_sw_denormal) > 0 then raise fp_denormal_operand; end if;
  if (fp_sw and fp_sw_zerodivide) > 0 then raise fp_divide_by_zero; end if;
  if (fp_sw and fp_sw_overflow) > 0 then raise fp_numeric_overflow; end if;
  if (fp_sw and fp_sw_underflow) > 0 then raise fp_numeric_underflow; end if;
--  if (fp_sw and fp_sw_inexact) > 0 then raise fp_inexact_result; end if;
  end fp_evaluate_exception;




----------------------------------------------------------------------------------------------------
procedure mantissa_to_BCD (
    num            : in t_extended;              -- Φφslo kterΘ p°evΘst
    BCD            : out t_BCDmantissa) =        -- znakovß reprezentace
-- P°evede zaokrouhlenou hodnotu NUM na °et∞zec v rozsahu 0 aŘ + 10e18-1.
----------------------------------------------------------------------------------------------------
var
  z                : mod unsigned 8;                -- zpracovßvan² nibble (BCD Φφslice)
  pBCD             : array 0..9 of mod unsigned 8;   -- mantisa v packed BCD formßtu
  FP               : t_extended;
  x                : t_unsigned;                 -- index znaku v BCD

begin

  FP:=num;

  -- p°evΘst float na packed BCD
  #syntax asm; 
    -- nacist cislo FP 
    lea     eax,FP
    fld     <10>[eax]
    -- ulozit jako BCD
    lea     eax,pBCD
    fbstp   <10>[eax]
  #end asm;  

  fp_evaluate_exception;

  -- indefinite
  if pBCD[pBCD:last] = 2$11111111 then
    raise fp_invalid_operand;
    end if;
 
  -- sign
  if (pBCD[pBCD:last] and 2$10000000) = 2$10000000 then
    raise fp_invalid_operand;
    end if;
 
  -- numerickß Φßst
  x:=BCD:first;
  for i in reverse pBCD:first..pBCD:last-1 loop
    -- z bytu vybrat prvnφ Φφslici
    z:=((pBCD[i] and 2$11110000) shr 4);
    BCD[x]:=t_char32("0":ord+z);
    x+1;

    -- z bytu vybrat druhou Φφslici
    z:=(pBCD[i] and 2$00001111);
    BCD[x]:=t_char32("0":ord+z);
    x+1;

    end loop;
  end mantissa_to_BCD;





----------------------------------------------------------------------------------------------------
procedure BCD_to_mantissa (
    BCD            : in t_BCDmantissa;           -- znakovß reprezentace   
    num            : out t_extended) =           -- numerickß reprezentace
-- P°evede celΘ Φφslo v rozsahu 0 aŘ + 10e18-1 na float point.
-- ╪et∞zec str 
--   - musφ mφt dΘlku v rozsahu 1 aŘ 18 znak∙,
--   - nesmφ obsahovat jinΘ znaky neŘ "0" az "9".
----------------------------------------------------------------------------------------------------
var
  x                : t_unsigned;                     -- po°adφ nibblu 
  z                : mod unsigned 8;                 -- zpracovßvan² nibble (BCD Φφslice)
  pBCD             : array 0..9 of mod unsigned 8;   -- mantisa v packed BCD formßtu
  FP               : t_extended;

begin

  x:=0;
  for i in reverse BCD:range loop
    -- nenumerick² znak
    if BCD[i]<"0" or BCD[i]>"9" then
      raise fp_invalid_operand;
      end if;

    -- p°evΘst na nibble
    z:=z:type(BCD[i]:ord-"0":ord);

    -- p°idat nibble to packed BCD
    if x mod 2 = 0
      -- p°idat sud² nibble
      then pBCD[x div 2] or (z and 2$00001111);
      -- p°idat lich² nibble
      else pBCD[x div 2] or ((z and 2$00001111) shl 4);
      end if;

    x+1;
    end loop;

  -- p°evΘst packed BCD na float
  #syntax asm; 
    -- nacist cislo BCD
    lea     eax,pBCD
    fbld    <10>[eax]
    -- ulozit jako FP
    lea     eax,FP
    fstp    <10>[eax]
  #end asm;  

  fp_evaluate_exception;

  num:=FP;

  end BCD_to_mantissa;




----------------------------------------------------------------------------------------------------
procedure BCD_to_float (
    -- dekadickß reprezentace
    sign           : in t_logical;               -- znamΘnko Φφsla (true = zßpornΘ)  
    BCD            : in t_BCDmantissa;           -- znakovß reprezentace   
    exp            : in t_signed;                -- exponent 
    -- float point Φφslo
    num            : out t_extended) =           -- numerickß reprezentace
-- P°evede °et∞zec na NUM.
-- %%TODO PouŘφvß instrukci fbstp kterß omezuje p°esnost p°evodu --> Φasem p°ed∞lat
----------------------------------------------------------------------------------------------------
var
  wexp             : t_signed;                   -- pracovnφ hodnota exponentu   
  i                : t_unsigned;                 -- index do tabulky mocninnΘho rozvoje

begin
  -- mantisu p°evΘst na float point
  BCD_to_mantissa(BCD,num);

  -- Mantisa je uvedena na 18 mφst, takŘe jsem zφskal Φφslo 1e17 krßt v∞tÜφ,
  -- musφme tudφŘ korigovat exponent. A jeÜt∞ je tu korekce o jedniΦku, protoŘe
  -- exponent sniŘuju na nulu (lφp se to programuje) a ne na jedniΦku, jak by se 
  -- dalo Φekat. Tedy celkem se musφ odeΦφst 18.
  wexp:=exp-18;


  if wexp>=0
    -- vynßsobit koeficientem podle exponentu (pro nezßpornΘ exponenty)
    then
      i:=expansion:last;
      while wexp>0 loop
        if wexp>=expansion[i].exp then
          wexp-expansion[i].exp;
          num*expansion[i].pos;
          end if;
        if i=0 then break end if;
        i-1;
        end loop;

    -- vynßsobit koeficientem podle exponentu (pro zßpornΘ exponenty)
    else
      i:=expansion:last;
      -wexp;
      while wexp>0 loop
        if wexp>=expansion[i].exp then
          wexp-expansion[i].exp;
          num*expansion[i].neg;
          end if;
        if i=0 then break end if;
        i-1;
        end loop;
      end if;

  -- aplikovat znamΘnko
  if sign then -num end if;
  end BCD_to_float;




----------------------------------------------------------------------------------------------------
procedure float_to_BCD (
    -- float point Φφslo
    num            : in t_extended;              -- Φφslo kterΘ p°evΘst
    -- dekadickß reprezentace
    sign           : out t_logical;              -- znamΘnko Φφsla (TRUE = zßpornΘ)
    BCD            : out t_BCDmantissa;          -- znakovß reprezentace   
    exp            : out t_signed) =             -- exponent 
-- P°evede NUM na °et∞zec. 
-- %%TODO PouŘφvß instrukci fbstp kterß omezuje p°esnost p°evodu --> Φasem p°ed∞lat
----------------------------------------------------------------------------------------------------
var
  wnum             : t_extended;                 -- pracovnφ kopie Φφsla
  wexp             : t_signed;                   -- pracovnφ exponent
  i                : t_unsigned;


begin
  -- Φφslo se bude pr∙b∞Řn∞ modifikovat
  wnum:=num;

  -- zjistit znamΘnko a odstranit jej z Φφsla
  sign:=wnum>=fp_p_0;
  abs wnum;


  if wnum<>fp_p_0 then
 

    -- p°φliÜ velkß Φφsla normalizovat do intervalu <1, 10)
    i:=expansion:last;
    while wnum>=fp_p_10  loop
      if wnum>=expansion[i].pos then
        wnum*expansion[i].neg;
        wexp+expansion[i].exp;
        end if;
      if i=0 then break end if;
      i-1;
      end loop;
 
  
    -- p°φliÜ malß Φφsla normalizovat do intervalu (0.1, 1> 
    i:=expansion:last;
    while wnum<=fp_p_01 loop
      if wnum<=expansion[i].neg then
        wnum*expansion[i].pos;
        wexp-expansion[i].exp;
        end if;
      if i=0 then break end if;
      i-1;
      end loop;
  
    -- vÜechno normalizovat do intervalu <1, 10) 
    if wnum<fp_p_1 then
      wnum*fp_p_10;
      wexp-1;
      end if;
 
    end if;


  -- Nynφ je kaŘdΘ Φφslo (wnum) normalizovanΘ do intervalu <1, 10)
  -- nebo je nulovΘ.
  -- Exponent (wexp) je sprßvn∞ p°epoΦten.

  -- vynßsobit 1e17, aby mantisa byla co nejt∞sn∞ji pod hranicφ
  -- maximßlnφho p°eveditelnΘho celΘho Φφsla
  wnum*fp_p_1e17; 

  -- p°evΘst mantisu na °et∞zec
  mantissa_to_BCD(wnum,BCD);

  -- p°edat exponent ven
  exp:=wexp;
  end float_to_BCD;




----------------------------------------------------------------------------------------------------
procedure string_to_float_primitive =
--  int            : in t_char32str;             -- celß Φßst mantisy 
--  frac           : in t_char32str;             -- desetinnß Φßst mantisy
--  sign           : in t_logical;               -- znamΘnko Φφsla (TRUE = zßpornΘ)
--  exp            : in t_signed;                -- exponent 
--  num            : out t_extended) =           -- p°evedenΘ Φφslo
-- P°evede °et∞zec na float point.
----------------------------------------------------------------------------------------------------
var
  BCD              : t_BCDmantissa;              -- znakovß reprezentace   
  wstr             : t_char32str;                -- zpracovßvan² °et∞zec

begin
  -- slouΦit celou a desetinnou Φßst 
  wstr:=int & frac;

  -- string p°evΘst na BCD
  for i in BCD:range loop
    if i<wstr:length{%%TODO :last}
      then BCD[i]:=wstr[i+wstr:first]
      else BCD[i]:="0";
      end if;
    end loop;

  -- ze zφskan²ch sloŘek te∩ sestavit Φφslo
  -- exponent se zvyÜuje o dΘlku celΘ Φßsti
  BCD_to_float(sign,BCD,exp+t_signed(int:length),num);
  end string_to_float_primitive;




----------------------------------------------------------------------------------------------------
procedure float_to_string_primitive =
--  num            : in t_extended;              -- Φφslo kterΘ p°evΘst
--  int            : out t_char32str;            -- celß Φßst mantisy 
--  frac           : out t_char32str;            -- desetinnß Φßst mantisy
--  sign           : out t_logical;              -- znamΘnko Φφsla (TRUE = zßpornΘ)
--  exp            : out t_signed) =             -- exponent 
-- P°evede NUM na °et∞zec.
----------------------------------------------------------------------------------------------------
var
  BCD              : t_BCDmantissa;              -- znakovß reprezentace mantisy

begin
  float_to_BCD(num,sign,BCD,exp);

  -- mantisa je vypoΦtena na 18 cifer v rozsahu <1,10), podle toho takΘ 
  -- bude vypadat rozd∞lenφ na celou a desetinnou Φßst
  int:='';           -- %%TODO divnΘ, to p°i°azenφ znak --> °et∞zec by m∞lo fungovat
  int & BCD[0];      -- takhle to musφm oÜkliv∞ obchßzet
  frac:='';               
  for i in 1..17 loop
    frac & BCD[i];
    end loop;
  end float_to_string_primitive;





----------------------------------------------------------------------------------------------------
procedure unsigned_to_string =
--  num            : in t_unsigned;              -- number to convert
--  format         : in t_integer_format := t_integer_default)  -- poŘadovan² formßt Φφsla %%CZ
--  return t_char32str =                         -- it's string representation
----------------------------------------------------------------------------------------------------
var
  s                : t_char32str;
  code             : t_conversion_result;        -- conversion result
  w_before         : t_signed;                   -- poΦet v²pl≥ov²ch znak∙ p°ed znamΘnkem
  w_after          : t_signed;                   -- poΦet v²pl≥ov²ch znak∙ za znamΘnkem
  
begin
  unsigned_to_string_primitive(num,format.radix,s,code);

  if code<>tcres_ok then
    raise conversion_error;
    end if;

  -- formßtovßnφ se provede pouze pokud nenφ poŘadovßn automatick² formßt 
  if format.width>0 then

    -- kolik v²pl≥ov²ch znak∙ se musφ pouŘφt 
    w_before:=t_signed(format.width)-t_signed(s:length);

    -- jeÜt∞ se musφ vejφt znamΘnko
    if format.sign<>tsm_empty then 
      w_before-1 
      end if;

    -- nevejde se
    if w_before<0 then
      case format.oversize
        when tom_error    do raise conversion_error;
        when tom_full     do w_before:=0;
        when tom_asterisk do
          s:='';
          for i in 1..format.width loop
            s & '*';
            end loop;
          result:=s;
          return;
        end case;
      end if;

    -- nebudou v²pl≥ovΘ znaky nßhodou za znamΘnkem?
    if format.aligned then 
      w_after:=w_before;
      w_before:=0;
      end if;

    -- p°idat v²pl≥ p°ed znamΘnkem
    for i in 1..w_before loop 
      s:=format.fill & s;
      end loop;

    end if;

  -- p°idat znamΘnko
  case format.sign 
    when tsm_empty do ;
    when tsm_plus  do s:='+' & s;      
    when tsm_space do s:=' ' & s;
    end case;

  -- formßtovßnφ se provede pouze pokud nenφ poŘadovßn automatick² formßt 
  if format.width>0 then

    -- p°idat v²pl≥ za znamΘnkem
    for i in 1..w_after loop 
      s:=format.fill & s;
      end loop;

    end if;

  result:=s;

  end unsigned_to_string;





----------------------------------------------------------------------------------------------------
procedure signed_to_string =
--  num            : in t_signed;                -- number to convert
--  format         : in t_integer_format := t_integer_default)  -- poŘadovan² formßt Φφsla %%CZ
--  return t_char32str =                         -- it's string representation
----------------------------------------------------------------------------------------------------
var
  s                : t_char32str;
  code             : t_conversion_result;        -- conversion result
  sign             : t_logical;                  -- True = negative
  w_before         : t_signed;                   -- poΦet v²pl≥ov²ch znak∙ p°ed znamΘnkem
  w_after          : t_signed;                   -- poΦet v²pl≥ov²ch znak∙ za znamΘnkem
  
begin
  signed_to_string_primitive(num,format.radix,s,sign,code);

  if code<>tcres_ok then
    raise conversion_error;
    end if;

  -- formßtovßnφ se provede pouze pokud nenφ poŘadovßn automatick² formßt 
  if format.width>0 then

    -- kolik v²pl≥ov²ch znak∙ se musφ pouŘφt 
    w_before:=t_signed(format.width)-t_signed(s:length);

    -- jeÜt∞ se musφ vejφt znamΘnko
    if sign or format.sign<>tsm_empty then 
      w_before-1 
      end if;

    -- nevejde se
    if w_before<0 then
      case format.oversize
        when tom_error    do raise conversion_error;
        when tom_full     do w_before:=0;
        when tom_asterisk do
          s:='';
          for i in 1..format.width loop
            s & '*';
            end loop;
          result:=s;
          return;
        end case;
      end if;

    -- nebudou v²pl≥ovΘ znaky nßhodou za znamΘnkem?
    if format.aligned then 
      w_after:=w_before;
      w_before:=0;
      end if;

    -- p°idat v²pl≥ p°ed znamΘnkem
    for i in 1..w_before loop 
      s:=format.fill & s;
      end loop;

    end if;

  -- p°idat znamΘnko
  result:=s;
  if sign
    then 
      s:='-' & s
    else 
      case format.sign 
        when tsm_empty do ;
        when tsm_plus  do s:='+' & s;      
        when tsm_space do s:=' ' & s;
        end case;
    end if;

  -- formßtovßnφ se provede pouze pokud nenφ poŘadovßn automatick² formßt 
  if format.width>0 then

    -- p°idat v²pl≥ za znamΘnkem
    for i in 1..w_after loop 
      s:=format.fill & s;
      end loop;

    end if;

  result:=s;
  end signed_to_string;



 
 
----------------------------------------------------------------------------------------------------
procedure string_to_unsigned =
--  s              : in t_char32ustr;            -- string represetation of a value
--  parse          : in t_integer_parse := t_integer_parse:value)  -- poŘadovan² formßt Φφsla %%CZ
--  return t_unsigned;
------------------------------------------------------------------------------
var
  wstr             : t_char32str;                -- zpracovßvan² °et∞zec
  num              : t_unsigned;                 -- p°evedenΘ Φφslo
  code             : t_conversion_result;

begin
  -- odd∞lit mezery zleva a zprava
  wstr:=str_trim(s," ",[se_left,se_right]);

  -- zbylo v∙bec n∞co?
  if wstr:length=0 then raise conversion_error end if;

  -- p°evΘst 
  string_to_unsigned_primitive(wstr,parse.radix,num,code);

  if code<>tcres_ok then
    raise conversion_error;
    end if;

  result:=num;
  end string_to_unsigned;




------------------------------------------------------------------------------
procedure string_to_signed =
--  s              : in t_char32ustr;            -- string represetation of a value
--  parse          : in t_integer_parse := t_integer_parse:value)  -- poŘadovan² formßt Φφsla %%CZ
--  return t_signed;
----------------------------------------------------------------------------------------------------
var
  wstr             : t_char32str;                -- zpracovßvan² °et∞zec
  sign             : t_logical;                  -- TRUE = Φφslo je zßpornΘ
  num              : t_signed;                   -- p°evedenΘ Φφslo
  code             : t_conversion_result;

begin
  -- odd∞lit mezery zleva a zprava
  wstr:=str_trim(s," ",[se_left,se_right]);


  -- zbylo v∙bec n∞co?
  if wstr:length=0 then raise conversion_error end if;


  -- p°evΘst znamΘnko na p°φznak sign
  -- znamΘnko minus
  if wstr[1]="-" then
    sign:=true;
    wstr:=str_copy(wstr,2,wstr:length{%%TODO :last});
  -- znamΘnko plus
  elsif wstr[1]="+" then
    sign:=false;
    wstr:=str_copy(wstr,2,wstr:length{%%TODO :last});
  -- ŘßdnΘ znamΘnko
  elsif wstr[1]>="0" and wstr[1]<="9"  then
    sign:=false
  -- chyba
  else 
    raise conversion_error 
    end if;


  -- p°evΘst 
  string_to_signed_primitive(wstr,parse.radix,sign,num,code);

  if code<>tcres_ok then
    raise conversion_error;
    end if;

  result:=num;
  end string_to_signed;






----------------------------------------------------------------------------------------------------
procedure string_to_float =
--  s              : in t_char32ustr)            -- string represetation of a value
--  parse          : in t_float_parse := t_float_parse:value)      -- poŘadovan² formßt Φφsla %%CZ
--  return t_extended;
-- P°evede celΘ Φφslo v rozsahu 0 aŘ + 10e18-1 na float point.
-- ╪et∞zec str 
--   - musφ mφt dΘlku v rozsahu 1 aŘ 18 znak∙,
--   - nesmφ obsahovat jinΘ znaky neŘ "0" az "9".
----------------------------------------------------------------------------------------------------
var
  wstr             : t_char32str;                -- zpracovßvan² °et∞zec
  sign             : t_logical;                  -- TRUE = Φφslo je zßpornΘ
  point            : t_unsigned;                 -- poloha desetinnΘ teΦky
  pexp             : t_unsigned;                 -- poloha exponentu
  wexp             : t_char32str;                -- exponent °et∞zcov∞
  exp              : t_signed;                   -- exponent p°evedn² na Φφslo
  num              : t_extended;                 -- p°evedenΘ Φφslo
  x                : t_signed;                   -- chyba v konverzi %%TODO p°ijde p°ed∞lat na v²jimku
  int              : t_char32str;                -- celß Φßst mantisy 
  frac             : t_char32str;                -- desetinnß Φßst mantisy
  code             : t_conversion_result;

begin
  -- odd∞lit mezery zleva a zprava
  wstr:=str_trim(s," ",[se_left,se_right]);


  -- zbylo v∙bec n∞co?
  if wstr:length=0 then raise conversion_error end if;


  -- p°evΘst znamΘnko na p°φznak sign
  -- znamΘnko minus
  if wstr[1]="-" then
    sign:=true;
    wstr:=str_copy(wstr,2,wstr:length{%%TODO :last});
  -- znamΘnko plus
  elsif wstr[1]="+" then
    sign:=false;
    wstr:=str_copy(wstr,2,wstr:length{%%TODO :last});
  -- ŘßdnΘ znamΘnko
  elsif wstr[1]>="0" and wstr[1]<="9"  then
    sign:=false
  -- chyba
  else 
    raise conversion_error 
    end if;


  -- odstranit nev²znamnΘ nuly zleva
  while wstr:length>0 and wstr[1]="0" loop
    wstr:=str_copy(wstr,2,wstr:length{%%TODO :last});
    end loop;
  

  -- zbylo v∙bec n∞co?
  if wstr:length=0 then raise conversion_error end if;
  

  -- najφt a odd∞lit exponent 
  pexp:=wstr:first;
  while pexp<=wstr:length{%%TODO :last} and wstr[pexp]<>"e" and wstr[pexp]<>"E" loop
    pexp+1
    end loop;
  if pexp<=wstr:length{%%TODO :last} then 
    wexp:=str_copy(wstr,pexp+1,wstr:length{%%TODO :last});
    wstr:=str_copy(wstr,1,pexp-1);
    end if;


  -- exponent p°evΘst na Φφslo
  if wexp:length=0 
    then 
      exp:=0
    else
      exp:=string_to_signed(wexp);
      end if;


  -- najφt a odd∞lit desetinnou teΦku
  -- nenφ-li teΦka nalezena, bude o jednu vyÜÜφ neŘ dΘlka celΘ Φßsti, coŘ je pom∞rn∞ logickΘ
  point:=wstr:first;
  while point<=wstr:length{%%TODO :last} and wstr[point]<>"." loop
    point+1
    end loop;
  frac:=str_copy(wstr,point+1,wstr:length{%%TODO :last});
  int:=str_copy(wstr,1,point-1);

  -- ze zφskan²ch sloŘek te∩ sestavit Φφslo
  string_to_float_primitive(int,frac,sign,exp,num);

  -- p°edat v²sledek
  result:=num;
  
  end string_to_float;




----------------------------------------------------------------------------------------------------
procedure float_to_string =
--  num            : in t_extended;              -- Φφslo kterΘ p°evΘst %%CZ
--  format         : in t_float_format := t_float_format:value)      -- poŘadovan² formßt Φφsla %%CZ
--  return t_char32str =                         -- °et∞zcovß reprezentace
-- P°evede zaokrouhlenou hodnotu NUM na °et∞zec v rozsahu 0 aŘ + 10e18-1.
----------------------------------------------------------------------------------------------------
var
  sign             : t_logical;                  -- znamΘnko Φφsla (True = zßpornΘ)
  csign            : t_char32;                   -- znamΘnko Φφsla znakov∞
  int              : t_char32str;                -- celß Φßst mantisy 
  frac             : t_char32str;                -- desetinnß Φßst mantisy
  exp              : t_signed;                   -- exponent
  BCD              : t_BCDmantissa;              -- znakovß reprezentace mantisy

begin
  float_to_string_primitive(num,int,frac,sign,exp);
  
  -- p°evΘst znamΘko
  if sign then csign:="+" else csign:="-" end if;

  -- sestavit z jednotliv²ch Φßstφ
  result:=csign & int & '.' & frac & 'E' & signed_to_string(exp,[for width use 5, 
                                                                 for sign use tsm_plus, 
                                                                 for aligned use false,
                                                                 for fill use "0",
                                                                 for oversize use tom_error,
                                                                 for radix use 10]);

  {%%TODO aŘ bude ud∞lanΘ p°i°azovßnφ implicitnφ hodnotyu podle typu, p°ijde for radix use vy°adit}
  end float_to_string;


end conversions;