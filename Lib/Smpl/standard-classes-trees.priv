----------------------------------------------------------------------------------------------------
module private trees =
-- Data structures - trees.
-- Flex Standard Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------

-- K implemetaci iterátorů:
-- Nepoužívají zásobník, jediné, co si pamatují, je aktuální prvek - [current_node]
-- Výkonné funkce : 
--   reset - ta najde první prvek k iterování a uloží ho do [current_node]
--   find_next - přečte si hodnotu z [current_node] a uloží do ní další prvek, případně nil, pokud už
--     v [current_node] byl poslední prvek
-- Invarianty procházení - pomáhají konstruovat algoritmy pro procházení:
-- Máme strom s očíslovanými vrcholy, vrchol číslo 1 se projde jako první, vrchol číslo 2 druhý atd.
-- Pak platí:
-- Prefix:
-- pro libovolný podstrom platí, že jeho kořen má nejmenší číslo z celého podstromu
-- pro každé dva uzly ve stejné hloubce platí, že ten vlevo má menší číslo
-- Postfix:
-- pro libovolný podstrom platí, že jeho kořen má největší číslo z celého podstromu
-- pro každé dva uzly ve stejné hloubce platí, že ten vlevo má menší číslo
-- Infix:
-- Očíslovaný strom je vyhledávací, tzn. pro každý podstrom platí, že čísla všech uzlů levého podstromu
-- jsou menší než číslo kořene a čísla všech uzlů pravého podstromu jsou větší než číslo kořene.
-- Inverzní pořadí:
-- Stačí vyměnit [left] za [right] u binárním stromů, případně [get_last] za [get_first] a [get_next]
-- za [get_prev] u obecných stromů

----------------------------------------------------------------------------------------------------
class private abstract c_binary_tree_node =
-- Uzel binárního stromu.
----------------------------------------------------------------------------------------------------

    end c_binary_tree_node;



----------------------------------------------------------------------------------------------------
class private abstract c_binary_tree =
-- Binární vyhledávací strom s podporou AVL. 
----------------------------------------------------------------------------------------------------

    with
      supervised c_binary_tree_node;
 
    var
      avl          : t_logical;                  -- T-vyvažovat
      unique_key   : t_logical;                  -- T-pouze uzly se stejnými klíči

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace stromu.
    --   Pokud je [homogenous] nastaven na true, ve stromě mohou být jen uzly typu [item_type].
    --   Pokud je [unique_key] nastaven na true, ve stromě nemohou být uzly se stejným klíčem.
    --   Pokud je [avl] nastaven na true, strom bude se bude vyvažovat.
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud je již strom definován
      if this.root<>nil then
        -- inicializace neproběhne
        execute(event_error);
        raise tree_error;
        end if;

      -- set up basic parameters
      this.item_type:=item_type;
      this.avl:=avl;
      this.unique_key:=unique_key;
      this.homogenous:=homogenous;
      end init;



    ------------------------------------------------------------------------------------------------
    static has_node_rec (
        i_current_node : in p_binary_tree_node;  -- aktuální uzel
        node           : in p_binary_tree_node)  -- hledaný uzel
        return t_logical =                       -- T-uzel nalezen
    -- Vrací [true], pokud je [node] prvkem stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- hledaný uzel musí být definovaný
      if i_current_node=nil then
        result:=false;
        return;
        end if;

      -- jsou si oba uzly rovny?
      if i_current_node=node then
        -- ano, vrátit True
        result:=true;
        return;
        end if;

      -- porovnat klíče uzlů
      case compare(i_current_node,node)
        -- je aktuální uzel větší než hledaný uzel?
        when cn_bigger do
            -- jdi doleva
            result:=has_node_rec(i_current_node^.left,node);

        -- je aktuální uzel menší než hledaný uzel?
        when cn_smaller do
            -- jdi doprava
            result:=has_node_rec(i_current_node^.right,node);

        -- klíče jsou si rovny, ale zatím není nalezen hledaný uzel
        when cn_equal do
            -- jedná se o avl strom s možností mít více stejných klíčů?
            if avl and not unique_key then
              -- ano, prohledat celý podstrom, nejříve pravý, pokud uzel nebude nalezen, prohledat levý
              result:=has_node_rec(i_current_node^.right,node);
              if not result then
                result:=has_node_rec(i_current_node^.left,node);
                end if;
              return;

            -- pokud to není alv, mohou být ve stromě uzly se stejnými klíči?
            elsif not unique_key then
              -- ano, jít doprava
              result:=has_node_rec(i_current_node^.right,node);

            -- hledaný uzel nebyl nalezen
            else
              result:=false;
              return;
              end if;
        end case;
      end has_node_rec;



    ------------------------------------------------------------------------------------------------
    static has_node =
    -- Vrací [true], pokud je [node] prvkem stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- hledaný uzel musí být definovaný
      if node=nil then
        return;
        end if;

      -- hledat uzel
      result:=has_node_rec(root,node);
      end has_node;



    ------------------------------------------------------------------------------------------------
    static get_root =
    -- Vrátí kořenový uzel. Pokud uzel není definován, vrací NIL.
    ------------------------------------------------------------------------------------------------
    begin
      -- vrátí root node
      result:=root;
      end get_root;



    ------------------------------------------------------------------------------------------------
    static node_weight (
        node       : p_binary_tree_node)         -- zkoumaný uzel
        return t_unsigned =                      -- váha uzlu
    -- Vrátí váhu uzlu stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud uzel existuje, vrátit jeho váhu, pokud uzel neexistuje vrátit 0
      if node=nil
        then result:=0
        else result:=node^.weight;
        end if;
      end node_weight;


    
    ------------------------------------------------------------------------------------------------
    static ll_rot (
        node       : in out p_binary_tree_node) =       -- kritický uzel
    -- LL rotace.
    ------------------------------------------------------------------------------------------------
    var 
      plnode          : p_binary_tree_node;      -- node^.left
      pxrnode         : p_binary_tree_node;      -- node^.left^.right
      weightleftright : t_unsigned;              -- node^.left^.right^.weight
      nodeup          : p_binary_tree_node;      -- node^.up

    begin
      -- inicializovat proměnné
      plnode:=node^.left;
      pxrnode:=plnode^.right;
      weightleftright:=node_weight(pxrnode);

      -- rotace uzlů
      node^.left:=pxrnode;
      plnode^.right:=node;

      -- nastavit váhy
      node^.weight:=1+weightleftright;
      plnode^.weight:=1+node^.weight;

      -- nastavit zpětné ukazatele
      plnode^.up:=node^.up;
      nodeup:=node^.up;
      node^.up:=plnode;
      if pxrnode<>nil then
        pxrnode^.up:=node;
        end if;

      -- byl [root] kritickým uzlem?
      if node=root 
        -- ano, nastavit nový root
        then 
          root:=plnode;

        -- ne, navázat předka bývalého kritického uzlu na [plnode]
        else
          -- byl kritický uzel na předka navázán zleva? navaž uzel zleva, jinak zprava 
          if nodeup^.left=node
            then nodeup^.left:=plnode;
            else nodeup^.right:=plnode;
            end if;
          end if;
      
      -- nastavit nový orotovaný uzel
      node:=plnode;
      end ll_rot;



    ------------------------------------------------------------------------------------------------
    static rr_rot (
        node       : in out p_binary_tree_node) =       -- kritický uzel
    -- RR rotace.
    ------------------------------------------------------------------------------------------------
    var 
      prnode          : p_binary_tree_node;             -- node^.right
      pxlnode         : p_binary_tree_node;             -- node^.right^.left
      weightrightleft : t_unsigned;              -- node^.right^.left^.weight
      nodeup          : p_binary_tree_node;             -- node^.up

    begin
      -- inicializovat proměnné
      prnode:=node^.right;
      pxlnode:=prnode^.left;
      weightrightleft:=node_weight(pxlnode);

      -- rotace uzlů
      node^.right:=pxlnode;
      prnode^.left:=node;

      -- nastavit váhy
      node^.weight:=1+weightrightleft;
      prnode^.weight:=1+node^.weight;

      -- nastavit zpětné ukazatele
      prnode^.up:=node^.up;
      nodeup:=node^.up;
      node^.up:=prnode;
      if pxlnode<>nil then
        pxlnode^.up:=node;
        end if;

      -- byl [root] kritickým uzlem?
      if node=root 
        -- ano, nastavit nový root
        then 
          root:=prnode;

        -- ne, navázat předka bývalého kritického uzlu na [prnode]
        else
          -- byl kritický uzel na předka navázán zleva? navaž uzel zleva, jinak zprava 
          if nodeup^.left=node
            then nodeup^.left:=prnode;  
            else nodeup^.right:=prnode; 
            end if;
          end if;

      -- nastavit nový orotovaný uzel
      node:=prnode;
      end rr_rot;



    ------------------------------------------------------------------------------------------------
    static dlr_rot (
        node       : in out p_binary_tree_node) =       -- kritický uzel
    -- dlr rotace.
    ------------------------------------------------------------------------------------------------
    var
      plnode          : p_binary_tree_node;             -- node^.left
      pxrnode         : p_binary_tree_node;             -- node^.left^.right
      weightleftright : t_unsigned;              -- node^.left^.right^.weight
      nodeup          : p_binary_tree_node;             -- node^.up

    begin
      -- inicializovat proměnné
      plnode:=node^.left;
      pxrnode:=plnode^.right;
      weightleftright:=node_weight(pxrnode);

      -- nastavit zpětné ukazatele
      pxrnode^.up:=node^.up;
      plnode^.up:=pxrnode;
      nodeup:=node^.up;
      node^.up:=pxrnode;
      if pxrnode^.left<>nil then
        pxrnode^.left^.up:=plnode;
        end if;
      if pxrnode^.right<>nil then
        pxrnode^.right^.up:=node;
        end if;

      -- rotace uzlů
      plnode^.right := pxrnode^.left;
      node^.left := pxrnode^.right;
      pxrnode^.left := plnode;
      pxrnode^.right := node;

      -- nastavit váhy
      node^.weight := weightleftright;
      plnode^.weight := node^.weight;
      pxrnode^.weight := node_weight(plnode);

      -- byl [root] kritickým uzlem?
      if node=root 
        -- ano, nastavit nový root
        then 
          root:=pxrnode;

        -- ne, navázat předka bývalého kritického uzlu na [pxrnode]
        else
          -- byl kritický uzel na předka navázán zleva? navaž uzel zleva, jinak zprava 
          if nodeup^.left=node 
            then nodeup^.left:=pxrnode;  
            else nodeup^.right:=pxrnode; 
            end if;
          end if;

      -- nastavit nový orotovaný uzel
      node:=pxrnode;
      end dlr_rot;



    ------------------------------------------------------------------------------------------------
    static drl_rot (
        node       : in out p_binary_tree_node) =       -- kritický uzel
    -- DRL rotace.
    ------------------------------------------------------------------------------------------------
    var
      prnode          : p_binary_tree_node;             -- node^.right
      noderightleft   : p_binary_tree_node;             -- node^.right^.left
      weightrightleft : t_unsigned;              -- node^.right^.left^.weight
      nodeup          : p_binary_tree_node;             -- node^.up

    begin
      -- inicializovat proměnné
      prnode:=node^.right;
      noderightleft:=prnode^.left;
      weightrightleft:=node_weight(noderightleft);

      -- nastavit zpětné ukazatele
      noderightleft^.up:=node^.up;
      prnode^.up:=noderightleft;
      nodeup:=node^.up;
      node^.up:=noderightleft;
      if noderightleft^.right<>nil then
        noderightleft^.right^.up:=prnode;
        end if;
      if noderightleft^.left<>nil then
        noderightleft^.left^.up:=node;
        end if;

      -- rotace uzlů
      prnode^.left:=noderightleft^.right;
      node^.right:=noderightleft^.left;
      noderightleft^.right:=prnode;
      noderightleft^.left:=node;

      -- nastavit váhy
      node^.weight:=weightrightleft;
      prnode^.weight:=node^.weight;
      noderightleft^.weight:=node_weight(prnode);

      -- byl [root] kritickým uzlem?
      if node=root 
        -- ano, nastavit nový root
        then 
          root:=noderightleft;

        -- ne, navázat předka bývalého kritického uzlu na [noderightleft]
        else
          -- byl kritický uzel na předka navázán zleva? navaž uzel zleva, jinak zprava 
          if nodeup^.left=node 
            then nodeup^.left:=noderightleft;  
            else nodeup^.right:=noderightleft; 
            end if;
          end if;

      -- nastavit nový orotovaný uzel
      node:=noderightleft;
      end drl_rot;



    ------------------------------------------------------------------------------------------------
    static make_avl (
        i_current_node : in out p_binary_tree_node; -- potenciální kritický uzel
        critical     : out t_logical) =          -- T-kritický uzel vyvážen
    -- Vytvoří z uzlu, který je kritický, uzel vyvážený. Nevyváženost musí být prvního stupně (=|2|),
    -- pokud je větší, sníží stupeň nevyváženosti uzlu. Pokud je menší, není prováděna žádná akce.
    ------------------------------------------------------------------------------------------------
    var
      plnode         : p_binary_tree_node;       -- i_current_node^.left
      prnode         : p_binary_tree_node;       -- i_current_node^.right
      hl             : t_unsigned;               -- plnode^.weight
      hr             : t_unsigned;               -- prnode^.weight
      hll            : t_unsigned;               -- left^.left^.weight
      hlr            : t_unsigned;               -- left^.right^.weight
      hrl            : t_unsigned;               -- right^.left^.weight
      hrr            : t_unsigned;               -- right^.right^.weight

    begin
      -- předpoklad nenalezení kritického uzlu
      critical:=false;

      -- uzel musí existovat
      if i_current_node=nil then
        return;
        end if;

      -- inicializovat proměnné
      plnode:=i_current_node^.left;
      prnode:=i_current_node^.right;
      hl:=node_weight(plnode);
      hr:=node_weight(prnode);

      -- je uzel kritický a těžsí vlevo?
      if hl>hr+1 then
        -- ano, zjistit výšky následovníků levého uzlu
        if plnode<>nil 
          then
            hll:=node_weight(i_current_node^.left^.left);
            hlr:=node_weight(i_current_node^.left^.right);
          else
            hll:=0;
            hlr:=0;
            end if;

        -- zjisit typ vyvažování
        if hll>=hlr
          then
            -- LL rorace
            ll_rot(i_current_node);
            critical:=true;
          else
            -- DLR rorace
            dlr_rot(i_current_node);
            critical:=true;
            end if;

      -- je uzel kritický a těžsí vpravo?
      elsif hl+1<hr then
        -- ano, zjistit výšky následovníků pravého uzlu
        if prnode<>nil 
          then 
            hrr:=node_weight(i_current_node^.right^.right);
            hrl:=node_weight(i_current_node^.right^.left);
          else 
            hrr:=0;
            hrl:=0;
            end if;

        -- zjisit typ vyvažování
        if hrr>=hrl
          then
            -- RR rorace
            rr_rot(i_current_node);
            critical:=true;
          else
            -- DRL rotace
            drl_rot(i_current_node);
            critical:=true;
            end if;

      -- korekce vah, pokud se nemuselo vyvažovat
      elsif hl>hr
        then i_current_node^.weight:=1+hl;
        else i_current_node^.weight:=1+hr;
      end if;
    end make_avl;



    ------------------------------------------------------------------------------------------------
    static insert_left (
        i_current_node : in p_binary_tree_node;           -- aktuální uzel 
        node         : in p_binary_tree_node) =         -- vkládaný uzel
    -- Přidá uzel [node] pod uzel [i_current_node] zleva, pokud je volné místo.
    ------------------------------------------------------------------------------------------------
    begin
      if i_current_node^.left=nil then
        -- ano, vlož uzel doleva
        node^.weight:=1;
        node^.left:=nil;
        node^.right:=nil;
        node^.up:=i_current_node;
        i_current_node^.left:=node;

        -- zvýšit počet uzlů ve stromu o 1
        succ count;
        end if;
      end insert_left;



    ------------------------------------------------------------------------------------------------
    static insert_right (
        i_current_node : in p_binary_tree_node;           -- aktuální uzel 
        node         : in p_binary_tree_node) =         -- vkládaný uzel
    -- Přidá uzel [node] pod uzel [i_current_node] zprava, pokud je volné místo.
    ------------------------------------------------------------------------------------------------
    begin
      -- je vpravo volné místo?
      if i_current_node^.right=nil then
        -- ano, vlož uzel doprava
        node^.weight:=1;
        node^.left:=nil;
        node^.right:=nil;
        node^.up:=i_current_node;
        i_current_node^.right:=node;

        -- zvýšit počet uzlů ve stromu o 1
        succ count;
        end if;
      end insert_right;



    ------------------------------------------------------------------------------------------------
    static insert_avl_rec (
        i_current_node : in out p_binary_tree_node;       -- aktuální uzel 
        node         : in p_binary_tree_node;           -- vkládaný uzel
        critical     : in out t_logical) =       -- T-nalezen kritický uzel
    -- Vloží uzel bez kontroly na neunikátnost klíče i duplicitu uzlu do stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- aktuální uzel musí být definován
      if i_current_node=nil then
        return;
        end if;

      -- porovnat klíče obou uzlů
      case compare(node,i_current_node)
        -- je hledaný klíč uzlu menší než aktuální?
        when cn_smaller do 
            -- pokud existuje levý následník, jdi doleva, jinak vlož vlevo
            if i_current_node^.left<>nil
              then insert_avl_rec(i_current_node^.left,node,critical);
              else insert_left(i_current_node,node);
              end if;

        -- je hledaný klíč uzlu větší než aktuální?
        when cn_bigger do
            -- pokud existuje pravý následník, jdi doprava, jinak vlož vravo
            if i_current_node^.right<>nil
              then insert_avl_rec(i_current_node^.right,node,critical);
              else insert_right(i_current_node,node);
              end if

        -- klíče jsou si rovny
        when cn_equal do
          -- pokud existuje pravý následník, jdi doprava, jinak vlož doprava
          if i_current_node^.right<>nil 
            then insert_avl_rec(i_current_node^.right,node,critical)
            else insert_right(i_current_node,node);
            end if;
          end case;

      -- má se uzel vyvažovat?
      if avl and not critical then
        -- vyvážit uzel
        make_avl(i_current_node,critical);
        end if;
      end insert_avl_rec;



    ------------------------------------------------------------------------------------------------
    static insert_rec (
        i_current_node : in out p_binary_tree_node;       -- aktuální uzel 
        node         : in p_binary_tree_node;           -- vkládaný uzel
        critical     : in out t_logical) =       -- T-nalezen kritický uzel
    -- Přidá uzel. Pokud se má vložit uzel se stejným klíčem, jaký už ve stromu existuje, 
    -- nový uzel se vloží doprava.
    ------------------------------------------------------------------------------------------------
    begin
      -- aktuální uzel musí být definován
      if i_current_node=nil then
        return;
        end if;

      -- je ve stromě již uzel obsažen?
      if i_current_node=node then
        -- ano, chyba
        execute(event_error);
        raise tree_error;
        end if;

      -- porovnat klíče obou uzlů
      case compare(node,i_current_node)
        -- je hledaný klíč uzlu menší než aktuální?
        when cn_smaller do 
            -- pokud existuje levý následník, jdi doleva, jinak vlož vlevo
            if i_current_node^.left<>nil
              then insert_rec(i_current_node^.left,node,critical);
              else insert_left(i_current_node,node);
              end if;

        -- je hledaný klíč uzlu větší než aktuální?
        when cn_bigger do
            -- pokud existuje pravý následník, jdi doprava, jinak vlož vravo
            if i_current_node^.right<>nil
              then insert_rec(i_current_node^.right,node,critical);
              else insert_right(i_current_node,node);
              end if

        -- klíče jsou si rovny
        when cn_equal do
            -- ano, je povoleno vkládat uzly s duplicitními klíči?
            if not unique_key
              -- ano, pokusit se jít dál
              then
                -- jde o avl strom?
                if avl 
                  -- ano, budou se muset testovat obě větve na existenci [node]
                  then
                    -- je v podstromu duplicitní uzel?
                    if not has_node_rec(i_current_node,node)
                      -- ne, vlož nový uzel
                      then
                        insert_avl_rec(i_current_node,node,critical);

                      -- ano, chyba
                      else
                        execute(event_error);
                        raise tree_error;
                      end if;

                  -- nejde o avl, ale mohou se vkládat uzly se stejnými klíči
                  else
                    -- pokud existuje pravý následník, jdi doprava, jinak vlož doprava
                    if i_current_node^.right<>nil 
                      then insert_rec(i_current_node^.right,node,critical)
                      else insert_right(i_current_node,node);
                      end if;
                    end if;

              -- ne, chyba
              else 
                execute(event_error);
                raise tree_error;
              end if;
          end case;

      -- má se uzel vyvažovat?
      if avl and not critical then
        -- vyvážit uzel
        make_avl(i_current_node,critical);
        end if;
      end insert_rec;



    ------------------------------------------------------------------------------------------------
    override insert =
    -- Přidá uzel do stromu. Pokud se má vložit uzel se stejným klíčem, jaký už ve stromu
    -- existuje, nový uzel se vloží doprava.
    ------------------------------------------------------------------------------------------------
    var
      node         : p_binary_tree_node;                -- vkládaný uzel
      critical     : t_logical:=false;           -- T-nalezen kritický uzel

    begin
      -- přetypovat
      node:=p_binary_tree_node(item);

      -- přidávaný uzel musí existovat
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- je kořen definován?
      if root=nil then
        -- vložit uzel
        node^.weight:=1;
        node^.left:=nil;
        node^.right:=nil;
        node^.up:=nil;
        root:=node;

        -- zvýšit počet uzlů ve stromu o 1
        succ count;
        return;
        end if;

      -- vložit uzel
      insert_rec(root,node,critical);
      end insert;



    ------------------------------------------------------------------------------------------------
    static merge_subtree_rec (
        node       : p_binary_tree_node) =              -- kořenový uzel přidávaného stromu
    -- Spojí dva stromy do jednoho. Stom [tree] reprezentuje strom přidávaných uzlů do stromu
    -- reprezentovanou instancí této třídy. Pokud uxistují dva uzly se stejným klíčem, je uzel 
    -- do stromu vložen v závislosti na parametru [unique_key].
    ------------------------------------------------------------------------------------------------
    begin
      -- jestliže kořen přidávaného stromu není definován, ukonči rekurzi
      if node=nil then
        return;
        end if;

      -- procházet stromem
      merge_subtree_rec(node^.left);
      merge_subtree_rec(node^.right);

      -- vložit do stromu uzel [node]
      insert(node);
      end merge_subtree_rec;


    
    ------------------------------------------------------------------------------------------------
    static merge_subtree =
    -- Spojí dva stromy do jednoho. Stom [tree] reprezentuje strom přidávaných uzlů do stromu
    -- reprezentovanou instancí této třídy. Pokud uxistují dva uzly se stejným klíčem, je uzel 
    -- do stromu vložen v závislosti na parametru [unique_key].
    ------------------------------------------------------------------------------------------------
    begin
      -- spojit stromy
      merge_subtree_rec(tree.root);

      -- deinicializace připojovaného stromu
      tree.root:=nil;
      tree.count:=0;
      end merge_subtree;



    ------------------------------------------------------------------------------------------------
    static bonded_remove_rec (
        i_current_node : in out p_binary_tree_node;
        node         : in p_binary_tree_node) =
    -- Vyjme uzel, který má pravého syna nebo oba syny.
    ------------------------------------------------------------------------------------------------
    var
      li_current_node : p_binary_tree_node;               -- i_current_node
      critical      : t_logical;                 -- nevyužitá proměnná

    begin
      -- nastavit lokální [i_current_node]
      li_current_node:=i_current_node;

      -- uzel musí existovat
      if li_current_node=nil then
        return;
        end if;

      -- existuje pravý uzel?
      if li_current_node^.right<>nil 
        -- ano, jít doprava
        then
          bonded_remove_rec(li_current_node^.right,node);

        -- ne, vyjmout uzel
        else
          -- ano, odstranit uzel [node]
          -- navázat levého syna nejpravějšího uzlu na předposlední procházený uzel
          if li_current_node^.up^.left=li_current_node 
            then li_current_node^.up^.left:=li_current_node^.left;
            else li_current_node^.up^.right:=li_current_node^.left;
            end if;

          -- získaný volný uzel uložit do stromu na místo rušeného uzlu
          li_current_node^.left:=node^.left;
          li_current_node^.right:=node^.right;
          li_current_node^.up:=node^.up;
          li_current_node^.weight:=node^.weight;

          -- pokud rušený uzel nemá předchůdce, zrušit kořen
          if node^.up=nil then
            root:=li_current_node;

          -- jinak předat vazbu předka na místo rušeného uzlu
          elsif node^.up^.left=node
            then node^.up^.left:=li_current_node;
            else node^.up^.right:=li_current_node;
            end if;

          -- nastavenit zpětné vazby pravého uzlu uzkazující nyní špatně na smazaný uzel
          if li_current_node^.right<>nil then
            li_current_node^.right^.up:=li_current_node;
            end if;

          -- nastavit zpětné vazby levého uzlu uzkazující nyní špatně na smazaný uzel
          if li_current_node^.left<>nil then
            li_current_node^.left^.up:=li_current_node;
            end if;
          end if;
  
      -- má se uzel vyvažovat?
      if avl then
        -- vyvážit uzel
        make_avl(li_current_node,critical);
        end if;
      end bonded_remove_rec;



    ------------------------------------------------------------------------------------------------
    override remove =
    -- Vyjme uzel ze stromu.
    ------------------------------------------------------------------------------------------------
    var 
      node         : p_binary_tree_node;                -- uzel pro vyjmutí ze stromu
      critical     : t_logical;                  -- nevyužitá proměnná

    begin
      -- přetypovat [item]
      node:=p_binary_tree_node(item);

      -- rušený uzel musí být definovaný
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud není uzel ve stromu nalezen, konec
      if not has_node(node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- má rušený uzel odkaz jen na pravého potomka nebo na žádného?
      if node^.left=nil 
        -- ano
        then
          -- má rušený uzel předka?
          if node^.up=nil then
            -- ne, nastavit nový kořen
            root:=node^.right;

            -- pokud existovala pravá větev
            if root<>nil then
              -- nastavit předka nového kořenu na nil
              root^.up:=nil;
              end if;

          -- ano, kořen má předka, tudíž spojíme předka s následníkem
          elsif node^.up^.left=node 
            then node^.up^.left:=node^.right;
            else node^.up^.right:=node^.right;
            end if;

        -- ne, má odkaz na levého nebo na oba potomky
        else
          -- odebere uzel
          bonded_remove_rec(node^.left,node);
          end if;

      -- snížit počet uzlů ve stromu o 1
      pred count;

      -- má se vyvažovat?
      if avl then
        -- vyvažovat uzly až ke kořeni
        loop
          -- jít na předka
          node:=node^.up;
      
          -- vyvážit uzel
          make_avl(node,critical);
          until node=root or node=nil;
        end if;
      end remove;



    ------------------------------------------------------------------------------------------------
    static get_node_count (
        node       : in p_binary_tree_node;         -- aktuální uzel 
        count      : in out t_unsigned) =        -- počet uzlů (pod)stromu
    -- Spočítá počet uzlů v podstromu včetně uzlu [node].
    ------------------------------------------------------------------------------------------------
    begin
      -- jestliže [node] není definován, ukonči rekurzi
      if node=nil then 
        return;
        end if;

      -- počet uzlů je o jeden větší
      succ count;

      -- procházet stromem 
      get_node_count(node^.left,count);
      get_node_count(node^.right,count);
      end get_node_count;



    ------------------------------------------------------------------------------------------------
    static split_subtree =
    -- Vyjme ze stromu podstrom včetně uzlu [node] a vytvoří a inicializuje novou instance 
    -- trídy [c_binary_tree]. Pokud uzel není nalezen, vrací prázdný strom se stejnými parametry jako
    -- má instace tohoto stromu.
    ------------------------------------------------------------------------------------------------
    var
      lnode        : p_binary_tree_node;                -- kořen nového stromu

    begin
      -- kořen podstromu/stromu
      lnode:=node;

      -- uzel musí být ve stromě nalezen
      if not has_node(lnode) then
        -- není nalezen, chyba
        execute(event_error);
        raise tree_error;
        end if;

      -- je odpojovaný uzel různý od [root]?
      if lnode^.up<>nil 
        -- ano, různý od kořenu
        then
          -- odpojit uzel z původního stromu
          if lnode^.up^.left=lnode 
            then lnode^.up^.left:=nil
            else lnode^.up^.right:=nil
            end if;

        -- ne, vymazat celý strom 
        else
          root:=nil;
          end if;

      -- nastavit předka nového kořenu na nil
      lnode^.up:=nil;

      -- inicializovat nový strom
      subtree.init(this.item_type,this.avl,this.unique_key,this.homogenous);

      -- má se původní strom znovu ustanovit?
      if avl then
        -- nastavit počet uzlů původního stromu
        count:=0;

        -- vytvořit původní strom na proměnnou subtree pro vyvolání merge_subtree
        subtree.root:=root;

        -- zrušit celý původní strom a zapamatovat si původní [root] pro znovuustanovení
        root:=nil;

        -- znovupostavit strom
        merge_subtree(subtree);
        end if;

      -- spočítat počet uzlů stromů
      subtree.count:=0;
      get_node_count(lnode,subtree.count);

      -- pokud nebyl strom znovu sestaven přes avl, spočítat počet uzlů v původním stromu
      if not avl then
        count-subtree.count;
        end if;

      -- vytvořit nový strom
      subtree.root:=lnode;
      end split_subtree;



    ------------------------------------------------------------------------------------------------
    override delete =
    -- Smaže uzel ze stromu a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    begin
      -- vyjmout uzel
      remove(item);

      -- uvolnit uzel z paměti
      discard item;
      end delete;



    ------------------------------------------------------------------------------------------------
    static delete_subtree =
    -- Smaže podstrom včetně uzlu [node] ze stromu a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    begin
      -- jestliže [node] není definován, ukonči rekurzi
      if node=nil then 
        return;
        end if;

      -- procházet stromem 
      delete_subtree(node^.left);
      delete_subtree(node^.right);

      -- vyjmout uzel
      remove(node);
 
      -- uvolnit uzel z paměti
      discard node;
      end delete_subtree;



    ------------------------------------------------------------------------------------------------
    static delete_all_rec (
        node       : in out p_binary_tree_node) =       -- rušená větev
    -- Zruší celou větev stromu a uvolní jejich paměť. Mazání je rychlejší, je použita v metodě
    -- delete_all. Při smazání větve nemusí již být strom vyvážen.
    ------------------------------------------------------------------------------------------------
    begin
      -- jestliže [node] není definován, ukončit rekurzi
      if node=nil then 
        return;
        end if;

      -- procházet stromem 
      delete_all_rec(node^.left);
      delete_all_rec(node^.right);

      -- uvolnit uzel z paměti
      discard node;
      end delete_all_rec;



    ------------------------------------------------------------------------------------------------
    override delete_all =
    -- Smaže všechny uzly ze stromu a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    begin
      -- smazat celý strom
      delete_all_rec(root);
      end delete_all;



    ------------------------------------------------------------------------------------------------
    static find_rec (
        tree       : p_binary_tree_node;
        node       : p_binary_tree_node)
        return p_binary_tree_node =
    -- Vyhledá uzel, který je rovný [node]
    ------------------------------------------------------------------------------------------------
    begin
      -- inicializovat
      result:=nil;

      -- uzel nebyl nalezen
      if tree=nil then return end if;

      -- porovnat klíče uzlů
      case compare(tree,node)
        -- je aktuální uzel větší než hledaný uzel?
        when cn_bigger do
            -- jdi doleva
            result:=find_rec(tree^.left,node);

        -- je aktuální uzel menší než hledaný uzel?
        when cn_smaller do
            -- jdi doprava
            result:=find_rec(tree^.right,node);

        -- klíče jsou si rovny, ale zatím není nalezen hledaný uzel
        when cn_equal do
            result:=tree;
        end case;

      end find_rec;

    ------------------------------------------------------------------------------------------------
    static find =
    -- Vyhledá uzel, který je rovný [node]
    ------------------------------------------------------------------------------------------------
    begin
      result:=find_rec(root,node);
      end find;

    end c_binary_tree;



----------------------------------------------------------------------------------------------------
class private c_binary_tree_iterator =
-- Iterator.
----------------------------------------------------------------------------------------------------

    with
      supervised c_binary_tree_node;

    var 
      direction    : t_tree_walking_direction;   -- řízení iterace
      tree         : p_binary_tree;              -- subjekt iterace
      current_node : p_binary_tree_node;         -- aktuální uzel


    
    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializuje iterator používaný pro průchod stromem.
    ------------------------------------------------------------------------------------------------
    begin
      -- inicializece řídících proměnných
      this.direction:=direction;
      this.tree:=^tree;

      -- resetování
      reset;
      end init;


 
    ------------------------------------------------------------------------------------------------
    override reset =
    -- Resetuje iterator do stavu po inicializaci.
    ------------------------------------------------------------------------------------------------
    begin
      -- dočasné nastavení [current_node]
      current_node:=tree^.get_root;

      -- strom je prázdný
      if current_node=nil then return end if;

      case direction
        -- prefix
        when ttwd_prefix do 
          -- nic nedělat - kořen je první

        -- inverzní prefix
        when ttwd_inv_prefix do 
          -- nic nedělat - kořen je první

        -- postfix
        when ttwd_postfix do 
          -- najít potomka
          loop
            -- nejdříve zkusit levý podstrom, když není zadán, tak pravý
            if current_node^.left<>nil then current_node:=current_node^.left;
            elsif current_node^.right<>nil then current_node:=current_node^.right;
            else break;
            end if;
            end loop;

        -- inverzní postfix
        when ttwd_inv_postfix do 
          -- najít potomka
          loop
            -- nejdříve zkusit pravý podstrom, když není zadán, tak levý
            if current_node^.right<>nil then current_node:=current_node^.right;
            elsif current_node^.left<>nil then current_node:=current_node^.left;
            else break;
            end if;
            end loop;

        -- infix
        when ttwd_infix do
          -- jít co nejvíce doleva
          while current_node^.left<>nil loop
            current_node:=current_node^.left;
            end loop;

        -- inverzní infix
        when ttwd_inv_infix do
          -- jít co nejvíce doprava
          while current_node^.right<>nil loop
            current_node:=current_node^.right;
            end loop;
        end case;

      end reset;


    ------------------------------------------------------------------------------------------------
    static find_next =
    -- Do [current_node] uloží další procházený uzel
    -- Předpokládá [current_node]<>nil
    ------------------------------------------------------------------------------------------------
    begin
      -- určit směr procházení
      case direction
        -- prefix
        when ttwd_prefix do
          -- pokud to jde doleva, jít do levého podstromu
          if current_node^.left<>nil then
            current_node:=current_node^.left;

          -- pokud to jde doprava, jít do pravého podstromu
          elsif current_node^.right<>nil then
            current_node:=current_node^.right;
            
          -- nejde to do podstromu, musíme se vrátit nahoru
          else
            -- jít nahoru tak dlouho, dokud se nedá odbočit doprava dolů
            while current_node<>nil loop
              -- šplháme po levé větvi a pravá větev má následníky?
              if current_node^.up<>nil and then current_node^.up^.left=current_node and then current_node^.up^.right<>nil then
                current_node:=current_node^.up^.right;
                return;
                end if;

              -- jít nahoru
              current_node:=current_node^.up;
              end loop;
            end if;

        -- inverzní prefix
        when ttwd_inv_prefix do
          -- pokud to jde doprava, jít do pravého podstromu
          if current_node^.right<>nil then
            current_node:=current_node^.right;

          -- pokud to jde doleva, jít do levého podstromu
          elsif current_node^.left<>nil then
            current_node:=current_node^.left;

          -- nejde to do podstromu, musíme se vrátit nahoru
          else
            -- jít nahoru tak dlouho, dokud se nedá odbočit doleva dolů
            while current_node<>nil loop
              -- šplháme po pravé větvi a levá větev má následníky?
              if current_node^.up<>nil and then current_node^.up^.right=current_node and then current_node^.up^.left<>nil then
                current_node:=current_node^.up^.left;
                return;
                end if;

              -- jít nahoru
              current_node:=current_node^.up;
              end loop;
            end if;

        -- postfix
        when ttwd_postfix do
          -- pokud to jde, jít doprava na stejnou úroveň a pak co nejvíce dolů
          if current_node^.up<>nil and then current_node^.up^.left=current_node and then current_node^.up^.right<>nil then
            current_node:=current_node^.up^.right;

            -- co nejvíce dolů
            loop
              if current_node^.left<>nil then current_node:=current_node^.left;
              elsif current_node^.right<>nil then current_node:=current_node^.right;
              else break;
              end if;
              end loop;

          else 
            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- inverzní postfix
        when ttwd_inv_postfix do
          -- pokud to jde, jít doleva na stejnou úroveň a pak co nejvíce dolů
          if current_node^.up<>nil and then current_node^.up^.right=current_node and then current_node^.up^.left<>nil then
            current_node:=current_node^.up^.left;

            -- co nejvíce dolů
            loop
              if current_node^.right<>nil then current_node:=current_node^.right;
              elsif current_node^.left<>nil then current_node:=current_node^.left;
              else break;
              end if;
              end loop;

          else 
            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- infix
        when ttwd_infix do
          -- když to jde doprava, tak doprava
          if current_node^.right<>nil then
            current_node:=current_node^.right;

            -- co nejvíce doleva
            while current_node^.left<>nil loop
              current_node:=current_node^.left;
              end loop;

          else
            -- jinak nahoru, nejdříve o kolik to jde po pravé větvi - vracení se, pak ještě o jednu nahoru
            while current_node^.up<>nil and then current_node^.up^.right=current_node loop
              current_node:=current_node^.up;
              end loop;

            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- inverzní infix
        when ttwd_inv_infix do
          -- když to jde doleva, tak doleva
          if current_node^.left<>nil then
            current_node:=current_node^.left;

            -- co nejvíce doprava
            while current_node^.right<>nil loop
              current_node:=current_node^.right;
              end loop;

          else
            -- jinak nahoru, nejdříve o kolik to jde po levé větvi - vracení se, pak ještě o jednu nahoru
            while current_node^.up<>nil and then current_node^.up^.left=current_node loop
              current_node:=current_node^.up;
              end loop;

            -- nahoru
            current_node:=current_node^.up;
            end if;
          end case;

      end find_next;



    ------------------------------------------------------------------------------------------------
    override get =
    -- Vrátí jeden uzel z korespondujícího stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- uzel, který má iterátor vrátit, je v current_node
      item:=current_node;

      -- výsledná hodnota - F, pokud je v [item] nil
      result:=item<>nil;

      -- pokud není co procházet, konec
      if not result then return end if;

      -- najít další uzel
      find_next;
      end get;
    
    end c_binary_tree_iterator;



----------------------------------------------------------------------------------------------------
class private c_tree_node =
-- Uzel stromu.
----------------------------------------------------------------------------------------------------
    var
      item_type    : t_tag;                      -- (root) type of its items

    ------------------------------------------------------------------------------------------------
    entry =
    -- Inicializovat seznam potomků.
    ------------------------------------------------------------------------------------------------
    begin
      down.init(item_type,true,false);
      end entry;

    end c_tree_node;



----------------------------------------------------------------------------------------------------
class private c_tree =
-- N-nární vyhledávací strom.
----------------------------------------------------------------------------------------------------

    with
      supervised c_tree_node;


    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace stromu.
    --   Pokud je [homogenous] nastaven na true, ve stromě mohou být jen uzly typu [item_type].
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud je již strom definován
      if this.root<>nil then
        -- inicializace neproběhne
        execute(event_error);
        raise tree_error;
        end if;

      -- set up basic parameters
      this.item_type:=item_type;
      this.homogenous:=homogenous;
      end init;



    ------------------------------------------------------------------------------------------------
    static get_node_count (
        node       : in p_tree_node)             -- podstrom
        return t_unsigned =
    -- Spočítá počet uzlů v podstromě určeném [node]
    ------------------------------------------------------------------------------------------------
    var
      child        : p_tree_node;                -- uzel

    begin
      -- započítat node
      result:=1;

      -- projít dětské uzly
      child:=node^.down.get_first;
      while child<>nil loop
        -- započítat podstromy [child]
        result+get_node_count(child);

        -- další díte
        child:=node^.down.get_next(child);
        end loop;
      end get_node_count;



    ------------------------------------------------------------------------------------------------
    static has_node_rec (
        current_node : in p_tree_node;           -- aktuální uzel
        node         : in p_tree_node)           -- hledaný uzel
        return t_logical =                       -- T-uzel nalezen
    -- Vrací logickou hodnotu, zda je uzel nalezen ve stromu.
    ------------------------------------------------------------------------------------------------
    var 
      down_node   : p_tree_node;                 -- potomek

    begin
      -- aktuální uzel musí být definovaný
      if current_node=nil then
        result:=false;
        return;
        end if;

      -- pokud se uzly shodují, vrátit true
      if current_node=node then
        result:=true;
        return;
        end if;

      -- zjistit prvního potomka
      down_node:=p_tree_node(current_node^.down.get_first);

      -- procházet potomky
      while down_node<>nil loop
        -- procházet podstrom
        result:=has_node_rec(down_node,node);

        -- pokud je uzel nalezen, konec
        if result then
          break;
          end if;
        
        -- jdi na dalšího potomka
        down_node:=current_node^.down.get_next(down_node);
        end loop;
      end has_node_rec;



    ------------------------------------------------------------------------------------------------
    static has_node =
    -- Vrací logickou hodnotu, zda je uzel nalezen ve stromu.
    --   Pokud [node]=NIL, hlásí chybu.
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud [node] není definovaný, hlásí chybu
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- hledat uzel
      result:=has_node_rec(root,node);
      end has_node;



    ------------------------------------------------------------------------------------------------
    static get_root =
    -- Vrací kořenový uzel.
    --   Pokud kořen není definován, vrací NIL.
    ------------------------------------------------------------------------------------------------
    begin
      -- vrátí root node
      result:=root;
      end get_root;



    ------------------------------------------------------------------------------------------------
    override insert =
    -- Vloží se do stromu kořen.
    ------------------------------------------------------------------------------------------------
    begin
      -- pokusit se do stromu vložit uzel na místo kořenu
      insert_node(p_tree_node(item),nil,id_add);
      end insert;



    ------------------------------------------------------------------------------------------------
    static do_insert (
        node         : in p_tree_node;           -- vkládaný uzel
        current_node : in p_tree_node;           -- aktuální uzel
        direction    : in t_insert_direction)    -- pozice vložení
        return t_logical =
    -- Vloží uzel do stromu.
    -- Interní metoda, neprovádí kontroly.
    -- Vrátí, zda vložení bylo úspěšné
    ------------------------------------------------------------------------------------------------
    begin
      -- na začátku předpokládáme chybu
      result:=false;

      -- dle směru vložení:
      case direction
        -- vloží jako posledního souseda
        when id_add do
            -- pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
            if current_node=root 
              -- chyba
              then
                execute(event_error);
                raise tree_error;
              
              -- vložit uzel
              else
                current_node^.up^.down.insert_last(node);
                node^.up:=current_node^.up;
                end if;

        -- vloží jako prvního souseda
        when id_add_first do
            -- pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
            if current_node=root 
              -- chyba
              then
                execute(event_error);
                raise tree_error;
              
              -- vložit uzel
              else
                current_node^.up^.down.insert_first(node);
                node^.up:=current_node^.up;
                end if;

        -- vloží jako posledního potomka
        when id_add_child do
            current_node^.down.insert_last(node);
            node^.up:=current_node;

        -- vloží jako prvního potomka
        when id_first_child do
            current_node^.down.insert_first(node);
            node^.up:=current_node;

        -- vloží hned před referenční uzel
        when id_insert_before do
            -- pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
            if current_node=root 
              -- chyba
              then
                execute(event_error);
                raise tree_error;
              
              -- vložit uzel
              else
                current_node^.up^.down.insert_before(current_node,node);
                node^.up:=current_node^.up;
                end if;

        -- vloží hned za referenční uzel
        when id_insert_after do
            -- pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
            if current_node=root 
              -- chyba
              then
                execute(event_error);
                raise tree_error;
              
              -- vložit uzel
              else
                current_node^.up^.down.insert_after(current_node,node);
                node^.up:=current_node^.up;
                end if;
        end case;

      -- vše proběhlo OK
      result:=true;
      end do_insert;



    ------------------------------------------------------------------------------------------------
    static insert_node =
    -- Vloží uzel do stromu.
    --   Pokud [node]=NIL, hlásí chybu.
    --   Pokud [current_node] není ve stromu nalezen, hlásí chybu.
    --   Pokud [node] je ve stromu nalezen, hlásí chybu.
    --   Pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud [node]=NIL, hlásí chybu
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- má se nový uzel vložit na místo kořenu?
      if current_node=nil then
        -- ano, nastavit předky
        node^.up:=nil;

        -- pokud existuje [root], nastavit předka a vložit bývalý kořen
        if root<>nil then
          root^.up:=node;
          node^.down.insert_last(root);
          end if;

        -- nastavit nový kořen
        root:=node;

        -- zvýšit počet uzlů ve stromu
        count+get_node_count(node);
        return;
        end if;

      -- pokud [current_node] není ve stromu nalezen, hlásí chybu
      if not has_node(current_node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud [node] je ve stromu nalezen, hlásí chybu.
      if has_node(node) then
        execute(event_error);
        raise tree_error;
        end if;

    -- vlastní vložení, pokud při něm nastala chyba, konec
    if not do_insert(node,current_node,direction) then return end if;

    -- zvýšit počet uzlů ve stromu
    count+get_node_count(node);
    end insert_node;



    ------------------------------------------------------------------------------------------------
    static merge_subtree =
    -- Spojí dva stromy do jednoho. Stom [tree] reprezentuje strom přidávaných uzlů do stromu
    -- reprezentovanou instancí této třídy.
    --   Pokud připojovaný strom je prázdný, hlásí chybu.
    --   Pokud [current_node]=NIL, zkusí se vložit kořen, pokud je kořen definován, hlásí chybu.
    --   Pokud [current_node] není ve stromu nalezen, hlásí chybu.
    --   Pokud libovoný uzel v [tree] je ve stromu nalezen, hlásí chybu.
    --   Pokud se má nový strom vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
    ------------------------------------------------------------------------------------------------
    var 
      node_found   : t_logical:=false;           -- T-uzel nalezen

    begin
      -- pokud [tree.root]=NIL, hlásí chybu
      if tree.root=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud libovoný uzel v [tree] je ve stromu nalezen, hlásí chybu
      if has_node(tree.root) or has_node_rec(tree.root,root) then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud [current_node]=NIL, zkusí se vložit kořen, pokud je kořen definován, hlásí chybu
      if current_node=nil then
        -- pokud je kořen definován, hlásí chybu
        if root<>nil then
          execute(event_error);
          raise tree_error;
          end if;

        -- vložit kořen
        root:=tree.root;

        -- vyprázdnit původní strom
        tree.root:=nil;
        tree.count:=0;
        return;
        end if;

      -- pokud [current_node] není ve stromu nalezen, hlásí chybu
      if not has_node(current_node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- vlastní vložení, pokud při něm nastala chyba, konec
      if not do_insert(tree.root,current_node,direction) then return end if;

      -- vyprázdnit původní strom
      tree.root:=nil;
      tree.count:=0;

      -- zvýšit počet uzlů ve stromu o tree^.count
      count+tree.count;
      end merge_subtree;



    ------------------------------------------------------------------------------------------------
    static get_count_node (
        current_node : in p_tree_node)           -- aktuální uzel
        return t_unsigned =
    -- Vrátí počet poduzlů včetně [current_node] ve stromu.
    ------------------------------------------------------------------------------------------------
    var
      down_node    : p_tree_node;                -- potomek

    begin
      -- uzel musí být definovaný
      if current_node=nil then
        result:=0;
        return;
        end if;
      
      -- uzel má váhu 1
      result:=1;

      -- zjistit prvního potomka
      down_node:=p_tree_node(current_node^.down.get_first);

      -- procházet potomky
      while down_node<>nil loop
        -- procházet podstrom
        result+get_count_node(down_node);

        -- jdi na dalšího potomka
        down_node:=current_node^.down.get_next(down_node);
        end loop;
      end get_count_node;


    
    ------------------------------------------------------------------------------------------------
    override remove =
    -- Vyjme uzel ze stromu, pokud má uzlem následníky, vyjme se celý podstrom.
    --   Pokud [item]=nil, hlásí se chyba.
    --   Pokud [item] není ve stromu nalezen, hlásí se chyba.
    ------------------------------------------------------------------------------------------------
    var 
      node         : p_tree_node;                -- uzel pro vyjmutí ze stromu

    begin
      -- přetypovat [item]
      node:=p_tree_node(item);

      -- rušený uzel musí být definovaný
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud [node] není ve stromu nalezen, hlásí se chyba
      if not has_node(node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud [node]=[root], smazat strom
      if node=root then
        root:=nil;
        count:=0;
        return;
        end if;

      -- korigovat počet uzlů ve stromu
      count-get_count_node(node);
      
      -- vyjmout uzel
      node^.up^.down.remove(node);
      end remove;



    ------------------------------------------------------------------------------------------------
    static split_subtree =
    -- Vyjme ze stromu podstrom včetně uzlu [node] a vytvoří a inicializuje novou instance 
    -- trídy [c_tree]. 
    --   Pokud uzel není nalezen, hlásí chybu.
    ------------------------------------------------------------------------------------------------
    var
      lnode        : p_tree_node;                -- kořen nového stromu

    begin
      -- kořen podstromu/stromu
      lnode:=node;

      -- pokud není [lnode] ve stromu nalezen, hlásí chybu
      if not has_node(lnode) then
        execute(event_error);
        return;
        end if;

      -- má se vyjmout kořen?
      if lnode^.up=nil 
        -- ano, zrušit [root]
        then
          root:=nil;

        -- ne, vyjmout podstrom
        else
          lnode^.up^.down.remove(node);
          end if;

      -- nastavit předka odpojeného podstromu
      lnode^.up:=nil;

      -- nastavit počet uzlů ve stromu
      subtree.count:=get_count_node(lnode);
      count-subtree.count;

      -- nastavit kořen nového stromu
      subtree.root:=lnode;
      end split_subtree;



    ------------------------------------------------------------------------------------------------
    override delete =
    -- Smaže uzel ze stromu včetně potomků a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    var
      lnode        : p_tree_node;                -- [node]
      down_node    : p_tree_node;                -- potomek

    begin
      -- lokální node
      lnode:=item;

      -- pokud [node] není definován, ukonči rekurzi
      if lnode=nil then 
        return;
        end if;

      -- zjistit prvního potomka
      down_node:=p_tree_node(lnode^.down.get_first);

      -- procházet potomky
      while down_node<>nil loop
        -- procházet podstrom
        delete(down_node);

        -- jdi na dalšího potomka
        down_node:=lnode^.down.get_next(down_node);
        end loop;

      -- vyjmout uzel
      remove(lnode);

      -- uvolnit uzel z paměti
      discard lnode;

      -- vynulování uvolněného ukazatele
      item:=nil;
      end delete;



    ------------------------------------------------------------------------------------------------
    override delete_all =
    -- Smaže všechny uzly ze stromu a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    begin
      -- smazat celý strom
      delete(root);
      end delete_all;



    ------------------------------------------------------------------------------------------------
    static move_subtree =
    -- Přesune podstrom z jednoho místa na jiné místo v tom samém stromu.
    --   Pokud [node]=NIL, hlásí chybu.
    --   Pokud [node] není ve stromu nalezen, hlásí chybu.
    --   Pokud [current_node] není ve stromu nalezen, hlásí chybu.
    --   Pokud se má uzel vložit vedle kořenového uzlu a má potomky, hlásí chybu.
    --   Pokud [current_node] je poduzlem [node], hlásí chybu.
    --   Pokud se má uzel podstromu vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu.
    ------------------------------------------------------------------------------------------------
    var
      sub          : p_tree;                     -- podstrom, pomocná instance
        
    begin
      -- vytvořit pomocnou instanci
      new sub;

      -- [current_node] je obsaženo v přesouvaném podstromě [node] => chyba
      if has_node_rec(node,current_node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- rozdělit na dva podstromy
      split_subtree(node,sub^);

      -- dočasný podstrom vložit na požadované místo
      merge_subtree(sub^,current_node,direction);

    leave
      -- uvolnit dočasný podstrom
      discard sub;
      end move_subtree;

    end c_tree;



----------------------------------------------------------------------------------------------------
class private c_tree_iterator = 
-- Iterator.
----------------------------------------------------------------------------------------------------

    with
      supervised c_tree_node;

    var 
      direction    : t_tree_walking_direction;   -- řízení iterace
      tree         : p_tree;                     -- subjekt iterace
      current_node : p_tree_node;                -- aktuální uzel

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializuje iterator používaný pro průchod stromem.
    ------------------------------------------------------------------------------------------------   
    begin
      -- inicializece řídících proměnných
      this.direction:=direction;
      this.tree:=^tree;

      -- chybný směr procházení
      if direction not in t_tree_walking_direction_set:[ttwd_prefix,ttwd_inv_prefix,ttwd_postfix,ttwd_inv_postfix] then
        raise tree_error;
        end if;

      -- resetování
      reset;
      end init;



    ------------------------------------------------------------------------------------------------
    override reset =
    -- Resetuje iterator do stavu po inicializaci.
    ------------------------------------------------------------------------------------------------
    begin
      -- dočasné nastavení [current_node]
      current_node:=tree^.get_root;

      -- strom je prázdný
      if current_node=nil then return end if;

      case direction
        -- prefix
        when ttwd_prefix do 
          -- nic nedělat - kořen je první

        -- inverzní prefix
        when ttwd_inv_prefix do 
          -- nic nedělat - kořen je první

        -- postfix
        when ttwd_postfix do 
          -- najít potomka
          loop
            -- sejít dolů, při rozhodování se vydat vždy nejlevější cestou
            if current_node^.down.get_first<>nil then 
              current_node:=current_node^.down.get_first;
            else
              break;
              end if;
            end loop;

        -- inverzní postfix
        when ttwd_inv_postfix do 
          -- najít potomka
          loop
            -- sejít dolů, při rozhodování se vydat vždy nejpravější cestou
            if current_node^.down.get_last<>nil then 
              current_node:=current_node^.down.get_last;
            else
              break;
              end if;
            end loop;
        end case;
      end reset;


    ------------------------------------------------------------------------------------------------
    static find_next =
    -- Do [current_node] uloží další procházený uzel
    -- Předpokládá [current_node]<>nil
    ------------------------------------------------------------------------------------------------
    begin
      -- určit směr procházení
      case direction
        -- prefix
        when ttwd_prefix do
          -- pokud to jde, jdeme dolů co nejvíce doleva
          if current_node^.down.get_first<>nil then
            current_node:=current_node^.down.get_first;

          -- nejde to do podstromu, musíme se vrátit nahoru
          else
            -- jít nahoru tak dlouho, dokud se nedá odbočit doprava dolů
            while current_node<>nil loop
              -- šplháme po levé větvi a pravá větev má následníky?
              if current_node^.up<>nil and then current_node^.up^.down.get_next(current_node)<>nil then
                current_node:=current_node^.up^.down.get_next(current_node);
                return;
                end if;

              -- jít nahoru
              current_node:=current_node^.up;
              end loop;
            end if;

        -- inverzní prefix
        when ttwd_inv_prefix do
          -- pokud to jde, jdeme dolů co nejvíce doprava
          if current_node^.down.get_last<>nil then
            current_node:=current_node^.down.get_last;

          -- nejde to do podstromu, musíme se vrátit nahoru
          else
            -- jít nahoru tak dlouho, dokud se nedá odbočit doleva dolů
            while current_node<>nil loop
              -- šplháme po levé větvi a pravá větev má předchůdce?
              if current_node^.up<>nil and then current_node^.up^.down.get_prev(current_node)<>nil then
                current_node:=current_node^.up^.down.get_prev(current_node);
                return;
                end if;

              -- jít nahoru
              current_node:=current_node^.up;
              end loop;
            end if;

        -- postfix
        when ttwd_postfix do
          -- pokud to jde, jít doprava na stejnou úroveň a pak co nejvíce dolů
          if current_node^.up<>nil and then current_node^.up^.down.get_next(current_node)<>nil then
            current_node:=current_node^.up^.down.get_next(current_node);

            -- co nejvíce dolů
            loop
              -- sejít dolů, při rozhodování se vydat vždy nejlevější cestou
              if current_node^.down.get_first<>nil then 
                current_node:=current_node^.down.get_first;
              else break;
                end if;
              end loop;

          else 
            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- inverzní postfix
        when ttwd_inv_postfix do
          -- pokud to jde, jít dolevana stejnou úroveň a pak co nejvíce dolů
          if current_node^.up<>nil and then current_node^.up^.down.get_prev(current_node)<>nil then
            current_node:=current_node^.up^.down.get_prev(current_node);

            -- co nejvíce dolů
            loop
              -- sejít dolů, při rozhodování se vydat vždy nejpravější cestou
              if current_node^.down.get_last<>nil then 
                current_node:=current_node^.down.get_last;
              else break;
                end if;
              end loop;

          else 
            -- nahoru
            current_node:=current_node^.up;
            end if;
          end case;
      end find_next;



    ------------------------------------------------------------------------------------------------
    override get =
    -- Vrátí jeden uzel z korespondujícího stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- uzel, který má iterátor vrátit, je v current_node
      item:=current_node;

      -- výsledná hodnota - F, pokud je v [item] nil
      result:=item<>nil;

      -- pokud není co procházet, konec
      if not result then return end if;

      -- najít další uzel
      find_next;
      end get;
 
    end c_tree_iterator;

end trees;

