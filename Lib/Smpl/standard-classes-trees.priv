{%%TODO(homogenous) - vyřešit případ vkládání nehomogenních dat, kdy ve stromě smějí být pouze
                      homogenní data}

----------------------------------------------------------------------------------------------------
module private trees =
-- Data structures - trees.
-- Flex Standard Multi-Platform Library
-- Copyright (C) 1999-2004 A && L soft
----------------------------------------------------------------------------------------------------

-- K implemetaci iterátorů:
-- Nepoužívají zásobník, jediné, co si pamatují, je aktuální prvek - [current_node]
-- Výkonné funkce : 
--   reset - ta najde první prvek k iterování a uloží ho do [current_node]
--   find_next - přečte si hodnotu z [current_node] a uloží do ní další prvek, případně nil, pokud už
--     v [current_node] byl poslední prvek
-- Invarianty procházení - pomáhají konstruovat algoritmy pro procházení:
-- Máme strom s očíslovanými vrcholy, vrchol číslo 1 se projde jako první, vrchol číslo 2 druhý atd.
-- Pak platí:
-- Prefix:
-- pro libovolný podstrom platí, že jeho kořen má nejmenší číslo z celého podstromu
-- pro každé dva uzly ve stejné hloubce platí, že ten vlevo má menší číslo
-- Postfix:
-- pro libovolný podstrom platí, že jeho kořen má největší číslo z celého podstromu
-- pro každé dva uzly ve stejné hloubce platí, že ten vlevo má menší číslo
-- Infix:
-- Očíslovaný strom je vyhledávací, tzn. pro každý podstrom platí, že čísla všech uzlů levého podstromu
-- jsou menší než číslo kořene a čísla všech uzlů pravého podstromu jsou větší než číslo kořene.
-- Inverzní pořadí:
-- Stačí vyměnit [left] za [right] u binárním stromů, případně [get_last] za [get_first] a [get_next]
-- za [get_prev] u obecných stromů

----------------------------------------------------------------------------------------------------
class private abstract c_binary_tree_node =
-- Uzel binárního stromu.
----------------------------------------------------------------------------------------------------

    end c_binary_tree_node;



----------------------------------------------------------------------------------------------------
class private abstract c_binary_tree =
-- Binární vyhledávací strom s podporou AVL. 
----------------------------------------------------------------------------------------------------

    with
      supervised c_binary_tree_node;
 
    var
      avl          : t_logical;                  -- T-vyvažovat
      unique_key   : t_logical;                  -- T-pouze uzly se stejnými klíči


    -- dopředné deklarace pomocných metod
    ------------------------------------------------------------------------------------------------
    static has_node_rec (
        i_current_node : in p_binary_tree_node;  -- aktuální uzel
        node           : in p_binary_tree_node)  -- hledaný uzel
        return t_logical;                        -- T-uzel nalezen
    -- Vrací [true], pokud je [node] prvkem stromu.
    ------------------------------------------------------------------------------------------------
    static insert_left (
        node       : in p_binary_tree_node;      -- aktuální uzel 
        new_node   : in p_binary_tree_node);     -- vkládaný uzel
    -- Přidá uzel [new_node] pod uzel [node] zleva, pokud je volné místo.
    ------------------------------------------------------------------------------------------------
    static insert_right (
        node       : in p_binary_tree_node;      -- aktuální uzel 
        new_node   : in p_binary_tree_node);     -- vkládaný uzel
    -- Přidá uzel [new_node] pod uzel [node] zprava, pokud je volné místo.
    ------------------------------------------------------------------------------------------------
    static compute_balance (
        node       : in p_binary_tree_node);     -- pointer na uzel stromu
    -- Spočte váhu [weight] a hloubku [depth] uzlu [node] podle jeho levého a pravého potomka, pokud
    -- uzel [node] existuje, tj. není [nil].
    ------------------------------------------------------------------------------------------------
    static remove_balance (
        node       : in out p_binary_tree_node;  -- pointer na uzel stromu
        rem        : in out t_logical);          -- [false] pokud nedošlo ke změně váhy uzlu [node]
                                                 -- po LL nebo RR rotaci
    -- Provede vyvážení uzlu [node] podle definice AVL po odebrání libovolného uzlu ze stromu.
    -- Pokud byla provedena LL nebo RR rotace uzlu [node] a nedošlo ke změně váhy uzlu [node],
    -- nastaví [rem] na [false] a již nedojde k žádné rotaci u všech předků uzlů [node].
    ------------------------------------------------------------------------------------------------
    static remove_balance_left (
        node       : in out p_binary_tree_node)  -- pointer na uzel stromu
        return t_logical;
    -- Provede vyvážení uzlu [node] podle definice AVL po odebrání libovolného uzlu některého pravého
    -- potomka uzlu [node] (nevyváženost vznikla v levém podstromu uzlu [node]).
    -- Vrací [false], pokud při LL rotaci nedošlo ke změně váhy uzlu, což implikuje ukončení provádění
    -- rotací všech předků uzlu [node].
    ------------------------------------------------------------------------------------------------
    static remove_balance_right (
        node       : in out p_binary_tree_node)  -- pointer na uzel stromu
        return t_logical;
    -- Provede vyvážení uzlu [node] podle definice AVL po odebrání libovolného uzlu některého levého
    -- potomka uzlu [node] (nevyváženost vznikla v pravém podstromu uzlu [node]).
    -- Vrací [false], pokud při RR rotaci nedošlo ke změně váhy uzlu, což implikuje ukončení provádění
    -- rotací všech předků uzlu [node].
    ------------------------------------------------------------------------------------------------
    static insert_balance (
        node       : in out p_binary_tree_node); -- pointer na uzel stromu
    -- Provede vyvážení uzlu [node] podle definice AVL po přidání libovolného uzlu do stromu.
    ------------------------------------------------------------------------------------------------
    static insert_balance_left (
        node       : in out p_binary_tree_node); -- pointer na uzel stromu
    -- Provede vyvážení uzlu [node] podle definice AVL po přidání libovolného uzlu některého levého
    -- potomka uzlu [node].
    ------------------------------------------------------------------------------------------------
    static insert_balance_right (
        node       : in out p_binary_tree_node); -- pointer na uzel stromu
    -- Provede vyvážení uzlu [node] podle definice AVL po přidání libovolného uzlu některého pravého
    -- potomka uzlu [node].
    ------------------------------------------------------------------------------------------------
    static rotate_left (
        node       : in out p_binary_tree_node); -- pointer na uzel stromu
    -- Provede LL rotaci uzlu [node]. Po provedení rotace spočte váhy levého a pravého potomka uzlu
    -- [node] (pokud existují) a váhu samotného uzlu [node].
    ------------------------------------------------------------------------------------------------
    static rotate_right (
        node       : in out p_binary_tree_node); -- pointer na uzel stromu
    -- Provede RR rotaci uzlu [node]. Po provedení rotace spočte váhy levého a pravého potomka uzlu
    -- [node] (pokud existují) a váhu samotného uzlu [node].
    ------------------------------------------------------------------------------------------------
    static insert_node (
        node       : in out p_binary_tree_node;  -- předek nově vkládaného uzlu [new_node]
        new_node   : in p_binary_tree_node);     -- nový vkládaný uzel
    -- Rekurzivně vkládá nový uzel [new_node] do stromu, jako potomka uzlu [node]. Pokud klíč
    -- vkládaného uzlu [new_node] již ve stromě existuje a je povoleno více výskytů téhož klíče
    -- ve stromě, pak nový uzel [new_node] uzložíme jako pravého potomka. Pokud není povolen
    -- vícenásobný výskyt téhož klíče ve stromě, generuje metoda výjimku [tree_error].
    ------------------------------------------------------------------------------------------------
    static remove_node (
        node       : in out p_binary_tree_node;  -- pointer na uzel stromu
        rem_node   : in p_binary_tree_node;      -- pointer na uzel stromu, který má být vyjmut
        removed    : out t_logical;              -- [true], pokud došlo k vyjmutí uzlu [rem_node]
        original   : out p_binary_tree_node;     -- pointer na uzel, kterým byl nahrazen odstraněný
                                                 -- uzel [rem_node], který obsahoval levého i pravého potomka
        equal      : in t_logical);              -- [true] pokud jsme se při vyhledávání uzlu [rem_node]
                                                 -- ve stromě [tree] posunuli do pravého podstromu uzlu [node]
                                                 -- a to v případě, kdy klíče uzlů [node] a [rem_node] byly
                                                 -- identické
    -- Vyjme uzel [rem_node] ze stromu. Rekurzivně vyhledává ve stromě uzel [rem_node] od zadaného
    -- uzlu [node] směrem ke koncovým uzlům. Pointer [original] uchovává uzel, kterým byl nahrazen
    -- odstraněný uzel [rem_node], který obsahuje levého i pravého potomka. Pokud uzel [rem_node]
    -- nebyl ve stromě nalezen, genereje metoda výjimku [tree_error].
    -- Uzel [rem_node] musí být nejprve ve stromě [tree] nalezen. Přitom se mohlo stát, že vlivem rotací
    -- při vyvažování mohl být pravý potomek (mající stejný klíč jako jeho předek) nějakého uzlu změněn
    -- na levého potomka. V takovém případě při identickém klíči nejprve vyhledáváme uzel v pravém
    -- podstromu uzlu a pokud ho v něm nenajdeme, prohledáváme navíc ještě v levém podstromu. Pokud
    -- ho ani v takovým případě nenalezneme, generuje metoda výjimku [tree_error]. Kvůli dvojímu
    -- prohledávání levého podstromu uzlu při identických klíčích je použita logická proměnná [equal].
    ------------------------------------------------------------------------------------------------
    static remove_both_children (
        node       : in out p_binary_tree_node;  -- pointer na uzel stromu
        curr       : in out p_binary_tree_node;  -- levý potomek uzlu [node]
        removed    : out t_logical;              -- [true], pokud došlo k vyjmutí uzlu [rem_node]
        original   : out p_binary_tree_node);    -- "nejpravější" uzel levého potomka uzlu [node]
    -- Vyjme uzel [node] ze stromu. Je volána v případě, kdy má uzel [node] oba dva potomky. Uzel
    -- [node] je nahrazen "nejpravějším" uzlem levého potomka uzlu [node].
    ------------------------------------------------------------------------------------------------
    static merge_subtree_rec (
        node       : p_binary_tree_node);        -- kořenový uzel přidávaného stromu
    -- Spojí dva stromy do jednoho. Stom [tree] reprezentuje strom přidávaných uzlů do stromu
    -- reprezentovanou instancí této třídy. Pokud uxistují dva uzly se stejným klíčem, je uzel 
    -- do stromu vložen v závislosti na parametru [unique_key].
    ------------------------------------------------------------------------------------------------
    static delete_all_rec (
        node       : in out p_binary_tree_node); -- rušená větev
    -- Zruší celou větev stromu a uvolní jejich paměť. Mazání je rychlejší, je použita v metodě
    -- delete_all. Při smazání větve nemusí již být strom vyvážen.
    ------------------------------------------------------------------------------------------------
    static find_rec (
        tree       : p_binary_tree_node;         -- uzel stromu
        node       : p_binary_tree_node)         -- uzel (resp. klíč), který ve stromě vyhledáváme
        return p_binary_tree_node;
    -- Rekurzivně vyhledá první uzel, který má klíč rovný [node].
    ------------------------------------------------------------------------------------------------
    static remove_subtree (
        node       : in p_binary_tree_node;      -- uzel stromu, který bude novým kořenem podstromu,
                                                 -- jež bude vyjmut
        sub_count  : out t_unsigned)             -- počet uzlů v odebraném podstromu
        return p_binary_tree_node;
    -- Odebere podstrom, jehož kořenem bude uzel [node], ze stromu.
    -- Pokud není uzel [node] ve stromu nalezen, generuje metoda výjimku [tree_error].
    -- Procedura vrací pointer na kořen nového podstromu, který byl odebrán. Parametr [sub_count]
    -- obsahuje počet uzlů v odebraném stromu. 
    ------------------------------------------------------------------------------------------------



    ------------------------------------------------------------------------------------------------
    static has_node_rec =
    -- Vrací [true], pokud je [node] prvkem stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- hledaný uzel musí být definovaný
      if i_current_node=nil then
        result:=false;
        return;
        end if;

      -- jsou si oba uzly rovny?
      if i_current_node=node then
        -- ano, vrátit True
        result:=true;
        return;
        end if;

      -- porovnat klíče uzlů
      case compare(i_current_node,node)
        -- je aktuální uzel větší než hledaný uzel?
        when cr_bigger do
            -- jdi doleva
            result:=has_node_rec(i_current_node^.left,node);

        -- je aktuální uzel menší než hledaný uzel?
        when cr_smaller do
            -- jdi doprava
            result:=has_node_rec(i_current_node^.right,node);

        -- klíče jsou si rovny, ale zatím není nalezen hledaný uzel
        when cr_equal do
            -- jedná se o avl strom s možností mít více stejných klíčů?
            if avl and not unique_key then
              -- ano, prohledat celý podstrom, nejříve pravý, pokud uzel nebude nalezen, prohledat levý
              result:=has_node_rec(i_current_node^.right,node);
              if not result then
                result:=has_node_rec(i_current_node^.left,node);
                end if;
              return;

            -- pokud to není avl, mohou být ve stromě uzly se stejnými klíči?
            elsif not unique_key then
              -- ano, jít doprava
              result:=has_node_rec(i_current_node^.right,node);

            -- hledaný uzel nebyl nalezen
            else
              result:=false;
              return;
              end if;
        end case;
      end has_node_rec;



    ------------------------------------------------------------------------------------------------
    static get_root =
    -- Vrátí kořenový uzel. Pokud uzel není definován, vrací NIL.
    ------------------------------------------------------------------------------------------------
    begin
      -- vrátí root node
      result:=root;
      end get_root; 



    ------------------------------------------------------------------------------------------------
    static get_node_count =
    -- Spočítá počet uzlů v podstromu včetně uzlu [node].
    ------------------------------------------------------------------------------------------------
    begin
      -- jestliže [node] není definován, ukonči rekurzi
      if node=nil then 
        return;
        end if;

      -- počet uzlů je o jeden větší
      succ count;

      -- procházet stromem 
      get_node_count(node^.left,count);
      get_node_count(node^.right,count);
      end get_node_count;



    ------------------------------------------------------------------------------------------------
    static insert_left =
    -- Přidá uzel [new_node] pod uzel [node] zleva, pokud je volné místo.
    ------------------------------------------------------------------------------------------------
    begin
      if node^.left=nil then
        -- ano, vlož uzel doleva
        new_node^.weight:=0;
        new_node^.depth:=1;
        new_node^.left:=nil;
        new_node^.right:=nil;
        new_node^.up:=node;
        node^.left:=new_node;

        -- zvýšit počet uzlů ve stromu o 1
        succ count;
        end if;
      end insert_left;



    ------------------------------------------------------------------------------------------------
    static insert_right =
    -- Přidá uzel [new_node] pod uzel [node] zprava, pokud je volné místo.
    ------------------------------------------------------------------------------------------------
    begin
      -- je vpravo volné místo?
      if node^.right=nil then
        -- ano, vlož uzel doprava
        new_node^.weight:=0;
        new_node^.depth:=1;
        new_node^.left:=nil;
        new_node^.right:=nil;
        new_node^.up:=node;
        node^.right:=new_node;

        -- zvýšit počet uzlů ve stromu o 1
        succ count;
        end if;
      end insert_right;



    ------------------------------------------------------------------------------------------------
    static compute_balance =
    -- Spočte váhu [weight] a hloubku [depth] uzlu [node] podle jeho levého a pravého potomka, pokud
    -- uzel [node] existuje, tj. není [nil].
    ------------------------------------------------------------------------------------------------
    var
      left_depth   : t_unsigned;                 -- hloubka levého potomka
      right_depth  : t_unsigned;                 -- hloubka pravého potomka

    begin
      -- pokud uzel [node] existuje, jeho spočteme hloubku a váhu
      if node<>nil then
        -- pokud existuje levý potomek uzlu [node], zjistíme jeho hloubku, je jeho váha 0
        if node^.left<>nil
          then left_depth:=node^.left^.depth;
          else left_depth:=0;
          end if;

        -- pokud existuje pravý potomek uzlu [node], zjistíme jeho hloubku, jinak je jeho váha 0
        if node^.right<>nil
          then right_depth:=node^.right^.depth;
          else right_depth:=0;
          end if;

        -- pokud je hloubka levého potomka větší než pravého, bude hloubka uzlu [node] o 1 větší
        -- než hloubka levého potomka, jinak o 1 větší než hloubka pravého potomka
        if left_depth>right_depth
          then node^.depth:=1+left_depth;
          else node^.depth:=1+right_depth;
          end if;

        -- určíme váhu uzlu [node] (rozdíl hloubky pravého potomka a hloubky levého potomka)
        node^.weight:=t_signed(right_depth)-t_signed(left_depth);
        end if;
      end compute_balance;



    ------------------------------------------------------------------------------------------------
    static remove_balance =
    -- Provede vyvážení uzlu [node] podle definice AVL po odebrání libovolného uzlu ze stromu.
    -- Pokud byla provedena LL nebo RR rotace uzlu [node] a nedošlo ke změně váhy uzlu [node],
    -- nastaví [rem] na [false] a již nedojde k žádné rotaci u všech předků uzlů [node].
    ------------------------------------------------------------------------------------------------
    begin
      if node^.weight>1 then rem:=remove_balance_right(node);
      elsif node^.weight<-1 then rem:=remove_balance_left(node);
        end if;
      end remove_balance;



    ------------------------------------------------------------------------------------------------
    static remove_balance_left =
    -- Provede vyvážení uzlu [node] podle definice AVL po odebrání libovolného uzlu některého pravého
    -- potomka uzlu [node] (nevyváženost vznikla v levém podstromu uzlu [node]).
    -- Vrací [false], pokud při LL rotaci nedošlo ke změně váhy uzlu, což implikuje ukončení provádění
    -- rotací všech předků uzlu [node].
    ------------------------------------------------------------------------------------------------
    var
      weight       : t_signed;                   -- váha uzlu [node]

    begin
      result:=true;
      if node^.left<>nil then
        -- je váha levého potomka nekladná?
        if node^.left^.weight<=0

          -- ano => LL rotace
          then
            -- uzložíme si váhu před LL rotací. Pokud se po provední rotace nezmění, ukončíme provádění
            -- rotací u všech předků uzlu [node]          
            weight:=node^.weight;

            -- LL rotace
            rotate_left(node);
            if node^.weight=weight then result:=false; end if;

          -- ne => LR rotace
          else
            rotate_right(node^.left);
            rotate_left(node);
            end if;
        end if;
      end remove_balance_left;



    ------------------------------------------------------------------------------------------------
    static remove_balance_right =
    -- Provede vyvážení uzlu [node] podle definice AVL po odebrání libovolného uzlu některého levého
    -- potomka uzlu [node] (nevyváženost vznikla v pravém podstromu uzlu [node]).
    -- Vrací [false], pokud při RR rotaci nedošlo ke změně váhy uzlu, což implikuje ukončení provádění
    -- rotací všech předků uzlu [node].
    ------------------------------------------------------------------------------------------------
    var
      weight       : t_signed;                   -- váha uzlu [node]

    begin
      result:=true;
      if node^.right<>nil then
        -- je váha pravého potomka nezáporná?
        if node^.right^.weight>=0

          -- ano => RR rotace
          then
            -- uzložíme si váhu před RR rotací. Pokud se po provední rotace nezmění, ukončíme provádění
            -- rotací u všech předků uzlu [node]          
            weight:=node^.weight;

            -- RR rotace
            rotate_right(node);
            if node^.weight=weight then result:=false; end if;

          -- ne => RL rotace
          else
            rotate_left(node^.right);
            rotate_right(node);
            end if;
        end if;
      end remove_balance_right;



    ------------------------------------------------------------------------------------------------
    static insert_balance =
    -- Provede vyvážení uzlu [node] podle definice AVL po přidání libovolného uzlu do stromu.
    ------------------------------------------------------------------------------------------------
    begin
      if node^.weight>1 then insert_balance_right(node);
      elsif node^.weight<-1 then insert_balance_left(node);
        end if;
      end insert_balance;



    ------------------------------------------------------------------------------------------------
    static insert_balance_left =
    -- Provede vyvážení uzlu [node] podle definice AVL po přidání libovolného uzlu některého levého
    -- potomka uzlu [node].
    ------------------------------------------------------------------------------------------------
    begin
      if node^.left<>nil then
        -- je váha levého uzlu záporná?
        if node^.left^.weight<0
          -- ano => LL rotace
          then rotate_left(node);

          -- ne => LR rotace
          else
            rotate_right(node^.left);
            rotate_left(node);
          end if;
        end if;
      end insert_balance_left;



    ------------------------------------------------------------------------------------------------
    static insert_balance_right =
    -- Provede vyvážení uzlu [node] podle definice AVL po přidání libovolného uzlu některého pravého
    -- potomka uzlu [node].
    ------------------------------------------------------------------------------------------------
    begin
      if node^.right<>nil then
        -- je váha pravého uzlu kladná?
        if node^.right^.weight>0
          -- Ano => RR rotace
          then rotate_right(node);

          -- Ne => RL rotace
          else
            rotate_left(node^.right);
            rotate_right(node);
            end if;
        end if;
      end insert_balance_right;



    ------------------------------------------------------------------------------------------------
    static rotate_left =
    -- Provede LL rotaci uzlu [node]. Po provedení rotace spočte váhy levého a pravého potomka uzlu
    -- [node] (pokud existují) a váhu samotného uzlu [node].
    ------------------------------------------------------------------------------------------------
    var
      p            : p_binary_tree_node;         -- pomocný pointer na uzel binárního stromu

    begin
      p:=node^.left;
      p^.up:=node^.up;
      node^.left:=p^.right;
      if p^.right<>nil then p^.right^.up:=node; end if;
      p^.right:=node;
      node^.up:=p;
      node:=p;

      -- spočteme váhu a hloubku levého a pravého potomka uzlu [node] a uzlu [node]
      compute_balance(node^.left);
      compute_balance(node^.right);
      compute_balance(node);
      end rotate_left;



    ------------------------------------------------------------------------------------------------
    static rotate_right =
    -- Provede RR rotaci uzlu [node]. Po provedení rotace spočte váhy levého a pravého potomka uzlu
    -- [node] (pokud existují) a váhu samotného uzlu [node].
    ------------------------------------------------------------------------------------------------
    var
      p            : p_binary_tree_node;         -- pomocný pointer na uzel binárního stromu

    begin
      p:=node^.right;
      p^.up:=node^.up;
      node^.right:=p^.left;
      if p^.left<>nil then p^.left^.up:=node; end if;
      p^.left:=node;
      node^.up:=p;
      node:=p;

      -- spočteme váhu a hloubku levého a pravého potomka uzlu [node] a uzlu [node]
      compute_balance(node^.left);
      compute_balance(node^.right);
      compute_balance(node);
      end rotate_right;



    ------------------------------------------------------------------------------------------------
    static insert_node =
    -- Rekurzivně vkládá nový uzel [new_node] do stromu, jako potomka uzlu [node]. Pokud klíč
    -- vkládaného uzlu [new_node] již ve stromě existuje a je povoleno více výskytů téhož klíče
    -- ve stromě, pak nový uzel [new_node] uzložíme jako pravého potomka. Pokud není povolen
    -- vícenásobný výskyt téhož klíče ve stromě, generuje metoda výjimku [tree_error].
    ------------------------------------------------------------------------------------------------
    var
      cmp          : t_compare_result;           -- výsledek porovnávání dvou uzlů

    begin
      -- porovnáme uzlu [new_node] a [node]
      cmp:=compare(new_node,node);

      -- podle výsledku porovnání vložíme nový uzel [new_node] do levého či pravého potomka
      case cmp

        -- klíč nového uzlu [new_node] je menší než klíč uzelu [node] => vkládáme do levého potomka
        when cr_smaller do
          -- obsahuje uzel [node] levého potomka?
          if node^.left<>nil

            -- ano => posuneme se do levého podstromu uzlu [node]
            then insert_node(node^.left,new_node);

            -- ne => nový uzel [new_node] se stane levým potomkem uzlu [node]
            else insert_left(node,new_node);
            end if;

        -- klíč nového uzlu [new_node] je větší nebo roven klíči uzlu [node] => vkládáme do pravého potomka
        when cr_bigger, cr_equal do
          -- pokud je klíč stejný a není povolen vícenásobný výskyt téhož klíče ve stromě, generujeme
          -- výjimku [tree_error]
          if cmp=cr_equal and unique_key then
            execute(event_error);
            raise tree_error;
            end if;

          -- obsahuje uzel [node] pravého potomka?
          if node^.right<>nil

            -- ano => posuneme se do pravého podstromu uzlu [node]
            then insert_node(node^.right,new_node);

            -- ne => nový uzel [new_node] se stane pravým potomkem uzlu [node]
            else insert_right(node,new_node);
            end if;
        end case;

      -- přepočteme výhu a hloubku uzlu [node]
      compute_balance(node);

      -- pokud jde o AVL strom, provedeme případné rotace při nevyvážení
      if avl then insert_balance(node); end if;
      end insert_node;



    ------------------------------------------------------------------------------------------------
    static delete_all_rec =
    -- Zruší celou větev stromu a uvolní jejich paměť. Mazání je rychlejší, je použita v metodě
    -- delete_all. Při smazání větve nemusí již být strom vyvážen.
    ------------------------------------------------------------------------------------------------
    begin
      -- jestliže [node] není definován, ukončit rekurzi
      if node=nil then 
        return;
        end if;

      -- procházet stromem 
      delete_all_rec(node^.left);
      delete_all_rec(node^.right);

      -- uvolnit uzel z paměti
      discard node;
      end delete_all_rec;



    ------------------------------------------------------------------------------------------------
    static find_rec =
    -- Rekurzivně vyhledá první uzel, který má klíč rovný [node].
    ------------------------------------------------------------------------------------------------
    begin
      -- inicializovat
      result:=nil;

      -- uzel nebyl nalezen
      if tree=nil then return end if;

      -- porovnat klíče uzlů
      case compare(tree,node)
        -- je aktuální uzel větší než hledaný uzel?
        when cr_bigger do
            -- jdi doleva
            result:=find_rec(tree^.left,node);

        -- je aktuální uzel menší než hledaný uzel?
        when cr_smaller do
            -- jdi doprava
            result:=find_rec(tree^.right,node);

        -- klíče jsou si rovny, ale zatím není nalezen hledaný uzel
        when cr_equal do
            result:=tree;
        end case;
      end find_rec;



    ------------------------------------------------------------------------------------------------
    static remove_subtree =
    -- Odebere podstrom, jehož kořenem bude uzel [node], ze stromu.
    -- Pokud není uzel [node] ve stromu nalezen, generuje metoda výjimku [tree_error].
    -- Procedura vrací pointer na kořen nového podstromu, který byl odebrán. Parametr [sub_count]
    -- obsahuje počet uzlů v odebraném stromu. 
    ------------------------------------------------------------------------------------------------
    var
      new_root     : p_binary_tree_node;         -- kořen nového stromu
      root_h       : p_binary_tree_node;         -- pomocný pointer na kořen původního stromu

    begin
      -- uzel musí být ve stromě nalezen
      if not has_node(node) then
        -- není nalezen, chyba
        execute(event_error);
        raise tree_error;
        end if;

      -- kořen nového podstromu
      new_root:=node;

      -- je odpojovaný uzel různý od [root]?
      if new_root^.up<>nil 
        -- ano, různý od kořenu
        then
          -- odpojit uzel z původního stromu
          if new_root^.up^.left=new_root
            then new_root^.up^.left:=nil
            else new_root^.up^.right:=nil
            end if;

        -- ne, vymazat celý strom 
        else
          root:=nil;
          end if;

      -- nastavit předka nového kořenu na nil
      new_root^.up:=nil;

      -- má se původní strom znovu ustanovit?
      if avl then
        -- nastavit počet uzlů původního stromu
        count:=0;

        -- vytvořit původní strom na proměnnou [root_h] pro vyvolání [merge_subtree]
        root_h:=root;

        -- zrušit celý původní strom a zapamatovat si původní [root] pro znovuustanovení
        root:=nil;

        -- znovupostavit strom
        merge_subtree_rec(root_h);
        end if;

      -- spočítat počet uzlů v novém podstromu
      sub_count:=0;
      get_node_count(new_root,sub_count);

      -- pokud nebyl strom znovu sestaven přes avl, spočítat počet uzlů v původním stromu
      if not avl then
        count-sub_count;
        end if;

      -- vracíme pointer na kořen nového podstromu
      result:=new_root;
    end remove_subtree;



    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace stromu.
    --   Pokud je [homogenous] nastaven na true, ve stromě mohou být jen uzly typu [item_type].
    --   Pokud je [unique_key] nastaven na true, ve stromě nemohou být uzly se stejným klíčem.
    --   Pokud je [avl] nastaven na true, strom bude se bude vyvažovat.
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud je již strom definován
      if this.root<>nil then
        -- inicializace neproběhne
        execute(event_error);
        raise tree_error;
        end if;

      -- set up basic parameters
      this.item_type:=item_type;
      this.avl:=avl;
      this.unique_key:=unique_key;
      this.homogenous:=homogenous;
      end init;



    ------------------------------------------------------------------------------------------------
    static has_node =
    -- Vrací [true], pokud je [node] prvkem stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- hledaný uzel musí být definovaný
      if node=nil then
        return;
        end if;

      -- hledat uzel
      result:=has_node_rec(root,node);
      end has_node;



    ------------------------------------------------------------------------------------------------
    override insert =
    -- Vloží uzel [node] do binárního stromu. Pokud se má vložit uzel s klíčem, který se již ve
    -- stromě vyskytuje a je povolen vícenásobný výskyt klíče ve stromě, je uzel vložen vpravo.
    -- Pokud vícenásobný výskyt není povolen, generuje metoda výjimku [tree_error].
    ------------------------------------------------------------------------------------------------
    var
      node         : p_binary_tree_node;         -- vkládaný uzel

    begin
      {%%TODO(homogenous) - vyřešit případ vkládání nehomogenních dat, kdy ve stromě smějí být pouze
                            homogenní data}

      -- přetypovat
      node:=p_binary_tree_node(item);

      -- přidávaný uzel musí existovat
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- je uzel prázdný?
      if root=nil
        -- ano => jde o první uzel
        then
          node^.left:=nil;
          node^.right:=nil;
          node^.up:=nil;
          node^.weight:=0;
          node^.depth:=1;
          root:=node;
          succ count;

        -- ne => uzel [node] do stromu vložíme pomocí metody [insert_node]
        else insert_node(root,node);
        end if;
      end insert;



    ------------------------------------------------------------------------------------------------
    static merge_subtree_rec =
    -- Spojí dva stromy do jednoho. Stom [tree] reprezentuje strom přidávaných uzlů do stromu
    -- reprezentovanou instancí této třídy. Pokud uxistují dva uzly se stejným klíčem, je uzel 
    -- do stromu vložen v závislosti na parametru [unique_key].
    ------------------------------------------------------------------------------------------------
    begin
      -- jestliže kořen přidávaného stromu není definován, ukonči rekurzi
      if node=nil then
        return;
        end if;

      -- procházet stromem
      merge_subtree_rec(node^.left);
      merge_subtree_rec(node^.right);

      -- vložit do stromu uzel [node]
      insert(node);
      end merge_subtree_rec;


    
    ------------------------------------------------------------------------------------------------
    static merge_subtree =
    -- Spojí dva stromy do jednoho. Stom [tree] reprezentuje strom přidávaných uzlů do stromu
    -- reprezentovanou instancí této třídy. Pokud uxistují dva uzly se stejným klíčem, je uzel 
    -- do stromu vložen v závislosti na parametru [unique_key] - v případě [unique_key]=[true] je
    -- generována výjimka [tree_error].
    ------------------------------------------------------------------------------------------------
    begin
      -- spojit stromy
      merge_subtree_rec(tree.root);

      -- deinicializace připojovaného stromu
      tree.root:=nil;
      tree.count:=0;
      end merge_subtree;



    ------------------------------------------------------------------------------------------------
    static remove_node =
    -- Vyjme uzel [rem_node] ze stromu. Rekurzivně vyhledává ve stromě uzel [rem_node] od zadaného
    -- uzlu [node] směrem ke koncovým uzlům. Pointer [original] uchovává uzel, kterým byl nahrazen
    -- odstraněný uzel [rem_node], který obsahuje levého i pravého potomka. Pokud uzel [rem_node]
    -- nebyl ve stromě nalezen, genereje metoda výjimku [tree_error].
    -- Uzel [rem_node] musí být nejprve ve stromě [tree] nalezen. Přitom se mohlo stát, že vlivem rotací
    -- při vyvažování mohl být pravý potomek (mající stejný klíč jako jeho předek) nějakého uzlu změněn
    -- na levého potomka. V takovém případě při identickém klíči nejprve vyhledáváme uzel v pravém
    -- podstromu uzlu a pokud ho v něm nenajdeme, prohledáváme navíc ještě v levém podstromu. Pokud
    -- ho ani v takovým případě nenalezneme, generuje metoda výjimku [tree_error]. Kvůli dvojímu
    -- prohledávání levého podstromu uzlu při identických klíčích je použita logická proměnná [equal].
    ------------------------------------------------------------------------------------------------
    var
      cmp          : t_compare_result;           -- výsledek porovnávání klíčů dvou uzlů

    begin
      -- uzel [rem_node] jsme ve stromě nenalezli
      if node=nil then
        -- jde o identický klíč a přišli jsme do tohotu uzlu z pravého podstromu uzlu s identickým klíčem?
        if equal
          -- ano => jdeme zpátky k identickému klíči
          then return;

          -- ne => uzel [rem_node] se ve stromě nevyskytuje => generujeme výjimku [tree_error]
          else
            execute(event_error);
            raise tree_error;
            end if;
        end if;

      -- porovnáme uzly [rem_node] a [node]
      cmp:=compare(rem_node,node);

      -- je klíč uzlu [rem_node] menší než klíč uzlu [node]? Ano => posuneme se do jeho levého podstromu
      if cmp=cr_smaller then
        remove_node(node^.left,rem_node,removed,original,equal);

        -- pokud byl uzel [rem_node] vyjmut, přepočteme váhu uzlu [node] a případně provedeme rotace
        if removed then
          compute_balance(node);
        
          -- pokud je strom AVL, pak provedeme případné rotace při nevyvážení
          if avl then remove_balance(node,removed); end if;
          end if;

      -- je klíč uzlu [rem_node] větší než klíč uzlu [node]? Ano => posuneme se do jeho pravého podstromu
      elsif cmp=cr_bigger then
        remove_node(node^.right,rem_node,removed,original,equal);

        -- pokud byl uzel [rem_node] vyjmut, přepočteme váhu uzlu [node] a případně provedeme rotace
        if removed then
          compute_balance(node);

          -- pokud je strom AVL, pak provedeme případné rotace při nevyvážení
          if avl then remove_balance(node,removed); end if;
          end if;

      -- je klíč uzlu [rem_node] stejný jako klíč uzlu [node]? Ano => posuneme se do jeho pravého podstromu
      -- a pokud v něm uzel nenalezneme, pak se ještě posuneme do jeho levého podstromu
      elsif cmp=cr_equal and node<>rem_node then
        -- je povolen vícenásobný výskyt klíče ve stromě?
        if not unique_key

          -- ano => stejný klíč nemusí být vlivem rotací nebo ubráním uzlu jen vpravo, ale i vlevo
          -- => prohledáme nejprve pravý podstrom, poté levý podstrom, přičemž parametr [equal]
          -- nastavíme na [true]
          then
            remove_node(node^.right,rem_node,removed,original,true);

            -- uzel jsme nenalezli => posuneme se do levého podstromu 
            if not removed then
              remove_node(node^.left,rem_node,removed,original,true);
              end if;

          -- ne => chyba, neboť není povolen vícenásobný výskyt klíče
          else
            execute(event_error);
            raise tree_error;
            end if;

        -- pokud byl uzel [rem_node] vyjmut, přepočteme váhu uzlu [node] a případně provedeme rotace
        if removed then
          compute_balance(node);

          -- pokud je strom AVL, pak provedeme případné rotace při nevyvážení
          if avl then remove_balance(node,removed); end if;
          end if;

      -- nalezli jsme uzel, který má být odstraněn
      elsif cmp=cr_equal and node=rem_node then
        -- neexistuje pravý potomek uzlu [node]? Ne => uzel [node] posuneme na levého potomka
        if node^.right=nil then
	  if node^.left<>nil then node^.left^.up:=node^.up; end if;
          if node^.left<>nil then
            node^.depth:=node^.left^.depth;
            node^.weight:=node^.left^.weight;
            end if;
          node:=node^.left;
          removed:=true;

        -- neexistuje levý potomek uzlu [node]? Ne => uzel [node] posuneme na pravého potomka
        elsif node^.left=nil then
          if node^.right<>nil then node^.right^.up:=node^.up; end if;
          if node^.right<>nil then
            node^.depth:=node^.right^.depth;
            node^.weight:=node^.right^.weight;
            end if;
          node:=node^.right;
          removed:=true;

        -- uzel [node] obsahuje levého i pravého potomka
        else
          -- uzel [node] nahradíme "nejpravějším" uzlem levého potomka uzlu [node], příčemž uchováme
          -- pointer na tento nejpravější uzel, abychom jeho datovou část mohli po ukončení volání
          -- procedury [remove_node] vložit do uzlu [node]
          remove_both_children(node,node^.left,removed,original);

          -- pokud byl uzel [rem_node] vyjmut, přepočítáme váhu uzlu [node] a případně provedeme
          -- rotace
          if removed
            then
              compute_balance(node);

              -- pokud je strom AVL, pak provedeme případné rotace při nevyvážení
              if avl then remove_balance(node,removed); end if;
            else
              removed:=true;
            end if;
          end if;

        -- dekrementujeme počet uzlů ve stromě
        pred count;

      -- uzel [rem_node] jsme ve stromě nenalezli => generujeme výjimku [tree_error]
      else
        execute(event_error);
        raise tree_error;
        end if;
      end remove_node;



    ------------------------------------------------------------------------------------------------
    static remove_both_children =
    -- Vyjme uzel [node] ze stromu. Je volána v případě, kdy má uzel [node] oba dva potomky. Uzel
    -- [node] je nahrazen "nejpravějším" uzlem levého potomka uzlu [node].
    ------------------------------------------------------------------------------------------------
    begin
      -- obsahuje uzel [curr] pravého potomka?
      if curr^.right=nil
        -- ne => uchováme si pointer na uzel [curr] (tím nahradíme datovou část uzlu [node], který
        --       se má odstranit)
        then
          original:=curr;
          if curr^.left<>nil then curr^.left^.up:=curr^.up; end if;
          curr:=curr^.left;
          removed:=true;

        -- ano => posuneme se na něho
        else
          -- posuneme se na pravého potomka
          remove_both_children(node,curr^.right,removed,original);

          -- pokud byl uzel [rem_node] vyjmut, přepočítáme váhu uzlu [node] a případně provedeme
          -- rotace
          if removed then
            compute_balance(curr);

            -- pokud je strom AVL, pak provedeme případné rotace při nevyvážení
            if avl then remove_balance(curr,removed); end if;
            end if;
          end if;
      end remove_both_children;

    
    
    ------------------------------------------------------------------------------------------------
    override remove =
    -- Vyjme uzel ze stromu.
    -- Pokud odstraněný uzel [node] obsahuje levého i pravého potomka, pak uzel [node] byl nahradíme
    -- "nejpravějším" uzlem jeho levého potomka - pointer na něj je uložen v [del]. Musíme provést
    -- "přesměrování", kdy uzel [node] se stane uzelem [del], přičemž zůstanou zachovány původní
    -- ukazatele, tj. dojde ke změně jen datové části uzlu.
    -- Pokud uzel [rem_node] nebyl ve stromě nalezen, genereje metoda výjimku [tree_error].
    ------------------------------------------------------------------------------------------------
    var
      removed      : t_logical:=false;           -- [true], pokud byl uzel [node] vyjmut ze stromu
      node         : p_binary_tree_node;         -- uzel určený k vyjmutí
      del          : p_binary_tree_node;         -- "nejpravější" uzel levého potomka uzlu [node]

    begin
      -- přetypovat [item]
      node:=p_binary_tree_node(item);

      -- rušený uzel musí být definovaný
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- odstraníme uzel [node] ze stromu
      remove_node(root,node,removed,del,false);

      -- uzel [rem_node] nebyl ve stromu nalezen (případ identických klíčů) => generujeme výjimku
      -- [tree_error]
      if not removed then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud odstraněný uzel [node] neměl levého a pravého potomka, je vše OK, končíme
      if del=nil then return; end if;

      -- odstraněný uzel [node] obsahoval levého i pravého potomka. Uzel [node] byl nahrazen
      -- "nejpravějším" uzlem svého levého potomka - pointer na něj je uložen v [del]. Nyní musíme
      -- provést "přesměrování", kdy uzel [node] se stane uzelem [del], přičemž zůstanou zachovány
      -- původní ukazatele, tj. dojde ke změně jen datové části uzlu.

      -- uzlu [del] přiřadíme uzel [node] (levého a pravého potomka, předka, váhu, hloubku)
      del^:=node^;

      -- pokud existuje levý či pravý potomek uzlu [node], pak bude mít nového předka - uzel [del]
      if node^.left<>nil then node^.left^.up:=del; end if;
      if node^.right<>nil then node^.right^.up:=del; end if;

      -- je uzel [node] kořen?
      if node^.up=nil

        -- Ano => bude nový kořen 
        then root:=del;

        -- Ne => předek uzlu [node] bude ukazovat na uzel [del]
        else
          if node^.up^.left=node
            then node^.up^.left:=del;
            else node^.up^.right:=del;
            end if;
        end if;
      end remove;



    ------------------------------------------------------------------------------------------------
    static split_subtree =
    -- Vyjme ze stromu podstrom včetně uzlu [node] a vytvoří a inicializuje novou instance 
    -- trídy [c_binary_tree]. Pokud uzel není nalezen generuje výjimku [tree_error].
    ------------------------------------------------------------------------------------------------
    begin
      -- inicializujeme nový podstrom
      subtree.init(this.item_type,this.avl,this.unique_key,this.homogenous);

      -- vytvoříme nový podstrom
      subtree.root:=remove_subtree(node,subtree.count);
      end split_subtree;



    ------------------------------------------------------------------------------------------------
    override delete =
    -- Smaže uzel ze stromu a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    begin
      -- vyjmout uzel
      remove(item);

      -- uvolnit uzel z paměti
      discard item;
      end delete;



    ------------------------------------------------------------------------------------------------
    static delete_subtree =
    -- Smaže podstrom včetně uzlu [node] ze stromu a uvolní pamět. Pokud není uzel [node] ve stromu
    -- nalezen, generuje metoda výjimku [tree_error].
    -- Pozn.: Uzel [node] po ukončení metody nemusí být nutně [nil]. V případě AVL vyvažování mohl
    -- být vnitřek (datová část) uzlu (který nebyl odstřaněn, ozn U) vložen na místo odstraněného uzlu
    -- [node], přičemž datová část uzlu [node] byla vložena do uzlu U a tento uzel byl následně
    -- odstraněn.
    ------------------------------------------------------------------------------------------------
    var
      count_h      : t_unsigned;                 -- pomocná proměnná udávající počet uzlů v odebraném
                                                 -- podstromu (tuto hodnotu nepotřebujeme, proměnná
                                                 -- je definována poze kvůli kompatibilitě při volání
                                                 -- procedury [remove_subtree])
      new_root     : p_binary_tree_node;         -- pomocný pointer na kořen odtrženého podstromu

    begin
      -- odstraníme ze stromu podstrom, jehož kořen je uzel [node]
      new_root:=remove_subtree(node,count_h);

      -- odstraníme z paměti všechny uzly podstromu, jehož vrcholem je uzel [node]
      delete_all_rec(new_root);
      end delete_subtree;



    ------------------------------------------------------------------------------------------------
    override delete_all =
    -- Smaže všechny uzly ze stromu a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    begin
      -- smažeme celý strom
      delete_all_rec(root);

      -- nastavíme počet uzlů ve stromě na 0
      count:=0;
      end delete_all;



    ------------------------------------------------------------------------------------------------
    static find =
    -- Vyhledá první uzel, který má klíč rovný [node]. Pokud takový uzel nenalezne, vrací [false].
    ------------------------------------------------------------------------------------------------
    begin
      result:=find_rec(root,node);
      end find;

    end c_binary_tree;



----------------------------------------------------------------------------------------------------
class private c_binary_tree_iterator =
-- Iterator.
----------------------------------------------------------------------------------------------------

    with
      supervised c_binary_tree_node;

    var 
      direction    : t_tree_walking_direction;   -- řízení iterace
      tree         : p_binary_tree;              -- subjekt iterace
      current_node : p_binary_tree_node;         -- aktuální uzel


    
    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializuje iterator používaný pro průchod stromem.
    ------------------------------------------------------------------------------------------------
    begin
      -- inicializece řídících proměnných
      this.direction:=direction;
      this.tree:=^tree;

      -- resetování
      reset;
      end init;


 
    ------------------------------------------------------------------------------------------------
    override reset =
    -- Resetuje iterator do stavu po inicializaci.
    ------------------------------------------------------------------------------------------------
    begin
      -- dočasné nastavení [current_node]
      current_node:=tree^.get_root;

      -- strom je prázdný
      if current_node=nil then return end if;

      case direction
        -- prefix
        when ttwd_prefix do 
          -- nic nedělat - kořen je první

        -- inverzní prefix
        when ttwd_inv_prefix do 
          -- nic nedělat - kořen je první

        -- postfix
        when ttwd_postfix do 
          -- najít potomka
          loop
            -- nejdříve zkusit levý podstrom, když není zadán, tak pravý
            if current_node^.left<>nil then current_node:=current_node^.left;
            elsif current_node^.right<>nil then current_node:=current_node^.right;
            else break;
            end if;
            end loop;

        -- inverzní postfix
        when ttwd_inv_postfix do 
          -- najít potomka
          loop
            -- nejdříve zkusit pravý podstrom, když není zadán, tak levý
            if current_node^.right<>nil then current_node:=current_node^.right;
            elsif current_node^.left<>nil then current_node:=current_node^.left;
            else break;
            end if;
            end loop;

        -- infix
        when ttwd_infix do
          -- jít co nejvíce doleva
          while current_node^.left<>nil loop
            current_node:=current_node^.left;
            end loop;

        -- inverzní infix
        when ttwd_inv_infix do
          -- jít co nejvíce doprava
          while current_node^.right<>nil loop
            current_node:=current_node^.right;
            end loop;
        end case;

      end reset;


    ------------------------------------------------------------------------------------------------
    static find_next =
    -- Do [current_node] uloží další procházený uzel
    -- Předpokládá [current_node]<>nil
    ------------------------------------------------------------------------------------------------
    begin
      -- určit směr procházení
      case direction
        -- prefix
        when ttwd_prefix do
          -- pokud to jde doleva, jít do levého podstromu
          if current_node^.left<>nil then
            current_node:=current_node^.left;

          -- pokud to jde doprava, jít do pravého podstromu
          elsif current_node^.right<>nil then
            current_node:=current_node^.right;
            
          -- nejde to do podstromu, musíme se vrátit nahoru
          else
            -- jít nahoru tak dlouho, dokud se nedá odbočit doprava dolů
            while current_node<>nil loop
              -- šplháme po levé větvi a pravá větev má následníky?
              if current_node^.up<>nil and then current_node^.up^.left=current_node and then current_node^.up^.right<>nil then
                current_node:=current_node^.up^.right;
                return;
                end if;

              -- jít nahoru
              current_node:=current_node^.up;
              end loop;
            end if;

        -- inverzní prefix
        when ttwd_inv_prefix do
          -- pokud to jde doprava, jít do pravého podstromu
          if current_node^.right<>nil then
            current_node:=current_node^.right;

          -- pokud to jde doleva, jít do levého podstromu
          elsif current_node^.left<>nil then
            current_node:=current_node^.left;

          -- nejde to do podstromu, musíme se vrátit nahoru
          else
            -- jít nahoru tak dlouho, dokud se nedá odbočit doleva dolů
            while current_node<>nil loop
              -- šplháme po pravé větvi a levá větev má následníky?
              if current_node^.up<>nil and then current_node^.up^.right=current_node and then current_node^.up^.left<>nil then
                current_node:=current_node^.up^.left;
                return;
                end if;

              -- jít nahoru
              current_node:=current_node^.up;
              end loop;
            end if;

        -- postfix
        when ttwd_postfix do
          -- pokud to jde, jít doprava na stejnou úroveň a pak co nejvíce dolů
          if current_node^.up<>nil and then current_node^.up^.left=current_node and then current_node^.up^.right<>nil then
            current_node:=current_node^.up^.right;

            -- co nejvíce dolů
            loop
              if current_node^.left<>nil then current_node:=current_node^.left;
              elsif current_node^.right<>nil then current_node:=current_node^.right;
              else break;
              end if;
              end loop;

          else 
            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- inverzní postfix
        when ttwd_inv_postfix do
          -- pokud to jde, jít doleva na stejnou úroveň a pak co nejvíce dolů
          if current_node^.up<>nil and then current_node^.up^.right=current_node and then current_node^.up^.left<>nil then
            current_node:=current_node^.up^.left;

            -- co nejvíce dolů
            loop
              if current_node^.right<>nil then current_node:=current_node^.right;
              elsif current_node^.left<>nil then current_node:=current_node^.left;
              else break;
              end if;
              end loop;

          else 
            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- infix
        when ttwd_infix do
          -- když to jde doprava, tak doprava
          if current_node^.right<>nil then
            current_node:=current_node^.right;

            -- co nejvíce doleva
            while current_node^.left<>nil loop
              current_node:=current_node^.left;
              end loop;

          else
            -- jinak nahoru, nejdříve o kolik to jde po pravé větvi - vracení se, pak ještě o jednu nahoru
            while current_node^.up<>nil and then current_node^.up^.right=current_node loop
              current_node:=current_node^.up;
              end loop;

            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- inverzní infix
        when ttwd_inv_infix do
          -- když to jde doleva, tak doleva
          if current_node^.left<>nil then
            current_node:=current_node^.left;

            -- co nejvíce doprava
            while current_node^.right<>nil loop
              current_node:=current_node^.right;
              end loop;

          else
            -- jinak nahoru, nejdříve o kolik to jde po levé větvi - vracení se, pak ještě o jednu nahoru
            while current_node^.up<>nil and then current_node^.up^.left=current_node loop
              current_node:=current_node^.up;
              end loop;

            -- nahoru
            current_node:=current_node^.up;
            end if;
          end case;

      end find_next;



    ------------------------------------------------------------------------------------------------
    override get =
    -- Vrátí jeden uzel z korespondujícího stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- uzel, který má iterátor vrátit, je v current_node
      item:=current_node;

      -- výsledná hodnota - F, pokud je v [item] nil
      result:=item<>nil;

      -- pokud není co procházet, konec
      if not result then return end if;

      -- najít další uzel
      find_next;
      end get;
    
    end c_binary_tree_iterator;



----------------------------------------------------------------------------------------------------
class private c_tree_node =
-- Uzel stromu.
----------------------------------------------------------------------------------------------------
    var
      item_type    : t_tag;                      -- (root) type of its items

    ------------------------------------------------------------------------------------------------
    entry =
    -- Inicializovat seznam potomků.
    ------------------------------------------------------------------------------------------------
    begin
      down.init(item_type,true,false);
      end entry;

    end c_tree_node;



----------------------------------------------------------------------------------------------------
class private c_tree =
-- N-nární vyhledávací strom.
----------------------------------------------------------------------------------------------------

    with
      supervised c_tree_node;


    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace stromu.
    --   Pokud je [homogenous] nastaven na true, ve stromě mohou být jen uzly typu [item_type].
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud je již strom definován
      if this.root<>nil then
        -- inicializace neproběhne
        execute(event_error);
        raise tree_error;
        end if;

      -- set up basic parameters
      this.item_type:=item_type;
      this.homogenous:=homogenous;
      end init;



    ------------------------------------------------------------------------------------------------
    static get_node_count =
    -- Spočítá počet uzlů v podstromě určeném [node]
    ------------------------------------------------------------------------------------------------
    var
      child        : p_tree_node;                -- uzel

    begin
      -- započítat node
      result:=1;

      -- projít dětské uzly
      child:=node^.down.get_first;
      while child<>nil loop
        -- započítat podstromy [child]
        result+get_node_count(child);

        -- další díte
        child:=node^.down.get_next(child);
        end loop;
      end get_node_count;



    ------------------------------------------------------------------------------------------------
    static has_node_rec (
        current_node : in p_tree_node;           -- aktuální uzel
        node         : in p_tree_node)           -- hledaný uzel
        return t_logical =                       -- T-uzel nalezen
    -- Vrací logickou hodnotu, zda je uzel nalezen ve stromu.
    ------------------------------------------------------------------------------------------------
    var 
      down_node   : p_tree_node;                 -- potomek

    begin
      -- aktuální uzel musí být definovaný
      if current_node=nil then
        result:=false;
        return;
        end if;

      -- pokud se uzly shodují, vrátit true
      if current_node=node then
        result:=true;
        return;
        end if;

      -- zjistit prvního potomka
      down_node:=p_tree_node(current_node^.down.get_first);

      -- procházet potomky
      while down_node<>nil loop
        -- procházet podstrom
        result:=has_node_rec(down_node,node);

        -- pokud je uzel nalezen, konec
        if result then
          break;
          end if;
        
        -- jdi na dalšího potomka
        down_node:=current_node^.down.get_next(down_node);
        end loop;
      end has_node_rec;



    ------------------------------------------------------------------------------------------------
    static has_node =
    -- Vrací logickou hodnotu, zda je uzel nalezen ve stromu.
    --   Pokud [node]=NIL, hlásí chybu.
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud [node] není definovaný, hlásí chybu
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- hledat uzel
      result:=has_node_rec(root,node);
      end has_node;



    ------------------------------------------------------------------------------------------------
    static get_root =
    -- Vrací kořenový uzel.
    --   Pokud kořen není definován, vrací NIL.
    ------------------------------------------------------------------------------------------------
    begin
      -- vrátí root node
      result:=root;
      end get_root;



    ------------------------------------------------------------------------------------------------
    override insert =
    -- Vloží se do stromu kořen.
    ------------------------------------------------------------------------------------------------
    begin
      {%%TODO(homogenous) - vyřešit případ vkládání nehomogenních dat, kdy ve stromě smějí být pouze
                            homogenní data}

      -- pokusit se do stromu vložit uzel na místo kořenu
      insert_node(p_tree_node(item),nil,id_add);
      end insert;



    ------------------------------------------------------------------------------------------------
    static do_insert (
        node         : in p_tree_node;           -- vkládaný uzel
        current_node : in p_tree_node;           -- aktuální uzel
        direction    : in t_insert_direction)    -- pozice vložení
        return t_logical =
    -- Vloží uzel do stromu.
    -- Interní metoda, neprovádí kontroly.
    -- Vrátí, zda vložení bylo úspěšné
    ------------------------------------------------------------------------------------------------
    begin
      -- na začátku předpokládáme chybu
      result:=false;

      -- dle směru vložení:
      case direction
        -- vloží jako posledního souseda
        when id_add do
            -- pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
            if current_node=root 
              -- chyba
              then
                execute(event_error);
                raise tree_error;
              
              -- vložit uzel
              else
                current_node^.up^.down.insert_last(node);
                node^.up:=current_node^.up;
                end if;

        -- vloží jako prvního souseda
        when id_add_first do
            -- pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
            if current_node=root 
              -- chyba
              then
                execute(event_error);
                raise tree_error;
              
              -- vložit uzel
              else
                current_node^.up^.down.insert_first(node);
                node^.up:=current_node^.up;
                end if;

        -- vloží jako posledního potomka
        when id_add_child do
            current_node^.down.insert_last(node);
            node^.up:=current_node;

        -- vloží jako prvního potomka
        when id_first_child do
            current_node^.down.insert_first(node);
            node^.up:=current_node;

        -- vloží hned před referenční uzel
        when id_insert_before do
            -- pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
            if current_node=root 
              -- chyba
              then
                execute(event_error);
                raise tree_error;
              
              -- vložit uzel
              else
                current_node^.up^.down.insert_before(current_node,node);
                node^.up:=current_node^.up;
                end if;

        -- vloží hned za referenční uzel
        when id_insert_after do
            -- pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
            if current_node=root 
              -- chyba
              then
                execute(event_error);
                raise tree_error;
              
              -- vložit uzel
              else
                current_node^.up^.down.insert_after(current_node,node);
                node^.up:=current_node^.up;
                end if;
        end case;

      -- vše proběhlo OK
      result:=true;
      end do_insert;



    ------------------------------------------------------------------------------------------------
    static insert_node =
    -- Vloží uzel do stromu.
    --   Pokud [node]=NIL, hlásí chybu.
    --   Pokud [current_node] není ve stromu nalezen, hlásí chybu.
    --   Pokud [node] je ve stromu nalezen, hlásí chybu.
    --   Pokud se má uzel vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
    ------------------------------------------------------------------------------------------------
    begin
      {%%TODO(homogenous) - vyřešit případ vkládání nehomogenních dat, kdy ve stromě smějí být pouze
                            homogenní data}

      -- pokud [node]=NIL, hlásí chybu
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- má se nový uzel vložit na místo kořenu?
      if current_node=nil then
        -- ano, nastavit předky
        node^.up:=nil;

        -- pokud existuje [root], nastavit předka a vložit bývalý kořen
        if root<>nil then
          root^.up:=node;
          node^.down.insert_last(root);
          end if;

        -- nastavit nový kořen
        root:=node;

        -- zvýšit počet uzlů ve stromu
        count+get_node_count(node);
        return;
        end if;

      -- pokud [current_node] není ve stromu nalezen, hlásí chybu
      if not has_node(current_node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud [node] je ve stromu nalezen, hlásí chybu.
      if has_node(node) then
        execute(event_error);
        raise tree_error;
        end if;

    -- vlastní vložení, pokud při něm nastala chyba, konec
    if not do_insert(node,current_node,direction) then return end if;

    -- zvýšit počet uzlů ve stromu
    count+get_node_count(node);
    end insert_node;



    ------------------------------------------------------------------------------------------------
    static merge_subtree =
    -- Spojí dva stromy do jednoho. Stom [tree] reprezentuje strom přidávaných uzlů do stromu
    -- reprezentovanou instancí této třídy.
    --   Pokud připojovaný strom je prázdný, hlásí chybu.
    --   Pokud [current_node]=NIL, zkusí se vložit kořen, pokud je kořen definován, hlásí chybu.
    --   Pokud [current_node] není ve stromu nalezen, hlásí chybu.
    --   Pokud libovoný uzel v [tree] je ve stromu nalezen, hlásí chybu.
    --   Pokud se má nový strom vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu
    ------------------------------------------------------------------------------------------------
    var 
      node_found   : t_logical:=false;           -- T-uzel nalezen

    begin
      -- pokud [tree.root]=NIL, hlásí chybu
      if tree.root=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud libovoný uzel v [tree] je ve stromu nalezen, hlásí chybu
      if has_node(tree.root) or has_node_rec(tree.root,root) then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud [current_node]=NIL, zkusí se vložit kořen, pokud je kořen definován, hlásí chybu
      if current_node=nil then
        -- pokud je kořen definován, hlásí chybu
        if root<>nil then
          execute(event_error);
          raise tree_error;
          end if;

        -- vložit kořen a nastavit počet uzlů ve stromě
        root:=tree.root;
        count:=tree.count;

        -- vyprázdnit původní strom
        tree.root:=nil;
        tree.count:=0;
        return;
        end if;

      -- pokud [current_node] není ve stromu nalezen, hlásí chybu
      if not has_node(current_node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- vlastní vložení, pokud při něm nastala chyba, konec
      if not do_insert(tree.root,current_node,direction) then return end if;

      -- zvýšit počet uzlů ve stromu o tree^.count
      count+tree.count;

      -- vyprázdnit původní strom
      tree.root:=nil;
      tree.count:=0;
      end merge_subtree;



    ------------------------------------------------------------------------------------------------
    static get_count_node (
        current_node : in p_tree_node)           -- aktuální uzel
        return t_unsigned =
    -- Vrátí počet poduzlů včetně [current_node] ve stromu.
    ------------------------------------------------------------------------------------------------
    var
      down_node    : p_tree_node;                -- potomek

    begin
      -- uzel musí být definovaný
      if current_node=nil then
        result:=0;
        return;
        end if;
      
      -- uzel má váhu 1
      result:=1;

      -- zjistit prvního potomka
      down_node:=p_tree_node(current_node^.down.get_first);

      -- procházet potomky
      while down_node<>nil loop
        -- procházet podstrom
        result+get_count_node(down_node);

        -- jdi na dalšího potomka
        down_node:=current_node^.down.get_next(down_node);
        end loop;
      end get_count_node;


    
    ------------------------------------------------------------------------------------------------
    override remove =
    -- Vyjme uzel ze stromu, pokud má uzlem následníky, vyjme se celý podstrom.
    --   Pokud [item]=nil, hlásí se chyba.
    --   Pokud [item] není ve stromu nalezen, hlásí se chyba.
    ------------------------------------------------------------------------------------------------
    var 
      node         : p_tree_node;                -- uzel pro vyjmutí ze stromu

    begin
      -- přetypovat [item]
      node:=p_tree_node(item);

      -- rušený uzel musí být definovaný
      if node=nil then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud [node] není ve stromu nalezen, hlásí se chyba
      if not has_node(node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- pokud [node]=[root], smazat strom
      if node=root then
        root:=nil;
        count:=0;
        return;
        end if;

      -- korigovat počet uzlů ve stromu
      count-get_count_node(node);
      
      -- vyjmout uzel
      node^.up^.down.remove(node);
      end remove;



    ------------------------------------------------------------------------------------------------
    static split_subtree =
    -- Vyjme ze stromu podstrom včetně uzlu [node] a vytvoří a inicializuje novou instance 
    -- trídy [c_tree]. 
    --   Pokud uzel není nalezen, hlásí chybu.
    ------------------------------------------------------------------------------------------------
    var
      lnode        : p_tree_node;                -- kořen nového stromu

    begin
      -- kořen podstromu/stromu
      lnode:=node;

      -- pokud není [lnode] ve stromu nalezen, hlásí chybu
      if not has_node(lnode) then
        execute(event_error);
        return;
        end if;

      -- má se vyjmout kořen?
      if lnode^.up=nil 
        -- ano, zrušit [root]
        then
          root:=nil;

        -- ne, vyjmout podstrom
        else
          lnode^.up^.down.remove(node);
          end if;

      -- nastavit předka odpojeného podstromu
      lnode^.up:=nil;

      -- nastavit počet uzlů ve stromu
      subtree.count:=get_count_node(lnode);
      count-subtree.count;

      -- nastavit kořen nového stromu
      subtree.root:=lnode;
      end split_subtree;



    ------------------------------------------------------------------------------------------------
    override delete =
    -- Smaže uzel ze stromu včetně potomků a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    var
      lnode        : p_tree_node;                -- [node]
      down_node    : p_tree_node;                -- potomek

    begin
      -- lokální node
      lnode:=item;

      -- pokud [node] není definován, ukonči rekurzi
      if lnode=nil then 
        return;
        end if;

      -- zjistit prvního potomka
      down_node:=p_tree_node(lnode^.down.get_first);

      -- procházet potomky
      while down_node<>nil loop
        -- procházet podstrom
        delete(down_node);

        -- jdi na prvního potomka
        down_node:=lnode^.down.get_first;
        end loop;

      -- vyjmout uzel
      remove(lnode);

      -- uvolnit uzel z paměti
      discard lnode;

      -- vynulování uvolněného ukazatele
      item:=nil;
      end delete;



    ------------------------------------------------------------------------------------------------
    override delete_all =
    -- Smaže všechny uzly ze stromu a uvolní pamět.
    ------------------------------------------------------------------------------------------------
    begin
      -- smazat celý strom
      delete(root);
      end delete_all;



    ------------------------------------------------------------------------------------------------
    static move_subtree =
    -- Přesune podstrom z jednoho místa na jiné místo v tom samém stromu.
    --   Pokud [node]=NIL, hlásí chybu.
    --   Pokud [node] není ve stromu nalezen, hlásí chybu.
    --   Pokud [current_node] není ve stromu nalezen, hlásí chybu.
    --   Pokud se má uzel vložit vedle kořenového uzlu a má potomky, hlásí chybu.
    --   Pokud [current_node] je poduzlem [node], hlásí chybu.
    --   Pokud se má uzel podstromu vložit jako sousední uzel, ale [current_node]=[root], hlásí chybu.
    ------------------------------------------------------------------------------------------------
    var
      sub          : p_tree;                     -- podstrom, pomocná instance
        
    begin
      -- vytvořit pomocnou instanci
      new sub;

      -- [current_node] je obsaženo v přesouvaném podstromě [node] => chyba
      if has_node_rec(node,current_node) then
        execute(event_error);
        raise tree_error;
        end if;

      -- rozdělit na dva podstromy
      split_subtree(node,sub^);

      -- dočasný podstrom vložit na požadované místo
      merge_subtree(sub^,current_node,direction);

    leave
      -- uvolnit dočasný podstrom
      discard sub;
      end move_subtree;

    end c_tree;



----------------------------------------------------------------------------------------------------
class private c_tree_iterator = 
-- Iterator.
----------------------------------------------------------------------------------------------------

    with
      supervised c_tree_node;

    var 
      direction    : t_tree_walking_direction;   -- řízení iterace
      tree         : p_tree;                     -- subjekt iterace
      current_node : p_tree_node;                -- aktuální uzel

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializuje iterator používaný pro průchod stromem.
    ------------------------------------------------------------------------------------------------   
    begin
      -- inicializece řídících proměnných
      this.direction:=direction;
      this.tree:=^tree;

      -- chybný směr procházení
      if direction not in t_tree_walking_direction_set:[ttwd_prefix,ttwd_inv_prefix,ttwd_postfix,ttwd_inv_postfix] then
        raise tree_error;
        end if;

      -- resetování
      reset;
      end init;



    ------------------------------------------------------------------------------------------------
    override reset =
    -- Resetuje iterator do stavu po inicializaci.
    ------------------------------------------------------------------------------------------------
    begin
      -- dočasné nastavení [current_node]
      current_node:=tree^.get_root;

      -- strom je prázdný
      if current_node=nil then return end if;

      case direction
        -- prefix
        when ttwd_prefix do 
          -- nic nedělat - kořen je první

        -- inverzní prefix
        when ttwd_inv_prefix do 
          -- nic nedělat - kořen je první

        -- postfix
        when ttwd_postfix do 
          -- najít potomka
          loop
            -- sejít dolů, při rozhodování se vydat vždy nejlevější cestou
            if current_node^.down.get_first<>nil then 
              current_node:=current_node^.down.get_first;
            else
              break;
              end if;
            end loop;

        -- inverzní postfix
        when ttwd_inv_postfix do 
          -- najít potomka
          loop
            -- sejít dolů, při rozhodování se vydat vždy nejpravější cestou
            if current_node^.down.get_last<>nil then 
              current_node:=current_node^.down.get_last;
            else
              break;
              end if;
            end loop;

        when others do raise feature_not_implemented;
        -- %%TODO(LIB) ttwd_infix;                                -- levý -> uzel -> pravý, jen pro binární strom
        -- %%TODO(LIB) ttwd_inv_infix;                            -- pravý -> uzel -> levý, jen pro binární strom
        end case;
      end reset;


    ------------------------------------------------------------------------------------------------
    static find_next =
    -- Do [current_node] uloží další procházený uzel
    -- Předpokládá [current_node]<>nil
    ------------------------------------------------------------------------------------------------
    begin
      -- určit směr procházení
      case direction
        -- prefix
        when ttwd_prefix do
          -- pokud to jde, jdeme dolů co nejvíce doleva
          if current_node^.down.get_first<>nil then
            current_node:=current_node^.down.get_first;

          -- nejde to do podstromu, musíme se vrátit nahoru
          else
            -- jít nahoru tak dlouho, dokud se nedá odbočit doprava dolů
            while current_node<>nil loop
              -- šplháme po levé větvi a pravá větev má následníky?
              if current_node^.up<>nil and then current_node^.up^.down.get_next(current_node)<>nil then
                current_node:=current_node^.up^.down.get_next(current_node);
                return;
                end if;

              -- jít nahoru
              current_node:=current_node^.up;
              end loop;
            end if;

        -- inverzní prefix
        when ttwd_inv_prefix do
          -- pokud to jde, jdeme dolů co nejvíce doprava
          if current_node^.down.get_last<>nil then
            current_node:=current_node^.down.get_last;

          -- nejde to do podstromu, musíme se vrátit nahoru
          else
            -- jít nahoru tak dlouho, dokud se nedá odbočit doleva dolů
            while current_node<>nil loop
              -- šplháme po levé větvi a pravá větev má předchůdce?
              if current_node^.up<>nil and then current_node^.up^.down.get_prev(current_node)<>nil then
                current_node:=current_node^.up^.down.get_prev(current_node);
                return;
                end if;

              -- jít nahoru
              current_node:=current_node^.up;
              end loop;
            end if;

        -- postfix
        when ttwd_postfix do
          -- pokud to jde, jít doprava na stejnou úroveň a pak co nejvíce dolů
          if current_node^.up<>nil and then current_node^.up^.down.get_next(current_node)<>nil then
            current_node:=current_node^.up^.down.get_next(current_node);

            -- co nejvíce dolů
            loop
              -- sejít dolů, při rozhodování se vydat vždy nejlevější cestou
              if current_node^.down.get_first<>nil then 
                current_node:=current_node^.down.get_first;
              else break;
                end if;
              end loop;

          else 
            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- inverzní postfix
        when ttwd_inv_postfix do
          -- pokud to jde, jít dolevana stejnou úroveň a pak co nejvíce dolů
          if current_node^.up<>nil and then current_node^.up^.down.get_prev(current_node)<>nil then
            current_node:=current_node^.up^.down.get_prev(current_node);

            -- co nejvíce dolů
            loop
              -- sejít dolů, při rozhodování se vydat vždy nejpravější cestou
              if current_node^.down.get_last<>nil then 
                current_node:=current_node^.down.get_last;
              else break;
                end if;
              end loop;

          else 
            -- nahoru
            current_node:=current_node^.up;
            end if;

        -- %%TODO(LIB)
        when others do raise feature_not_implemented;
        end case;
      end find_next;



    ------------------------------------------------------------------------------------------------
    override get =
    -- Vrátí jeden uzel z korespondujícího stromu.
    ------------------------------------------------------------------------------------------------
    begin
      -- uzel, který má iterátor vrátit, je v current_node
      item:=current_node;

      -- výsledná hodnota - F, pokud je v [item] nil
      result:=item<>nil;

      -- pokud není co procházet, konec
      if not result then return end if;

      -- najít další uzel
      find_next;
      end get;
 
    end c_tree_iterator;

end trees;


