----------------------------------------------------------------------------------------------------
module private names =
-- Object names.
-- Flex Standard Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
-- To do:
--   -- add suport for quotes in file names
--   -- change the silly implementation of [c_name.join] into clone & join of the [components] lists
----------------------------------------------------------------------------------------------------

with
  standard.classes,
  standard.classes.lists,
  standard.strings;

----- Generic mechanisms for manipulation with names in a context of a namespace -------------------

----------------------------------------------------------------------------------------------------
class {%%TODO(ABSTRACT) abstract} private c_namespace =
-- Zaklad pro odvozeni konkretniho namespace.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    virtual check_name =
    -- Check if the given plain-text name [text_name] is a valid name in this namespace. When the
    -- name is a valid name, [valid] is set to [true], otherwise it is set to [false].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented
      end check_name;



    ------------------------------------------------------------------------------------------------
    virtual decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of components [components]
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    virtual compose_name =
    -- Composes a plain-text name [text_name] from a list of components [components]. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented
      end compose_name;

    end c_namespace;



----------------------------------------------------------------------------------------------------
class {%%TODO(ABSTRACT) abstract} private c_name_component =
-- A single component of a name.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    virtual decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of subcomponents [subcomponents]
    ------------------------------------------------------------------------------------------------
    var
      base_name    : p_name_subcomponent_base_name; -- base name of a component

    begin
      -- by defalult, the name is composed of one component only - a base name
      new base_name;
      base_name^.set_name(text_name);
      subcomponents.insert(base_name);
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    virtual compose_name =
    -- Composes a plain-text name [text_name] from a list of subcomponents of this component. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    var
      base_name    : p_name_subcomponent_base_name; -- base name of a component

    begin
      -- by default, return the base name
      subcomponents.set_first(p_list_item(base_name));
      new text_name range base_name^.name^:length;
      text_name^:=base_name^.name^;
      end compose_name;



    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalization
    ------------------------------------------------------------------------------------------------
    begin
      subcomponents.delete_all;
      end exit;

    end c_name_component;



----------------------------------------------------------------------------------------------------
class {%%TODO(ABSTRACT) abstract} private c_name_subcomponent =
-- A single subcomponent of a name's component.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static set_name =
    -- Assigns a plain-text name of this subcomponent.
    ------------------------------------------------------------------------------------------------
    begin
      -- discard the existing name, if any
      discard name;

      -- set a new name
      new name range text_name:length;
      name^:=text_name;
      end set_name;



    ------------------------------------------------------------------------------------------------
    exit =
    ------------------------------------------------------------------------------------------------
    begin
      discard name;
      end exit;

    end c_name_subcomponent;



----------------------------------------------------------------------------------------------------
class private c_name =
-- A name split into a list of components.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of components [components]
    ------------------------------------------------------------------------------------------------
    var
      valid        : t_logical;                  -- [true] if the name is a valid name in the given 
                                                 -- namespace
      system_ns    : c_namespace_system;

    begin
    { %%TODO(LIB)
      -- try to figure-out the right namespace

    }
      -- decompose the name
      system_ns.check_name(text_name,name_type,valid);
      if valid
        then system_ns.decompose_name(text_name,name_type,this.name_type,components,ns_data);
        else raise name_error;
        end if;
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    static compose_name =
    -- Composes a plain-text name [text_name] from a list of components [components]. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    var
      system_ns    : c_namespace_system;

    begin
    { %%TODO(LIB)
      -- compose the name in context of the same namespace as used for decomposition
    }
      system_ns.compose_name(components,ns_data,text_name);
      end compose_name;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Joins a prefix and a suffix into this name. 
    ------------------------------------------------------------------------------------------------
    var
      prefix_name  : p_text_name;
      suffix_name  : p_text_name;
      full_name    : p_text_name;

    begin
      prefix.compose_name(prefix_name);
      suffix.compose_name(suffix_name);
      new full_name range prefix_name^:length+suffix_name^:length+1;
      full_name^:=prefix_name^;
      if full_name^<>'' and then full_name^[full_name^:length]<>"\" then
        full_name^ & "\";
        end if;
      full_name^ & suffix_name^;    
      decompose_name(full_name^,tnt_unspecified);
    leave
      discard prefix_name;
      discard suffix_name;
      discard full_name;
      end join;



    ------------------------------------------------------------------------------------------------
    static join_before =
    -- Prepends a prefix before this name. This name must be a relative name.
    ------------------------------------------------------------------------------------------------
    var
      x_prefix     : c_name;                     -- temporary copy of the prefix
      text_name    : p_text_name;                -- plain-text name of the prefix
      component    : p_name_component;           -- component being copied from the prefix to this name

    begin 
      -- make a copy of the prefix
      begin
        prefix.compose_name(text_name);
        x_prefix.decompose_name(text_name^,tnt_unspecified);
      leave
        discard text_name;
        end;

      -- prepend it to the beginnig of this name
      loop
        -- remove the first component from the temporary suffix
        component:=x_prefix.components.remove_last;
        if component=nil then break; end if;

        -- insert it at the end of this name
        components.insert_first(component);
        end loop;
      end join_before;



    ------------------------------------------------------------------------------------------------
    static join_after =
    -- Appends a suffix to this name. The [suffix] must be a relative name.
    ------------------------------------------------------------------------------------------------
    var
      x_suffix     : c_name;                     -- temporary copy of the suffix
      text_name    : p_text_name;                -- plain-text name of the suffic
      component    : p_name_component;           -- component being copied from the suffix to this name

    begin 
      -- make a copy of the suffix
      begin
        suffix.compose_name(text_name);
        x_suffix.decompose_name(text_name^,tnt_relative);
      leave
        discard text_name;
        end;

      -- append it to the end of this name
      loop
        -- remove the first component from the temporary suffix
        component:=x_suffix.components.remove_first;
        if component=nil then break; end if;

        -- insert it at the end of this name
        components.insert(component);
        end loop;
      end join_after;



    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalization
    ------------------------------------------------------------------------------------------------
    begin
      components.delete_all;
      discard ns_data;
      end exit;

    end c_name;



----------------------------------------------------------------------------------------------------
class private c_names =
-- A collection of names.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    entry =
    -- Initialization
    ------------------------------------------------------------------------------------------------
    begin
      init(c_name:tag,false,false);
      end entry;

    end c_names;



----------------------------------------------------------------------------------------------------
procedure register_namespace =
-- Registers a new namespace.
--
-- Remarks:
--   The system namespace ([c_namespace_system]) is registered by default.
----------------------------------------------------------------------------------------------------
begin
  -- %%TODO(LIB)
{
  -- check if it is an ancestor of c_namespace
  if not (namspace>c_namespace:tag) then
    ...
    end if;

  -- add to the list of registered namespaces
  namespaces.insert(...);
}
  end register_namespace;



----- Implementation of a system native namespace --------------------------------------------------

----------------------------------------------------------------------------------------------------
class private c_namespace_system =
-- This platform's native namespace.
----------------------------------------------------------------------------------------------------

    type
      -- internal differentiation between types of names
      t_system_name_type = enum
          tsnt_empty;                            -- an empty name
          tsnt_absolute_unc;                     -- an UNC name in the form "\\server\share\path"
          tsnt_absolute_local;                   -- a local absolute name in the form "c:\path"
          tsnt_root_relative;                    -- a root-relative name in the form "\path"
          tsnt_relative;                         -- a relative name in the form "path"
          end enum;

      -- system-namespace specific data
      t_namespace_specific_system = t_namespace_specific with record
          name_type: t_system_name_type;
          end record;
      p_namespace_specific_system = ^class t_namespace_specific_system;

    ------------------------------------------------------------------------------------------------
    override check_name =
    -- Check if the given plain-text name [text_name] is a valid name in this namespace. When the
    -- name is a valid name, [valid] is set to [true], otherwise it is set to [false].
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure check_for_valid_characters (
            from   : in t_unsigned)              -- starting index into [text_name] from which to check
            return t_logical =
        -- Checks if the name contains only valid characters
        --------------------------------------------------------------------------------------------
        begin
          for i in from..text_name:length loop
            -- the invalid characters within a name are >, <, :, " and |
            -- more precisely, \ and / are also invalid characters, but in this stage, we do not
            -- distinguish between a full path and a file name
            if {%%TODO(SET)text_name[i] in [">","<",":",""","|"]} text_name[i]=">" or text_name[i]="<" or text_name[i]=":" or text_name[i]=""" or text_name[i]="|" then
              result:=false;
              end if;
            end loop;
          result:=true;
          end check_for_valid_characters;

    begin
      -- empty name always matches
      if text_name='' then
        valid:=true;
        return;
        end if;

      -- possibly a UNC name
      if name_type in t_name_type_set:[tnt_absolute,tnt_unspecified] and then {%%TODO(SLICE)text_name[1..2]='\\'} text_name:length>=4 and then (text_name[1]="\" and text_name[2]="\") then
      {%%TODO(SLICE) %%TODO(LIB)
        -- it could be a "long" UNC name
        if text_name[1..8]='\\?\UNC\' then
          ...
          end if;
      }
        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        valid:=check_for_valid_characters(3);

      -- possibly a "c:\file.ext" name
      elsif name_type in t_name_type_set:[tnt_absolute,tnt_unspecified] and then text_name:length>=2 
      and then (((text_name[1]>="a" and text_name[1]<="z") or (text_name[1]>="A" and text_name[1]<="Z")) {%%TODO(SET)text_name[1] in ["a".."z","A".."Z"]} and text_name[2]=":") then
        -- the third character shall be a backslash
        if text_name:length>=3 and then text_name[3]<>"\" then  
          valid:=false;
          return;
          end if;

        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        valid:=check_for_valid_characters(4);

      -- possibly a relative name 
      elsif name_type in t_name_type_set:[tnt_relative,tnt_unspecified] then
        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        valid:=check_for_valid_characters(1);

      -- definitely an invalid name
      else
        valid:=false;
        end if;
      end check_name;



    ------------------------------------------------------------------------------------------------
    override decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of components [components]
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure separate_component_name (
            start  : in out t_unsigned;          -- actual position in [text_name]
            name   : out p_text_name;            -- separated subcomponent name
            is_folder : out t_logical) =         -- [true] if the subcomponent represents a folder 
                                                 -- for sure
        -- Separates the name of a subcomponent starting at position [start] from the [text_name].
        --------------------------------------------------------------------------------------------
        var
          stop     : t_unsigned;

        begin
          -- find the end of the name
          stop:=start;
          while stop<=text_name:length and then {%%TODO(SLICE)text_name[stop] not in ["\","/"]} (text_name[stop]<>"\" and text_name[stop]<>"/") loop
            succ stop;
            end loop;

          -- copy it
          new name range stop-start;
          for i in start..stop-1 loop
            name^ & text_name[i];
            end loop;

          -- decide if it is a folder name for sure
          is_folder:=stop<=text_name:length or name^='.' or name^='..';

          -- update the [start] position
          start:=stop+1;
          end separate_component_name;



        --------------------------------------------------------------------------------------------
        procedure parse_rest_of_name (
            initial : in t_unsigned) =           -- initial position for parsing
        -- Parses the rest of the name starting with position [initial].
        --------------------------------------------------------------------------------------------
        var
          folder   : p_name_component_folder;    -- folder component
          file_or_folder : p_name_component_file_or_folder; -- file or folder component
          name     : p_text_name;                -- name of a single component
          start    : t_unsigned;                 -- actual position in [text_name]
          is_folder: t_logical;                  -- [true] if the subcomponent represents a folder 
                                                 -- for sure
        begin
          start:=initial;
          while start<=text_name:length loop
            begin
              -- separate the name of a folder or file
              separate_component_name(start,name,is_folder);

              -- create a component
              if is_folder

                -- it is a folder for sure
                then
                  new folder;
                  folder^.decompose_name(name^);
                  components.insert(folder);

                -- it can be either a folder or a file
                else
                  new file_or_folder;
                  file_or_folder^.decompose_name(name^);
                  components.insert(file_or_folder);
                  end if;
            leave
              -- free the plain-text name
              discard name;
              end;
            end loop;
          end parse_rest_of_name;

    var
      server       : p_name_component_server;    -- server component
      drive        : p_name_component_drive;     -- drive component
      name         : p_text_name;                -- name of a single component
      start        : t_unsigned;                 -- actual position in [text_name]
      is_folder    : t_logical;                  -- [true] if the subcomponent represents a folder 
                                                 -- for sure

    begin
      -- prepare namespace specific data
      new p_namespace_specific_system(ns_data);

      -- empty name - no decomposition possible
      if text_name='' then
        return;
        end if;

      -- possibly a UNC name
      if proposed_nt in t_name_type_set:[tnt_absolute,tnt_unspecified] and then {%%TODO(SLICE)text_name[1..2]='\\'} text_name:length>=4 and then (text_name[1]="\" and text_name[2]="\") then
      {%%TODO(SLICE) %%TODO(LIB)
        -- it could be a "long" UNC name
        if text_name[1..8]='\\?\UNC\' then
          ...
          end if;
      }                                                        
        {%%TODO(DECLARE) server, drive, start, name, is_folder }

        -- remember the type of the name
        p_namespace_specific_system(ns_data)^.name_type:=tsnt_absolute_unc;
        
        -- set the detected name type to an absolute name
        detected_nt:=tnt_absolute;

        -- the first component of a name is a server
        start:=3;
        separate_component_name(start,name,is_folder);
        new server;
        server^.decompose_name(name^);
        components.insert(server);
        discard name;

        -- the second component of a name is a share
        separate_component_name(start,name,is_folder);
        new server;
        server^.decompose_name(name^);
        components.insert(server);
        discard name;

        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        parse_rest_of_name(start);

      -- possibly a "c:\file.ext" name
      elsif proposed_nt in t_name_type_set:[tnt_absolute,tnt_unspecified] and then text_name:length>=2 
      and then (((text_name[1]>="a" and text_name[1]<="z") or (text_name[1]>="A" and text_name[1]<="Z")) {%%TODO(SET)text_name[1] in ["a".."z","A".."Z"]} and text_name[2]=":") then
        -- the third character shall be a backslash
        if text_name:length>=3 and then text_name[3]<>"\" then  
          -- %%FLEX signal an error !
          return;
          end if;

        -- remember the type of the name
        p_namespace_specific_system(ns_data)^.name_type:=tsnt_absolute_local;
        
        -- set the detected name type to an absolute name
        detected_nt:=tnt_absolute;

        -- the first component of a name is a drive
        {%%TODO(DECLARE) drive, name }
        new name range 1;
        name^ & text_name[1];
        new drive;
        drive^.decompose_name(name^);
        components.insert(drive);
        discard name;

        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes
        parse_rest_of_name(4);
        
      -- possibly a relative name 
      elsif proposed_nt in t_name_type_set:[tnt_relative,tnt_unspecified] then
        -- remember the type of the name
        if {%%TODO(SET) text_name[1] in ["\","/"]} text_name[1]="\" or text_name[1]="/"
          then p_namespace_specific_system(ns_data)^.name_type:=tsnt_root_relative;
          else p_namespace_specific_system(ns_data)^.name_type:=tsnt_relative;
          end if;
        
        -- set the detected name type to a relative name
        detected_nt:=tnt_relative;

        -- the rest of the file name shall be a list of folder/file names separated by (back)slashes       
        parse_rest_of_name(1);

      -- definitely an invalid name
      else
        -- %%FLEX signal an error !
        return;
        end if;

    leave
      -- discard any unfreed memory
      discard name;
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    override compose_name =
    -- Composes a plain-text name [text_name] from a list of components [components]. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure append_name_component (
            component : in t_text_name) =
        -- Appends the name of a component to the full plain-text name.
        --------------------------------------------------------------------------------------------
        var
          _text_name : p_text_name;

        begin
          -- reallocate memory
          if text_name=nil
            then new text_name range component:length
            else
              -- %%TODO(ADJUST) adjust text_name range text_name^:length+component:length;
              new _text_name range text_name^:length+component:length;
              _text_name^:=text_name^;
              discard text_name;
              text_name:=_text_name;
              end if;

          -- append the component's name
          text_name^ & component;
          end append_name_component; 



        --------------------------------------------------------------------------------------------
        procedure append_rest_of_path (
            first_file_or_folder : in p_name_component_file_or_folder) =
        -- Appends the rest of the path beginning with [file_or_folder].
        --------------------------------------------------------------------------------------------
        var
          text_name : p_text_name;               -- a plain-text name of a component
          file_or_folder : p_name_component_file_or_folder; -- the file or folder actually being processed

        begin
          file_or_folder:=first_file_or_folder;
          while file_or_folder<>nil loop
            -- append the name of this file or folder
            begin
              file_or_folder^.compose_name(text_name);
              append_name_component(text_name^);
            leave
              discard text_name;
              end;

            -- get next entry
            components.set_next(p_list_item(file_or_folder));

            -- don't forget the separating backslash
            if file_or_folder<>nil then
              append_name_component('\');
              end if;
            end loop;
          end append_rest_of_path;

    var
      server       : p_name_component_server;    -- the server component
      share        : p_name_component_drive;     -- the share component
      drive        : p_name_component_drive;     -- the drive component
      component_name : p_text_name;              -- a plain-text name of a component

    begin
      case p_namespace_specific_system(ns_data)^.name_type
        -- an empty name
        when tsnt_empty do new text_name range {%%FLEX 0 => Constant out of range}1;

        -- an UNC name in the form "\\server\share\path"
        when tsnt_absolute_unc do
            -- append the server name
            begin
              server:=components.get_first;
              server^.compose_name(component_name);
              append_name_component('\\');
              append_name_component(component_name^);
            leave
              discard component_name;
              end;

            -- append the share name
            begin
              share:=components.get_next(server);
              share^.compose_name(component_name);
              append_name_component('\');
              append_name_component(component_name^);
            leave
              discard component_name;
              end;

            -- append the rest of the path
            append_name_component('\');
            append_rest_of_path(components.get_next(share));

        -- a local absolute name in the form "c:\path"
        when tsnt_absolute_local do
            -- append the drive name
            begin
              drive:=components.get_first;
              drive^.compose_name(component_name);
              append_name_component(component_name^);
              append_name_component(':\');
            leave
              discard component_name;
              end;

            -- append the rest of the path
            append_rest_of_path(components.get_next(drive));

        -- a root-relative name in the form "\path"
        when tsnt_root_relative do
            -- append the rest of the path
            append_name_component('\');
            append_rest_of_path(components.get_first);

        -- a relative name in the form "path"
        when tsnt_relative do
            -- append the rest of the path
            append_rest_of_path(components.get_first);
        end case;
      
      -- prepare iterator
      --iterator.init(this,
      end compose_name;

    end c_namespace_system;



----------------------------------------------------------------------------------------------------
class private c_name_component_server =
-- Name of a server.
----------------------------------------------------------------------------------------------------

    end c_name_component_server;



----------------------------------------------------------------------------------------------------
class private c_name_component_drive =
-- Name of a drive (or a "share" or a "volume" in some naming conventions) within a server.
----------------------------------------------------------------------------------------------------
    
    end c_name_component_drive;



----------------------------------------------------------------------------------------------------
class private c_name_component_file_or_folder =
-- Name of a folder or a file.
----------------------------------------------------------------------------------------------------
    
    ------------------------------------------------------------------------------------------------
    static get_base_name =
    -- Retrieves the base name of a file or folder name.
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------
    var
      base_name_subcomponent : p_name_subcomponent_base_name;

    begin
      subcomponents.set_first(p_list_item(base_name_subcomponent));
      new base_name range base_name_subcomponent^.name^:length;
      base_name^:=base_name_subcomponent^.name^;
      #if #declared tomash;; #and then; tomash then;
        #warning 'README';
        {
          Mˆla by se pou‘¡t metoda [compose_name] prvn¡ subkomponenty m¡sto ru‡n¡ho skl d n¡ jm‚na.
        }
      #end if;
      end get_base_name;



    ------------------------------------------------------------------------------------------------
    static check_last_extension =
    -- Checks if the last extension of the name is equal to the given extension.
    ------------------------------------------------------------------------------------------------
    var
      ext          : p_name_subcomponent_extension; -- extension

    begin
      -- if there are any extensions in the name...
      if subcomponents.count>1 then
        -- retrieve the last
        ext:=subcomponents.get_last;

        -- and compare with the given extension
        result:=str_compare_case_insensitive(ext^.name^,extension);
        end if;
      end check_last_extension;



    ------------------------------------------------------------------------------------------------
    static replace_last_extension =
    -- Replaces the last extension of the name with the given extension.
    ------------------------------------------------------------------------------------------------
    var
      ext          : p_name_subcomponent_extension; -- extension

    begin
      -- if there are any extensions in the name...
      if subcomponents.count>1 then
        -- retrieve the last
        ext:=subcomponents.get_last;

        -- replace it with the value
        ext^.set_name(extension);
        end if;
      end replace_last_extension;



    ------------------------------------------------------------------------------------------------
    static append_extension =
    -- Appends the given extension to the name.
    ------------------------------------------------------------------------------------------------
    var
      ext          : p_name_subcomponent_extension; -- extension

    begin
      -- create a subcomponent
      new ext;
      ext^.set_name(extension);
      subcomponents.insert(ext);
      end append_extension;



    ------------------------------------------------------------------------------------------------
    override decompose_name =
    -- Decomposes a plain-text name [text_name] into a list of subcomponents [subcomponents]
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure separate_subcomponent_name (
            start  : in out t_unsigned;          -- actual position in [text_name]
            name   : out p_text_name) =          -- separated subcomponent name
        -- Separates the name of a subcomponent starting at position [start] from the [text_name].
        --------------------------------------------------------------------------------------------
        var
          stop     : t_unsigned;

        begin
          -- find the end of the name
          stop:=start;
          while stop<=text_name:length and then text_name[stop]<>"." loop
            succ stop;
            end loop;

          -- copy it
          new name range stop-start;
          for i in start..stop-1 loop
            name^ & text_name[i];
            end loop;

          -- update the [start] position
          start:=stop+1;
          end separate_subcomponent_name;

    var
      base_name    : p_name_subcomponent_base_name; -- base name
      extension    : p_name_subcomponent_extension; -- extension
      name         : p_text_name;                -- plain-text name of a single subcomponent
      start        : t_unsigned;                 -- actual position in [text_name]

    begin
      -- there are two special cases of folder names: '.' and '..' => handle them separately
      if text_name='.' or text_name='..' then
        new base_name;
        base_name^.set_name(text_name);
        subcomponents.insert(base_name);
        return;
        end if;

      -- start from the beginning of the name
      start:=1;

      -- separate the base name
      separate_subcomponent_name(start,name);

      -- create a subcomponent
      new base_name;
      base_name^.set_name(name^);
      subcomponents.insert(base_name);

      -- free the plain-text name
      discard name;

      -- separate all extensions
      while start<=text_name:length loop
        -- separate one extension
        separate_subcomponent_name(start,name);

        -- create a subcomponent
        new extension;
        extension^.set_name(name^);
        subcomponents.insert(extension);

        -- free the plain-text name
        discard name;
        end loop;
      end decompose_name;



    ------------------------------------------------------------------------------------------------
    override compose_name =
    -- Composes a plain-text name [text_name] from a list of subcomponents of this component. 
    --   The caller is responsible for freeing the memory.
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure append_name_subcomponent (
            subcomponent : in t_text_name) =
        -- Appends s name of a subcomponent to the full plain-text name of the component.
        --------------------------------------------------------------------------------------------
        var
          _text_name : p_text_name;

        begin
          -- reallocate memory
          if text_name=nil
            then new text_name range subcomponent:length
            else
              -- %%TODO(ADJUST) adjust text_name range text_name^:length+subcomponent:length;
              new _text_name range text_name^:length+subcomponent:length;
              _text_name^:=text_name^;
              discard text_name;
              text_name:=_text_name;
              end if;

          -- append the subcomponent's name
          text_name^ & subcomponent;
          end append_name_subcomponent; 

    var
      base_name    : p_name_subcomponent_base_name; -- base name of a component
      extension    : p_name_subcomponent_extension; -- extension

    begin
      -- retrieve the base name
      subcomponents.set_first(p_list_item(base_name));
      append_name_subcomponent(base_name^.name^);

      -- append all extensions
      extension:=subcomponents.get_next(base_name);
      while extension<>nil loop
        -- append the extension to the full plain-text name
        append_name_subcomponent('.');
        append_name_subcomponent(extension^.name^);
        
        -- retrieve next extension
        subcomponents.set_next(p_list_item(extension));
        end loop;
      end compose_name;

    end c_name_component_file_or_folder;



----------------------------------------------------------------------------------------------------
class private c_name_component_file =
-- Name of a file.
----------------------------------------------------------------------------------------------------
    
    end c_name_component_file;



----------------------------------------------------------------------------------------------------
class private c_name_component_folder =
-- Name of a folder.
----------------------------------------------------------------------------------------------------
    
    end c_name_component_folder;



----------------------------------------------------------------------------------------------------
class private c_name_subcomponent_base_name =
-- Base part of a name.
----------------------------------------------------------------------------------------------------
    
    end c_name_subcomponent_base_name;



----------------------------------------------------------------------------------------------------
class private c_name_subcomponent_extension =
-- Extension of a name.
----------------------------------------------------------------------------------------------------
    
    end c_name_subcomponent_extension;



----------------------------------------------------------------------------------------------------
entry =
-- Initialization.
----------------------------------------------------------------------------------------------------
begin
  -- register the system namespace
  register_namespace(c_namespace_system:tag);
  end entry;



end names;