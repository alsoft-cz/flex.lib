----------------------------------------------------------------------------------------------------
module private console =
-- Console I/O.
-- Flex Standard Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------

with
  standard.input,
  standard.characters,
  standard.characters.unicode;

use
  system,
  system.windows,
  system.windows.windef,
  system.windows.winbase,
  system.windows.wincon;
  

var
  -- handle to standard input and output
  stdin        : system.windows.windef.tsys_handle;
  stdout       : system.windows.windef.tsys_handle;
  stderr       : system.windows.windef.tsys_handle;

  stdout_redirected : t_logical;                 -- [true] if the standard output is redirected

message
  input_error;     -- exception to raise when an input error occurs


----------------------------------------------------------------------------------------------------
class c_console_input_queue;
type p_console_input_queue = ^class c_console_input_queue;
class c_console_input_queue = extend c_input_queue;
----------------------------------------------------------------------------------------------------
    
    
    -- %% Temporary use
    ------------------------------------------------------------------------------------------------
    procedure sys_ctrl_key_state_to_key_modifiers_mask (
      sys_var      : in system.windows.windef.tsys_dword;
      flex_var     : out t_key_modifier_mask)=
    -- converts dword into t_modifiers_key_mask
    ------------------------------------------------------------------------------------------------
    begin
      if (sys_var and system.windows.wincon.left_alt_pressed)=system.windows.wincon.left_alt_pressed
          then flex_var + t_key_modifier_mask:[tkm_alt] end if;
      if (sys_var and system.windows.wincon.right_alt_pressed)=system.windows.wincon.right_alt_pressed
          then flex_var + t_key_modifier_mask:[tkm_altgr] end if;
      if (sys_var and system.windows.wincon.shift_pressed)=system.windows.wincon.shift_pressed
          then flex_var + t_key_modifier_mask:[tkm_left_shift] end if;
      if (sys_var and system.windows.wincon.shift_pressed)=system.windows.wincon.shift_pressed then
        flex_var + t_key_modifier_mask:[tkm_rigth_shift] + t_key_modifier_mask:[tkm_left_shift] end if;
      if (sys_var and system.windows.wincon.left_ctrl_pressed)=system.windows.wincon.left_ctrl_pressed
          then flex_var + t_key_modifier_mask:[tkm_left_control] end if;
      if (sys_var and system.windows.wincon.right_ctrl_pressed)=system.windows.wincon.right_ctrl_pressed 
          then flex_var + t_key_modifier_mask:[tkm_right_control] end if;
      end sys_ctrl_key_state_to_key_modifiers_mask;

    

    ------------------------------------------------------------------------------------------------
    override fill_queue = 
    -- Overriden method that fills console input queue
    ------------------------------------------------------------------------------------------------
    var 
      input_record : system.windows.wincon.tsys_input_record0;      
      sys_count    : system.windows.windef.tsys_dword;
      kbd_event    : p_keyboard_event;
      key_input_record : system.windows.wincon.tsys_key_event_record;
        
    begin
      -- check for event in console input buffer
      error:=not system.windows.wincon.peekconsoleinput(stdin,input_record,1,sys_count);
      if error or sys_count=0 then return; end if;

      -- get the console input event
      error:=not system.windows.wincon.readconsoleinput(stdin,input_record,1,sys_count);
      if error or sys_count=0 then return; end if;

      -- push input event to the queue
      if input_record.eventtype=system.windows.wincon.key_event then
        -- initialize new kdb_event
        new kbd_event;

        -- fill kbd_event record
        kbd_event^.event_type:=tit_keyboard_input;
        key_input_record:=input_record.keyevent;
        kbd_event^.key_down:=t_logical(key_input_record.bkeydown);
        -- %% repeat count
        -- %% override key code
        -- %% override scan code
        kbd_event^.char:=t_char32(key_input_record.wchar);
        sys_ctrl_key_state_to_key_modifiers_mask(key_input_record.dwcontrolkeystate,
                                                 kbd_event^.key_modifier);

        -- add event in the queue
        queue_data & p_input_event(kbd_event);
        count:=1;
    	end if;

      end fill_queue;



    -- %% Temporary use
    -----------------------------------------------------------------------------------------------
    procedure key_modifiers_mask_to_sys_ctrl_key_state (
      sys_var      : out system.windows.windef.tsys_dword;
      flex_var     : in t_key_modifier_mask)=
    -- converts dword into t_modifiers_key_mask
    ------------------------------------------------------------------------------------------------
    begin
    {#if #declared radekr; #and then; radekr then;
    %% TODO
      
      if tkm_alt in flex_var then
        sys_var or system.windows.wincon.left_alt_pressed end if;
      if tkm_altgr in flex_var then
        sys_var + system.windows.wincon.right_alt_pressed end if;
      if tkm_left_shift then 
        sys_var + system.windows.wincon.shift_pressed
          then flex_var + t_key_modifier_mask:[] end if;
      if tkm_rigth_shift in (sys_var and system.windows.wincon.shift_pressed)= then
        flex_var + t_key_modifier_mask:[] + t_key_modifier_mask:[tkm_left_shift] system.windows.wincon.shift_pressed end if;
      if (sys_var and system.windows.wincon.left_ctrl_pressed)=system.windows.wincon.left_ctrl_pressed
          then flex_var + t_key_modifier_mask:[tkm_left_control] end if;
      if (sys_var and system.windows.wincon.right_ctrl_pressed)=system.windows.wincon.right_ctrl_pressed 
          then flex_var + t_key_modifier_mask:[tkm_right_control] end if;
      
    #end if;}
      raise feature_not_implemented;
      end key_modifiers_mask_to_sys_ctrl_key_state;



    ------------------------------------------------------------------------------------------------
    override put_event =
    -- Overriden method that puts syntethic events to system console input queue.
    ------------------------------------------------------------------------------------------------
    #if #declared radekr; #and then; radekr then;
    var 
      input_record : system.windows.wincon.psys_input_record0;      
      sys_count    : system.windows.windef.tsys_dword;
      error        : t_logical;
      kbd_event    : p_keyboard_event;
      key_input_record : system.windows.wincon.tsys_key_event_record;
    #end if;
      
    begin
    #if #declared radekr; #and then; radekr then;
      -- convert to system input record


      -- write event to system
      result:=not system.windows.wincon.writeconsoleinput(stdin,input_record,1,sys_count);
    #end if;

      raise feature_not_implemented;
      end put_event;

    end c_console_input_queue;


var 
  -- %% Task  
  input_queue  : p_console_input_queue;          -- console input queue is allocated on the first use

----------------------------------------------------------------------------------------------------
procedure write =
-- Writes the string <par>s</par> to the actual cursor position and moves the cursor to the first
-- position after the text. When the text doesn't fit to the actual line, it is splitted to as
-- many lines as necessary. When the text needs to be wrapped beyond the last line of the console, 
-- the console's content is scrolled by one line up.
----------------------------------------------------------------------------------------------------
var
  wstr         : windows.windef.winnt.psys_wstr;
  astr         : windows.windef.winnt.psys_ustr;
  written      : system.windows.windef.tsys_dword;

begin
  -- [writeconsole] cannot handle redirected output, so the application must
  -- cope with this and use [writefile] instead...
  if stdout_redirected

    -- write using [writefile] to a redirected standard output
    then
      begin
        to_ascii_string(s,astr);
        if not windows.winbase.writefile(stdout,astr^,s:length,written,nil) then
          -- %%TODO(HANDLEERROR)
          end if;
      leave
        discard astr;
        end;

    -- otherwise write using the [writeconsole] function
    else 
      begin
        to_system_string(s,wstr);
        if system.windows.wincon.writeconsole(stdout,wstr^,s:length,written,nil) then
          -- %%TODO(HANDLEERROR)
          end if;
      leave
        discard wstr;
        end;
      end if;
  end write;



----------------------------------------------------------------------------------------------------
procedure write_line =
-- Does the same as <ent>write</ent> and then moves the cursor to the beginning of the next line 
-- following the end of the text. When the output ends on the last line of the console, the 
-- console's content is scrolled by one line up.
----------------------------------------------------------------------------------------------------
begin
  write(s);
  write(\13\10);
  end write_line;



----------------------------------------------------------------------------------------------------
procedure write_at =
-- Writes the string <par>s</par> to the given position. The cursor's position is left intact.
-- When the text doesn't fit to the actual line, it is splitted to as many lines as necessary.
-- 
-- Parameters:
--   x,y           When the position is outside of the visible console area, 
--                 <ent>parameter_error</ent> is raised.
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented;
  end write_at;



----------------------------------------------------------------------------------------------------
procedure set_cursor_position =
-- Sets actual cursor position.
-- 
-- Parameters:
--   x,y           When the position is outside of the visible console area, 
--                 <ent>parameter_error</ent> is raised.
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented;
  end set_cursor_position;



----------------------------------------------------------------------------------------------------
procedure get_cursor_position =
-- Returns actual cursor position.
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented;
  end get_cursor_position;



----------------------------------------------------------------------------------------------------
procedure get_console_info =
-- Returns basic information about the console.
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented;
  end get_console_info;


{----------------------------------------------------------------------------------------------------
procedure get_console_event =
-- Returns console event from the console. This event cointains information about console input 
-- that has been done.
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented; 
  end get_console_event;}



----------------------------------------------------------------------------------------------------
procedure read_char =
-- Reads character [char] form system console input buffer. This subprogram stop the execution and
-- wait until a character is read.
-- Ignores control character.
-- This subprogram empties the console input queue, so we do not receive any buffered characters 
-- pressed before the subprogram call.
----------------------------------------------------------------------------------------------------
var 
  kbd_event        : p_keyboard_event;
  event_filter     : t_input_type_filter;
  error            : t_logical;

begin
  -- allocate [input_queue] object
  if input_queue=nil then
    -- only on first use
    new input_queue;
    end if;

  -- set input event filter and wait for pressed character
  event_filter:=t_input_type_filter:[tit_keyboard_input];
  input_queue^.flush_queue(event_filter);
  while kbd_event=nil or else (kbd_event^.char:ord<$21 or not kbd_event^.key_down) loop;
    input_queue^.get_event(event_filter,p_input_event(kbd_event),error);
    end loop;

  -- translate character
  input_queue^.flush_queue(event_filter);
  if error then raise input_error; end if;
  c:=kbd_event^.char;
  end read_char;



----------------------------------------------------------------------------------------------------
class c_console_output_text_stream;
type p_console_output_text_stream = ^class c_console_output_text_stream;
class c_console_output_text_stream = extend c_output_text_stream;
-- Console output text stream.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override write =
    -- Writes [text] to the output.                                    
    ------------------------------------------------------------------------------------------------
    begin
      current module.write(text);
      end write;



    ------------------------------------------------------------------------------------------------
    override write_line =
    -- Writes [text] to the output and transitions to a new line.
    ------------------------------------------------------------------------------------------------
    begin
      current module.write_line(text);
      end write_line;
    
    end c_console_output_text_stream;



----------------------------------------------------------------------------------------------------
entry =
-- Module initialization.
----------------------------------------------------------------------------------------------------
begin
  -- retrieve handles for standard input/output from the operating system
  stdin:=system.windows.winbase.getstdhandle(system.windows.winbase.std_input_handle);
  stdout:=system.windows.winbase.getstdhandle(system.windows.winbase.std_output_handle);
  stderr:=system.windows.winbase.getstdhandle(system.windows.winbase.std_error_handle);

  -- find out if the standard output is redirected to a file or not
  stdout_redirected:=true; -- %%TODO(MSDN)

  -- initialize the console output stream
  new p_console_output_text_stream(console_output);
  end entry;


----------------------------------------------------------------------------------------------------
exit =
-- Module finalization.
----------------------------------------------------------------------------------------------------
begin
  -- free input_queue
  if input_queue<>nil then
    discard input_queue; 
    end if;
  end exit;



end console;