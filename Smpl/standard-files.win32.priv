----------------------------------------------------------------------------------------------------
module private files =
-- Files.
-- Flex Standard Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------

with
  classes,
  classes.lists;

use 
  system,
  system.windows,
  system.windows.windef,
  system.windows.winbase;

----------------------------------------------------------------------------------------------------
class c_file_output_stream; type p_file_output_stream = ^class c_file_output_stream;
class c_file_output_stream = extend c_output_stream;
-- Temporary, to be removed once interfaces (abstract classes) will work.
----------------------------------------------------------------------------------------------------
    
    var
      pf           : p_file;
      ofs          : t_file_pointer;

    ------------------------------------------------------------------------------------------------
    static init ( 
        pf         : in p_file) =
    ------------------------------------------------------------------------------------------------
    begin
      this.pf:=pf;
      end init;



    ------------------------------------------------------------------------------------------------
    override get_output_written =
    ------------------------------------------------------------------------------------------------
    begin
      result:=ofs;
      end get_output_written;



    ------------------------------------------------------------------------------------------------
    override write =
    ------------------------------------------------------------------------------------------------
    begin
      pf^.write(ofs,data,data:size);
      ofs+data:size;
      end write;



    ------------------------------------------------------------------------------------------------
    override writex =
    ------------------------------------------------------------------------------------------------
    begin
      pf^.write(ofs,data,len);
      ofs+len;
      end writex;

    end c_file_output_stream;



----------------------------------------------------------------------------------------------------
class private c_filesystem_object =
-- Filesystem class.
----------------------------------------------------------------------------------------------------
-- This class is used as a general ancestor for all filesystem objects, such as c_drive, c_folder
-- and c_file.
-- As such contains general attributes common to all of those filesystem objects and provides
-- methods to operate with these attributes and other virtual methods that have to be overriden.
----------------------------------------------------------------------------------------------------

    
    ------------------------------------------------------------------------------------------------
    virtual get_datim =
    -- Returns requested date and time information. When the subprogram fails, [res] is set to 
    -- [tfe_get_info].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end get_datim;



    ------------------------------------------------------------------------------------------------
    virtual set_datim =
    -- Sets all date and time informations of the file contained in [kind] to [datim]. When the 
    -- method fails, [res] is set to [tfe_set_info].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end set_datim;



    ------------------------------------------------------------------------------------------------
    virtual get_attribute =                        
    -- Returns the state of the given file attribute [attr]. When the subprogram fails, [res] is set 
    -- to [tfe_get_info] and the return value is undefined.
    ------------------------------------------------------------------------------------------------
    var
      win32_attrs   : windows.windef.tsys_dword;
      sys_name      : windows.windef.winnt.psys_wstr; -- system name
      
    begin
      -- composes system file name
      declare var
        text_name  : p_text_name;                -- plain-text name of a file
      begin
        name.compose_name(text_name);
        to_system_string(text_name^,sys_name);
      leave
        discard text_name;
        end declare;

      -- read file attributes
      win32_attrs:=windows.winbase.GetFileAttributes(sys_name);
      if win32_attrs=system.windows.winbase.INVALID_FILE_ATTRIBUTES then
        #if #declared tomash;; #and then; tomash then;
          #warning 'README';
          {
            Na tohle je tu nˆjak  metoda [set_result] nebo tak nˆco, kter  kromˆ nastaven¡
            k¢du chyby vol  trigger [event_error]. Pros¡m zmˆnit.
          }
        #end if;
        res:=tfe_get_info;
        return;
        end if;

      -- remap win32 attributes to ours
      case attr
        when tfattr_readonly    do result:=(win32_attrs and system.windows.windef.winnt.FILE_ATTRIBUTE_READONLY) <> 0;
        when tfattr_temporary   do result:=(win32_attrs and system.windows.windef.winnt.FILE_ATTRIBUTE_TEMPORARY) <> 0;
        when tfattr_compressed  do result:=(win32_attrs and system.windows.windef.winnt.FILE_ATTRIBUTE_COMPRESSED) <> 0;
        when tfattr_encrypted   do result:=(win32_attrs and system.windows.windef.winnt.FILE_ATTRIBUTE_ENCRYPTED) <> 0;
        when tfattr_sparse      do result:=(win32_attrs and system.windows.windef.winnt.FILE_ATTRIBUTE_SPARSE_FILE) <> 0;
        when tfattr_hidden      do result:=(win32_attrs and system.windows.windef.winnt.FILE_ATTRIBUTE_HIDDEN) <> 0;
        when others             do res := tfe_get_info; return;{%%TODO(ERRORS)};
        end case;

    leave
      discard sys_name;
      end get_attribute;



    ------------------------------------------------------------------------------------------------
    virtual set_attribute =
    -- Sets the state of the given file attribute [attr]. When the subprogram fails, [res] is set to 
    -- [tfe_set_info].
    ------------------------------------------------------------------------------------------------
    var
      win32_attrs   : windows.windef.tsys_dword;
      sys_name      : windows.windef.winnt.psys_wstr; -- system name
      text_name     : p_text_name;                -- plain-text name of a file
      attr_mask     : windows.windef.tsys_dword;

    begin
      -- composes system file name
      declare var
        text_name  : p_text_name;                -- plain-text name of a file
      begin
        name.compose_name(text_name);
        to_system_string(text_name^,sys_name);
      leave
        discard text_name;
        end declare;

      -- read original file attributes
      win32_attrs:=windows.winbase.GetFileAttributes(sys_name);
      if win32_attrs = system.windows.winbase.INVALID_FILE_ATTRIBUTES then
        #if #declared tomash;; #and then; tomash then;
          #warning 'README';
          {
            Na tohle je tu nˆjak  metoda [set_result] nebo tak nˆco, kter  kromˆ nastaven¡
            k¢du chyby vol  trigger [event_error]. Pros¡m zmˆnit.
          }
        #end if;
        res:=tfe_set_info;
        return;
        end if;

      -- prepare attribute mask  = which bit will be set/reset
      case attr
        when tfattr_readonly    do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_READONLY;
        when tfattr_temporary   do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_TEMPORARY;
--      when tfattr_compressed  do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_COMPRESSED;   {by other system calls than SetFileAttributes}
--      when tfattr_encrypted   do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_ENCRYPTED;
--      when tfattr_sparse      do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_SPARSE_FILE;
        when tfattr_hidden      do attr_mask := system.windows.windef.winnt.FILE_ATTRIBUTE_HIDDEN;
        when others             do res := tfe_set_info; return; {%%TODO(ERRORS)};
        end case;

      -- change bit as required
      if status 
        then win32_attrs or attr_mask
        else win32_attrs and not attr_mask
        end if;

      -- store modified flags
      if not windows.winbase.SetFileAttributes(sys_name, win32_attrs) then 
        #if #declared tomash;; #and then; tomash then;
          #warning 'README';
          {
            Na tohle je tu nˆjak  metoda [set_result] nebo tak nˆco, kter  kromˆ nastaven¡
            k¢du chyby vol  trigger [event_error]. Pros¡m zmˆnit.
          }
        #end if;
        res:=tfe_set_info 
        end if;

    leave
      discard sys_name;
      end set_attribute;

    end c_filesystem_object;



---- Working with files ----------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private c_file = 
-- File access class.
----------------------------------------------------------------------------------------------------

    var
      handle       : windows.windef.tsys_handle  -- OS file handle
                   := windows.winbase.invalid_handle_value;
      sys_error    : windows.windef.tsys_dword;  -- system error code

    ------------------------------------------------------------------------------------------------
    static set_ok =
    -- Clears [this.res] error flag.
    ------------------------------------------------------------------------------------------------
    begin
      res:=tfe_ok;
      sys_error:=0;  
      end set_ok;



    ------------------------------------------------------------------------------------------------
    static set_error (
        res        : in t_fs_object_error) =     -- error code
    -- Sets [this.res] to [res], retrieves the error code from the operating system  and executes 
    -- the [event_error] trigger.
    ------------------------------------------------------------------------------------------------
    begin
      -- get error code from the operating system
      sys_error:=windows.winbase.getlasterror;
      if sys_error=0{%%TODO(LIB) windows.winbase.winerror.no_error} then
        return;
        end if;

      -- set result
      this.res:=res;
      
      -- trigger the error event
      execute(event_error);
      end set_error;



    ------------------------------------------------------------------------------------------------
    static init_decomposed_name =
    -- Initializes the instance of the file access class.
    ------------------------------------------------------------------------------------------------
    var
      text_name    : p_text_name;

    begin
      -- %%TODO(ADJUST) remember the file name
      -- this.name:=name;
      name.compose_name(text_name);
      this.name.decompose_name(text_name^,tnt_unspecified);
    leave
      discard text_name;
      end init_decomposed_name;



    ------------------------------------------------------------------------------------------------
    static init_text_name =
    -- Initializes the instance of the file access class.
    ------------------------------------------------------------------------------------------------
    begin
      -- remember the file name
      this.name.decompose_name(name,tnt_unspecified);
      end init_text_name;


  {
    ------------------------------------------------------------------------------------------------
    procedure set_global_error_policy =
    -- Sets the global error reporting policy. 
    ------------------------------------------------------------------------------------------------
    begin
      global_error_policy:=error_policy;
      end set_global_error_policy;



    ------------------------------------------------------------------------------------------------
    static set_local_error_policy =
    -- Sets the local error reporting policy. 
    ------------------------------------------------------------------------------------------------
    begin
      local_error_policy:=error_policy;
      end set_local_error_policy;
  }


    ------------------------------------------------------------------------------------------------
    static open_or_create (
        mode       : in t_fs_object_mode_set;         -- requested open mode
        access     : in t_file_access;           -- requested access mode
        sharing    : in t_file_sharing_set;      -- requested sharing mode
        oflag      : in windows.windef.tsys_dword) = -- opening mode
    -- Opens or creates a file.
    ------------------------------------------------------------------------------------------------
    var
      sys_rights   : windows.windef.tsys_dword;  -- system access rights
      sys_sharing  : windows.windef.tsys_dword;  -- system sharing mode
      sys_flags    : windows.windef.tsys_dword;  -- system flags
      sys_name     : windows.windef.winnt.psys_wstr; -- system name
      text_name    : p_text_name;                -- plain-text name of file

    begin
      -- remember file open parameters
      this.mode:=mode;
      this.access:=access;
      this.sharing:=sharing;

      -- prepare system access rights
      if tfm_read  in mode then sys_rights or windows.windef.winnt.generic_read  end if;
      if tfm_write in mode then sys_rights or windows.windef.winnt.generic_write end if;

      -- prepare system sharing mode
      if tfs_read  in sharing then sys_sharing or windows.windef.winnt.file_share_read  end if;
      if tfs_write in sharing then sys_sharing or windows.windef.winnt.file_share_write end if;

      -- set system caching policy
      case access
        when tfa_random        do sys_flags or windows.winbase.file_flag_random_access;
        when tfa_sequential    do sys_flags or windows.winbase.file_flag_sequential_scan;
        when tfa_write_through do sys_flags or windows.winbase.file_flag_write_through;
        when tfa_no_cache      do sys_flags or windows.winbase.file_flag_no_buffering;
        end case;

      { %%TODO(DECLARE) declare sys_name : ... }
      begin
        -- prepare UNICODE ASCIIZ file name
        -- %%FLEX return of t_char32ustr
        begin
          name.compose_name(text_name);
          to_system_string(text_name^,sys_name);
        leave
          discard text_name;
          end;
   
        -- open file
        handle:=windows.winbase.createfile(
          sys_name^,sys_rights,sys_sharing,nil,oflag{windows.winbase.open_existing},
          sys_flags,windows.winbase.null_handle)

      leave
        -- free temporary name
        discard sys_name;
        end;

      -- check result
      if handle=windows.winbase.invalid_handle_value

        -- error
        then set_error(tfe_open);

        -- ok
        else set_ok;
        end if;
      end open_or_create;



    ------------------------------------------------------------------------------------------------
    virtual open =
    -- Opens existing file.
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      -- open the file
      if always
        then open_or_create(mode,access,sharing,windows.winbase.open_always);
        else open_or_create(mode,access,sharing,windows.winbase.open_existing);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end open;



    ------------------------------------------------------------------------------------------------
    virtual create =  
    -- Creates a new file.
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      -- create the file
      if always
        then open_or_create(mode,access,sharing,windows.winbase.create_always);
        else open_or_create(mode,access,sharing,windows.winbase.create_new);
        end if;

      -- if error change error attribute to tfe_create
      if res=tfe_open then res:=tfe_create end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end create;



    ------------------------------------------------------------------------------------------------
    static close =
    -- Closes the file.
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      -- close a file a we have a valid handle
      if handle=windows.winbase.invalid_handle_value or else windows.winbase.closehandle(handle)

        -- ok
        then set_ok

        -- error
        else set_error(tfe_close);
        end if;

      -- get rid of the handle
      handle:=windows.winbase.invalid_handle_value;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end close;



    ------------------------------------------------------------------------------------------------
    static seek (
        pos        : in t_file_pointer;          -- position within the file from its beginning
        res        : in t_fs_object_error) =     -- error code to set when method fails
    -- Sets file pointer to the given position from the beginnig of the.
    ------------------------------------------------------------------------------------------------
    begin
      if windows.winbase.setfilepointer(handle,pos,nil,windows.winbase.file_begin)=windows.winbase.invalid_set_file_pointer
        then set_error(res);
        else set_ok;
        end if;
      end seek;



    ------------------------------------------------------------------------------------------------
    static seek_end (
        pos        : in t_file_pointer;          -- position within the file from its end
        res        : in t_fs_object_error) =     -- error code to set when method fails
    -- Sets file pointer to the given position from the end of the.
    ------------------------------------------------------------------------------------------------
    begin
      if windows.winbase.setfilepointer(handle,pos,nil,windows.winbase.file_end)=windows.winbase.invalid_set_file_pointer
        then set_error(res);
        else set_ok;
        end if;
      end seek_end;



    ------------------------------------------------------------------------------------------------
    static read =
    -- Reads LEN bytes at position POS from the file and stores them to the BUFFER.
    -- File must be open with the read (read/write) access.
    ------------------------------------------------------------------------------------------------
    var
      read         : windows.windef.tsys_dword;  -- number of bytes actualy read

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- set file pointer
      seek(pos,tfe_read);
      if res<>tfe_ok then 
        return 
        end if;

      -- read data
      if windows.winbase.readfile(handle,buffer,len,read,nil)

        -- read operation succeeded
        then
          -- not enough data read ?
          if read<len

            -- yes => error
            then set_error(tfe_read);

            -- no => ok
            else set_ok;
            end if;

        -- error
        else set_error(tfe_read);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end read;



    ------------------------------------------------------------------------------------------------
    static write =
    -- Writes [len] bytes of data from [buffer] to the file to position 
    -- [pos].
    -- File must be opened for write (or read/write) access.
    ------------------------------------------------------------------------------------------------
    var
      written      : windows.windef.tsys_dword;  -- number of bytes actually written

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- set file pointer
      seek(pos,tfe_write);
      if res<>tfe_ok then 
        return 
        end if;

      -- write data
      if windows.winbase.writefile(handle,buffer,len,written,nil)

        -- write operation succeeded
        then
          -- not all data written ?
          if written<len

            -- yes => error
            then set_error(tfe_write);

            -- no => ok
            else set_ok;
            end if;

        -- error
        else set_error(tfe_write);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end write;



    ------------------------------------------------------------------------------------------------
    static append =
    -- Writes [len] bytes of data from [buffer] to the end of file.
    --   File must be opened for write (or read/write) access, otherwise the write operation fails.
    -- When the write operation fails due to any kind of error, [res] is set to 
    -- [tfe_write].
    ------------------------------------------------------------------------------------------------
    var
      written      : windows.windef.tsys_dword;  -- number of bytes actually written

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- set file pointer
      seek_end(0,tfe_write);
      if res<>tfe_ok then 
        return 
        end if;

      -- write data
      if windows.winbase.writefile(handle,buffer,len,written,nil)

        -- write operation succeeded
        then
          -- not all data written ?
          if written<len

            -- yes => error
            then set_error(tfe_write);

            -- no => ok
            else set_ok;
            end if;

        -- error
        else set_error(tfe_write);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end append;



    ------------------------------------------------------------------------------------------------
    static get_size =
    -- Current size of the file.
    ------------------------------------------------------------------------------------------------
    var
      sys_size     : windows.windef.tsys_dword;  -- file size (low order 32 bits)

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- get the size of the file
      sys_size:=windows.winbase.getfilesize(handle,nil);
      if sys_size=sys_size:last{-1}

        -- error
        then
          result:=0;
          set_error(tfe_get_info);

        -- ok
        else
          result:=t_file_pointer(sys_size);
          set_ok;
          end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end get_size;



    ------------------------------------------------------------------------------------------------
    static set_size =
    -- Sets file's size to [size].
    -- When [size] is shorter than the actual file size, the file is truncated. When
    -- [size] is longer than the actual file size, it is enlarged and the new space is 
    -- filled with binary zeroes when [zero] is [true], otherwise it is left
    -- uninitialized.
    ------------------------------------------------------------------------------------------------
    begin 
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end set_size;



    ------------------------------------------------------------------------------------------------
    static get_output_stream =
    -- Temporary, to be removed once interfaces (abstract classes) will work.
    ------------------------------------------------------------------------------------------------
    var
      os           : p_file_output_stream;

    begin
      new os;
      os^.init(^this);
      result:=os;
      end get_output_stream;



  { 
    ------------------------------------------------------------------------------------------------
    entry =
    -- Initialization.
    ------------------------------------------------------------------------------------------------
    begin
      -- initialize local error reporting policy
      local_error_policy:=global_error_policy;
      end entry;
  }


    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalization.
    ------------------------------------------------------------------------------------------------
    begin
      -- close a potentially unclosed file
      if handle<>windows.winbase.invalid_handle_value then
        close;
        end if;
      end exit;
 
    end c_file;



---- Working with folders --------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class c_folder_content_trigger = extend c_trigger;
----------------------------------------------------------------------------------------------------

    type
      -- the desired content of the collection
      t_collection_content = enum
           content_files;                        -- the collection shall contain names of files
           content_folders;                      -- the collection shall contain names of folders
           end enum;

    ------------------------------------------------------------------------------------------------
    static init (
        parent     : in p_folder;                -- parent folder
        collection : in p_names;                 -- related collection of names
        content    : in t_collection_content);   -- the desired content of the collection
    -- Initializes the content trigger.
    ------------------------------------------------------------------------------------------------

  private

    var
      parent       : p_folder;                   -- parent folder
      collection   : p_names;                    -- related collection of names
      content      : t_collection_content;       -- the desired content of the collection
      initialized  : t_logical;                  -- [true] if the collection has already been initialized

    ------------------------------------------------------------------------------------------------
    static init =
    -- Initializes the content trigger.
    ------------------------------------------------------------------------------------------------
    begin
      this.parent:=parent;
      this.collection:=collection;
      this.content:=content;
      end init;



    ------------------------------------------------------------------------------------------------
    override execute =
    -- Trigger of the "before" action on an uninitialized collection.
    ------------------------------------------------------------------------------------------------
    var
      _search_mask : p_text_name;
      search_mask  : p_text_name;                -- search mask
      sys_search_mask : windows.windef.winnt.psys_wstr;     -- system search mask
      find_data    : windows.winbase.tsys_win32_find_dataw; -- data returned by the system
      search_op    : windows.winbase.FINDEX_SEARCH_OPS;     -- system search operation type
      search_handle: windows.windef.tsys_handle := windows.winbase.invalid_handle_value; -- handle of the search
      name         : p_name;                     -- decomposed name being inserted into the collection
      text_name    : p_text_name;                -- found plain-text name

    begin
      -- intercept only before-calls to uninitialized collection
      if {%%TODO(TAG) event<>event_before or else} initialized then
        return;
        end if;

      -- the collection is now initialized
      -- %%TODO(TAG) After specializing the event to event_before_retrieve, move this statement
      -- back to the end of this procedure. Actually here it serves on as an unwanted recursion 
      -- barrier.
      initialized:=true;

      -- compose name of the parent folder with search mask
      -- %%TODO(ADJUST) parent^.name.compose_name(search_mask);
      --                adjust search_mask range search_mask^:length+2;
      parent^.name.compose_name(_search_mask);
      new search_mask range _search_mask^:length+2;
      search_mask^:=_search_mask^;
      if search_mask^[search_mask^:length]<>"\"
        then search_mask^ & '\*';
        else search_mask^ & "*";
        end if;

      -- convert to a system string
      to_system_string(search_mask^,sys_search_mask);

      begin
        -- setup the search
        case content
          when content_files   do search_op:=windows.winbase.FindExSearchNameMatch;
          when content_folders do search_op:=windows.winbase.FindExSearchLimitToDirectories;
          end case;
        search_handle:=windows.winbase.findfirstfileexw(sys_search_mask,windows.winbase.FindExInfoStandard,find_data,search_op,nil,0);

        -- process all found entries
        if search_handle<>windows.winbase.invalid_handle_value then
          loop
            -- insert matching entry into the names collection
            if (content=content_files and (find_data.dwfileattributes and windows.windef.winnt.file_attribute_directory)=0)
            or (content=content_folders and (find_data.dwfileattributes and windows.windef.winnt.file_attribute_directory)<>0) then
              -- %%TODO(DECLARE) declare name, text_name
              begin
                -- prepare a plain-text name
                from_system_string(windows.windef.winnt.psys_wstr(^find_data.cFileName),p_char32ustr(text_name));

                -- ignore special directories '.' and '..' 
                if content<>content_folders or else (text_name^<>'.' and text_name^<>'..') then
                  -- decompose into a [c_name]
                  new name;
                  name^.decompose_name(text_name^,tnt_relative);

                  -- insert into the collection
                  collection^.insert(p_list_item(name));
                  end if;

              leave
                discard text_name;
                end;
              end if;

            -- search for the next entry
            until not windows.winbase.findnextfile(search_handle,find_data);
          end if;

      leave
        -- close the search
        if not windows.winbase.findclose(search_handle) then
          -- and what? %%FLEX
          end if;
        end;

    leave
      discard _search_mask;
      discard search_mask;
      discard sys_search_mask;
      end execute;

    end c_folder_content_trigger;



----------------------------------------------------------------------------------------------------
class private c_folder = 
----------------------------------------------------------------------------------------------------

    var 
      handle       : windows.windef.tsys_handle; -- OS file handle
      sys_error    : windows.windef.tsys_dword;  -- system error code

      -- triggers of the "before" action on uninitialized names collections
      files_trigger   : c_folder_content_trigger;
      folders_trigger : c_folder_content_trigger;

    ------------------------------------------------------------------------------------------------
    static set_ok =
    -- Clears [this.res] error flag.
    ------------------------------------------------------------------------------------------------
    begin
      res:=tfe_ok;
      sys_error:=0;  
      end set_ok;



    ------------------------------------------------------------------------------------------------
    static set_error (
        res        : in t_fs_object_error) =     -- error code
    -- Sets [this.res] to [res], retrieves the error code from the operating system  and executes 
    -- the [event_error] trigger.
    ------------------------------------------------------------------------------------------------
    begin
      -- set result
      this.res:=res;
      
      -- get error code from the operating system
      sys_error:=windows.winbase.getlasterror;

      -- trigger the error event
      execute(event_error);
      end set_error;



    ------------------------------------------------------------------------------------------------
    static init_decomposed_name =
    -- Initializes the instance of the folder access class with the given folder name. 
    --
    -- Result:
    --   This subprogram always succeeds.
    --
    -- Remarks:
    --   -- This subprogram is not triggerable.
    ------------------------------------------------------------------------------------------------
    var
      text_name    : p_text_name;

    begin
      -- %%TODO(ADJUST) remember the file name
      -- this.name:=name;
      name.compose_name(text_name);
      this.name.decompose_name(text_name^,tnt_unspecified);
    leave
      discard text_name;
      end init_decomposed_name;



    ------------------------------------------------------------------------------------------------
    static init_text_name =
    -- Initializes the instance of the folder access class with the given folder name. 
    --
    -- Result:
    --   This subprogram always succeeds.
    --
    -- Remarks:
    --   -- This subprogram is not triggerable.
    ------------------------------------------------------------------------------------------------
    begin
      this.name.decompose_name(name,tnt_unspecified);
      end init_text_name;
    
    
{    
    ------------------------------------------------------------------------------------------------
    static open =
    -- Opens an existing folder.
    --
    -- Result:
    --   When folder does not exist opening failes, [res] is set to [tfe_open].
    --   When user program has no rigths to open the folder, opening fails,
    --      [res] is set to [tfe_open].
    ------------------------------------------------------------------------------------------------
    var
      sys_rights   : windows.windef.tsys_dword;  -- system access rights
      sys_sharing  : windows.windef.tsys_dword;  -- system sharing mode
      sys_flags    : windows.windef.tsys_dword;  -- system flags
      sys_name     : windows.windef.winnt.psys_wstr; -- system name
      text_name    : p_text_name;                -- plain-text name of a file

    begin
      -- trigger the 'before' event
      execute(event_before);

      -- remember file open parameters
      this.mode:=mode;

      -- prepare system access rights
      if tfm_read  in mode then sys_rights or windows.windef.winnt.generic_read  end if;
      if tfm_write in mode then sys_rights or windows.windef.winnt.generic_write end if;

{      -- prepare system sharing mode
      if tfs_read  in sharing then sys_sharing or windows.windef.winnt.file_share_read  end if;
      if tfs_write in sharing then sys_sharing or windows.windef.winnt.file_share_write end if;}

      -- set system caching policy
{      case access
        when tfa_random        do sys_flags or windows.winbase.file_flag_random_access;
        when tfa_sequential    do sys_flags or windows.winbase.file_flag_sequential_scan;
        when tfa_write_through do sys_flags or windows.winbase.file_flag_write_through;
        when tfa_no_cache      do sys_flags or windows.winbase.file_flag_no_buffering;
        end case;}

      -- set directory flag
      sys_flags or windows.winbase.file_flag_backup_semantics;

      {%%FLEX declare sys_name : ... }
      begin
        -- prepare UNICODE ASCIIZ file name
        -- %%FLEX return of t_char32ustr
        begin
          name.compose_name(text_name);
          to_system_string(text_name^,sys_name);
        leave
          discard text_name;
          end;
   
        -- open file
        handle:=windows.winbase.createfile(
          sys_name^,sys_rights,sys_sharing,nil,windows.winbase.open_existing,
          sys_flags,windows.winbase.null_handle)

      leave
        -- free temporary name
        discard sys_name;
        end;

      -- check result
      if handle=windows.winbase.invalid_handle_value

        -- error
        then set_error(tfe_open);

        -- ok
        else set_ok;
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end open;
}    
    
    
    ------------------------------------------------------------------------------------------------
    static create =
    -- Creates a new folder.
    --
    -- Result:
    --   When folder exists then it will be opened.
    --   When folder does not exist, new one is created.
    --   When user program has no rigths to create the folder, creation fails,
    --      [res] is set to [tfe_create].
    ------------------------------------------------------------------------------------------------
    var 
      sys_res      : windows.windef.tsys_bool;   -- result of system call
      sys_name     : windows.windef.winnt.psys_wstr; -- system name
      sys_template_name : windows.windef.winnt.psys_wstr; -- system name of template folder
      text_name    : p_text_name;                -- plain-text name of a file

    begin
      -- trigger the 'before' event
      execute(event_before);

      begin 
        -- convert folder name
        begin
          name.compose_name(text_name);
          to_system_string(text_name^,sys_name);
        leave
          discard text_name;
          end;

        if template=nil 

          -- creation of a new directory 
          then
            sys_res:=windows.winbase.createdirectory(sys_name,nil{%%TODO security attributes});

          -- creation of given the template directory
          else
            begin
              template^.name.compose_name(text_name);
              to_system_string(text_name^,sys_template_name);
            leave
              discard text_name;
              end;
            sys_res:=windows.winbase.createdirectoryex(sys_template_name,sys_name,nil{%%TODO security attributes});
            end if;

      leave   
        discard sys_name;
        discard sys_template_name;
        end;

      -- check result 
      if sys_res 
        -- ok
        then
          set_ok;

        --error
        else
          set_error(tfe_create);
          end if;
    {
      -- %%TODO mo‘n  by open nemusel b˜t sou‡ st¡ create, ale to by zase neodpov¡dalo koncepci soubor–
      -- open the created directory
      if res<>tfe_ok then open(mode); end if;
    }
    leave
      -- trigger the 'after' event
      execute(event_after);
      end create;
    
    
{    
    ------------------------------------------------------------------------------------------------
    static close =
    -- Closes the file.
    -- The file needs not to be opened (nothing happens in this case).
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      if windows.winbase.closehandle(handle)
        -- ok
        then set_ok

        -- error
        else set_error(tfe_close);
        end if;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end close;
}


    ------------------------------------------------------------------------------------------------
    static get_sub_folder =
    -- 
    ------------------------------------------------------------------------------------------------
    begin
      result.init_decomposed_name(this.name);
      result.name.join_after(sub_folder);
      end get_sub_folder;



    ------------------------------------------------------------------------------------------------
    entry =
    -- Initialization.
    ------------------------------------------------------------------------------------------------
    begin
      -- setup the triggers for files and folders names collections
      files_trigger.init(^this,^files,files_trigger.content_files);
      folders_trigger.init(^this,^folders,folders_trigger.content_folders);
      files.register_trigger(^files_trigger);
      folders.register_trigger(^folders_trigger);
      end entry;

    end c_folder;



---- Working with drives ---------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private c_drive = 
----------------------------------------------------------------------------------------------------
    
--    var 
--      mount_point  : protected c_name;
--      mounted      : protected boolean;
--      root_folder  : protected c_folder;

    ------------------------------------------------------------------------------------------------
    static set_mount_point =
    -- Sets [mount_point] of the drive to [new_mount_point].
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end set_mount_point;
    

    
    ------------------------------------------------------------------------------------------------
    static get_mount_point =
    -- Returns mount point of the logical drive.
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end get_mount_point;
    

    
    ------------------------------------------------------------------------------------------------
    static mount =
    -- Mounts drive to the specified [mount_point].
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end mount;
    

    
    ------------------------------------------------------------------------------------------------
    static unmount = 
    -- Unmounts the drive. On system which does not support unmounting it simulates the unmount and 
    -- then the drive will behave as unmounted for our application.
    -- %%TODO to je ale nˆjak˜ divn˜
    ------------------------------------------------------------------------------------------------
    begin
      -- trigger the 'before' event
      execute(event_before);

      raise feature_not_implemented;

    leave
      -- trigger the 'after' event
      execute(event_after);
      end unmount; 

    end c_drive;



----------------------------------------------------------------------------------------------------
class private c_drives =
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static update =
    -- Updates the list of available drives.
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end update;


    end c_drives;



----------------------------------------------------------------------------------------------------
class private c_file_manager =
----------------------------------------------------------------------------------------------------
    
    ------------------------------------------------------------------------------------------------
    static copy_file =
    -- Copies file of name [srcname] to a file at destination of [destname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_copy].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end copy_file;



    ------------------------------------------------------------------------------------------------
    static move_file =
    -- Moves file of name [srcname] to a file at destination of [destname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_move].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end move_file;



    ------------------------------------------------------------------------------------------------
    static delete_file =
    -- Deletes file of name [filename].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_delete].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end delete_file;



    ------------------------------------------------------------------------------------------------
    static copy_folder =
    -- Copies folder of name [srcname] to a folder at destination of [destname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_copy].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end copy_folder;



    ------------------------------------------------------------------------------------------------
    static move_folder =
    -- Moves file of name [srcname] to a file at destination of [destname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_move].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end move_folder;



    ------------------------------------------------------------------------------------------------
    static remove_folder =
    -- Removes folder of name [pathname].
    --
    -- Result:
    --   If program has no rigths to perform such opration subprogram fails.
    --   If parametr [always] is false the folder must be empty otherwise this operation fails.
    --   If subprogram fails [fm_error] flag will be set to [tfme_delete].
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end remove_folder;



    ------------------------------------------------------------------------------------------------
    virtual progress = 
    -- Returns progress information about the operation being processed.
    ------------------------------------------------------------------------------------------------
    begin
      raise feature_not_implemented;
      end progress;


    end c_file_manager;



----------------------------------------------------------------------------------------------------
class c_file_output_text_stream; type p_file_output_text_stream = ^class c_file_output_text_stream;
class c_file_output_text_stream = extend c_output_text_stream;
-- Temporary, to be removed once interfaces (abstract classes) will work.
----------------------------------------------------------------------------------------------------

    var
      pf           : p_file;                     -- related file
      encoder      : p_character_encoder;        -- character encoder
      buffer       : c_output_buffer;            -- output buffer

    ------------------------------------------------------------------------------------------------
    static init ( 
        pf           : in p_text_file;
        write_method : in c_output_buffer.p_write_method) =
    -- Initializes the stream.
    ------------------------------------------------------------------------------------------------
    begin
      -- remember the related file
      this.pf:=pf;

      -- initialize the buffer
      buffer.init(4096,write_method);
      end init;



    ------------------------------------------------------------------------------------------------
    static flush =
    -- Flushes the contents of the [buffer] to the physical output.
    ------------------------------------------------------------------------------------------------
    begin
      buffer.flush;
      end flush;



    ------------------------------------------------------------------------------------------------
    override write =
    ------------------------------------------------------------------------------------------------
    var
      all_out      : t_logical;
      b            : t_unsigned8;

    begin
      -- do we have an encoder to encode the text ?
      if encoder<>nil

        -- yes => convert and output all characters
        then
          for i in text:range loop
            -- overt one character
            encoder^.put_character(text[i]);

            -- output all bytes
            loop
              encoder^.get_output(b,all_out);
              buffer.write_byte(b);
              until all_out;
            end loop;

        -- no => don't do any changes to the text
        else
          buffer.write_block(text[1{%%TODO(SLICE)..text:length}],text:length*text:base:size);
          end if;
      end write;



    ------------------------------------------------------------------------------------------------
    override write_line =
    ------------------------------------------------------------------------------------------------
    begin
      write(text);
      write(\13\10);
      end write_line;

    end c_file_output_text_stream;


          
----------------------------------------------------------------------------------------------------
class private c_text_file = 
-- File access class.
----------------------------------------------------------------------------------------------------

    var
      -- %%TODO(ABSTRACT) Remove when interfaces become available
      os           : p_file_output_text_stream;

    ------------------------------------------------------------------------------------------------
    static write_method : c_output_buffer.t_write_method =
    ------------------------------------------------------------------------------------------------
    begin
      append(data,len);
      end write_method;



    ------------------------------------------------------------------------------------------------
    static set_encoder =
    -- Assigns a character encoder to the output stream.
    ------------------------------------------------------------------------------------------------
    begin
      os^.encoder:=encoder;
      end set_encoder;



    ------------------------------------------------------------------------------------------------
    static get_text_output_stream =
    -- Temporary, to be removed once interfaces (abstract classes) will work.
    ------------------------------------------------------------------------------------------------
    begin
      if os=nil then
        new os;
        os^.init(^this,^write_method);
        end if;
      result:=os;
      end get_text_output_stream;



    ------------------------------------------------------------------------------------------------
    static close =
    -- Closes the file.
    ------------------------------------------------------------------------------------------------
    begin
      -- flush all data and discard the output stream
      if tfm_write in mode and then os<>nil then
        os^.flush;
        discard os;
        end if;

      -- close the file
      --%%TODO(ANCESTOR) this:parent.close;
      p_file(^this)^.close;
      end close;



    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalization. 
    ------------------------------------------------------------------------------------------------
    begin
      -- %%TODO(ANCESTOR) Remove when inherited calls become available.
      close;

      -- %%TODO(ABSTRACT) Remove when interfaces become available
      discard os;
      end exit;
 
    end c_text_file;

end files;